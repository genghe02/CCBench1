{"response body": "ChatCompletion(id='chatcmpl-AiK1Aanc6Wfe9CvnM99V2nnPlRHzZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```python\\n\"\"\"\\nDocFileHandler is a class designed to simplify the manipulation of Microsoft Word (.docx) files. \\nIt provides methods to read text, write text, add headings, and insert tables in a Word document. \\nThis class aims to streamline document processing tasks, making it easier for users to generate \\nand modify .docx files programmatically.\\n\\nDependencies:\\n- Requires the `python-docx` library to manipulate Word documents.\\n\"\"\"\\nfrom docx import Document\\nfrom docx.shared import Pt\\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\\n\\n\\nclass DocFileHandler:\\n    def __init__(self, file_path):\\n        \"\"\"\\n        Initializes the DocFileHandler with the specified file path.\\n\\n        Parameters:\\n            file_path (str): The path to the .docx file that will be manipulated.\\n        \"\"\"\\n        self.file_path = file_path\\n\\n    def read_text(self):\\n        \"\"\"\\n        Reads the text content from the .docx file.\\n\\n        Returns:\\n            str: The complete text of the document, joined by new line characters.\\n\\n        Test cases:\\n            # Test case 1: Normal usage\\n            input = \"path/to/existing/document.docx\"\\n            expected_output = \"This is the first paragraph.\\\\nThis is the second paragraph.\"\\n            \\n            # Test case 2: Empty document\\n            input = \"path/to/empty/document.docx\"\\n            expected_output = \"\"\\n            \\n            # Test case 3: Non-existing document\\n            input = \"path/to/non_existing/document.docx\"\\n            expected_output = Exception or error handling\\n        \"\"\"\\n        doc = Document(self.file_path)\\n        text = []\\n        for paragraph in doc.paragraphs:\\n            text.append(paragraph.text)\\n        return \"\\\\n\".join(text)\\n\\n    def write_text(self, content, font_size=12, alignment=\\'left\\'):\\n        \"\"\"\\n        Writes the provided content to the .docx file with specified formatting.\\n\\n        Parameters:\\n            content (str): The text content to write in the document.\\n            font_size (int, optional): The font size of the written text. Default is 12.\\n            alignment (str, optional): The alignment of the text (\\'left\\', \\'center\\', \\'right\\'). Default is \\'left\\'.\\n\\n        Returns:\\n            bool: True if the content is written successfully, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Normal usage\\n            input = (\"Hello, World!\", 14, \\'center\\')\\n            expected_output = True\\n            \\n            # Test case 2: Unsupported alignment\\n            input = (\"Text with wrong alignment\", 12, \\'unsupported\\')\\n            expected_output = True  # Defaulting to left\\n            \\n            # Test case 3: Invalid file path\\n            input = (\"Some content\", 12, \\'left\\')\\n            expected_output = False  # If the file path is invalid\\n        \"\"\"\\n        try:\\n            doc = Document()\\n            paragraph = doc.add_paragraph()\\n            run = paragraph.add_run(content)\\n            font = run.font\\n            font.size = Pt(font_size)\\n            alignment_value = self._get_alignment_value(alignment)\\n            paragraph.alignment = alignment_value\\n            doc.save(self.file_path)\\n            return True\\n        except:\\n            return False\\n\\n    def add_heading(self, heading, level=1):\\n        \"\"\"\\n        Adds a heading to the .docx file.\\n\\n        Parameters:\\n            heading (str): The text of the heading to add.\\n            level (int, optional): The level of the heading (1 to 5). Default is 1.\\n\\n        Returns:\\n            bool: True if the heading is added successfully, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Normal usage\\n            input = (\"My Heading\", 1)\\n            expected_output = True\\n            \\n            # Test case 2: Invalid heading level\\n            input = (\"My Heading\", 6)\\n            expected_output = False\\n            \\n            # Test case 3: Empty heading\\n            input = (\"\", 1)\\n            expected_output = True\\n        \"\"\"\\n        try:\\n            doc = Document(self.file_path)\\n            doc.add_heading(heading, level)\\n            doc.save(self.file_path)\\n            return True\\n        except:\\n            return False\\n\\n    def add_table(self, data):\\n        \"\"\"\\n        Adds a table to the .docx file based on given data.\\n\\n        Parameters:\\n            data (list of list): A list of rows, where each row is a list of cell values.\\n\\n        Returns:\\n            bool: True if the table is added successfully, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Normal usage\\n            input = [[1, 2, 3], [4, 5, 6]]\\n            expected_output = True\\n            \\n            # Test case 2: Empty data\\n            input = []\\n            expected_output = False  # As at least one row is needed\\n            \\n            # Test case 3: Malformed data\\n            input = [[\\'A\\', \\'B\\'], [\\'C\\']]\\n            expected_output = True  # Auto-fills missing cells with empty strings\\n        \"\"\"\\n        try:\\n            doc = Document(self.file_path)\\n            table = doc.add_table(rows=len(data), cols=len(data[0])) if data else None\\n            if table:\\n                for i, row in enumerate(data):\\n                    for j, cell_value in enumerate(row):\\n                        table.cell(i, j).text = str(cell_value)\\n            doc.save(self.file_path)\\n            return True\\n        except:\\n            return False\\n\\n    def _get_alignment_value(self, alignment):\\n        \"\"\"\\n        Gets the corresponding alignment value for the paragraph.\\n\\n        Parameters:\\n            alignment (str): The alignment specified by the user.\\n\\n        Returns:\\n            WD_PARAGRAPH_ALIGNMENT: The alignment value for the paragraph.\\n\\n        Test cases:\\n            # Test case 1: Left alignment\\n            input = \\'left\\'\\n            expected_output = WD_PARAGRAPH_ALIGNMENT.LEFT\\n            \\n            # Test case 2: Center alignment\\n            input = \\'center\\'\\n            expected_output = WD_PARAGRAPH_ALIGNMENT.CENTER\\n            \\n            # Test case 3: Invalid alignment\\n            input = \\'invalid\\'\\n            expected_output = WD_PARAGRAPH_ALIGNMENT.LEFT  # Defaults to left\\n        \"\"\"\\n        alignment_options = {\\n            \\'left\\': WD_PARAGRAPH_ALIGNMENT.LEFT,\\n            \\'center\\': WD_PARAGRAPH_ALIGNMENT.CENTER,\\n            \\'right\\': WD_PARAGRAPH_ALIGNMENT.RIGHT\\n        }\\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)\\n```', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735126744, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier=None, system_fingerprint='fp_d02d531b47', usage=CompletionUsage(completion_tokens=1330, prompt_tokens=1736, total_tokens=3066, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=1536)))", "test_case_name": "DocFileHandler.txt"}