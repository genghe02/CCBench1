{"response body": "ChatCompletion(id='chatcmpl-A6GSickKWgSmIvc6vw9BwxIALjjAl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content=\"```python\\nimport numpy as np\\nfrom gensim import matutils\\nfrom numpy import dot, array\\n\\n# This is a utility class for handling vector operations including similarity calculations.\\nclass VectorUtil:\\n    @staticmethod\\n    def similarity(vector_1, vector_2):\\n        # Compute the cosine similarity between two vectors.\\n        # param vector_1: array-like, the first input vector.\\n        # param vector_2: array-like, the second input vector.\\n        # return: float, the cosine similarity value ranging from -1 to 1.\\n        # >>> VectorUtil.similarity(np.array([1, 0]), np.array([0, 1]))  # returns 0.0\\n        # >>> VectorUtil.similarity(np.array([1, 0]), np.array([1, 0]))  # returns 1.0\\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\\n\\n    @staticmethod\\n    def cosine_similarities(vector_1, vectors_all):\\n        # Calculate cosine similarities between a single vector and a list of vectors.\\n        # param vector_1: array-like, the reference vector for comparison.\\n        # param vectors_all: array-like, a matrix of vectors to compare against.\\n        # return: array, an array of cosine similarity values.\\n        # >>> VectorUtil.cosine_similarities(np.array([1, 0]), np.array([[1, 0], [0, 1]]))  # returns array([1.0, 0.0])\\n        norm = np.linalg.norm(vector_1)\\n        all_norms = np.linalg.norm(vectors_all, axis=1)\\n        dot_products = dot(vectors_all, vector_1)\\n        similarities = dot_products / (norm * all_norms)\\n        return similarities\\n\\n    @staticmethod\\n    def n_similarity(vector_list_1, vector_list_2):\\n        # Compute the similarity based on the average of two lists of vectors.\\n        # param vector_list_1: list of array-like, first list of vectors.\\n        # param vector_list_2: list of array-like, second list of vectors.\\n        # return: float, the computed similarity value.\\n        # >>> VectorUtil.n_similarity([np.array([1, 2]), np.array([2, 3])], [np.array([1, 1]), np.array([1, 1])])  # returns a similarity score\\n        if not (len(vector_list_1) and len(vector_list_2)):\\n            raise ZeroDivisionError('At least one of the passed list is empty.')\\n\\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),\\n                   matutils.unitvec(array(vector_list_2).mean(axis=0)))\\n\\n    @staticmethod\\n    def compute_idf_weight_dict(total_num, number_dict):\\n        # Calculate the Inverse Document Frequency (IDF) weights for a dictionary of term frequencies.\\n        # param total_num: int, the total number of documents.\\n        # param number_dict: dict, a dictionary with terms as keys and their document frequency as values.\\n        # return: dict, a dictionary of terms and their corresponding IDF weights.\\n        # >>> VectorUtil.compute_idf_weight_dict(10, {'term1': 2, 'term2': 5})  # returns a dict with IDF values\\n        index_2_key_map = {}\\n\\n        index = 0\\n\\n        count_list = []\\n        for key, count in number_dict.items():\\n            index_2_key_map[index] = key\\n            count_list.append(count)\\n            index = index + 1\\n\\n        a = np.array(count_list)\\n        ## smooth, in case the divide by zero error\\n        a = np.log((total_num + 1) / (a + 1))\\n        result = {}\\n\\n        for index, w in enumerate(a):\\n            key = index_2_key_map[index]\\n            result[key] = w\\n\\n        return result\\n```\", refusal=None, role='assistant', function_call=None, tool_calls=None))], created=1726056612, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier=None, system_fingerprint='fp_483d39d857', usage=CompletionUsage(completion_tokens=826, prompt_tokens=1169, total_tokens=1995))", "test_case_name": "VectorCalculator.txt"}