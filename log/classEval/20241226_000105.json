{"response body": "ChatCompletion(id='chatcmpl-AiO6VHoEmvwEbbfEXPWQrvdZL9t1e', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='\"\"\"\\nA Utility class that provides functionalities for managing a calendar of events.\\n\\nThis class allows you to add, remove, and retrieve events by time and date. It also helps to detect availability and get a list of available time slots.\\n\"\"\"\\n\\nfrom datetime import datetime, timedelta\\n\\nclass CalendarUtil:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initializes the CalendarUtil class with an empty list of events.\\n        \"\"\"\\n        self.events = []\\n\\n    def add_event(self, event):\\n        \"\"\"\\n        Add an event to the calendar.\\n\\n        Parameters:\\n            event (dict): A dictionary containing details of the event to be added\\n        \\n        Test cases:\\n            # Test case 1: Add new event\\n            event = {\\'name\\': \\'Meeting\\', \\'date\\': datetime(2022, 8, 15, 14, 0), \\'end_time\\': datetime(2022, 8, 15, 16, 0)}\\n            add_event(event)\\n            assert len(self.events) == 1\\n            \\n            # Test case 2: Add existing event\\n            add_event(event)\\n            assert len(self.events) == 2\\n            \\n            # Test case 3: Add invalid event\\n            event = {}\\n            add_event(event)\\n            assert len(self.events) == 2\\n        \"\"\"\\n        self.events.append(event)\\n\\n    def remove_event(self, event):\\n        \"\"\"\\n        Remove an event from the calendar.\\n\\n        Parameters:\\n            event (dict): A dictionary containing details of the event to be removed\\n        \\n        Test cases:\\n            # Test case 1: Remove existing event\\n            remove_event(event)\\n            assert len(self.events) == 1\\n            \\n            # Test case 2: Remove non-existing event\\n            event = {}\\n            remove_event(event)\\n            assert len(self.events) == 1\\n            \\n            # Test case 3: Remove multiple events\\n            event = {\\'name\\': \\'Task\\', \\'date\\': datetime(2022, 8, 18, 11, 0), \\'end_time\\': datetime(2022, 8, 18, 12, 0)}\\n            add_event(event)\\n            assert len(self.events) == 2\\n        \"\"\"\\n        if event in self.events:\\n            self.events.remove(event)\\n\\n    def get_events(self, date):\\n        \"\"\"\\n        Get events scheduled for a specific date.\\n\\n        Parameters:\\n            date (datetime): The date to retrieve events for\\n\\n        Returns:\\n            list: List of events scheduled for the specified date\\n\\n        Test cases:\\n            # Test case 1: Retrieve events on a specific date\\n            date = datetime(2022, 8, 15)\\n            events = get_events(date)\\n            assert len(events) == 1\\n            \\n            # Test case 2: No events on the given date\\n            date = datetime(2022, 8, 10)\\n            events = get_events(date)\\n            assert len(events) == 0\\n            \\n            # Test case 3: Check for multiple events on the same date\\n            events = get_events(date)\\n            assert len(events) > 1\\n        \"\"\"\\n        events_on_date = []\\n        for event in self.events:\\n            if event[\\'date\\'].date() == date.date():\\n                events_on_date.append(event)\\n        return events_on_date\\n\\n    def is_available(self, start_time, end_time):\\n        \"\"\"\\n        Check if a time slot is available.\\n\\n        Parameters:\\n            start_time (datetime): Start time of the slot\\n            end_time (datetime): End time of the slot\\n\\n        Returns:\\n            bool: True if the slot is available, False otherwise\\n\\n        Test cases:\\n            # Test case 1: Check availability for an available slot\\n            start_time = datetime(2022, 8, 15, 13, 0)\\n            end_time = datetime(2022, 8, 15, 14, 0)\\n            assert is_available(start_time, end_time) == True\\n            \\n            # Test case 2: Check availability for an overlapped slot\\n            start_time = datetime(2022, 8, 15, 13, 30)\\n            end_time = datetime(2022, 8, 15, 14, 30)\\n            assert is_available(start_time, end_time) == False\\n            \\n            # Test case 3: Check availability for an empty slot\\n            start_time = datetime(2022, 8, 20, 9, 0)\\n            end_time = datetime(2022, 8, 20, 10, 0)\\n            assert is_available(start_time, end_time) == True\\n        \"\"\"\\n        for event in self.events:\\n            if start_time < event[\\'end_time\\'] and end_time > event[\\'start_time\\']:\\n                return False\\n        return True\\n\\n    def get_available_slots(self, date):\\n        \"\"\"\\n        Get a list of available time slots for a specific date.\\n\\n        Parameters:\\n            date (datetime): The date to get available time slots\\n\\n        Returns:\\n            list: List of available time slots for the specified date as tuples\\n        \\n        Test cases:\\n            # Test case 1: Get available slots on a day\\n            date = datetime(2022, 8, 15)\\n            slots = get_available_slots(date)\\n            assert len(slots) > 0\\n            \\n            # Test case 2: Get available slots on a fully booked day\\n            date = datetime(2022, 8, 20)\\n            slots = get_available_slots(date)\\n            assert len(slots) == 0\\n            \\n            # Test case 3: Get available slots on a mixed day\\n            date = datetime(2022, 8, 18)\\n            slots = get_available_slots(date)\\n            assert len(slots) > 0\\n        \"\"\"\\n        available_slots = []\\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\\n\\n        while start_time < end_time:\\n            slot_end_time = start_time + timedelta(minutes=60)\\n            if self.is_available(start_time, slot_end_time):\\n                available_slots.append((start_time, slot_end_time))\\n            start_time += timedelta(minutes=60)\\n\\n        return available_slots\\n\\n    def get_upcoming_events(self, num_events):\\n        \"\"\"\\n        Get a list of upcoming events.\\n\\n        Parameters:\\n            num_events (int): Number of upcoming events to retrieve\\n\\n        Returns:\\n            list: List of upcoming events as per count specified\\n\\n        Test cases:\\n            # Test case 1: Get specific number of upcoming events\\n            num_events = 2\\n            upcoming = get_upcoming_events(num_events)\\n            assert len(upcoming) == num_events\\n            \\n            # Test case 2: Get all upcoming events\\n            num_events = 0\\n            upcoming = get_upcoming_events(num_events)\\n            assert len(upcoming) == len(self.events)\\n            \\n            # Test case 3: No upcoming events available\\n            num_events = 3\\n            upcoming = get_upcoming_events(num_events)\\n            assert len(upcoming) == 0\\n        \"\"\"\\n        now = datetime.now()\\n        upcoming_events = []\\n        for event in self.events:\\n            if event[\\'start_time\\'] >= now:\\n                upcoming_events.append(event)\\n            if len(upcoming_events) == num_events:\\n                break\\n        return upcoming_events', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735142451, model='gpt-3.5-turbo-0125', object='chat.completion', service_tier=None, system_fingerprint=None, usage=CompletionUsage(completion_tokens=1525, prompt_tokens=1465, total_tokens=2990, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))", "test_case_name": "CalendarUtil.txt"}