{"response body": "{\n  \"id\": \"6adc54cd-6337-48f3-8f86-06a73a629df0\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\nfrom datetime import datetime\\n\\nclass EmailClient:\\n    # A class for managing email clients, including sending, receiving, and managing emails.\\n    def __init__(self, addr, capacity) -> None:\\n        # Initialize the email client with an address and a capacity limit for the inbox.\\n        # param addr: str, the email address of the client.\\n        # param capacity: int, the maximum capacity of the inbox in bytes.\\n        self.addr = addr\\n        self.capacity = capacity\\n        self.inbox = []\\n    \\n    def send_to(self, recv, content, size):\\n        # Send an email to another client if the recipient's inbox has enough space.\\n        # param recv: EmailClient, the recipient client.\\n        # param content: str, the content of the email.\\n        # param size: int, the size of the email in bytes.\\n        # return: bool, True if the email was sent successfully, False otherwise.\\n        # >>> client1 = EmailClient(\\\"client1@example.com\\\", 1000)\\n        # >>> client2 = EmailClient(\\\"client2@example.com\\\", 1000)\\n        # >>> client1.send_to(client2, \\\"Hello\\\", 100)\\n        # True\\n        # >>> client1.send_to(client2, \\\"Hello again\\\", 1000)\\n        # False\\n        if not recv.is_full_with_one_more_email(size):\\n            timestamp = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n            email = {\\n                \\\"sender\\\": self.addr,\\n                \\\"receiver\\\": recv.addr,\\n                \\\"content\\\": content,\\n                \\\"size\\\": size,\\n                \\\"time\\\": timestamp,\\n                \\\"state\\\": \\\"unread\\\"\\n            }\\n            recv.inbox.append(email)\\n            return True\\n        else:\\n            self.clear_inbox(size)\\n            return False\\n    \\n    def fetch(self):\\n        # Fetch the next unread email from the inbox.\\n        # return: dict or None, the next unread email if available, otherwise None.\\n        # >>> client = EmailClient(\\\"client@example.com\\\", 1000)\\n        # >>> client.inbox = [{\\\"sender\\\": \\\"sender@example.com\\\", \\\"receiver\\\": \\\"client@example.com\\\", \\\"content\\\": \\\"Hello\\\", \\\"size\\\": 100, \\\"time\\\": \\\"2023-01-01 12:00:00\\\", \\\"state\\\": \\\"unread\\\"}]\\n        # >>> client.fetch()\\n        # {'sender': 'sender@example.com', 'receiver': 'client@example.com', 'content': 'Hello', 'size': 100, 'time': '2023-01-01 12:00:00', 'state': 'read'}\\n        # >>> client.fetch()\\n        # None\\n        if len(self.inbox) == 0:\\n            return None\\n        for i in range(len(self.inbox)):\\n            if self.inbox[i]['state'] == \\\"unread\\\":\\n                self.inbox[i]['state'] = \\\"read\\\"\\n                return self.inbox[i]\\n        return None\\n\\n    def is_full_with_one_more_email(self, size):\\n        # Check if the inbox will be full if one more email of the given size is added.\\n        # param size: int, the size of the email in bytes.\\n        # return: bool, True if the inbox will be full, False otherwise.\\n        # >>> client = EmailClient(\\\"client@example.com\\\", 1000)\\n        # >>> client.inbox = [{\\\"sender\\\": \\\"sender@example.com\\\", \\\"receiver\\\": \\\"client@example.com\\\", \\\"content\\\": \\\"Hello\\\", \\\"size\\\": 900, \\\"time\\\": \\\"2023-01-01 12:00:00\\\", \\\"state\\\": \\\"unread\\\"}]\\n        # >>> client.is_full_with_one_more_email(100)\\n        # True\\n        # >>> client.is_full_with_one_more_email(50)\\n        # False\\n        occupied_size = self.get_occupied_size()\\n        return True if occupied_size + size > self.capacity else False\\n        \\n    def get_occupied_size(self):\\n        # Calculate the total size of all emails currently in the inbox.\\n        # return: int, the total size of the inbox in bytes.\\n        # >>> client = EmailClient(\\\"client@example.com\\\", 1000)\\n        # >>> client.inbox = [{\\\"sender\\\": \\\"sender@example.com\\\", \\\"receiver\\\": \\\"client@example.com\\\", \\\"content\\\": \\\"Hello\\\", \\\"size\\\": 100, \\\"time\\\": \\\"2023-01-01 12:00:00\\\", \\\"state\\\": \\\"unread\\\"}, {\\\"sender\\\": \\\"sender@example.com\\\", \\\"receiver\\\": \\\"client@example.com\\\", \\\"content\\\": \\\"Hello again\\\", \\\"size\\\": 200, \\\"time\\\": \\\"2023-01-01 12:00:00\\\", \\\"state\\\": \\\"unread\\\"}]\\n        # >>> client.get_occupied_size()\\n        # 300\\n        occupied_size = 0\\n        for email in self.inbox:\\n            occupied_size += email[\\\"size\\\"]\\n        return occupied_size\\n\\n    def clear_inbox(self, size):\\n        # Clear the inbox until enough space is freed to accommodate a new email of the given size.\\n        # param size: int, the size of the new email in bytes.\\n        # >>> client = EmailClient(\\\"client@example.com\\\", 1000)\\n        # >>> client.inbox = [{\\\"sender\\\": \\\"sender@example.com\\\", \\\"receiver\\\": \\\"client@example.com\\\", \\\"content\\\": \\\"Hello\\\", \\\"size\\\": 900, \\\"time\\\": \\\"2023-01-01 12:00:00\\\", \\\"state\\\": \\\"unread\\\"}]\\n        # >>> client.clear_inbox(200)\\n        # >>> client.inbox\\n        # []\\n        if len(self.addr) == 0:\\n            return\\n        freed_space = 0\\n        while freed_space < size and self.inbox:\\n            email = self.inbox[0]\\n            freed_space += email['size']\\n            del self.inbox[0]\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1727079747,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1c141eb703\",\n  \"usage\": {\n    \"completion_tokens\": 1512,\n    \"prompt_tokens\": 1229,\n    \"total_tokens\": 2741,\n    \"prompt_cache_hit_tokens\": 576,\n    \"prompt_cache_miss_tokens\": 653\n  }\n}", "test_case_name": "EmailClient.txt"}