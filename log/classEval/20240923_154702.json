{"response body": "{\n  \"id\": \"a2620fa2-88a8-43d1-8067-0dac906708b0\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\nimport random\\n\\n\\nclass MahjongConnect:\\n    # This class represents a Mahjong Connect game, which includes methods to create a game board, check for valid moves, and manage the game state.\\n    def __init__(self, BOARD_SIZE, ICONS):\\n        # Initialize the Mahjong Connect game with a specified board size and set of icons.\\n        # param BOARD_SIZE: tuple, the dimensions of the game board (rows, columns)\\n        # param ICONS: list, the set of icons to be used on the game board\\n        # >>> game = MahjongConnect((3, 3), ['A', 'B', 'C'])\\n        self.BOARD_SIZE = BOARD_SIZE\\n        self.ICONS = ICONS\\n        self.board = self.create_board()\\n\\n    def create_board(self):\\n        # Create a game board with random icons based on the specified board size and icon set.\\n        # return: list of lists, the game board with random icons\\n        # >>> game = MahjongConnect((2, 2), ['A', 'B'])\\n        # >>> game.create_board()\\n        # [['A', 'B'], ['B', 'A']]\\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\\n        return board\\n\\n    def is_valid_move(self, pos1, pos2):\\n        # Check if a move between two positions on the board is valid according to the game rules.\\n        # param pos1: tuple, the first position (row, column) on the board\\n        # param pos2: tuple, the second position (row, column) on the board\\n        # return: bool, True if the move is valid, False otherwise\\n        # >>> game = MahjongConnect((3, 3), ['A', 'B', 'C'])\\n        # >>> game.board = [['A', 'B', 'C'], ['B', 'A', 'C'], ['C', 'B', 'A']]\\n        # >>> game.is_valid_move((0, 0), (1, 1))\\n        # True\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n\\n        # Check if positions are within the game board range\\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\\n            0] and 0 <= y2 <\\n                self.BOARD_SIZE[1]):\\n            return False\\n\\n        # Check if the two positions are the same\\n        if pos1 == pos2:\\n            return False\\n\\n        # Check if the two positions have the same icon\\n        if self.board[x1][y1] != self.board[x2][y2]:\\n            return False\\n\\n        # Check if there is a valid path between the two positions\\n        if not self.has_path(pos1, pos2):\\n            return False\\n\\n        return True\\n\\n    def has_path(self, pos1, pos2):\\n        # Check if there is a valid path between two positions on the board.\\n        # param pos1: tuple, the first position (row, column) on the board\\n        # param pos2: tuple, the second position (row, column) on the board\\n        # return: bool, True if there is a valid path, False otherwise\\n        # >>> game = MahjongConnect((3, 3), ['A', 'B', 'C'])\\n        # >>> game.board = [['A', 'B', 'C'], ['B', 'A', 'C'], ['C', 'B', 'A']]\\n        # >>> game.has_path((0, 0), (1, 1))\\n        # True\\n        visited = set()\\n        stack = [pos1]\\n\\n        while stack:\\n            current_pos = stack.pop()\\n            if current_pos == pos2:\\n                return True\\n\\n            if current_pos in visited:\\n                continue\\n\\n            visited.add(current_pos)\\n            x, y = current_pos\\n\\n            # Check adjacent positions (up, down, left, right)\\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\\n                        stack.append((new_x, new_y))\\n\\n        return False\\n\\n    def remove_icons(self, pos1, pos2):\\n        # Remove the icons at the specified positions from the board.\\n        # param pos1: tuple, the first position (row, column) on the board\\n        # param pos2: tuple, the second position (row, column) on the board\\n        # return: None\\n        # >>> game = MahjongConnect((3, 3), ['A', 'B', 'C'])\\n        # >>> game.board = [['A', 'B', 'C'], ['B', 'A', 'C'], ['C', 'B', 'A']]\\n        # >>> game.remove_icons((0, 0), (1, 1))\\n        # >>> game.board\\n        # [[' ', 'B', 'C'], ['B', ' ', 'C'], ['C', 'B', 'A']]\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n        self.board[x1][y1] = ' '\\n        self.board[x2][y2] = ' '\\n\\n    def is_game_over(self):\\n        # Check if the game is over by verifying if there are any icons left on the board.\\n        # return: bool, True if the game is over, False otherwise\\n        # >>> game = MahjongConnect((2, 2), ['A', 'B'])\\n        # >>> game.board = [[' ', ' '], [' ', ' ']]\\n        # >>> game.is_game_over()\\n        # True\\n        for row in self.board:\\n            if any(icon != ' ' for icon in row):\\n                return False\\n        return True\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1727077548,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1c141eb703\",\n  \"usage\": {\n    \"completion_tokens\": 1514,\n    \"prompt_tokens\": 1487,\n    \"total_tokens\": 3001,\n    \"prompt_cache_hit_tokens\": 576,\n    \"prompt_cache_miss_tokens\": 911\n  }\n}", "test_case_name": "MahjongConnect.txt"}