{"response body": "{\n  \"id\": \"ad4a2645-ac81-45f4-998f-4444062a51b2\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\n\\\"\\\"\\\"\\nThis class provides utility functions for managing and querying calendar events.\\nIt allows adding, removing, and retrieving events, checking availability, and finding available time slots.\\n\\\"\\\"\\\"\\n\\nfrom datetime import datetime, timedelta\\n\\nclass CalendarUtil:\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Initializes the CalendarUtil class with an empty list of events.\\n        \\\"\\\"\\\"\\n        self.events = []\\n\\n    def add_event(self, event):\\n        \\\"\\\"\\\"\\n        Adds an event to the calendar.\\n\\n        Parameters:\\n            event (dict): A dictionary representing the event with keys 'date', 'start_time', and 'end_time'.\\n\\n        Test cases:\\n            # Test case 1: Add a valid event\\n            calendar = CalendarUtil()\\n            event = {'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)}\\n            calendar.add_event(event)\\n            assert len(calendar.events) == 1\\n\\n            # Test case 2: Add another event\\n            event2 = {'date': datetime(2023, 10, 2), 'start_time': datetime(2023, 10, 2, 12, 0), 'end_time': datetime(2023, 10, 2, 13, 0)}\\n            calendar.add_event(event2)\\n            assert len(calendar.events) == 2\\n\\n            # Test case 3: Add an event with missing keys (should raise an error)\\n            try:\\n                event3 = {'date': datetime(2023, 10, 3)}\\n                calendar.add_event(event3)\\n            except KeyError:\\n                assert True\\n        \\\"\\\"\\\"\\n        self.events.append(event)\\n\\n    def remove_event(self, event):\\n        \\\"\\\"\\\"\\n        Removes an event from the calendar.\\n\\n        Parameters:\\n            event (dict): The event to remove.\\n\\n        Test cases:\\n            # Test case 1: Remove an existing event\\n            calendar = CalendarUtil()\\n            event = {'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)}\\n            calendar.add_event(event)\\n            calendar.remove_event(event)\\n            assert len(calendar.events) == 0\\n\\n            # Test case 2: Remove a non-existing event\\n            event2 = {'date': datetime(2023, 10, 2), 'start_time': datetime(2023, 10, 2, 12, 0), 'end_time': datetime(2023, 10, 2, 13, 0)}\\n            calendar.remove_event(event2)\\n            assert len(calendar.events) == 0\\n\\n            # Test case 3: Remove an event with missing keys (should raise an error)\\n            try:\\n                event3 = {'date': datetime(2023, 10, 3)}\\n                calendar.remove_event(event3)\\n            except KeyError:\\n                assert True\\n        \\\"\\\"\\\"\\n        if event in self.events:\\n            self.events.remove(event)\\n\\n    def get_events(self, date):\\n        \\\"\\\"\\\"\\n        Retrieves all events on a specific date.\\n\\n        Parameters:\\n            date (datetime): The date to retrieve events for.\\n\\n        Returns:\\n            list: A list of events on the specified date.\\n\\n        Test cases:\\n            # Test case 1: Retrieve events on a date with events\\n            calendar = CalendarUtil()\\n            event = {'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)}\\n            calendar.add_event(event)\\n            events = calendar.get_events(datetime(2023, 10, 1))\\n            assert len(events) == 1\\n\\n            # Test case 2: Retrieve events on a date without events\\n            events = calendar.get_events(datetime(2023, 10, 2))\\n            assert len(events) == 0\\n\\n            # Test case 3: Retrieve events with an invalid date (should raise an error)\\n            try:\\n                events = calendar.get_events('invalid_date')\\n            except AttributeError:\\n                assert True\\n        \\\"\\\"\\\"\\n        events_on_date = []\\n        for event in self.events:\\n            if event['date'].date() == date.date():\\n                events_on_date.append(event)\\n        return events_on_date\\n\\n    def is_available(self, start_time, end_time):\\n        \\\"\\\"\\\"\\n        Checks if a time slot is available.\\n\\n        Parameters:\\n            start_time (datetime): The start time of the slot.\\n            end_time (datetime): The end time of the slot.\\n\\n        Returns:\\n            bool: True if the slot is available, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Check an available slot\\n            calendar = CalendarUtil()\\n            event = {'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)}\\n            calendar.add_event(event)\\n            assert calendar.is_available(datetime(2023, 10, 1, 12, 0), datetime(2023, 10, 1, 13, 0)) == True\\n\\n            # Test case 2: Check an unavailable slot\\n            assert calendar.is_available(datetime(2023, 10, 1, 10, 30), datetime(2023, 10, 1, 11, 30)) == False\\n\\n            # Test case 3: Check a slot with invalid time (should raise an error)\\n            try:\\n                calendar.is_available('invalid_time', datetime(2023, 10, 1, 12, 0))\\n            except TypeError:\\n                assert True\\n        \\\"\\\"\\\"\\n        for event in self.events:\\n            if start_time < event['end_time'] and end_time > event['start_time']:\\n                return False\\n        return True\\n\\n    def get_available_slots(self, date):\\n        \\\"\\\"\\\"\\n        Retrieves all available time slots on a specific date.\\n\\n        Parameters:\\n            date (datetime): The date to retrieve available slots for.\\n\\n        Returns:\\n            list: A list of tuples representing available slots, each tuple containing (start_time, end_time).\\n\\n        Test cases:\\n            # Test case 1: Retrieve available slots on a date with no events\\n            calendar = CalendarUtil()\\n            slots = calendar.get_available_slots(datetime(2023, 10, 1))\\n            assert len(slots) == 24\\n\\n            # Test case 2: Retrieve available slots on a date with events\\n            event = {'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)}\\n            calendar.add_event(event)\\n            slots = calendar.get_available_slots(datetime(2023, 10, 1))\\n            assert len(slots) == 23\\n\\n            # Test case 3: Retrieve available slots with an invalid date (should raise an error)\\n            try:\\n                slots = calendar.get_available_slots('invalid_date')\\n            except AttributeError:\\n                assert True\\n        \\\"\\\"\\\"\\n        available_slots = []\\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\\n\\n        while start_time < end_time:\\n            slot_end_time = start_time + timedelta(minutes=60)\\n            if self.is_available(start_time, slot_end_time):\\n                available_slots.append((start_time, slot_end_time))\\n            start_time += timedelta(minutes=60)\\n\\n        return available_slots\\n\\n    def get_upcoming_events(self, num_events):\\n        \\\"\\\"\\\"\\n        Retrieves the next upcoming events.\\n\\n        Parameters:\\n            num_events (int): The number of upcoming events to retrieve.\\n\\n        Returns:\\n            list: A list of the next upcoming events.\\n\\n        Test cases:\\n            # Test case 1: Retrieve upcoming events when there are enough events\\n            calendar = CalendarUtil()\\n            event1 = {'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)}\\n            event2 = {'date': datetime(2023, 10, 2), 'start_time': datetime(2023, 10, 2, 12, 0), 'end_time': datetime(2023, 10, 2, 13, 0)}\\n            calendar.add_event(event1)\\n            calendar.add_event(event2)\\n            upcoming_events = calendar.get_upcoming_events(2)\\n            assert len(upcoming_events) == 2\\n\\n            # Test case 2: Retrieve upcoming events when there are fewer events than requested\\n            upcoming_events = calendar.get_upcoming_events(3)\\n            assert len(upcoming_events) == 2\\n\\n            # Test case 3: Retrieve upcoming events with an invalid number (should raise an error)\\n            try:\\n                upcoming_events = calendar.get_upcoming_events('invalid_number')\\n            except TypeError:\\n                assert True\\n        \\\"\\\"\\\"\\n        now = datetime.now()\\n        upcoming_events = []\\n        for event in self.events:\\n            if event['start_time'] >= now:\\n                upcoming_events.append(event)\\n            if len(upcoming_events) == num_events:\\n                break\\n        return upcoming_events\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1735193712,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1a5c54ff19\",\n  \"usage\": {\n    \"completion_tokens\": 2126,\n    \"prompt_tokens\": 1504,\n    \"total_tokens\": 3630,\n    \"prompt_cache_hit_tokens\": 960,\n    \"prompt_cache_miss_tokens\": 544\n  }\n}", "test_case_name": "CalendarUtil.txt"}