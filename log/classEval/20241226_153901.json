{"response body": {"id": "2b7245cd-966d-45c1-8afd-e6712cb57c48", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-12-26 15:39:05", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "\"\"\"\nThis class implements a simple Email Client with features such as sending and receiving emails, checking inbox capacity and clearing the inbox.\n\"\"\"\nfrom datetime import datetime\n\nclass EmailClient:\n    def __init__(self, addr: str, capacity: int) -> None:\n        \"\"\"\n        Initializes an EmailClient instance.\n\n        Parameters:\n            addr (str): The email address of this client.\n            capacity (int): The maximum storage capacity of the client's inbox.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n    \n    def send_to(self, recv, content: str, size: int) -> bool:\n        \"\"\"\n        Sends an email to another EmailClient.\n\n        Parameters:\n            recv (EmailClient): The recipient EmailClient.\n            content (str): The content of the email.\n            size (int): The size of the email.\n\n        Returns:\n            bool: True if the email is successfully sent, False otherwise.\n\n        Test cases:\n            # Test case 1: Successful sending\n            client1 = EmailClient(\"client1@example.com\", 100)\n            client2 = EmailClient(\"client2@example.com\", 100)\n            assert client1.send_to(client2, \"Hello, Client2!\", 10) == True\n\n            # Test case 2: Recipient's inbox is full\n            client1 = EmailClient(\"client1@example.com\", 100)\n            client2 = EmailClient(\"client2@example.com\", 10)\n            assert client1.send_to(client2, \"Hello, Client2!\", 20) == False\n\n            # Test case 3: Sender's inbox is full but can be cleared\n            client1 = EmailClient(\"client1@example.com\", 100)\n            client2 = EmailClient(\"client2@example.com\", 100)\n            client1.inbox = [{\"size\": 80}] * 2  # Fill the inbox\n            assert client1.send_to(client2, \"Hello, Client2!\", 20) == True\n        \"\"\"\n        if not recv.is_full_with_one_more_email(size):\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n    \n    def fetch(self):\n        \"\"\"\n        Fetches the first unread email from the inbox and marks it as read.\n\n        Returns:\n            dict: The fetched email. None if there are no unread emails.\n\n        Test cases:\n            # Test case 1: Fetching an unread email\n            client = EmailClient(\"client@example.com\", 100)\n            client.inbox = [{\"state\": \"unread\", \"content\": \"Hello!\"}]\n            assert client.fetch() == {\"state\": \"read\", \"content\": \"Hello!\"}\n\n            # Test case 2: Fetching when all emails are read\n            client = EmailClient(\"client@example.com\", 100)\n            client.inbox = [{\"state\": \"read\", \"content\": \"Hello!\"}]\n            assert client.fetch() == None\n\n            # Test case 3: Fetching when the inbox is empty\n            client = EmailClient(\"client@example.com\", 100)\n            assert client.fetch() == None\n        \"\"\"\n        if len(self.inbox) == 0:\n            return None\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == \"unread\":\n                self.inbox[i]['state'] = \"read\"\n                return self.inbox[i]\n        return None\n\n    def is_full_with_one_more_email(self, size: int) -> bool:\n        \"\"\"\n        Checks if the inbox can accommodate one more email of a given size.\n\n        Parameters:\n            size (int): The size of the email.\n\n        Returns:\n            bool: True if the inbox is full, False otherwise.\n\n        Test cases:\n            # Test case 1: Inbox has enough space\n            client = EmailClient(\"client@example.com\", 100)\n            assert client.is_full_with_one_more_email(50) == False\n\n            # Test case 2: Inbox is full\n            client = EmailClient(\"client@example.com\", 100)\n            client.inbox = [{\"size\": 100}]\n            assert client.is_full_with_one_more_email(1) == True\n\n            # Test case 3: Inbox is exactly full with one more email\n            client = EmailClient(\"client@example.com\", 100)\n            client.inbox = [{\"size\": 90}]\n            assert client.is_full_with_one_more_email(10) == False\n        \"\"\"\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False\n        \n    def get_occupied_size(self) -> int:\n        \"\"\"\n        Gets the total size of all emails in the inbox.\n\n        Returns:\n            int: The total size of all emails in the inbox.\n\n        Test cases:\n            # Test case 1: Inbox with multiple emails\n            client = EmailClient(\"client@example.com\", 100)\n            client.inbox = [{\"size\": 10}, {\"size\": 20}, {\"size\": 30}]\n            assert client.get_occupied_size() == 60\n\n            # Test case 2: Empty inbox\n            client = EmailClient(\"client@example.com\", 100)\n            assert client.get_occupied_size() == 0\n\n            # Test case 3: Inbox with one email\n            client = EmailClient(\"client@example.com\", 100)\n            client.inbox = [{\"size\": 50}]\n            assert client.get_occupied_size() == 50\n        \"\"\"\n        occupied_size = 0\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        return occupied_size\n\n    def clear_inbox(self, size: int) -> None:\n        \"\"\"\n        Clears the inbox to make space for a new email of a given size.\n\n        Parameters:\n            size (int): The size of the new email.\n\n        Test cases:\n            # Test case 1: Clear enough space for a new email\n            client = EmailClient(\"client@example.com\", 100)\n            client.inbox = [{\"size\": 50}, {\"size\": 50}, {\"size\": 50}]\n            client.clear_inbox(50)\n            assert client.get_occupied_size() == 50\n\n            # Test case 2: Clear an empty inbox\n            client = EmailClient(\"client@example.com\", 100)\n            client.clear_inbox(50)\n            assert client.get_occupied_size() == 0\n\n            # Test case 3: Clear a full inbox\n            client = EmailClient(\"client@example.com\", 100)\n            client.inbox = [{\"size\": 50}, {\"size\": 50}]\n            client.clear_inbox(50)\n            assert client.get_occupied_size() == 0\n        \"\"\"\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]"}}], "usage": {"completion_tokens": 1524, "prompt_tokens": 1468, "total_tokens": 2992}, "feeType": "1", "consume": 1.968976}, "test_case_name": "EmailClient.txt"}