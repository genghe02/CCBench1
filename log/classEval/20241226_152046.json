{"response body": {"id": "65c95cee-ef7a-4b75-bd11-d31dc5d21a1c", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-12-26 15:20:49", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "\"\"\"\nThis class provides functionality to evaluate mathematical expressions using basic operations (addition, subtraction,\nmultiplication, division, exponentiation) with proper operator precedence and parentheses support.\n\"\"\"\n\nclass Calculator:\n    def __init__(self):\n        \"\"\"\n        Initialization method that sets up the dictionary of operator functions.\n        \n        This dictionary maps operator symbols to their corresponding mathematical operations.\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Evaluates the given mathematical expression.\n\n        Parameters:\n            expression (str): A string representing a mathematical expression with numbers, operators and parentheses.\n        \n        Returns:\n            float: The result of evaluating the expression. Returns None if the expression is invalid.\n        \n        Test cases:\n            # Test case 1: Normal usage with all operators and parentheses\n            assert calculate(\"2+3*4^2/(1-5)^2\") == -4.0\n            \n            # Test case 2: Expression with floating point numbers\n            assert calculate(\"1.5*3\") == 4.5\n            \n            # Test case 3: Invalid expression\n            assert calculate(\"2+3*\") == None\n        \"\"\"\n\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        for char in expression:\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n\n                if char in '+-*/^':\n                    while (\n                            operator_stack and\n                            operator_stack[-1] != '(' and\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\n                    ):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n                    operator_stack.append(char)\n                elif char == '(':\n                    operator_stack.append(char)\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n                    operator_stack.pop()\n\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the precedence of the given operator.\n        \n        Parameters:\n            operator (str): A string representing a mathematical operator.\n            \n        Returns:\n            int: The precedence of the operator. Higher number means higher precedence.\n            \n        Test cases:\n            # Test case 1: High precedence operator\n            assert precedence('^') == 3\n            \n            # Test case 2: Low precedence operator\n            assert precedence('+') == 1\n            \n            # Test case 3: Non-operator character\n            assert precedence('a') == 0\n        \"\"\"\n        precedences = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Pops the top two operands and the top operator from their respective stacks, applies the operator to the operands,\n        and pushes the result back onto the operand stack.\n        \n        Parameters:\n            operand_stack (list): A list of operands (numbers).\n            operator_stack (list): A list of operators.\n            \n        Returns:\n            tuple: A tuple containing the updated operand stack and operator stack.\n            \n        Test cases:\n            # Test case 1: Apply addition operator\n            operand_stack = [1, 2], operator_stack = ['+']\n            apply_operator(operand_stack, operator_stack) should return ([3], [])\n            \n            # Test case 2: Apply multiplication operator\n            operand_stack = [2, 3], operator_stack = ['*']\n            apply_operator(operand_stack, operator_stack) should return ([6], [])\n            \n            # Test case 3: Apply exponentiation operator\n            operand_stack = [2, 3], operator_stack = ['^']\n            apply_operator(operand_stack, operator_stack) should return ([8], [])\n        \"\"\"\n        operator = operator_stack.pop()\n        if operator == '^':\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        else:\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = self.operators[operator](operand1, operand2)\n            operand_stack.append(result)\n        return operand_stack, operator_stack"}}], "usage": {"completion_tokens": 1025, "prompt_tokens": 1540, "total_tokens": 2565}, "feeType": "1", "consume": 1.56524}, "test_case_name": "Calculator.txt"}