{"response body": {"id": "73ea5794-753b-4b15-96cc-17e9b6ed4e1e", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-12-26 16:10:17", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "\"\"\"\nThis class provides a utility for generating SQL statements for a specified table.\n\"\"\"\n\nclass SQLGenerator:\n    def __init__(self, table_name):\n        \"\"\"\n        Initialization method for the SQLGenerator class.\n\n        Parameters:\n            table_name (str): The name of the table to generate SQL statements for.\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generate a SQL SELECT statement for the specified fields and condition.\n\n        Parameters:\n            fields (list of str): The fields to select. If None, selects all fields.\n            condition (str): The WHERE clause condition. If None, no condition is applied.\n        \n        Returns:\n            str: The generated SQL SELECT statement.\n        \n        Test cases:\n            # Test case 1: Select all fields with no condition\n            assert select() == \"SELECT * FROM table_name;\"\n\n            # Test case 2: Select specific fields with no condition\n            assert select(['field1', 'field2']) == \"SELECT field1, field2 FROM table_name;\"\n\n            # Test case 3: Select all fields with a condition\n            assert select(condition=\"field1 = 'value'\") == \"SELECT * FROM table_name WHERE field1 = 'value';\"\n        \"\"\"\n        if fields is None:\n            fields = \"*\"\n        else:\n            fields = \", \".join(fields)\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        \"\"\"\n        Generate a SQL INSERT statement for the specified data.\n\n        Parameters:\n            data (dict): The data to insert, with field names as keys and values as values.\n        \n        Returns:\n            str: The generated SQL INSERT statement.\n        \n        Test cases:\n            # Test case 1: Insert data with one field\n            assert insert({'field1': 'value1'}) == \"INSERT INTO table_name (field1) VALUES ('value1');\"\n\n            # Test case 2: Insert data with multiple fields\n            assert insert({'field1': 'value1', 'field2': 'value2'}) == \"INSERT INTO table_name (field1, field2) VALUES ('value1', 'value2');\"\n        \"\"\"\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generate a SQL UPDATE statement for the specified data and condition.\n\n        Parameters:\n            data (dict): The data to update, with field names as keys and new values as values.\n            condition (str): The WHERE clause condition for the update.\n        \n        Returns:\n            str: The generated SQL UPDATE statement.\n        \n        Test cases:\n            # Test case 1: Update one field with a condition\n            assert update({'field1': 'new_value1'}, \"field1 = 'value1'\") == \"UPDATE table_name SET field1 = 'new_value1' WHERE field1 = 'value1';\"\n\n            # Test case 2: Update multiple fields with a condition\n            assert update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field1 = 'value1' AND field2 = 'value2'\") == \"UPDATE table_name SET field1 = 'new_value1', field2 = 'new_value2' WHERE field1 = 'value1' AND field2 = 'value2';\"\n        \"\"\"\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        return sql + \";\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generate a SQL DELETE statement for the specified condition.\n\n        Parameters:\n            condition (str): The WHERE clause condition for the deletion.\n        \n        Returns:\n            str: The generated SQL DELETE statement.\n        \n        Test cases:\n            # Test case 1: Delete records with a condition\n            assert delete(\"field1 = 'value1'\") == \"DELETE FROM table_name WHERE field1 = 'value1';\"\n        \"\"\"\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generate a SQL SELECT statement for females under the specified age.\n\n        Parameters:\n            age (int): The age threshold.\n        \n        Returns:\n            str: The generated SQL SELECT statement.\n        \n        Test cases:\n            # Test case 1: Select females under age 20\n            assert select_female_under_age(20) == \"SELECT * FROM table_name WHERE age < 20 AND gender = 'female';\"\n        \"\"\"\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generate a SQL SELECT statement for records within the specified age range.\n\n        Parameters:\n            min_age (int): The minimum age.\n            max_age (int): The maximum age.\n        \n        Returns:\n            str: The generated SQL SELECT statement.\n        \n        Test cases:\n            # Test case 1: Select records between ages 20 and 30\n            assert select_by_age_range(20, 30) == \"SELECT * FROM table_name WHERE age BETWEEN 20 AND 30;\"\n        \"\"\"\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)"}}], "usage": {"completion_tokens": 1197, "prompt_tokens": 1473, "total_tokens": 2670}, "feeType": "1", "consume": 1.686012}, "test_case_name": "SQLGenerator.txt"}