{"response body": {"id": "b3ab6d6c-033c-4b0b-a670-a7ec955e3e4e", "object": "chat.completion", "model": "gpt-35-turbo", "created": "2024-09-23 13:54:16", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "from datetime import datetime\n\nclass EmailClient:\n    # This class represents an Email Client with the ability to send and receive emails.\n\n    def __init__(self, addr, capacity) -> None:\n        # Initializes an instance of EmailClient with a given address and capacity for the inbox.\n        # :param addr: str, the address associated with the EmailClient\n        # :param capacity: int, the maximum capacity of the inbox\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        # Sends an email to the specified recipient if space is available in the recipient's inbox.\n        # :param recv: EmailClient, the recipient EmailClient to send the email to\n        # :param content: str, the content of the email\n        # :param size: int, the size of the email in bytes\n        # :return: bool, True if the email was successfully sent, False if inbox was full\n        # Test cases:\n        # - Sending email to a recipient with available space\n        # - Clearing inbox if recipient's inbox is full\n        if not recv.is_full_with_one_more_email(size):\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        # Fetches the first unread email from the inbox, marks it as read, and returns it.\n        # :return: dict, the email object if found, None otherwise\n        # Test cases:\n        # - Fetching the first unread email\n        # - No unread emails in the inbox\n        if len(self.inbox) == 0:\n            return None\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == \"unread\":\n                self.inbox[i]['state'] = \"read\"\n                return self.inbox[i]\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        # Checks if adding an email of a certain size would exceed the inbox capacity.\n        # :param size: int, the size of the email to be added\n        # :return: bool, True if adding the email would exceed capacity, False otherwise\n        # Test cases:\n        # - Inbox is full with one more email\n        # - Inbox has space for one more email\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        # Computes the total size occupied by emails in the inbox.\n        # :return: int, the total occupied size in bytes\n        # Test cases:\n        # - Calculating total occupied size in an empty inbox\n        # - Calculating total occupied size in a non-empty inbox\n        occupied_size = 0\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        return occupied_size\n\n    def clear_inbox(self, size):\n        # Clears emails from the inbox to free up space based on the specified size.\n        # :param size: int, the size of emails to clear from the inbox\n        # Test cases:\n        # - Clearing emails based on the given size\n        # - No emails to clear\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]"}}], "usage": {"completion_tokens": 804, "prompt_tokens": 1063, "total_tokens": 1867}, "feeType": "1", "consume": 0.0126189343}, "test_case_name": "EmailClient.txt"}