{"response body": {"id": "34b6cac9-96e3-43e3-9b77-b557c7a959bc", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-09-23 19:01:25", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "```python\nimport random\n\n# This class represents a game of Mahjong Connect. It includes methods to create the game board, validate moves, check for a path between two positions, remove matched icons, and check if the game is over.\nclass MahjongConnect:\n    # Initializes a MahjongConnect object with a specific board size and set of icons.\n    # param BOARD_SIZE: tuple, the size of the game board (height, width)\n    # param ICONS: list, the icons used in the game\n    # >>> game = MahjongConnect((5, 5), ['A', 'B', 'C', 'D', 'E'])\n    # >>> print(game.BOARD_SIZE)\n    # (5, 5)\n    # >>> print(game.ICONS)\n    # ['A', 'B', 'C', 'D', 'E']\n    def __init__(self, BOARD_SIZE, ICONS):\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    # Creates a random game board with given size and icons.\n    # return: list of lists, the game board\n    # >>> game = MahjongConnect((2, 2), ['A', 'B'])\n    # >>> game.create_board()\n    # [['A', 'B'], ['B', 'A']]\n    def create_board(self):\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    # Checks if a move is valid, i.e., the two positions are within the board, different, have the same icon, and have a path between them.\n    # param pos1: tuple, the first position (x1, y1)\n    # param pos2: tuple, the second position (x2, y2)\n    # return: bool, True if the move is valid, False otherwise\n    # >>> game = MahjongConnect((3, 3), ['A', 'B'])\n    # >>> game.is_valid_move((0, 0), (0, 1))\n    # False\n    # >>> game.is_valid_move((0, 0), (0, 0))\n    # False\n    def is_valid_move(self, pos1, pos2):\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within the game board range\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 <\n                self.BOARD_SIZE[1]):\n            return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True\n\n    # Checks if there is a path between two positions with the same icon.\n    # param pos1: tuple, the first position (x1, y1)\n    # param pos2: tuple, the second position (x2, y2)\n    # return: bool, True if there is a path, False otherwise\n    # >>> game = MahjongConnect((3, 3), ['A', 'B'])\n    # >>> game.has_path((0, 0), (0, 1))\n    # False\n    def has_path(self, pos1, pos2):\n        visited = set()\n        stack = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Check adjacent positions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n\n        return False\n\n    # Removes the icons at two positions from the game board.\n    # param pos1: tuple, the first position (x1, y1)\n    # param pos2: tuple, the second position (x2, y2)\n    # >>> game = MahjongConnect((3, 3), ['A', 'B'])\n    # >>> game.remove_icons((0, 0), (0, 1))\n    # >>> print(game.board)\n    # [[' ', ' ', 'B'], ['A', 'B', 'A'], ['B', 'A', 'B']]\n    def remove_icons(self, pos1, pos2):\n        x1, y1 = pos1\n        x2, y2 = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n    # Checks if the game is over, i.e., all icons have been removed from the game board.\n    # return: bool, True if the game is over, False otherwise\n    # >>> game = MahjongConnect((3, 3), ['A', 'B'])\n    # >>> game.remove_icons((0, 0), (0, 1))\n    # >>> game.remove_icons((1, 0), (1, 1))\n    # >>> game.remove_icons((2, 0), (2, 1))\n    # >>> print(game.is_game_over())\n    # False\n    def is_game_over(self):\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True\n```"}}], "usage": {"completion_tokens": 1326, "prompt_tokens": 1301, "total_tokens": 2627}, "feeType": "1", "consume": 1.723508}, "test_case_name": "MahjongConnect.txt"}