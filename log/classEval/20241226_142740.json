{"response body": "{\n  \"id\": \"2c785fab-edea-4ad6-b7ad-62c7d81c437d\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\n\\\"\\\"\\\"\\nThis class implements a Mahjong Connect game, which involves matching pairs of icons on a game board.\\nThe class provides methods to create the game board, validate moves, check for valid paths between icons,\\nremove matched icons, and determine if the game is over.\\n\\\"\\\"\\\"\\n\\nimport random\\n\\n\\nclass MahjongConnect:\\n    def __init__(self, BOARD_SIZE, ICONS):\\n        \\\"\\\"\\\"\\n        Initializes the Mahjong Connect game with a specified board size and set of icons.\\n\\n        Parameters:\\n            BOARD_SIZE (tuple): A tuple (rows, cols) representing the dimensions of the game board.\\n            ICONS (list): A list of strings representing the icons to be used on the board.\\n\\n        Test cases:\\n            # Test case 1: Initialize with a 5x5 board and 4 icons\\n            game = MahjongConnect((5, 5), ['A', 'B', 'C', 'D'])\\n            assert game.BOARD_SIZE == (5, 5)\\n            assert game.ICONS == ['A', 'B', 'C', 'D']\\n\\n            # Test case 2: Initialize with a 3x3 board and 2 icons\\n            game = MahjongConnect((3, 3), ['X', 'Y'])\\n            assert game.BOARD_SIZE == (3, 3)\\n            assert game.ICONS == ['X', 'Y']\\n\\n            # Test case 3: Initialize with a 1x1 board and 1 icon\\n            game = MahjongConnect((1, 1), ['Z'])\\n            assert game.BOARD_SIZE == (1, 1)\\n            assert game.ICONS == ['Z']\\n        \\\"\\\"\\\"\\n        self.BOARD_SIZE = BOARD_SIZE\\n        self.ICONS = ICONS\\n        self.board = self.create_board()\\n\\n    def create_board(self):\\n        \\\"\\\"\\\"\\n        Creates a game board filled with randomly chosen icons.\\n\\n        Returns:\\n            list: A 2D list representing the game board with randomly placed icons.\\n\\n        Test cases:\\n            # Test case 1: Create a 2x2 board with 2 icons\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            board = game.create_board()\\n            assert len(board) == 2\\n            assert all(len(row) == 2 for row in board)\\n\\n            # Test case 2: Create a 3x3 board with 3 icons\\n            game = MahjongConnect((3, 3), ['X', 'Y', 'Z'])\\n            board = game.create_board()\\n            assert len(board) == 3\\n            assert all(len(row) == 3 for row in board)\\n\\n            # Test case 3: Create a 1x1 board with 1 icon\\n            game = MahjongConnect((1, 1), ['Z'])\\n            board = game.create_board()\\n            assert len(board) == 1\\n            assert len(board[0]) == 1\\n        \\\"\\\"\\\"\\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\\n        return board\\n\\n    def is_valid_move(self, pos1, pos2):\\n        \\\"\\\"\\\"\\n        Validates if a move between two positions is valid.\\n\\n        Parameters:\\n            pos1 (tuple): A tuple (x1, y1) representing the first position.\\n            pos2 (tuple): A tuple (x2, y2) representing the second position.\\n\\n        Returns:\\n            bool: True if the move is valid, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Valid move with matching icons\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['A', 'B']]\\n            assert game.is_valid_move((0, 0), (1, 0)) == True\\n\\n            # Test case 2: Invalid move with non-matching icons\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['A', 'B']]\\n            assert game.is_valid_move((0, 0), (0, 1)) == False\\n\\n            # Test case 3: Invalid move with positions out of bounds\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['A', 'B']]\\n            assert game.is_valid_move((0, 0), (2, 2)) == False\\n        \\\"\\\"\\\"\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n\\n        # Check if positions are within the game board range\\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\\n            0] and 0 <= y2 <\\n                self.BOARD_SIZE[1]):\\n            return False\\n\\n        # Check if the two positions are the same\\n        if pos1 == pos2:\\n            return False\\n\\n        # Check if the two positions have the same icon\\n        if self.board[x1][y1] != self.board[x2][y2]:\\n            return False\\n\\n        # Check if there is a valid path between the two positions\\n        if not self.has_path(pos1, pos2):\\n            return False\\n\\n        return True\\n\\n    def has_path(self, pos1, pos2):\\n        \\\"\\\"\\\"\\n        Checks if there is a valid path between two positions on the board.\\n\\n        Parameters:\\n            pos1 (tuple): A tuple (x1, y1) representing the first position.\\n            pos2 (tuple): A tuple (x2, y2) representing the second position.\\n\\n        Returns:\\n            bool: True if a valid path exists, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Path exists between adjacent positions\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['A', 'B']]\\n            assert game.has_path((0, 0), (1, 0)) == True\\n\\n            # Test case 2: No path exists between positions\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['B', 'A']]\\n            assert game.has_path((0, 0), (1, 1)) == False\\n\\n            # Test case 3: Path exists through multiple steps\\n            game = MahjongConnect((3, 3), ['A', 'B'])\\n            game.board = [['A', 'A', 'B'], ['A', 'B', 'B'], ['B', 'A', 'A']]\\n            assert game.has_path((0, 0), (2, 2)) == True\\n        \\\"\\\"\\\"\\n        visited = set()\\n        stack = [pos1]\\n\\n        while stack:\\n            current_pos = stack.pop()\\n            if current_pos == pos2:\\n                return True\\n\\n            if current_pos in visited:\\n                continue\\n\\n            visited.add(current_pos)\\n            x, y = current_pos\\n\\n            # Check adjacent positions (up, down, left, right)\\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\\n                        stack.append((new_x, new_y))\\n\\n        return False\\n\\n    def remove_icons(self, pos1, pos2):\\n        \\\"\\\"\\\"\\n        Removes the icons at the specified positions from the board.\\n\\n        Parameters:\\n            pos1 (tuple): A tuple (x1, y1) representing the first position.\\n            pos2 (tuple): A tuple (x2, y2) representing the second position.\\n\\n        Test cases:\\n            # Test case 1: Remove icons at valid positions\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['A', 'B']]\\n            game.remove_icons((0, 0), (1, 0))\\n            assert game.board == [[' ', 'B'], [' ', 'B']]\\n\\n            # Test case 2: Remove icons at the same position (invalid)\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['A', 'B']]\\n            game.remove_icons((0, 0), (0, 0))\\n            assert game.board == [['A', 'B'], ['A', 'B']]\\n\\n            # Test case 3: Remove icons at out-of-bounds positions (invalid)\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['A', 'B']]\\n            game.remove_icons((0, 0), (2, 2))\\n            assert game.board == [['A', 'B'], ['A', 'B']]\\n        \\\"\\\"\\\"\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n        self.board[x1][y1] = ' '\\n        self.board[x2][y2] = ' '\\n\\n    def is_game_over(self):\\n        \\\"\\\"\\\"\\n        Checks if the game is over by verifying if all icons have been removed from the board.\\n\\n        Returns:\\n            bool: True if the game is over, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Game is not over\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [['A', 'B'], ['A', 'B']]\\n            assert game.is_game_over() == False\\n\\n            # Test case 2: Game is over\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [[' ', ' '], [' ', ' ']]\\n            assert game.is_game_over() == True\\n\\n            # Test case 3: Game is partially over\\n            game = MahjongConnect((2, 2), ['A', 'B'])\\n            game.board = [[' ', 'B'], [' ', ' ']]\\n            assert game.is_game_over() == False\\n        \\\"\\\"\\\"\\n        for row in self.board:\\n            if any(icon != ' ' for icon in row):\\n                return False\\n        return True\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1735194429,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1a5c54ff19\",\n  \"usage\": {\n    \"completion_tokens\": 2318,\n    \"prompt_tokens\": 1732,\n    \"total_tokens\": 4050,\n    \"prompt_cache_hit_tokens\": 960,\n    \"prompt_cache_miss_tokens\": 772\n  }\n}", "test_case_name": "MahjongConnect.txt"}