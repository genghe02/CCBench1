{"response body": {"id": "da7d1e76-c4d3-4661-a968-6aabaf12dbaa", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-09-23 19:39:08", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "```python\n# This class provides multiple methods to decipher encrypted text using different decryption algorithms.\nclass DecryptionUtils:\n    def __init__(self, key):\n        # Constructor for the DecryptionUtils class.\n        # param key: str, The key used for decryption.\n        self.key = key\n    \n    def caesar_decipher(self, ciphertext, shift):\n        # This method uses the Caesar cipher to decipher the given encrypted text.\n        # param ciphertext: str, The encrypted text to be deciphered.\n        # param shift: int, The number of places by which each letter in the plaintext is shifted down the alphabet.\n        # return: str, The decrypted/plain text.\n        # test cases:\n        # >>> decrypt = DecryptionUtils('key')\n        # >>> decrypt.caesar_decipher('CDE', 2)\n        # 'ABC'\n        plaintext = \"\"\n        for char in ciphertext:\n            if char.isalpha():\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n                plaintext += shifted_char\n            else:\n                plaintext += char\n        return plaintext\n    \n    def vigenere_decipher(self, ciphertext):\n        # This method uses the Vigen\u00e8re cipher to decipher the given encrypted text.\n        # param ciphertext: str, The encrypted text to be deciphered.\n        # return: str, The decrypted/plain text.\n        # test cases:\n        # >>> decrypt = DecryptionUtils('key')\n        # >>> decrypt.vigenere_decipher('DAHJ')\n        # 'CAES'\n        decrypted_text = \"\"\n        key_index = 0\n        for char in ciphertext:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n                key_index += 1\n            else:\n                decrypted_text += char\n        return decrypted_text\n    \n    def rail_fence_decipher(self, encrypted_text, rails):\n        # This method uses the Rail Fence cipher to decipher the given encrypted text.\n        # param encrypted_text: str, The encrypted text to be deciphered.\n        # param rails: int, The number of rails used in the Rail Fence cipher.\n        # return: str, The decrypted/plain text.\n        # test cases:\n        # >>> decrypt = DecryptionUtils('key')\n        # >>> decrypt.rail_fence_decipher('HWEAESRO', 3)\n        # 'HELLOSAW'\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            fence[row][col] = ''\n            col += 1\n            row += direction\n\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n\n        plain_text = ''\n        direction = -1\n        row, col = 0, 0\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n\n        return plain_text\n```\n"}}], "usage": {"completion_tokens": 785, "prompt_tokens": 1116, "total_tokens": 1901}, "feeType": "1", "consume": 1.171096}, "test_case_name": "DecryptionUtils.txt"}