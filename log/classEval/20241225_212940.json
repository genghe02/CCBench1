{"response body": "ChatCompletion(id='chatcmpl-AiLjpGzo6nztbNDe9OKU6sSNo03rX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```python\\n\"\"\"\\nThis class provides utilities for processing and extracting information from HTML content.\\n\"\"\"\\n\\nimport re\\nimport string\\nimport gensim\\nfrom bs4 import BeautifulSoup\\n\\n\\nclass HtmlUtil:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initializes the HtmlUtil instance with predefined markers for various content types.\\n        \"\"\"\\n        self.SPACE_MARK = \\'-SPACE-\\'\\n        self.JSON_MARK = \\'-JSON-\\'\\n        self.MARKUP_LANGUAGE_MARK = \\'-MARKUP_LANGUAGE-\\'\\n        self.URL_MARK = \\'-URL-\\'\\n        self.NUMBER_MARK = \\'-NUMBER-\\'\\n        self.TRACE_MARK = \\'-TRACE-\\'\\n        self.COMMAND_MARK = \\'-COMMAND-\\'\\n        self.COMMENT_MARK = \\'-COMMENT-\\'\\n        self.CODE_MARK = \\'-CODE-\\'\\n\\n    @staticmethod\\n    def __format_line_feed(text):\\n        \"\"\"\\n        Replaces consecutive line feed characters in a string with a single line feed.\\n\\n        Parameters:\\n            text (str): The input text to format.\\n\\n        Returns:\\n            str: The formatted text with single line feeds.\\n        \\n        Test cases:\\n            # Test case 1: Multiple line feeds\\n            assert __format_line_feed(\\'Hello\\\\n\\\\nWorld\\') == \\'Hello\\\\nWorld\\'\\n            \\n            # Test case 2: Single line feed\\n            assert __format_line_feed(\\'Hello\\\\nWorld\\') == \\'Hello\\\\nWorld\\'\\n            \\n            # Test case 3: No line feeds\\n            assert __format_line_feed(\\'Hello World\\') == \\'Hello World\\'\\n        \"\"\"\\n        return re.sub(re.compile(r\\'\\\\\\\\n+\\'), \\'\\\\\\\\n\\', text)\\n\\n    def format_line_html_text(self, html_text):\\n        \"\"\"\\n        Formats HTML text by replacing certain elements and adding markers.\\n\\n        Parameters:\\n            html_text (str): The HTML text to be formatted.\\n\\n        Returns:\\n            str: The formatted HTML text as plain text.\\n\\n        Test cases:\\n            # Test case 1: Valid HTML with list and paragraphs\\n            assert format_line_html_text(\\'<ul><li>Item 1</li><li>Item 2.</li></ul>\\') == \\'[-]Item 1.[-]Item 2.\\'\\n            \\n            # Test case 2: HTML with code tags\\n            assert format_line_html_text(\\'<pre>code block</pre><p>Text</p>\\') == \\'-CODE-Text.\\'\\n            \\n            # Test case 3: Empty input\\n            assert format_line_html_text(None) == \\'\\'\\n        \"\"\"\\n        if html_text is None or len(html_text) == 0:\\n            return \\'\\'\\n        \\n        soup = BeautifulSoup(html_text, \\'lxml\\')\\n\\n        code_tag = soup.find_all(name=[\\'pre\\', \\'blockquote\\'])\\n        for tag in code_tag:\\n            tag.string = self.CODE_MARK\\n\\n        ul_ol_group = soup.find_all(name=[\\'ul\\', \\'ol\\'])\\n        for ul_ol_item in ul_ol_group:\\n            li_group = ul_ol_item.find_all(\\'li\\')\\n            for li_item in li_group:\\n                li_item_text = li_item.get_text().strip()\\n                if len(li_item_text) == 0:\\n                    continue\\n                if li_item_text[-1] in string.punctuation:\\n                    li_item.string = \\'[{0}]{1}\\'.format(\\'-\\', li_item_text)\\n                    continue\\n                li_item.string = \\'[{0}]{1}.\\'.format(\\'-\\', li_item_text)\\n\\n        p_group = soup.find_all(name=[\\'p\\'])\\n        for p_item in p_group:\\n            p_item_text = p_item.get_text().strip()\\n            if p_item_text:\\n                if p_item_text[-1] in string.punctuation:\\n                    p_item.string = p_item_text\\n                    continue\\n                next_sibling = p_item.find_next_sibling()\\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\\n                    p_item.string = p_item_text + \\':\\'\\n                    continue\\n                p_item.string = p_item_text + \\'.\\'\\n\\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\\n        return self.__format_line_feed(clean_text)\\n\\n    def extract_code_from_html_text(self, html_text):\\n        \"\"\"\\n        Extracts code blocks from formatted HTML text.\\n\\n        Parameters:\\n            html_text (str): The HTML text to extract code from.\\n\\n        Returns:\\n            list: A list of code snippets extracted from the HTML.\\n\\n        Test cases:\\n            # Test case 1: HTML with a code block\\n            assert extract_code_from_html_text(\\'<pre>code block</pre>\\') == [\\'code block\\']\\n            \\n            # Test case 2: No code block\\n            assert extract_code_from_html_text(\\'<p>No code here.</p>\\') == []\\n            \\n            # Test case 3: Multiple code blocks\\n            assert extract_code_from_html_text(\\'<pre>code 1</pre><pre>code 2</pre>\\') == [\\'code 1\\', \\'code 2\\']\\n        \"\"\"\\n        text_with_code_tag = self.format_line_html_text(html_text)\\n\\n        if self.CODE_MARK not in text_with_code_tag:\\n            return []\\n\\n        code_index_start = 0\\n        soup = BeautifulSoup(html_text, \\'lxml\\')\\n        code_tag = soup.find_all(name=[\\'pre\\', \\'blockquote\\'])\\n        code_count = text_with_code_tag.count(self.CODE_MARK)\\n        code_list = []\\n        for code_index in range(code_index_start, code_index_start + code_count):\\n            code = code_tag[code_index].get_text()\\n            if code:\\n                code_list.append(code)\\n        return code_list\\n```', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735133357, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier=None, system_fingerprint='fp_0aa8d3e20b', usage=CompletionUsage(completion_tokens=1130, prompt_tokens=2014, total_tokens=3144, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))", "test_case_name": "HtmlUtil.txt"}