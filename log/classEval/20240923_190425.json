{"response body": {"id": "c6326f00-8bab-4b37-b34a-50615a65fecc", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-09-23 19:04:25", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "```python\n# This class provides a convenient way to generate SQL queries for a specific table.\nclass SQLGenerator:\n    def __init__(self, table_name):\n        # Constructor for the SQLGenerator class.\n        # param table_name: str, the name of the table for which SQL queries will be generated.\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        # Method to generate a SELECT SQL query.\n        # param fields: list, the fields to select. If None, select all fields.\n        # param condition: str, the condition for the WHERE clause.\n        # return: str, the generated SQL query.\n        # test cases:\n        # >>> gen = SQLGenerator(\"users\")\n        # >>> gen.select([\"name\", \"age\"], \"age > 21\")\n        if fields is None:\n            fields = \"*\"\n        else:\n            fields = \", \".join(fields)\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        # Method to generate an INSERT SQL query.\n        # param data: dict, the data to insert. Keys are field names, values are corresponding values.\n        # return: str, the generated SQL query.\n        # test cases:\n        # >>> gen = SQLGenerator(\"users\")\n        # >>> gen.insert({\"name\": \"John\", \"age\": 21})\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n    def update(self, data, condition):\n        # Method to generate an UPDATE SQL query.\n        # param data: dict, the data to update. Keys are field names, values are corresponding values.\n        # param condition: str, the condition for the WHERE clause.\n        # return: str, the generated SQL query.\n        # test cases:\n        # >>> gen = SQLGenerator(\"users\")\n        # >>> gen.update({\"name\": \"John\", \"age\": 22}, \"id = 1\")\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        return sql + \";\"\n\n    def delete(self, condition):\n        # Method to generate a DELETE SQL query.\n        # param condition: str, the condition for the WHERE clause.\n        # return: str, the generated SQL query.\n        # test cases:\n        # >>> gen = SQLGenerator(\"users\")\n        # >>> gen.delete(\"id = 1\")\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        # Method to generate a SELECT SQL query for females under a certain age.\n        # param age: int, the maximum age.\n        # return: str, the generated SQL query.\n        # test cases:\n        # >>> gen = SQLGenerator(\"users\")\n        # >>> gen.select_female_under_age(21)\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        # Method to generate a SELECT SQL query for people within a certain age range.\n        # param min_age: int, the minimum age.\n        # param max_age: int, the maximum age.\n        # return: str, the generated SQL query.\n        # test cases:\n        # >>> gen = SQLGenerator(\"users\")\n        # >>> gen.select_by_age_range(20, 30)\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)\n```"}}], "usage": {"completion_tokens": 825, "prompt_tokens": 1068, "total_tokens": 1893}, "feeType": "1", "consume": 1.185048}, "test_case_name": "SQLGenerator.txt"}