{"response body": {"id": "1abdaffd-70c7-46bc-9afb-00702594bf23", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-12-26 16:20:42", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "\"\"\"\nThe class VectorUtil provides static methods for dealing with vector operations frequently used in machine learning and data science. \nThese include computing similarity between vectors, cosine similarities, normalized similarity for lists of vectors, and inverse document frequency (IDF) weights for a dictionary.\n\"\"\"\n\nimport numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\n\nclass VectorUtil:\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between two vectors.\n\n        Parameters:\n            vector_1 (array-like): The first vector\n            vector_2 (array-like): The second vector\n\n        Returns:\n            float: The cosine similarity between vector_1 and vector_2\n\n        Test cases:\n            # Test case 1: Normal case\n            assert VectorUtil.similarity([1, 0], [1, 0]) == 1.0\n\n            # Test case 2: Orthogonal vectors\n            assert VectorUtil.similarity([1, 0], [0, 1]) == 0.0\n\n            # Test case 3: Error handling with incompatible vectors\n            try:\n                VectorUtil.similarity([1, 0], [1, 0, 0])\n                assert False\n            except ValueError:\n                assert True\n        \"\"\"\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute the cosine similarities between a vector and a list of vectors.\n\n        Parameters:\n            vector_1 (array-like): The vector to compare\n            vectors_all (array-like): A list of vectors to compare with vector_1\n\n        Returns:\n            array: An array of cosine similarity scores\n\n        Test cases:\n            # Test case 1: Normal case\n            assert np.array_equal(VectorUtil.cosine_similarities([1, 0], [[1, 0], [0, 1]]), [1.0, 0.0])\n\n            # Test case 2: Edge case with empty vectors_all\n            assert np.array_equal(VectorUtil.cosine_similarities([1, 0], []), [])\n\n            # Test case 3: Error handling with incompatible vectors\n            try:\n                VectorUtil.cosine_similarities([1, 0], [[1, 0, 0], [0, 1]])\n                assert False\n            except ValueError:\n                assert True\n        \"\"\"\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n        dot_products = dot(vectors_all, vector_1)\n        similarities = dot_products / (norm * all_norms)\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute the normalized similarity between the mean vectors of two lists of vectors.\n\n        Parameters:\n            vector_list_1 (list of array-like): The first list of vectors\n            vector_list_2 (list of array-like): The second list of vectors\n\n        Returns:\n            float: The normalized similarity between the mean vectors\n\n        Test cases:\n            # Test case 1: Normal case\n            assert VectorUtil.n_similarity([[1, 0], [0, 1]], [[1, 0], [0, 1]]) == 0.0\n\n            # Test case 2: Edge case with empty lists\n            try:\n                VectorUtil.n_similarity([], [[1, 0], [0, 1]])\n                assert False\n            except ZeroDivisionError:\n                assert True\n\n            # Test case 3: Error handling with incompatible vectors\n            try:\n                VectorUtil.n_similarity([[1, 0]], [[1, 0, 0]])\n                assert False\n            except ValueError:\n                assert True\n        \"\"\"\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),\n                   matutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Compute the inverse document frequency (IDF) weights for a dictionary of counts.\n\n        Parameters:\n            total_num (int): The total number of documents\n            number_dict (dict): A dictionary where keys are terms and values are counts of each term\n\n        Returns:\n            dict: A dictionary where keys are terms and values are IDF weights\n\n        Test cases:\n            # Test case 1: Normal case\n            assert VectorUtil.compute_idf_weight_dict(4, {'apple': 2, 'banana': 1}) == {'apple': 0.4054651081081644, 'banana': 0.6931471805599453}\n\n            # Test case 2: Edge case with empty dictionary\n            assert VectorUtil.compute_idf_weight_dict(4, {}) == {}\n\n            # Test case 3: Error handling with total_num <= 0\n            try:\n                VectorUtil.compute_idf_weight_dict(0, {'apple': 2, 'banana': 1})\n                assert False\n            except ZeroDivisionError:\n                assert True\n        \"\"\"\n        index_2_key_map = {}\n\n        index = 0\n\n        count_list = []\n        for key, count in number_dict.items():\n            index_2_key_map[index] = key\n            count_list.append(count)\n            index = index + 1\n\n        a = np.array(count_list)\n        # smooth, in case the divide by zero error\n        a = np.log((total_num + 1) / (a + 1))\n        result = {}\n\n        for index, w in enumerate(a):\n            key = index_2_key_map[index]\n            result[key] = w\n\n        return result"}}], "usage": {"completion_tokens": 1242, "prompt_tokens": 1445, "total_tokens": 2687}, "feeType": "1", "consume": 1.713044}, "test_case_name": "VectorCalculator.txt"}