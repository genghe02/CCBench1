{"response body": "ChatCompletion(id='chatcmpl-AiK8n9oCvjsl1wODsHGCGMlZFNqJ0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```python\\n\"\"\"\\nMahjongConnect: A class that represents a Mahjong game board, facilitating the gameplay mechanics\\nof connecting matching icons on a 2D grid.\\n\\nPurpose:\\nThe MahjongConnect class is designed to handle the core functionalities of a Mahjong game,\\nincluding board creation, move validation, pathfinding between icons, and game state checks.\\n\\nFunctionality:\\n- Create a game board with specified icon configurations.\\n- Validate moves based on game rules.\\n- Check if there\u2019s a clear path between two selected icons.\\n- Remove icons from the board once matched.\\n- Determine if the game is over based on remaining icons.\\n\\nDependencies:\\n- The `random` module is used to randomly select icons for the board.\\n\"\"\"\\n\\nimport random\\n\\nclass MahjongConnect:\\n    def __init__(self, BOARD_SIZE, ICONS):\\n        \"\"\"\\n        Initializes the Mahjong game board with given size and icons.\\n\\n        Parameters:\\n            BOARD_SIZE (tuple): A tuple representing the size of the board (rows, columns).\\n            ICONS (list): A list of icons to populate the board.\\n\\n        Test cases:\\n            # Test case 1: Standard initialization\\n            game = MahjongConnect((4, 4), [\\'A\\', \\'B\\', \\'C\\', \\'D\\'])\\n            assert game.BOARD_SIZE == (4, 4)\\n            assert len(game.ICONS) == 4\\n\\n            # Test case 2: Empty icons\\n            try:\\n                game = MahjongConnect((4, 4), [])\\n            except ValueError:\\n                assert True\\n\\n            # Test case 3: Extremely small board\\n            game = MahjongConnect((1, 1), [\\'A\\'])\\n            assert game.BOARD_SIZE == (1, 1)\\n        \"\"\"\\n        self.BOARD_SIZE = BOARD_SIZE\\n        self.ICONS = ICONS\\n        self.board = self.create_board()\\n\\n    def create_board(self):\\n        \"\"\"\\n        Creates a 2D board filled with randomly selected icons based on provided ICONS.\\n\\n        Returns:\\n            list: A 2D list representing the game board.\\n\\n        Test cases:\\n            # Test case 1: Check board size\\n            board = self.create_board()\\n            assert len(board) == self.BOARD_SIZE[0] and len(board[0]) == self.BOARD_SIZE[1]\\n\\n            # Test case 2: All icons should be from the given ICONS\\n            board = self.create_board()\\n            for row in board:\\n                for icon in row:\\n                    assert icon in self.ICONS\\n\\n            # Test case 3: Board re-creation consistency\\n            board1 = self.create_board()\\n            board2 = self.create_board()\\n            assert board1 != board2  # Not guaranteed, but likely different\\n        \"\"\"\\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\\n        return board\\n\\n    def is_valid_move(self, pos1, pos2):\\n        \"\"\"\\n        Validates if a move between two positions is allowed based on game rules.\\n\\n        Parameters:\\n            pos1 (tuple): The first position (x1, y1).\\n            pos2 (tuple): The second position (x2, y2).\\n\\n        Returns:\\n            bool: True if the move is valid, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Valid move between identical icons\\n            valid = self.is_valid_move((0, 0), (1, 1))\\n            assert valid == True  # Define game conditions accordingly\\n\\n            # Test case 2: Move with out-of-bounds positions\\n            valid = self.is_valid_move((-1, -1), (0, 0))\\n            assert valid == False\\n\\n            # Test case 3: Move on different icons\\n            self.board[0][0] = \\'A\\'\\n            self.board[1][1] = \\'B\\'\\n            valid = self.is_valid_move((0, 0), (1, 1))\\n            assert valid == False\\n        \"\"\"\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n\\n        # Check if positions are within the game board range\\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[0] and 0 <= y2 < self.BOARD_SIZE[1]):\\n            return False\\n\\n        # Check if the two positions are the same\\n        if pos1 == pos2:\\n            return False\\n\\n        # Check if the two positions have the same icon\\n        if self.board[x1][y1] != self.board[x2][y2]:\\n            return False\\n\\n        # Check if there is a valid path between the two positions\\n        if not self.has_path(pos1, pos2):\\n            return False\\n\\n        return True\\n\\n    def has_path(self, pos1, pos2):\\n        \"\"\"\\n        Checks if there is a clear path between two positions on the board.\\n\\n        Parameters:\\n            pos1 (tuple): The first position (x1, y1).\\n            pos2 (tuple): The second position (x2, y2).\\n\\n        Returns:\\n            bool: True if a path exists, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Direct path available\\n            assert self.has_path((0, 0), (1, 0)) == True\\n\\n            # Test case 2: No path available between different icons\\n            self.board[0][0] = \\'A\\'\\n            self.board[1][0] = \\'B\\'\\n            assert self.has_path((0, 0), (1, 0)) == False\\n\\n            # Test case 3: Complex path through surroundings\\n            self.board[0][0] = \\'A\\'\\n            self.board[0][1] = \\'A\\'\\n            self.board[1][1] = \\'A\\'\\n            assert self.has_path((0, 0), (1, 1)) == True\\n        \"\"\"\\n        visited = set()\\n        stack = [pos1]\\n\\n        while stack:\\n            current_pos = stack.pop()\\n            if current_pos == pos2:\\n                return True\\n\\n            if current_pos in visited:\\n                continue\\n\\n            visited.add(current_pos)\\n            x, y = current_pos\\n\\n            # Check adjacent positions (up, down, left, right)\\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\\n                        stack.append((new_x, new_y))\\n\\n        return False\\n\\n    def remove_icons(self, pos1, pos2):\\n        \"\"\"\\n        Removes the icons at the specified positions from the board.\\n\\n        Parameters:\\n            pos1 (tuple): The first position (x1, y1).\\n            pos2 (tuple): The second position (x2, y2).\\n\\n        Test cases:\\n            # Test case 1: Remove icons successfully\\n            self.board[0][0] = \\'A\\'\\n            self.board[1][1] = \\'A\\'\\n            self.remove_icons((0, 0), (1, 1))\\n            assert self.board[0][0] == \\' \\' and self.board[1][1] == \\' \\'\\n\\n            # Test case 2: Attempt to remove icons in invalid positions\\n            try:\\n                self.remove_icons((-1, -1), (2, 2))\\n            except IndexError:\\n                assert True\\n\\n            # Test case 3: Remove icons that are already empty\\n            self.board[0][0] = \\' \\'\\n            self.remove_icons((0, 0), (1, 1))\\n            assert self.board[0][0] == \\' \\' and self.board[1][1] == \\' \\'\\n        \"\"\"\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n        self.board[x1][y1] = \\' \\'\\n        self.board[x2][y2] = \\' \\'\\n\\n    def is_game_over(self):\\n        \"\"\"\\n        Checks if the game is over by determining if there are any remaining icons on the board.\\n\\n        Returns:\\n            bool: True if the game is over (no icons left), False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Game is not over\\n            self.board[0][0] = \\'A\\'\\n            assert self.is_game_over() == False\\n\\n            # Test case 2: Game is over\\n            self.board = [[\\' \\' for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\\n            assert self.is_game_over() == True\\n\\n            # Test case 3: Mixed icons present\\n            self.board[0][0] = \\'A\\'\\n            self.board[1][1] = \\'B\\'\\n            assert self.is_game_over() == False\\n        \"\"\"\\n        for row in self.board:\\n            if any(icon != \\' \\' for icon in row):\\n                return False\\n        return True\\n```\\nIn this completion, the `MahjongConnect` class has been thoroughly documented in compliance with Python standards. Each method contains detailed descriptions, parameters, return types, and multiple relevant test cases to demonstrate functionality, edge cases, and error handling scenarios.', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735127217, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier=None, system_fingerprint='fp_d02d531b47', usage=CompletionUsage(completion_tokens=2009, prompt_tokens=1998, total_tokens=4007, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))", "test_case_name": "MahjongConnect.txt"}