{"response body": "ChatCompletion(id='chatcmpl-AiLo2WREflHvrvemci8iCBU1azBr9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```python\\n\"\"\"\\nThis class implements a Mahjong Connect game with a specified board size and icon set.\\nIt provides methods to create the game board, validate moves, check for paths, \\nremove icons, and determine if the game is over.\\n\"\"\"\\n\\nimport random\\n\\n\\nclass MahjongConnect:\\n    def __init__(self, BOARD_SIZE, ICONS):\\n        \"\"\"\\n        Initializes the MahjongConnect game with a specified board size and icons.\\n\\n        Parameters:\\n            BOARD_SIZE (tuple): A tuple representing the dimensions of the board (rows, columns).\\n            ICONS (list): A list of icons to be used in the game.\\n\\n        Test cases:\\n            # Test case 1: Normal initialization\\n            game = MahjongConnect((4, 4), [\\'A\\', \\'B\\', \\'C\\', \\'D\\'])\\n            assert game.BOARD_SIZE == (4, 4)\\n            assert len(game.ICONS) == 4\\n            assert len(game.board) == 4\\n            \\n            # Test case 2: Checking board elements\\n            game_check = MahjongConnect((2, 2), [\\'X\\', \\'Y\\'])\\n            assert len(game_check.board) == 2\\n            assert len(game_check.board[0]) == 2\\n            \\n            # Test case 3: Empty icon set\\n            game_empty_icons = MahjongConnect((3, 3), [])\\n            assert game_empty_icons.ICONS == []\\n        \"\"\"\\n        self.BOARD_SIZE = BOARD_SIZE\\n        self.ICONS = ICONS\\n        self.board = self.create_board()\\n\\n    def create_board(self):\\n        \"\"\"\\n        Creates the game board by randomly placing icons.\\n\\n        Returns:\\n            list: A 2D list representing the game board, where each cell contains an icon.\\n\\n        Test cases:\\n            # Test case 1: Board size and icons are as expected\\n            board = self.create_board()\\n            assert len(board) == self.BOARD_SIZE[0]\\n            assert len(board[0]) == self.BOARD_SIZE[1]\\n            \\n            # Test case 2: Valid icons in the board\\n            board = self.create_board()\\n            assert all(icon in self.ICONS for row in board for icon in row) \\n            \\n            # Test case 3: Empty board check (though it should not be possible)\\n            game_empty = MahjongConnect((0, 0), [])\\n            assert game_empty.create_board() == []\\n        \"\"\"\\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\\n        return board\\n\\n    def is_valid_move(self, pos1, pos2):\\n        \"\"\"\\n        Validates if the move between two positions is allowed.\\n\\n        Parameters:\\n            pos1 (tuple): The first position (x1, y1).\\n            pos2 (tuple): The second position (x2, y2).\\n\\n        Returns:\\n            bool: True if the move is valid, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Valid move\\n            assert is_valid_move((0, 0), (1, 1)) == True\\n            \\n            # Test case 2: Invalid move (same position)\\n            assert is_valid_move((0, 0), (0, 0)) == False\\n            \\n            # Test case 3: Out of bounds\\n            assert is_valid_move((0, 0), (5, 5)) == False\\n        \"\"\"\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n\\n        # Check if positions are within the game board range\\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and \\n                0 <= x2 < self.BOARD_SIZE[0] and 0 <= y2 < self.BOARD_SIZE[1]):\\n            return False\\n\\n        # Check if the two positions are the same\\n        if pos1 == pos2:\\n            return False\\n\\n        # Check if the two positions have the same icon\\n        if self.board[x1][y1] != self.board[x2][y2]:\\n            return False\\n\\n        # Check if there is a valid path between the two positions\\n        if not self.has_path(pos1, pos2):\\n            return False\\n\\n        return True\\n\\n    def has_path(self, pos1, pos2):\\n        \"\"\"\\n        Checks if there is a valid path between two positions on the board.\\n\\n        Parameters:\\n            pos1 (tuple): The starting position (x1, y1).\\n            pos2 (tuple): The ending position (x2, y2).\\n\\n        Returns:\\n            bool: True if a path exists, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Direct path\\n            assert has_path((0, 0), (0, 1)) == True\\n            \\n            # Test case 2: No path\\n            assert has_path((0, 0), (1, 2)) == False\\n            \\n            # Test case 3: Same icons and valid path\\n            self.board = [[\\'X\\', \\' \\', \\'X\\'], [\\' \\', \\'X\\', \\' \\'], [\\'X\\', \\' \\', \\'X\\']]\\n            assert has_path((0, 0), (2, 0)) == True\\n        \"\"\"\\n        visited = set()\\n        stack = [pos1]\\n\\n        while stack:\\n            current_pos = stack.pop()\\n            if current_pos == pos2:\\n                return True\\n\\n            if current_pos in visited:\\n                continue\\n\\n            visited.add(current_pos)\\n            x, y = current_pos\\n\\n            # Check adjacent positions (up, down, left, right)\\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\\n                        stack.append((new_x, new_y))\\n\\n        return False\\n\\n    def remove_icons(self, pos1, pos2):\\n        \"\"\"\\n        Removes the icons at the given positions from the board.\\n\\n        Parameters:\\n            pos1 (tuple): The first position (x1, y1).\\n            pos2 (tuple): The second position (x2, y2).\\n\\n        Test cases:\\n            # Test case 1: Valid removal\\n            self.board = [[\\'X\\', \\'O\\'], [\\'O\\', \\'X\\']]\\n            remove_icons((0, 0), (1, 0))\\n            assert self.board[0][0] == \\' \\'\\n            assert self.board[1][0] == \\' \\'\\n            \\n            # Test case 2: Removing already empty position\\n            self.board = [[\\' \\', \\'O\\'], [\\'O\\', \\'X\\']]\\n            remove_icons((0, 0), (1, 0))\\n            assert self.board[0][0] == \\' \\'\\n            assert self.board[1][0] == \\' \\'\\n            \\n            # Test case 3: Out of bounds removal (Should not raise errors)\\n            remove_icons((5, 5), (6, 6))\\n        \"\"\"\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n        if 0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1]:\\n            self.board[x1][y1] = \\' \\'\\n        if 0 <= x2 < self.BOARD_SIZE[0] and 0 <= y2 < self.BOARD_SIZE[1]:\\n            self.board[x2][y2] = \\' \\'\\n\\n    def is_game_over(self):\\n        \"\"\"\\n        Checks if the game is over by determining if all icons have been removed.\\n\\n        Returns:\\n            bool: True if the game is over (all icons removed), False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Game not over\\n            self.board = [[\\'X\\', \\'O\\'], [\\'O\\', \\'X\\']]\\n            assert is_game_over() == False\\n            \\n            # Test case 2: Game over\\n            self.board = [[\\' \\', \\' \\'], [\\' \\', \\' \\']]\\n            assert is_game_over() == True\\n            \\n            # Test case 3: Mixed board\\n            self.board = [[\\'X\\', \\'O\\'], [\\' \\', \\' \\']]\\n            assert is_game_over() == False\\n        \"\"\"\\n        for row in self.board:\\n            if any(icon != \\' \\' for icon in row):\\n                return False\\n        return True\\n```', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735133618, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier=None, system_fingerprint='fp_0aa8d3e20b', usage=CompletionUsage(completion_tokens=1814, prompt_tokens=2006, total_tokens=3820, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))", "test_case_name": "MahjongConnect.txt"}