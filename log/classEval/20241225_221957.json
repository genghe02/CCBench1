{"response body": "ChatCompletion(id='chatcmpl-AiMWd34zhisKDi2CsmpJmpfyKUUwJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='# CalendarUtil.py\\n\\nfrom datetime import datetime, timedelta\\n\\nclass CalendarUtil:\\n    \"\"\"\\n    This class provides utility functions for managing events on a calendar.\\n    \"\"\"\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize the CalendarUtil object with an empty list of events.\\n        \"\"\"\\n        self.events = []\\n\\n    def add_event(self, event):\\n        \"\"\"\\n        Add an event to the calendar.\\n\\n        Parameters:\\n            event (dict): A dictionary representing the event to be added.\\n        \\n        Test cases:\\n            # Test case 1: Adding a new event\\n            event = {\\'title\\': \\'Meeting\\', \\'date\\': datetime(2022, 12, 1, 10, 0), \\'start_time\\': datetime(2022, 12, 1, 10, 0), \\'end_time\\': datetime(2022, 12, 1, 11, 0)}\\n            add_event(event)\\n            assert len(self.events) == 1\\n\\n            # Test case 2: Adding an event with invalid data\\n            event = {\\'title\\': \\'Meeting\\', \\'date\\': \\'2022-12-01\\', \\'start_time\\': \\'10:00\\', \\'end_time\\': \\'11:00\\'}\\n            add_event(event)\\n            assert len(self.events) == 1\\n\\n            # Test case 3: Adding a duplicate event\\n            event = {\\'title\\': \\'Meeting\\', \\'date\\': datetime(2022, 12, 1, 10, 0), \\'start_time\\': datetime(2022, 12, 1, 10, 0), \\'end_time\\': datetime(2022, 12, 1, 11, 0)}\\n            add_event(event)\\n            assert len(self.events) == 1\\n        \"\"\"\\n        self.events.append(event)\\n\\n    def remove_event(self, event):\\n        \"\"\"\\n        Remove an event from the calendar.\\n\\n        Parameters:\\n            event (dict): A dictionary representing the event to be removed.\\n        \\n        Test cases:\\n            # Test case 1: Removing an existing event\\n            remove_event(event)\\n            assert event not in self.events\\n\\n            # Test case 2: Removing a non-existing event\\n            event = {\\'title\\': \\'Meeting\\', \\'date\\': datetime(2022, 12, 1, 10, 0), \\'start_time\\': datetime(2022, 12, 1, 10, 0), \\'end_time\\': datetime(2022, 12, 1, 11, 0)}\\n            remove_event(event)\\n            assert event not in self.events\\n\\n            # Test case 3: Removing event with invalid data\\n            event = {\\'title\\': \\'Meeting\\', \\'date\\': \\'2022-12-01\\', \\'start_time\\': \\'10:00\\', \\'end_time\\': \\'11:00\\'}\\n            remove_event(event)\\n            assert event not in self.events\\n        \"\"\"\\n        if event in self.events:\\n            self.events.remove(event)\\n\\n    def get_events(self, date):\\n        \"\"\"\\n        Get all events on a specific date from the calendar.\\n\\n        Parameters:\\n            date (datetime): The date to get events for.\\n        \\n        Returns:\\n            list: A list of events on the specified date.\\n        \\n        Test cases:\\n            # Test case 1: Get events for a valid date\\n            date = datetime(2022, 12, 1)\\n            assert len(get_events(date)) >= 0\\n\\n            # Test case 2: Get events for an empty date\\n            date = datetime(2022, 11, 30)\\n            assert len(get_events(date)) == 0\\n\\n            # Test case 3: Get events for a future date\\n            date = datetime(2023, 1, 1)\\n            assert len(get_events(date)) == 0\\n        \"\"\"\\n        events_on_date = []\\n        for event in self.events:\\n            if event[\\'date\\'].date() == date.date():\\n                events_on_date.append(event)\\n        return events_on_date\\n\\n    def is_available(self, start_time, end_time):\\n        \"\"\"\\n        Check if a time slot is available for scheduling an event.\\n\\n        Parameters:\\n            start_time (datetime): The start time of the event.\\n            end_time (datetime): The end time of the event.\\n        \\n        Returns:\\n            bool: True if the time slot is available, False otherwise.\\n        \\n        Test cases:\\n            # Test case 1: Check availability for a new time slot\\n            start_time = datetime(2022, 12, 1, 10, 0)\\n            end_time = datetime(2022, 12, 1, 11, 0)\\n            assert is_available(start_time, end_time) == True\\n\\n            # Test case 2: Check availability for an overlapping time slot\\n            start_time = datetime(2022, 12, 1, 10, 30)\\n            end_time = datetime(2022, 12, 1, 11, 30)\\n            assert is_available(start_time, end_time) == False\\n\\n            # Test case 3: Check availability for a completely booked day\\n            start_time = datetime(2022, 12, 1, 0, 0)\\n            end_time = datetime(2022, 12, 1, 23, 59)\\n            assert is_available(start_time, end_time) == False\\n        \"\"\"\\n        for event in self.events:\\n            if start_time < event[\\'end_time\\'] and end_time > event[\\'start_time\\']:\\n                return False\\n        return True\\n\\n    def get_available_slots(self, date):\\n        \"\"\"\\n        Get all available time slots on a specific date for scheduling events.\\n\\n        Parameters:\\n            date (datetime): The date to get available time slots for.\\n        \\n        Returns:\\n            list: A list of available time slots on the specified date.\\n        \\n        Test cases:\\n            # Test case 1: Get available slots for a new date\\n            date = datetime(2022, 12, 1)\\n            assert len(get_available_slots(date)) > 0\\n\\n            # Test case 2: Get available slots for a completely booked day\\n            date = datetime(2022, 12, 1)\\n            assert len(get_available_slots(date)) == 0\\n\\n            # Test case 3: Get available slots for a date in the past\\n            date = datetime(2022, 11, 30)\\n            assert len(get_available_slots(date)) > 0\\n        \"\"\"\\n        available_slots = []\\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\\n\\n        while start_time < end_time:\\n            slot_end_time = start_time + timedelta(minutes=60)\\n            if self.is_available(start_time, slot_end_time):\\n                available_slots.append((start_time, slot_end_time))\\n            start_time += timedelta(minutes=60)\\n\\n        return available_slots\\n\\n    def get_upcoming_events(self, num_events):\\n        \"\"\"\\n        Get the upcoming events based on the current date.\\n\\n        Parameters:\\n            num_events (int): The number of upcoming events to retrieve.\\n        \\n        Returns:\\n            list: A list of upcoming events.\\n        \\n        Test cases:\\n            # Test case 1: Get next 3 upcoming events\\n            num_events = 3\\n            assert len(get_upcoming_events(num_events)) == 3\\n\\n            # Test case 2: Get next 5 upcoming events\\n            num_events = 5\\n            assert len(get_upcoming_events(num_events)) == 5\\n\\n            # Test case 3: Get next 0 upcoming events\\n            num_events = 0\\n            assert len(get_upcoming_events(num_events)) == 0\\n        \"\"\"\\n        now = datetime.now()\\n        upcoming_events = []\\n        for event in self.events:\\n            if event[\\'start_time\\'] >= now:\\n                upcoming_events.append(event)\\n            if len(upcoming_events) == num_events:\\n                break\\n        return upcoming_events', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735136383, model='gpt-3.5-turbo-0125', object='chat.completion', service_tier=None, system_fingerprint=None, usage=CompletionUsage(completion_tokens=1670, prompt_tokens=1737, total_tokens=3407, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))", "test_case_name": "CalendarUtil.txt"}