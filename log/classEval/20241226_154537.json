{"response body": {"id": "7514f01d-e544-4e54-9e71-6ec955f02421", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-12-26 15:45:40", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "```python\n\"\"\"\nThis class provides utility functions for HTML text processing, including extracting, formatting, and marking text.\n\"\"\"\n\nimport re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\n\nclass HtmlUtil:\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HtmlUtil class with several special marks for representing different types of text.\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace all multi-line breaks with a single line break.\n        \n        Parameters:\n            text (str): The text to be formatted\n        \n        Returns:\n            str: The formatted text\n        \"\"\"\n        return re.sub(re.compile(r'\\n+'), '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        Format the HTML text by replacing different elements with their corresponding marks and removing unnecessary punctuations.\n\n        Parameters:\n            html_text (str): The HTML text to be formatted\n        \n        Returns:\n            str: The formatted text\n        \n        Test cases:\n            # Test case 1: Normal usage\n            html_text = '<p>Test</p>'\n            assert format_line_html_text(html_text) == 'Test.'\n            \n            # Test case 2: With code tag\n            html_text = '<pre>print(\"Hello, world!\")</pre>'\n            assert format_line_html_text(html_text) == '-CODE-'\n            \n            # Test case 3: With empty tag\n            html_text = '<p></p>'\n            assert format_line_html_text(html_text) == ''\n        \"\"\"\n        if html_text is None or len(html_text) == 0:\n            return ''\n        soup = BeautifulSoup(html_text, 'lxml')\n\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                p_item.string = p_item_text + '.'\n\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        Extract code blocks from HTML text.\n        \n        Parameters:\n            html_text (str): The HTML text from which to extract code blocks\n        \n        Returns:\n            list: A list of strings, each representing a code block\n        \n        Test cases:\n            # Test case 1: Normal usage\n            html_text = '<pre>print(\"Hello, world!\")</pre>'\n            assert extract_code_from_html_text(html_text) == ['print(\"Hello, world!\")']\n            \n            # Test case 2: Multiple code blocks\n            html_text = '<pre>print(\"Hello\")</pre><pre>print(\"world!\")</pre>'\n            assert extract_code_from_html_text(html_text) == ['print(\"Hello\")', 'print(\"world!\")']\n            \n            # Test case 3: Without code block\n            html_text = '<p>Test</p>'\n            assert extract_code_from_html_text(html_text) == []\n        \"\"\"\n        text_with_code_tag = self.format_line_html_text(html_text)\n\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n\n        code_index_start = 0\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        code_list = []\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list\n```"}}], "usage": {"completion_tokens": 1053, "prompt_tokens": 1668, "total_tokens": 2721}, "feeType": "1", "consume": 1.645464}, "test_case_name": "HtmlUtil.txt"}