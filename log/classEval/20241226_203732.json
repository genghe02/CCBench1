{"response body": "ChatCompletion(id='chatcmpl-AihP6vln6yp08PbZstEC7NSvMnaUO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='\"\"\"\\nThis class provides a set of utility functions for managing calendar events and availability.\\n\"\"\"\\n\\nfrom datetime import datetime, timedelta\\n\\nclass CalendarUtil:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize the CalendarUtil class.\\n\\n        Initializes a list to store calendar events.\\n        \"\"\"\\n        self.events = []\\n\\n    def add_event(self, event):\\n        \"\"\"\\n        Add an event to the calendar.\\n\\n        Parameters:\\n            event (dict): A dictionary representing the event to be added.\\n\\n        Test cases:\\n            # Test case 1: Adding a new event\\n            input_event = {\\'title\\': \\'Meeting\\', \\'date\\': datetime(2023, 9, 14, 14, 30), \\'duration\\': timedelta(hours=1)}\\n            add_event(input_event)\\n            assert events == [input_event]\\n\\n            # Test case 2: Adding duplicate event\\n            input_event = {\\'title\\': \\'Meeting\\', \\'date\\': datetime(2023, 9, 14, 14, 30), \\'duration\\': timedelta(hours=1)}\\n            add_event(input_event)\\n            assert events == [input_event, input_event]\\n\\n            # Test case 3: Adding invalid event\\n            input_event = None\\n            add_event(input_event)\\n            assert events == [input_event, input_event]\\n\\n        \"\"\"\\n        self.events.append(event)\\n\\n    def remove_event(self, event):\\n        \"\"\"\\n        Remove an event from the calendar.\\n\\n        Parameters:\\n            event (dict): A dictionary representing the event to be removed.\\n\\n        Test cases:\\n            # Test case 1: Remove existing event\\n            remove_event(events[0])\\n            assert events == []\\n\\n            # Test case 2: Remove non-existent event\\n            invalid_event = {\\'title\\': \\'Exam\\', \\'date\\': datetime(2023, 10, 10, 9, 0), \\'duration\\': timedelta(hours=2)}\\n            remove_event(invalid_event)\\n            assert events == []\\n\\n            # Test case 3: Remove first occurrence of event\\n            add_event(invalid_event)\\n            add_event(events[0])\\n            remove_event(invalid_event)\\n            assert events == [events[0]]\\n        \"\"\"\\n        if event in self.events:\\n            self.events.remove(event)\\n\\n    def get_events(self, date):\\n        \"\"\"\\n        Get all events scheduled for a specific date.\\n\\n        Parameters:\\n            date (datetime): Date for which events need to be retrieved.\\n\\n        Returns:\\n            list: A list of events scheduled for the specified date.\\n        \\n        Test cases:\\n            # Test case 1: Events on specific date\\n            assert get_events(datetime(2023, 9, 14, 0, 0)) == [events[0]]\\n\\n            # Test case 2: No events on date\\n            assert get_events(datetime(2023, 10, 10, 0, 0)) == []\\n\\n            # Test case 3: Invalid input date\\n            assert get_events(None) == []\\n        \"\"\"\\n\\n        events_on_date = []\\n        for event in self.events:\\n            if event[\\'date\\'].date() == date.date():\\n                events_on_date.append(event)\\n        return events_on_date\\n\\n    def is_available(self, start_time, end_time):\\n        \"\"\"\\n        Check if a time slot is available for scheduling.\\n\\n        Parameters:\\n            start_time (datetime): Start time of the slot\\n            end_time (datetime): End time of the slot\\n\\n        Returns:\\n            bool: True if the slot is available; False otherwise\\n\\n        Test cases:\\n            # Test case 1: Available slot\\n            assert is_available(datetime(2023, 9, 14, 15, 0), datetime(2023, 9, 14, 16, 0)) == True\\n\\n            # Test case 2: Slot overlap\\n            assert is_available(datetime(2023, 9, 12, 8, 30), datetime(2023, 9, 12, 9, 30)) == False\\n\\n            # Test case 3: Empty slot\\n            assert is_available(datetime(2023, 10, 10, 10, 0), datetime(2023, 10, 10, 12, 0)) == True\\n        \"\"\"\\n\\n        for event in self.events:\\n            if start_time < event[\\'end_time\\'] and end_time > event[\\'start_time\\']:\\n                return False\\n        return True\\n\\n    def get_available_slots(self, date):\\n        \"\"\"\\n        Get available time slots for a specific date.\\n\\n        Parameters:\\n            date (datetime): Date for which to find available slots\\n\\n        Returns:\\n            list: List of tuples representing available time slots\\n        \\n        Test cases:\\n            # Test case 1: Available slots on date\\n            assert get_available_slots(datetime(2023, 9, 14, 0, 0)) == [(datetime(2023, 9, 14, 0, 0), datetime(2023, 9, 14, 1, 0))]\\n\\n            # Test case 2: No slots available\\n            assert get_available_slots(datetime(2023, 9, 12, 0, 0)) == []\\n\\n            # Test case 3: Invalid date\\n            assert get_available_slots(None) == []\\n        \"\"\"\\n\\n        available_slots = []\\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\\n\\n        while start_time < end_time:\\n            slot_end_time = start_time + timedelta(minutes=60)\\n            if self.is_available(start_time, slot_end_time):\\n                available_slots.append((start_time, slot_end_time))\\n            start_time += timedelta(minutes=60)\\n\\n        return available_slots\\n\\n    def get_upcoming_events(self, num_events):\\n        \"\"\"\\n        Retrieve a specified number of upcoming events.\\n        \\n        Parameters:\\n            num_events (int): Number of upcoming events to return\\n\\n        Returns:\\n            list: List of upcoming events\\n        \\n        Test cases:\\n            # Test case 1: All upcoming events\\n            assert get_upcoming_events(5) == [events[0]]\\n\\n            # Test case 2: No upcoming events\\n            assert get_upcoming_events(0) == []\\n\\n            # Test case 3: Limited number of events\\n            assert get_upcoming_events(2) == [events[0]]\\n        \"\"\"\\n\\n        now = datetime.now()\\n        upcoming_events = []\\n        for event in self.events:\\n            if event[\\'start_time\\'] >= now:\\n                upcoming_events.append(event)\\n            if len(upcoming_events) == num_events:\\n                break\\n        return upcoming_events', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735216640, model='gpt-3.5-turbo-0125', object='chat.completion', service_tier=None, system_fingerprint=None, usage=CompletionUsage(completion_tokens=1375, prompt_tokens=1465, total_tokens=2840, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))", "test_case_name": "CalendarUtil.txt"}