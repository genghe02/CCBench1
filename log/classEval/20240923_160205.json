{"response body": "{\n  \"id\": \"c273c06f-310b-4dd6-bdd7-282d73398fc4\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\nfrom datetime import datetime, timedelta\\n\\nclass CalendarUtil:\\n    # A utility class for managing and querying calendar events.\\n    def __init__(self):\\n        # Initialize the CalendarUtil object with an empty list of events.\\n        self.events = []\\n\\n    def add_event(self, event):\\n        # Add a new event to the calendar.\\n        # param event: dict, the event details to be added\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)})\\n        self.events.append(event)\\n\\n    def remove_event(self, event):\\n        # Remove an event from the calendar.\\n        # param event: dict, the event details to be removed\\n        # >>> calendar = CalendarUtil()\\n        # >>> event = {'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)}\\n        # >>> calendar.add_event(event)\\n        # >>> calendar.remove_event(event)\\n        if event in self.events:\\n            self.events.remove(event)\\n\\n    def get_events(self, date):\\n        # Retrieve all events scheduled on a specific date.\\n        # param date: datetime, the date to query for events\\n        # return: list, a list of events scheduled on the given date\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)})\\n        # >>> calendar.get_events(datetime(2023, 10, 1))\\n        events_on_date = []\\n        for event in self.events:\\n            if event['date'].date() == date.date():\\n                events_on_date.append(event)\\n        return events_on_date\\n\\n    def is_available(self, start_time, end_time):\\n        # Check if the time slot between start_time and end_time is available.\\n        # param start_time: datetime, the start time of the slot to check\\n        # param end_time: datetime, the end time of the slot to check\\n        # return: bool, True if the slot is available, False otherwise\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)})\\n        # >>> calendar.is_available(datetime(2023, 10, 1, 9, 0), datetime(2023, 10, 1, 10, 0))\\n        for event in self.events:\\n            if start_time < event['end_time'] and end_time > event['start_time']:\\n                return False\\n        return True\\n\\n    def get_available_slots(self, date):\\n        # Retrieve all available 1-hour slots on a specific date.\\n        # param date: datetime, the date to query for available slots\\n        # return: list, a list of tuples representing available slots (start_time, end_time)\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)})\\n        # >>> calendar.get_available_slots(datetime(2023, 10, 1))\\n        available_slots = []\\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\\n\\n        while start_time < end_time:\\n            slot_end_time = start_time + timedelta(minutes=60)\\n            if self.is_available(start_time, slot_end_time):\\n                available_slots.append((start_time, slot_end_time))\\n            start_time += timedelta(minutes=60)\\n\\n        return available_slots\\n\\n    def get_upcoming_events(self, num_events):\\n        # Retrieve the next 'num_events' upcoming events.\\n        # param num_events: int, the number of upcoming events to retrieve\\n        # return: list, a list of upcoming events\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 1), 'start_time': datetime(2023, 10, 1, 10, 0), 'end_time': datetime(2023, 10, 1, 11, 0)})\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 2), 'start_time': datetime(2023, 10, 2, 10, 0), 'end_time': datetime(2023, 10, 2, 11, 0)})\\n        # >>> calendar.get_upcoming_events(1)\\n        now = datetime.now()\\n        upcoming_events = []\\n        for event in self.events:\\n            if event['start_time'] >= now:\\n                upcoming_events.append(event)\\n            if len(upcoming_events) == num_events:\\n                break\\n        return upcoming_events\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1727078451,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1c141eb703\",\n  \"usage\": {\n    \"completion_tokens\": 1485,\n    \"prompt_tokens\": 1257,\n    \"total_tokens\": 2742,\n    \"prompt_cache_hit_tokens\": 576,\n    \"prompt_cache_miss_tokens\": 681\n  }\n}", "test_case_name": "CalendarUtil.txt"}