{"response body": "{\n  \"id\": \"bd48f24c-f3de-4a61-bf99-5ee3083c8ebc\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\n\\\"\\\"\\\"\\nThis class represents an EmailClient that manages sending, receiving, and organizing emails. \\nIt includes functionality to handle email storage, check capacity, and manage the inbox.\\n\\\"\\\"\\\"\\n\\nfrom datetime import datetime\\n\\nclass EmailClient:\\n    def __init__(self, addr, capacity) -> None:\\n        \\\"\\\"\\\"\\n        Initializes the EmailClient with an email address and a storage capacity.\\n\\n        Parameters:\\n            addr (str): The email address of the client.\\n            capacity (int): The maximum storage capacity in bytes for the inbox.\\n        \\\"\\\"\\\"\\n        self.addr = addr\\n        self.capacity = capacity\\n        self.inbox = []\\n    \\n    def send_to(self, recv, content, size):\\n        \\\"\\\"\\\"\\n        Sends an email to a recipient if their inbox has enough space.\\n\\n        Parameters:\\n            recv (EmailClient): The recipient's EmailClient instance.\\n            content (str): The content of the email.\\n            size (int): The size of the email in bytes.\\n\\n        Returns:\\n            bool: True if the email was successfully sent, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Successful email send\\n            sender = EmailClient('sender@example.com', 1000)\\n            receiver = EmailClient('receiver@example.com', 1000)\\n            assert sender.send_to(receiver, 'Hello', 500) == True\\n\\n            # Test case 2: Email send fails due to full inbox\\n            sender = EmailClient('sender@example.com', 1000)\\n            receiver = EmailClient('receiver@example.com', 1000)\\n            receiver.inbox.append({'size': 1000, 'state': 'unread'})\\n            assert sender.send_to(receiver, 'Hello', 500) == False\\n\\n            # Test case 3: Email send after clearing inbox\\n            sender = EmailClient('sender@example.com', 1000)\\n            receiver = EmailClient('receiver@example.com', 1000)\\n            receiver.inbox.append({'size': 1000, 'state': 'unread'})\\n            sender.clear_inbox(500)\\n            assert sender.send_to(receiver, 'Hello', 500) == True\\n        \\\"\\\"\\\"\\n        if not recv.is_full_with_one_more_email(size):\\n            timestamp = datetime.now().strftime(\\\"%Y-%m-%d %H:%M:%S\\\")\\n            email = {\\n                \\\"sender\\\": self.addr,\\n                \\\"receiver\\\": recv.addr,\\n                \\\"content\\\": content,\\n                \\\"size\\\": size,\\n                \\\"time\\\": timestamp,\\n                \\\"state\\\": \\\"unread\\\"\\n            }\\n            recv.inbox.append(email)\\n            return True\\n        else:\\n            self.clear_inbox(size)\\n            return False\\n    \\n    def fetch(self):\\n        \\\"\\\"\\\"\\n        Fetches the next unread email from the inbox.\\n\\n        Returns:\\n            dict or None: The next unread email as a dictionary, or None if no unread emails are available.\\n\\n        Test cases:\\n            # Test case 1: Fetch unread email\\n            client = EmailClient('user@example.com', 1000)\\n            client.inbox.append({'state': 'unread', 'content': 'Hello'})\\n            assert client.fetch() is not None\\n\\n            # Test case 2: No unread emails\\n            client = EmailClient('user@example.com', 1000)\\n            client.inbox.append({'state': 'read', 'content': 'Hello'})\\n            assert client.fetch() is None\\n\\n            # Test case 3: Empty inbox\\n            client = EmailClient('user@example.com', 1000)\\n            assert client.fetch() is None\\n        \\\"\\\"\\\"\\n        if len(self.inbox) == 0:\\n            return None\\n        for i in range(len(self.inbox)):\\n            if self.inbox[i]['state'] == \\\"unread\\\":\\n                self.inbox[i]['state'] = \\\"read\\\"\\n                return self.inbox[i]\\n        return None\\n\\n    def is_full_with_one_more_email(self, size):\\n        \\\"\\\"\\\"\\n        Checks if the inbox will be full if another email of the given size is added.\\n\\n        Parameters:\\n            size (int): The size of the email to be added in bytes.\\n\\n        Returns:\\n            bool: True if the inbox will be full, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Inbox has enough space\\n            client = EmailClient('user@example.com', 1000)\\n            assert client.is_full_with_one_more_email(500) == False\\n\\n            # Test case 2: Inbox will be full\\n            client = EmailClient('user@example.com', 1000)\\n            client.inbox.append({'size': 600, 'state': 'unread'})\\n            assert client.is_full_with_one_more_email(500) == True\\n\\n            # Test case 3: Exact capacity\\n            client = EmailClient('user@example.com', 1000)\\n            client.inbox.append({'size': 500, 'state': 'unread'})\\n            assert client.is_full_with_one_more_email(500) == False\\n        \\\"\\\"\\\"\\n        occupied_size = self.get_occupied_size()\\n        return True if occupied_size + size > self.capacity else False\\n        \\n    def get_occupied_size(self):\\n        \\\"\\\"\\\"\\n        Calculates the total size of all emails in the inbox.\\n\\n        Returns:\\n            int: The total size of the inbox in bytes.\\n\\n        Test cases:\\n            # Test case 1: Empty inbox\\n            client = EmailClient('user@example.com', 1000)\\n            assert client.get_occupied_size() == 0\\n\\n            # Test case 2: Inbox with one email\\n            client = EmailClient('user@example.com', 1000)\\n            client.inbox.append({'size': 500, 'state': 'unread'})\\n            assert client.get_occupied_size() == 500\\n\\n            # Test case 3: Inbox with multiple emails\\n            client = EmailClient('user@example.com', 1000)\\n            client.inbox.append({'size': 300, 'state': 'unread'})\\n            client.inbox.append({'size': 200, 'state': 'unread'})\\n            assert client.get_occupied_size() == 500\\n        \\\"\\\"\\\"\\n        occupied_size = 0\\n        for email in self.inbox:\\n            occupied_size += email[\\\"size\\\"]\\n        return occupied_size\\n\\n    def clear_inbox(self, size):\\n        \\\"\\\"\\\"\\n        Clears the inbox to free up space by deleting the oldest emails.\\n\\n        Parameters:\\n            size (int): The amount of space to free up in bytes.\\n\\n        Test cases:\\n            # Test case 1: Clear inbox with enough emails\\n            client = EmailClient('user@example.com', 1000)\\n            client.inbox.append({'size': 300, 'state': 'unread'})\\n            client.inbox.append({'size': 200, 'state': 'unread'})\\n            client.clear_inbox(400)\\n            assert len(client.inbox) == 1\\n\\n            # Test case 2: Clear inbox with insufficient emails\\n            client = EmailClient('user@example.com', 1000)\\n            client.inbox.append({'size': 300, 'state': 'unread'})\\n            client.clear_inbox(400)\\n            assert len(client.inbox) == 0\\n\\n            # Test case 3: Clear empty inbox\\n            client = EmailClient('user@example.com', 1000)\\n            client.clear_inbox(400)\\n            assert len(client.inbox) == 0\\n        \\\"\\\"\\\"\\n        if len(self.addr) == 0:\\n            return\\n        freed_space = 0\\n        while freed_space < size and self.inbox:\\n            email = self.inbox[0]\\n            freed_space += email['size']\\n            del self.inbox[0]\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1735194083,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1a5c54ff19\",\n  \"usage\": {\n    \"completion_tokens\": 1640,\n    \"prompt_tokens\": 1492,\n    \"total_tokens\": 3132,\n    \"prompt_cache_hit_tokens\": 960,\n    \"prompt_cache_miss_tokens\": 532\n  }\n}", "test_case_name": "EmailClient.txt"}