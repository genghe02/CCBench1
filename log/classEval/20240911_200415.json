{"response body": "ChatCompletion(id='chatcmpl-A6GMgwcZes4R8vdQHV2lqYB7fdySG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content=\"```python\\nfrom datetime import datetime, timedelta\\n\\n# This class provides utility functions to manage calendar events such as adding, removing, and fetching events, along with checking availability.\\nclass CalendarUtil:\\n    def __init__(self):\\n        # Initialize the CalendarUtil instance with an empty list to store events.\\n        self.events = []\\n\\n    def add_event(self, event):\\n        # Add a new event to the calendar.\\n        # param event: dict, an event containing details such as 'date', 'start_time', and 'end_time'.\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 15), 'start_time': datetime(2023, 10, 15, 10, 0), 'end_time': datetime(2023, 10, 15, 11, 0)})\\n        self.events.append(event)\\n\\n    def remove_event(self, event):\\n        # Remove an event from the calendar if it exists.\\n        # param event: dict, the event details to be removed.\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 15), 'start_time': datetime(2023, 10, 15, 10, 0), 'end_time': datetime(2023, 10, 15, 11, 0)})\\n        # >>> calendar.remove_event({'date': datetime(2023, 10, 15), 'start_time': datetime(2023, 10, 15, 10, 0), 'end_time': datetime(2023, 10, 15, 11, 0)}) \\n        if event in self.events:\\n            self.events.remove(event)\\n\\n    def get_events(self, date):\\n        # Retrieve a list of events on a specific date.\\n        # param date: datetime, the date for which to retrieve events.\\n        # return: list, a list of events occurring on the specified date.\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 15), 'start_time': datetime(2023, 10, 15, 10, 0), 'end_time': datetime(2023, 10, 15, 11, 0)})\\n        # >>> calendar.get_events(datetime(2023, 10, 15))\\n        events_on_date = []\\n        for event in self.events:\\n            if event['date'].date() == date.date():\\n                events_on_date.append(event)\\n        return events_on_date\\n\\n    def is_available(self, start_time, end_time):\\n        # Check if a specified time slot is available for an event.\\n        # param start_time: datetime, the start time of the slot to check.\\n        # param end_time: datetime, the end time of the slot to check.\\n        # return: bool, True if the slot is available, False otherwise.\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 15), 'start_time': datetime(2023, 10, 15, 10, 0), 'end_time': datetime(2023, 10, 15, 11, 0)})\\n        # >>> calendar.is_available(datetime(2023, 10, 15, 9, 0), datetime(2023, 10, 15, 10, 0)) # Should return True\\n        # >>> calendar.is_available(datetime(2023, 10, 15, 10, 0), datetime(2023, 10, 15, 11, 0)) # Should return False\\n        for event in self.events:\\n            if start_time < event['end_time'] and end_time > event['start_time']:\\n                return False\\n        return True\\n\\n    def get_available_slots(self, date):\\n        # Get a list of available time slots for a specific date.\\n        # param date: datetime, the date for which to find available slots.\\n        # return: list, a list of available hour-long slots on the specified date.\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 15), 'start_time': datetime(2023, 10, 15, 10, 0), 'end_time': datetime(2023, 10, 15, 11, 0)})\\n        # >>> calendar.get_available_slots(datetime(2023, 10, 15)) # Should return slots excluding 10:00 to 11:00\\n        available_slots = []\\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\\n\\n        while start_time < end_time:\\n            slot_end_time = start_time + timedelta(minutes=60)\\n            if self.is_available(start_time, slot_end_time):\\n                available_slots.append((start_time, slot_end_time))\\n            start_time += timedelta(minutes=60)\\n\\n        return available_slots\\n\\n    def get_upcoming_events(self, num_events):\\n        # Retrieve a specified number of upcoming events.\\n        # param num_events: int, the number of upcoming events to retrieve.\\n        # return: list, a list of the upcoming events sorted by start time.\\n        # >>> calendar = CalendarUtil()\\n        # >>> calendar.add_event({'date': datetime(2023, 10, 15), 'start_time': datetime(2023, 10, 15, 10, 0), 'end_time': datetime(2023, 10, 15, 11, 0)})\\n        # >>> calendar.get_upcoming_events(1) # Should return the upcoming event added.\\n        now = datetime.now()\\n        upcoming_events = []\\n        for event in self.events:\\n            if event['start_time'] >= now:\\n                upcoming_events.append(event)\\n            if len(upcoming_events) == num_events:\\n                break\\n        return upcoming_events\\n```\", refusal=None, role='assistant', function_call=None, tool_calls=None))], created=1726056238, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier=None, system_fingerprint='fp_483d39d857', usage=CompletionUsage(completion_tokens=1273, prompt_tokens=1213, total_tokens=2486))", "test_case_name": "CalendarUtil.txt"}