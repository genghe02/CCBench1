{"response body": "{\n  \"id\": \"a13e7c23-9568-4ecf-9b57-7a8a7bda8756\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\n\\\"\\\"\\\"\\nThis class provides functionality to handle reading from and writing to Word documents (.docx files). \\nIt includes methods for reading text, writing text with custom formatting, adding headings, and inserting tables.\\n\\\"\\\"\\\"\\n\\nfrom docx import Document\\nfrom docx.shared import Pt\\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\\n\\n\\nclass DocFileHandler:\\n    def __init__(self, file_path):\\n        \\\"\\\"\\\"\\n        Initializes the DocFileHandler with the specified file path.\\n\\n        Parameters:\\n            file_path (str): The path to the .docx file to be handled.\\n        \\\"\\\"\\\"\\n        self.file_path = file_path\\n\\n    def read_text(self):\\n        \\\"\\\"\\\"\\n        Reads and returns the text content from the .docx file.\\n\\n        Returns:\\n            str: The concatenated text content of all paragraphs in the document.\\n\\n        Test cases:\\n            # Test case 1: Read from a document with multiple paragraphs\\n            handler = DocFileHandler('example.docx')\\n            assert handler.read_text() == \\\"Paragraph 1\\\\nParagraph 2\\\"\\n\\n            # Test case 2: Read from an empty document\\n            handler = DocFileHandler('empty.docx')\\n            assert handler.read_text() == \\\"\\\"\\n\\n            # Test case 3: Read from a non-existent document\\n            handler = DocFileHandler('nonexistent.docx')\\n            with pytest.raises(Exception):\\n                handler.read_text()\\n        \\\"\\\"\\\"\\n        doc = Document(self.file_path)\\n        text = []\\n        for paragraph in doc.paragraphs:\\n            text.append(paragraph.text)\\n        return \\\"\\\\n\\\".join(text)\\n\\n    def write_text(self, content, font_size=12, alignment='left'):\\n        \\\"\\\"\\\"\\n        Writes the specified content to the .docx file with custom font size and alignment.\\n\\n        Parameters:\\n            content (str): The text content to write to the document.\\n            font_size (int, optional): The font size for the text. Defaults to 12.\\n            alignment (str, optional): The alignment of the text. Can be 'left', 'center', or 'right'. Defaults to 'left'.\\n\\n        Returns:\\n            bool: True if the operation was successful, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Write text with default settings\\n            handler = DocFileHandler('output.docx')\\n            assert handler.write_text(\\\"Hello, World!\\\") == True\\n\\n            # Test case 2: Write text with custom font size and alignment\\n            handler = DocFileHandler('output.docx')\\n            assert handler.write_text(\\\"Centered Text\\\", font_size=14, alignment='center') == True\\n\\n            # Test case 3: Write to a read-only file\\n            handler = DocFileHandler('readonly.docx')\\n            assert handler.write_text(\\\"Test\\\") == False\\n        \\\"\\\"\\\"\\n        try:\\n            doc = Document()\\n            paragraph = doc.add_paragraph()\\n            run = paragraph.add_run(content)\\n            font = run.font\\n            font.size = Pt(font_size)\\n            alignment_value = self._get_alignment_value(alignment)\\n            paragraph.alignment = alignment_value\\n            doc.save(self.file_path)\\n            return True\\n        except:\\n            return False\\n\\n    def add_heading(self, heading, level=1):\\n        \\\"\\\"\\\"\\n        Adds a heading to the .docx file.\\n\\n        Parameters:\\n            heading (str): The text of the heading.\\n            level (int, optional): The level of the heading (1 for top-level, 2 for subheading, etc.). Defaults to 1.\\n\\n        Returns:\\n            bool: True if the operation was successful, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Add a top-level heading\\n            handler = DocFileHandler('output.docx')\\n            assert handler.add_heading(\\\"Main Title\\\") == True\\n\\n            # Test case 2: Add a subheading\\n            handler = DocFileHandler('output.docx')\\n            assert handler.add_heading(\\\"Subtitle\\\", level=2) == True\\n\\n            # Test case 3: Add a heading to a read-only file\\n            handler = DocFileHandler('readonly.docx')\\n            assert handler.add_heading(\\\"Test Heading\\\") == False\\n        \\\"\\\"\\\"\\n        try:\\n            doc = Document(self.file_path)\\n            doc.add_heading(heading, level)\\n            doc.save(self.file_path)\\n            return True\\n        except:\\n            return False\\n\\n    def add_table(self, data):\\n        \\\"\\\"\\\"\\n        Adds a table to the .docx file with the specified data.\\n\\n        Parameters:\\n            data (list of lists): The data to populate the table. Each inner list represents a row.\\n\\n        Returns:\\n            bool: True if the operation was successful, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Add a table with multiple rows and columns\\n            handler = DocFileHandler('output.docx')\\n            data = [[\\\"Name\\\", \\\"Age\\\"], [\\\"Alice\\\", \\\"30\\\"], [\\\"Bob\\\", \\\"25\\\"]]\\n            assert handler.add_table(data) == True\\n\\n            # Test case 2: Add an empty table\\n            handler = DocFileHandler('output.docx')\\n            data = []\\n            assert handler.add_table(data) == True\\n\\n            # Test case 3: Add a table to a read-only file\\n            handler = DocFileHandler('readonly.docx')\\n            data = [[\\\"Test\\\", \\\"Data\\\"]]\\n            assert handler.add_table(data) == False\\n        \\\"\\\"\\\"\\n        try:\\n            doc = Document(self.file_path)\\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\\n            for i, row in enumerate(data):\\n                for j, cell_value in enumerate(row):\\n                    table.cell(i, j).text = str(cell_value)\\n            doc.save(self.file_path)\\n            return True\\n        except:\\n            return False\\n\\n    def _get_alignment_value(self, alignment):\\n        \\\"\\\"\\\"\\n        Converts the alignment string to the corresponding WD_PARAGRAPH_ALIGNMENT value.\\n\\n        Parameters:\\n            alignment (str): The alignment string ('left', 'center', or 'right').\\n\\n        Returns:\\n            WD_PARAGRAPH_ALIGNMENT: The corresponding alignment value.\\n\\n        Test cases:\\n            # Test case 1: Left alignment\\n            assert self._get_alignment_value('left') == WD_PARAGRAPH_ALIGNMENT.LEFT\\n\\n            # Test case 2: Center alignment\\n            assert self._get_alignment_value('center') == WD_PARAGRAPH_ALIGNMENT.CENTER\\n\\n            # Test case 3: Right alignment\\n            assert self._get_alignment_value('right') == WD_PARAGRAPH_ALIGNMENT.RIGHT\\n\\n            # Test case 4: Invalid alignment\\n            assert self._get_alignment_value('invalid') == WD_PARAGRAPH_ALIGNMENT.LEFT\\n        \\\"\\\"\\\"\\n        alignment_options = {\\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\\n        }\\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1735194037,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1a5c54ff19\",\n  \"usage\": {\n    \"completion_tokens\": 1483,\n    \"prompt_tokens\": 1500,\n    \"total_tokens\": 2983,\n    \"prompt_cache_hit_tokens\": 960,\n    \"prompt_cache_miss_tokens\": 540\n  }\n}", "test_case_name": "DocFileHandler.txt"}