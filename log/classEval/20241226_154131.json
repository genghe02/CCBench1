{"response body": {"id": "0a7addba-821f-4a8d-94d3-36f28a75c77a", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-12-26 15:41:34", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "\"\"\"\nThe class ExpressionCalculator provides methods to perform arithmetic operations on mathematical expressions. \nIt transforms the input expression into a postfix notation, and then calculates the result. \nIt supports parentheses, negation, and the operators +, -, *, /, %.\n\"\"\"\n\nimport re\nfrom collections import deque\nfrom decimal import Decimal\n\n\nclass ExpressionCalculator:\n    def __init__(self):\n        \"\"\"\n        Initialization method to set up the deque for postfix notation and operator priority.\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given arithmetic expression.\n\n        Parameters:\n            expression (str): The arithmetic expression to calculate.\n        \n        Returns:\n            float: The result of the calculation.\n        \n        Test cases:\n            # Test case 1: Normal usage with all operators\n            assert calculate(\"((2+3)*4)/2%3\") == 1.0\n            \n            # Test case 2: Expression with negative numbers\n            assert calculate(\"-1+2\") == 1.0\n            \n            # Test case 3: Expression with parentheses\n            assert calculate(\"(2+3)*(4-2)\") == 10.0\n        \"\"\"\n        self.prepare(self.transform(expression))\n\n        result_stack = deque()\n        self.postfix_stack.reverse()\n\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n            if not self.is_operator(current_op):\n                current_op = current_op.replace(\"~\", \"-\")\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        return float(eval(\"*\".join(result_stack)))\n\n    def prepare(self, expression):\n        \"\"\"\n        Convert the input infix expression into postfix notation.\n\n        Parameters:\n            expression (str): The infix expression to be converted.\n        \n        Test cases:\n            # Test case 1: Normal usage\n            assert prepare(\"(2+3)*4\") == deque(['2', '3', '+', '4', '*'])\n            \n            # Test case 2: Expression with parentheses\n            assert prepare(\"((2+3)*4)/2\") == deque(['2', '3', '+', '4', '*', '2', '/'])\n            \n            # Test case 3: Expression with negative numbers\n            assert prepare(\"-1+2\") == deque(['~1', '2', '+'])\n        \"\"\"\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n\n        for i, current_op in enumerate(arr):\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if the character is an arithmetic operator.\n\n        Parameters:\n            c (str): The character to check.\n        \n        Returns:\n            bool: True if the character is an operator, False otherwise.\n        \n        Test cases:\n            # Test case 1: Addition operator\n            assert is_operator('+') == True\n            \n            # Test case 2: Non-operator character\n            assert is_operator('3') == False\n            \n            # Test case 3: Parentheses\n            assert is_operator('(') == True\n        \"\"\"\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the priorities of two operators.\n\n        Parameters:\n            cur (str): The current operator.\n            peek (str): The operator at the top of the stack.\n        \n        Returns:\n            bool: True if the priority of peek is higher or equal to cur, False otherwise.\n        \n        Test cases:\n            # Test case 1: Same priority\n            assert compare('*', '/') == True\n            \n            # Test case 2: Lower priority\n            assert compare('*', '+') == False\n            \n            # Test case 3: Higher priority\n            assert compare('+', '*') == True\n        \"\"\"\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the arithmetic operation on two values.\n\n        Parameters:\n            first_value (str): The first value.\n            second_value (str): The second value.\n            current_op (str): The operator.\n        \n        Returns:\n            Decimal: The result of the operation.\n        \n        Test cases:\n            # Test case 1: Addition\n            assert _calculate('2', '3', '+') == 5.0\n            \n            # Test case 2: Division\n            assert _calculate('4', '2', '/') == 2.0\n            \n            # Test case 3: Modulo\n            assert _calculate('10', '3', '%') == 1.0\n        \"\"\"\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Perform necessary transformations on the input expression.\n\n        Parameters:\n            expression (str): The input expression.\n        \n        Returns:\n            str: The transformed expression.\n        \n        Test cases:\n            # Test case 1: Expression with negative numbers\n            assert transform(\"-1+2\") == '~1+2'\n            \n            # Test case 2: Expression with parentheses\n            assert transform(\"(-1+2)*3\") == '~1+2*3'\n            \n            # Test case 3: Expression with whitespace\n            assert transform(\" 1 + 2 \") == '1+2'\n        \"\"\"\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        expression = re.sub(r\"=$\", \"\", expression)\n        arr = list(expression)\n\n        for i, c in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return \"0\" + \"\".join(arr)\n        else:\n            return \"\".join(arr)"}}], "usage": {"completion_tokens": 1677, "prompt_tokens": 1970, "total_tokens": 3647}, "feeType": "1", "consume": 2.321264}, "test_case_name": "ExpressionCalculator.txt"}