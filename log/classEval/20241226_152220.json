{"response body": {"id": "7f609273-fdd9-4932-94dd-5cc41a325b35", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-12-26 15:22:23", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "```python\n\"\"\"\nThe class CalendarUtil serves as a utility tool to manage a list of events. It provides methods to add or remove an event, \nget all events on a particular date, check if a time slot is available, get all available slots on a particular date, \nand get a certain number of upcoming events.\n\"\"\"\n\nfrom datetime import datetime, timedelta\n\nclass CalendarUtil:\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of the CalendarUtil class.\n        \n        This method initializes an empty list to store the events.\n        \"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Adds an event to the list of events.\n        \n        Parameters:\n            event (dict): A dictionary containing details of the event. It should include 'date', 'start_time', and 'end_time' keys.\n            \n        Test cases:\n            # Test case 1: Adding a valid event\n            cal = CalendarUtil()\n            event = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 12, 0)}\n            cal.add_event(event)\n            assert len(cal.events) == 1\n            \n            # Test case 2: Adding an event with missing keys\n            cal = CalendarUtil()\n            event = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0)}\n            cal.add_event(event)\n            # This should raise a KeyError\n            \n            # Test case 3: Adding an event with invalid date/time\n            cal = CalendarUtil()\n            event = {'date': '2023-01-01', 'start_time': '10:00', 'end_time': '12:00'}\n            cal.add_event(event)\n            # This should raise a TypeError\n        \"\"\"\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Removes an event from the list of events if it exists.\n        \n        Parameters:\n            event (dict): A dictionary containing details of the event to be removed.\n            \n        Test cases:\n            # Test case 1: Removing an existing event\n            cal = CalendarUtil()\n            event = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 12, 0)}\n            cal.add_event(event)\n            cal.remove_event(event)\n            assert len(cal.events) == 0\n            \n            # Test case 2: Trying to remove an event that doesn't exist\n            cal = CalendarUtil()\n            event = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 12, 0)}\n            cal.remove_event(event)\n            # This should not raise an error, but also not remove any event\n            \n            # Test case 3: Trying to remove an event with missing/incorrect keys\n            cal = CalendarUtil()\n            event = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0)}\n            cal.remove_event(event)\n            # This should not raise an error, but also not remove any event\n        \"\"\"\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        \"\"\"\n        Returns a list of all events on a particular date.\n        \n        Parameters:\n            date (datetime): The date for which to get the events.\n            \n        Returns:\n            list: A list of dictionaries, each representing an event on the given date.\n            \n        Test cases:\n            # Test case 1: Getting events on a date with events\n            cal = CalendarUtil()\n            event1 = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 12, 0)}\n            event2 = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 14, 0), 'end_time': datetime(2023, 1, 1, 16, 0)}\n            cal.add_event(event1)\n            cal.add_event(event2)\n            events = cal.get_events(datetime(2023, 1, 1))\n            assert len(events) == 2\n            \n            # Test case 2: Getting events on a date with no events\n            cal = CalendarUtil()\n            events = cal.get_events(datetime(2023, 1, 1))\n            assert len(events) == 0\n            \n            # Test case 3: Trying to get events with an invalid date\n            cal = CalendarUtil()\n            events = cal.get_events('2023-01-01')\n            # This should raise a TypeError\n        \"\"\"\n        events_on_date = []\n        for event in self.events:\n            if event['date'].date() == date.date():\n                events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Checks if the time slot between start_time and end_time is available (i.e., no events are scheduled in this time slot).\n        \n        Parameters:\n            start_time (datetime): The start of the time slot.\n            end_time (datetime): The end of the time slot.\n            \n        Returns:\n            bool: True if the time slot is available, False otherwise.\n            \n        Test cases:\n            # Test case 1: Checking an available time slot\n            cal = CalendarUtil()\n            event = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 12, 0)}\n            cal.add_event(event)\n            assert cal.is_available(datetime(2023, 1, 1, 12, 0), datetime(2023, 1, 1, 14, 0)) == True\n            \n            # Test case 2: Checking a time slot that is not available\n            cal = CalendarUtil()\n            event = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 12, 0)}\n            cal.add_event(event)\n            assert cal.is_available(datetime(2023, 1, 1, 11, 0), datetime(2023, 1, 1, 13, 0)) == False\n            \n            # Test case 3: Checking a time slot with invalid start_time/end_time\n            cal = CalendarUtil()\n            assert cal.is_available('10:00', '12:00') == False\n            # This should raise a TypeError\n        \"\"\"\n        for event in self.events:\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Gets a list of all available 1-hour time slots on a particular date.\n        \n        Parameters:\n            date (datetime): The date for which to get the available slots.\n            \n        Returns:\n            list: A list of tuples, each representing an available time slot. Each tuple contains two datetimes: start_time and end_time.\n            \n        Test cases:\n            # Test case 1: Getting available slots on a date with some events\n            cal = CalendarUtil()\n            event1 = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 11, 0)}\n            event2 = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 12, 0), 'end_time': datetime(2023, 1, 1, 13, 0)}\n            cal.add_event(event1)\n            cal.add_event(event2)\n            slots = cal.get_available_slots(datetime(2023, 1, 1))\n            assert len(slots) == 22  # 24 hours in a day, minus 2 hours occupied by events\n            \n            # Test case 2: Getting available slots on a date with no events\n            cal = CalendarUtil()\n            slots = cal.get_available_slots(datetime(2023, 1, 1))\n            assert len(slots) == 24  # 24 hours in a day, all available\n            \n            # Test case 3: Trying to get slots with an invalid date\n            cal = CalendarUtil()\n            slots = cal.get_available_slots('2023-01-01')\n            # This should raise a TypeError\n        \"\"\"\n        available_slots = []\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n\n        while start_time < end_time:\n            slot_end_time = start_time + timedelta(minutes=60)\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time += timedelta(minutes=60)\n\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Gets a list of the next num_events upcoming events.\n        \n        Parameters:\n            num_events (int): The number of upcoming events to get.\n            \n        Returns:\n            list: A list of dictionaries, each representing an upcoming event.\n            \n        Test cases:\n            # Test case 1: Getting upcoming events when there are enough upcoming events\n            cal = CalendarUtil()\n            event1 = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 11, 0)}\n            event2 = {'date': datetime(2023, 1, 2), 'start_time': datetime(2023, 1, 2, 10, 0), 'end_time': datetime(2023, 1, 2, 11, 0)}\n            cal.add_event(event1)\n            cal.add_event(event2)\n            events = cal.get_upcoming_events(2)\n            assert len(events) == 2\n            \n            # Test case 2: Getting upcoming events when there are not enough upcoming events\n            cal = CalendarUtil()\n            event = {'date': datetime(2023, 1, 1), 'start_time': datetime(2023, 1, 1, 10, 0), 'end_time': datetime(2023, 1, 1, 11, 0)}\n            cal.add_event(event)\n            events = cal.get_upcoming_events(2)\n            assert len(events) == 1\n            \n            # Test case 3: Trying to get upcoming events with an invalid num_events\n            cal = CalendarUtil()\n            events = cal.get_upcoming_events('two')\n            # This should raise a TypeError\n        \"\"\"\n        now = datetime.now()\n        upcoming_events = []\n        for event in self.events:\n            if event['start_time'] >= now:\n                upcoming_events.append(event)\n            if len(upcoming_events) == num_events:\n                break\n        return upcoming_events\n```"}}], "usage": {"completion_tokens": 2530, "prompt_tokens": 1465, "total_tokens": 3995}, "feeType": "1", "consume": 2.8449}, "test_case_name": "CalendarUtil.txt"}