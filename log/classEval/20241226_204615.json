{"response body": "ChatCompletion(id='chatcmpl-AihXSjrjRR0ECu6odiIxFkHD8Wpo7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='\"\"\"\\nThis class represents a MahjongConnect game board and provides methods to manipulate the board, make moves, and check the game state.\\n\"\"\"\\n\\nimport random\\n\\n\\nclass MahjongConnect:\\n    def __init__(self, BOARD_SIZE, ICONS):\\n        \"\"\"\\n        Initialize the MahjongConnect game board.\\n\\n        Parameters:\\n            BOARD_SIZE (tuple): A tuple representing the size of the game board (rows, columns).\\n            ICONS (list): A list of icons that can appear on the game board.\\n\\n        Test cases:\\n            # Test case 1: Check board creation\\n            new_game = MahjongConnect((5, 5), [\\'A\\', \\'B\\', \\'C\\'])\\n            assert new_game.board == [[\\'A\\', \\'B\\', \\'A\\', \\'C\\', \\'B\\'], [\\'C\\', \\'A\\', \\'B\\', \\'B\\', \\'C\\'], [\\'A\\', \\'C\\', \\'B\\', \\'C\\', \\'A\\'],\\n                                      [\\'B\\', \\'A\\', \\'C\\', \\'B\\', \\'A\\'], [\\'C\\', \\'C\\', \\'A\\', \\'A\\', \\'B\\']]\\n        \"\"\"\\n        self.BOARD_SIZE = BOARD_SIZE\\n        self.ICONS = ICONS\\n        self.board = self.create_board()\\n\\n    def create_board(self):\\n        \"\"\"\\n        Create a new game board with random icons.\\n\\n        Returns:\\n            list: A 2D list representing the game board with randomly placed icons.\\n\\n        Test cases:\\n            # Test case 1: Check board creation\\n            new_game = MahjongConnect((5, 5), [\\'A\\', \\'B\\', \\'C\\'])\\n            assert len(new_game.create_board()) == 5\\n\\n            # Test case 2: Check empty board creation\\n            test_game = MahjongConnect((3, 4), [\\'X\\', \\'Y\\'])\\n            assert all(all(cell == \\' \\' for cell in row) for row in test_game.create_board())\\n\\n            # Test case 3: Check board size\\n            test_game = MahjongConnect((7, 3), [\\'X\\', \\'Y\\', \\'Z\\'])\\n            assert len(test_game.create_board()[0]) == 3\\n        \"\"\"\\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\\n        return board\\n\\n    def is_valid_move(self, pos1, pos2):\\n        \"\"\"\\n        Check if a move between two positions is valid.\\n\\n        Parameters:\\n            pos1 (tuple): The coordinates (row, column) of the first position.\\n            pos2 (tuple): The coordinates (row, column) of the second position.\\n\\n        Returns:\\n            bool: True if the move is valid, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Valid move\\n            assert is_valid_move((0, 0), (0, 1)) == True\\n\\n            # Test case 2: Invalid move - same position\\n            assert is_valid_move((1, 2), (1, 2)) == False\\n\\n            # Test case 3: Invalid move - different icons\\n            assert is_valid_move((2, 2), (2, 3)) == False\\n        \"\"\"\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n\\n        # Check if positions are within the game board range\\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[0] and 0 <= y2 < self.BOARD_SIZE[1]):\\n            return False\\n\\n        # Check if the two positions are the same\\n        if pos1 == pos2:\\n            return False\\n\\n        # Check if the two positions have the same icon\\n        if self.board[x1][y1] != self.board[x2][y2]:\\n            return False\\n\\n        # Check if there is a valid path between the two positions\\n        if not self.has_path(pos1, pos2):\\n            return False\\n\\n        return True\\n\\n    def has_path(self, pos1, pos2):\\n        \"\"\"\\n        Check if there is a valid path between two positions.\\n\\n        Parameters:\\n            pos1 (tuple): The coordinates (row, column) of the first position.\\n            pos2 (tuple): The coordinates (row, column) of the second position.\\n\\n        Returns:\\n            bool: True if there is a valid path between the two positions, False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Valid path\\n            assert has_path((0, 0), (0, 1)) == True\\n\\n            # Test case 2: Invalid path\\n            assert has_path((1, 2), (1, 4)) == False\\n\\n            # Test case 3: Valid path - move through adjacent icons\\n            assert has_path((2, 2), (4, 2)) == True\\n        \"\"\"\\n\\n        visited = set()\\n        stack = [pos1]\\n\\n        while stack:\\n            current_pos = stack.pop()\\n            if current_pos == pos2:\\n                return True\\n\\n            if current_pos in visited:\\n                continue\\n\\n            visited.add(current_pos)\\n            x, y = current_pos\\n\\n            # Check adjacent positions (up, down, left, right)\\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\\n                        stack.append((new_x, new_y))\\n\\n        return False\\n\\n    def remove_icons(self, pos1, pos2):\\n        \"\"\"\\n        Remove icons at two positions from the game board.\\n\\n        Parameters:\\n            pos1 (tuple): The coordinates (row, column) of the first position.\\n            pos2 (tuple): The coordinates (row, column) of the second position.\\n\\n        Returns:\\n            None\\n\\n        Test cases:\\n            # Test case 1: Remove icons at positions\\n            game = MahjongConnect((4, 4), [\\'A\\', \\'B\\'])\\n            game.remove_icons((0, 0), (1, 0))\\n            assert game.board[0][0] == \\' \\' and game.board[1][0] == \\' \\'\\n\\n            # Test case 2: No change when removing the same icon\\n            test_game = MahjongConnect((3, 3), [\\'X\\'])\\n            test_game.remove_icons((0, 0), (1, 1))\\n            assert test_game.board[0][0] == \\'X\\' and test_game.board[1][1] == \\'X\\'\\n\\n            # Test case 3: Check removal of icons with different icons\\n            game = MahjongConnect((4, 4), [\\'A\\', \\'B\\'])\\n            game.remove_icons((0, 0), (0, 1))\\n            assert game.board[0][0] == \\'A\\' and game.board[0][1] == \\'B\\'\\n        \"\"\"\\n\\n        x1, y1 = pos1\\n        x2, y2 = pos2\\n        self.board[x1][y1] = \\' \\'\\n        self.board[x2][y2] = \\' \\'\\n\\n    def is_game_over(self):\\n        \"\"\"\\n        Check if the game is over by evaluating whether the board is completely cleared.\\n\\n        Returns:\\n            bool: True if the game is over (board is empty), False otherwise.\\n\\n        Test cases:\\n            # Test case 1: Game over when board is empty\\n            empty_game = MahjongConnect((3, 3), [\\'A\\', \\'B\\'])\\n            assert empty_game.is_game_over() == True\\n\\n            # Test case 2: Incomplete game\\n            game = MahjongConnect((4, 3), [\\'X\\', \\'Y\\', \\'Z\\'])\\n            assert game.is_game_over() == False\\n\\n            # Test case 3: Game over with different icon set\\n            test_game = MahjongConnect((2, 2), [\\'P\\', \\'Q\\'])\\n            test_game.board = [[\\' \\', \\' \\'], [\\' \\', \\' \\']]\\n            assert test_game.is_game_over() == True\\n        \"\"\"\\n        for row in self.board:\\n            if any(icon != \\' \\' for icon in row):\\n                return False\\n        return True\\n\"\"\"', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735217158, model='gpt-3.5-turbo-0125', object='chat.completion', service_tier=None, system_fingerprint=None, usage=CompletionUsage(completion_tokens=1777, prompt_tokens=1706, total_tokens=3483, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))", "test_case_name": "MahjongConnect.txt"}