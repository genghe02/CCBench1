{"response body": "ChatCompletion(id='chatcmpl-AiOMrMfCOGvQ8ptZ4eEEDWcAlYd5U', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='\"\"\"\\nThe class `VectorUtil` provides utility functions for working with vectors, specifically to calculate similarity and cosine similarities between vectors.\\n\\n\"\"\"\\n\\nimport numpy as np\\nfrom gensim import matutils\\nfrom numpy import dot, array\\n\\n\\nclass VectorUtil:\\n    \\n    @staticmethod\\n    def similarity(vector_1, vector_2):\\n        \"\"\"\\n        Calculate the cosine similarity between two vectors.\\n        \\n        Parameters:\\n            vector_1 (numpy.ndarray): The first input vector\\n            vector_2 (numpy.ndarray): The second input vector\\n\\n        Returns:\\n            float: The cosine similarity between the two input vectors\\n        \\n        Test cases:\\n            # Test case 1: Non-zero vectors\\n            assert similarity(np.array([1, 0]), np.array([1, 1])) == 0.7071\\n            \\n            # Test case 2: Zero vector\\n            assert similarity(np.array([0, 0]), np.array([1, 1])) == 0.0\\n            \\n            # Test case 3: Orthogonal vectors\\n            assert similarity(np.array([1, 0]), np.array([0, 1])) == 0.0\\n\\n        \"\"\"\\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\\n\\n    @staticmethod\\n    def cosine_similarities(vector_1, vectors_all):\\n        \"\"\"\\n        Calculate the cosine similarities between a single vector and a list of vectors.\\n        \\n        Parameters:\\n            vector_1 (numpy.ndarray): The input vector for comparison\\n            vectors_all (numpy.ndarray): A matrix of vectors for comparison\\n        \\n        Returns:\\n            numpy.ndarray: An array of cosine similarities between the input vector and each vector in `vectors_all`\\n        \\n        Test cases:\\n            # Test case 1: Single vector\\n            assert (cosine_similarities(np.array([1, 0]), np.array([[1, 1], [0, 1]])) == [0.7071, 0.0]).all()\\n            \\n            # Test case 2: Zero vectors\\n            assert (cosine_similarities(np.array([0, 0]), np.array([[1, 1], [0, 1]])) == [0.0, 0.0]).all()\\n            \\n            # Test case 3: Orthogonal vectors\\n            assert (cosine_similarities(np.array([1, 0]), np.array([[0, 1], [0, -1]])) == [0.0, -1.0]).all()\\n\\n        \"\"\"\\n        norm = np.linalg.norm(vector_1)\\n        all_norms = np.linalg.norm(vectors_all, axis=1)\\n        dot_products = dot(vectors_all, vector_1)\\n        similarities = dot_products / (norm * all_norms)\\n        return similarities\\n\\n    @staticmethod\\n    def n_similarity(vector_list_1, vector_list_2):\\n        \"\"\"\\n        Calculate the cosine similarity between the averages of two lists of vectors.\\n        \\n        Parameters:\\n            vector_list_1 (list): List of numpy.ndarray vectors to compute average and similarity\\n            vector_list_2 (list): List of numpy.ndarray vectors to compute average and similarity\\n        \\n        Returns:\\n            float: The cosine similarity between the averaged vectors of vector_list_1 and vector_list_2\\n        \\n        Test cases:\\n            # Test case 1: Single vector for each list\\n            assert n_similarity([np.array([1, 0])], [np.array([1, 1])]) == 0.7071\\n            \\n            # Test case 2: Multiple vectors in each list\\n            assert n_similarity([np.array([1, 0]), np.array([0, 1])], [np.array([1, 1])]) == 0.9239\\n            \\n            # Test case 3: Empty lists\\n            with pytest.raises(ZeroDivisionError):\\n                n_similarity([], [])\\n        \"\"\"\\n        \\n        if not (len(vector_list_1) and len(vector_list_2)):\\n            raise ZeroDivisionError(\\'At least one of the passed lists is empty.\\')\\n\\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),\\n                   matutils.unitvec(array(vector_list_2).mean(axis=0)))\\n\\n    @staticmethod\\n    def compute_idf_weight_dict(total_num, number_dict):\\n        \"\"\"\\n        Compute the Inverse Document Frequency (IDF) weights for a given dictionary of counts.\\n        \\n        Parameters:\\n            total_num (int): The total number of documents or occurrences\\n            number_dict (dict): Dictionary of items and their counts\\n        \\n        Returns:\\n            dict: A dictionary mapping items to their IDF weights\\n        \\n        Test cases:\\n            # Test case 1: Normal computation\\n            assert compute_idf_weight_dict(100, {\\'word1\\': 20, \\'word2\\': 30}) == {\\'word1\\': 1.3863, \\'word2\\': 1.0986}\\n\\n            # Test case 2: Zero count\\n            assert compute_idf_weight_dict(100, {\\'word1\\': 0, \\'word2\\': 50}) == {\\'word1\\': 4.6052, \\'word2\\': 0.6931}\\n\\n            # Test case 3: Empty dictionary\\n            assert compute_idf_weight_dict(100, {}) == {}\\n\\n        \"\"\"\\n        index_2_key_map = {}\\n\\n        index = 0\\n\\n        count_list = []\\n        for key, count in number_dict.items():\\n            index_2_key_map[index] = key\\n            count_list.append(count)\\n            index = index + 1\\n\\n        a = np.array(count_list)\\n        ## smooth, in case of divide by zero error\\n        a = np.log((total_num + 1) / (a + 1))\\n        result = {}\\n\\n        for index, w in enumerate(a):\\n            key = index_2_key_map[index]\\n            result[key] = w\\n\\n        return result', refusal=None, role='assistant', audio=None, function_call=None, tool_calls=None))], created=1735143465, model='gpt-3.5-turbo-0125', object='chat.completion', service_tier=None, system_fingerprint=None, usage=CompletionUsage(completion_tokens=1218, prompt_tokens=1445, total_tokens=2663, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))", "test_case_name": "VectorCalculator.txt"}