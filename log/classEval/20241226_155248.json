{"response body": {"id": "3bc4d36e-dd3e-4bea-bb95-877fe57c8c84", "object": "chat.completion", "model": "gpt-4-32k", "created": "2024-12-26 15:52:52", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "\"\"\"\nThis class represents a game of Mahjong Connect, handling the game board creation, move validation, path finding, \nicon removal, and game completion check.\n\"\"\"\n\nimport random\n\n\nclass MahjongConnect:\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        Initializes the game board with given size and icons.\n        \n        Parameters:\n            BOARD_SIZE (tuple): A tuple of two integers representing the number of rows and columns of the game board.\n            ICONS (list): A list of characters representing the icons used in the game.\n        \n        Test cases:\n            # Test case 1: Normal board size and icons\n            game = MahjongConnect((5, 5), ['A', 'B', 'C', 'D'])\n            \n            # Test case 2: Larger board size\n            game = MahjongConnect((10, 10), ['A', 'B', 'C', 'D'])\n            \n            # Test case 3: Invalid board size\n            game = MahjongConnect((-1, 5), ['A', 'B', 'C', 'D'])  # Raises ValueError\n        \"\"\"\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        Creates the game board by randomly placing icons on each position.\n        \n        Returns:\n            list: A 2D list representing the game board.\n        \n        Test cases:\n            # Test case 1: Normal usage\n            game = MahjongConnect((5, 5), ['A', 'B', 'C', 'D'])\n            print(game.create_board())  # Outputs a 5x5 board with random icons\n        \"\"\"\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        Checks if a move between two positions is valid.\n        \n        Parameters:\n            pos1 (tuple): A tuple of two integers representing the starting position of the move.\n            pos2 (tuple): A tuple of two integers representing the ending position of the move.\n        \n        Returns:\n            bool: True if the move is valid, False otherwise.\n        \n        Test cases:\n            # Test case 1: Valid move\n            game = MahjongConnect((5, 5), ['A', 'B', 'C', 'D'])\n            assert game.is_valid_move((0, 0), (0, 1)) == True\n            \n            # Test case 2: Invalid move (no path)\n            assert game.is_valid_move((0, 0), (4, 4)) == False\n            \n            # Test case 3: Invalid move (same position)\n            assert game.is_valid_move((0, 0), (0, 0)) == False\n        \"\"\"\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within the game board range\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 <\n                self.BOARD_SIZE[1]):\n            return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        Checks if there is a valid path between two positions.\n        \n        Parameters:\n            pos1 (tuple): A tuple of two integers representing the starting position of the path.\n            pos2 (tuple): A tuple of two integers representing the ending position of the path.\n        \n        Returns:\n            bool: True if there is a valid path, False otherwise.\n            \n        Test cases:\n            # Test case 1: Valid path\n            game = MahjongConnect((5, 5), ['A', 'B', 'C', 'D'])\n            assert game.has_path((0, 0), (0, 1)) == True\n            \n            # Test case 2: Invalid path\n            assert game.has_path((0, 0), (4, 4)) == False\n            \n            # Test case 3: Path to self\n            assert game.has_path((0, 0), (0, 0)) == False\n        \"\"\"\n        visited = set()\n        stack = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Check adjacent positions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n\n        return False\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        Removes the icons at the specified positions.\n        \n        Parameters:\n            pos1 (tuple): A tuple of two integers representing the position of the first icon.\n            pos2 (tuple): A tuple of two integers representing the position of the second icon.\n            \n        Test cases:\n            # Test case 1: Normal usage\n            game = MahjongConnect((5, 5), ['A', 'B', 'C', 'D'])\n            game.remove_icons((0, 0), (0, 1))  # Icons at (0, 0) and (0, 1) are removed\n            \n            # Test case 2: Removing non-existing icons\n            game.remove_icons((10, 10), (11, 11))  # Throws IndexError\n            \n            # Test case 3: Removing same position\n            game.remove_icons((0, 0), (0, 0))  # Icon at (0, 0) is removed\n        \"\"\"\n        x1, y1 = pos1\n        x2, y2 = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Checks if the game is over (no more icons left on the board).\n        \n        Returns:\n            bool: True if the game is over, False otherwise.\n            \n        Test cases:\n            # Test case 1: Game not over\n            game = MahjongConnect((5, 5), ['A', 'B', 'C', 'D'])\n            assert game.is_game_over() == False\n            \n            # Test case 2: Game over\n            for i in range(5):\n                for j in range(5):\n                    game.remove_icons((i, j), (i, j))\n            assert game.is_game_over() == True\n        \"\"\"\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True"}}], "usage": {"completion_tokens": 1623, "prompt_tokens": 1706, "total_tokens": 3329}, "feeType": "1", "consume": 2.159072}, "test_case_name": "MahjongConnect.txt"}