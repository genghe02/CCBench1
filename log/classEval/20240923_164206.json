{"response body": "{\n  \"id\": \"2f3ec982-b7f2-476a-b9ff-f781b1f72244\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\n# This class provides a simple calculator that can evaluate mathematical expressions using basic operators.\\nclass Calculator:\\n    def __init__(self):\\n        # Initialize the calculator with a dictionary of supported operators and their corresponding lambda functions.\\n        self.operators = {\\n            '+': lambda x, y: x + y,\\n            '-': lambda x, y: x - y,\\n            '*': lambda x, y: x * y,\\n            '/': lambda x, y: x / y,\\n            '^': lambda x, y: x ** y\\n        }\\n\\n    def calculate(self, expression):\\n        # Evaluate a mathematical expression using the Shunting Yard algorithm.\\n        # param expression: str, the mathematical expression to be evaluated.\\n        # return: float, the result of the evaluated expression, or None if the expression is invalid.\\n        # >>> calc = Calculator()\\n        # >>> calc.calculate(\\\"3+5*2\\\")\\n        # 13.0\\n        # >>> calc.calculate(\\\"(3+5)*2\\\")\\n        # 16.0\\n        # >>> calc.calculate(\\\"3+5*2^2\\\")\\n        # 23.0\\n        operand_stack = []\\n        operator_stack = []\\n        num_buffer = ''\\n\\n        for char in expression:\\n            if char.isdigit() or char == '.':\\n                num_buffer += char\\n            else:\\n                if num_buffer:\\n                    operand_stack.append(float(num_buffer))\\n                    num_buffer = ''\\n\\n                if char in '+-*/^':\\n                    while (\\n                            operator_stack and\\n                            operator_stack[-1] != '(' and\\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\\n                    ):\\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\\n\\n                    operator_stack.append(char)\\n                elif char == '(':\\n                    operator_stack.append(char)\\n                elif char == ')':\\n                    while operator_stack and operator_stack[-1] != '(':\\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\\n\\n                    operator_stack.pop()\\n\\n        if num_buffer:\\n            operand_stack.append(float(num_buffer))\\n\\n        while operator_stack:\\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\\n\\n        return operand_stack[-1] if operand_stack else None\\n\\n    def precedence(self, operator):\\n        # Determine the precedence level of a given operator.\\n        # param operator: str, the operator whose precedence is to be determined.\\n        # return: int, the precedence level of the operator.\\n        # >>> calc = Calculator()\\n        # >>> calc.precedence('+')\\n        # 1\\n        # >>> calc.precedence('*')\\n        # 2\\n        # >>> calc.precedence('^')\\n        # 3\\n        precedences = {\\n            '+': 1,\\n            '-': 1,\\n            '*': 2,\\n            '/': 2,\\n            '^': 3\\n        }\\n        return precedences.get(operator, 0)\\n\\n    def apply_operator(self, operand_stack, operator_stack):\\n        # Apply the operator at the top of the operator stack to the top two operands on the operand stack.\\n        # param operand_stack: list, the stack of operands.\\n        # param operator_stack: list, the stack of operators.\\n        # return: tuple, the updated operand and operator stacks after applying the operator.\\n        # >>> calc = Calculator()\\n        # >>> calc.apply_operator([3.0, 5.0], ['+'])\\n        # ([8.0], [])\\n        # >>> calc.apply_operator([3.0, 5.0], ['*'])\\n        # ([15.0], [])\\n        operator = operator_stack.pop()\\n        if operator == '^':\\n            operand2 = operand_stack.pop()\\n            operand1 = operand_stack.pop()\\n            result = self.operators[operator](operand1, operand2)\\n            operand_stack.append(result)\\n        else:\\n            operand2 = operand_stack.pop()\\n            operand1 = operand_stack.pop()\\n            result = self.operators[operator](operand1, operand2)\\n            operand_stack.append(result)\\n        return operand_stack, operator_stack\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1727080872,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1c141eb703\",\n  \"usage\": {\n    \"completion_tokens\": 1031,\n    \"prompt_tokens\": 1337,\n    \"total_tokens\": 2368,\n    \"prompt_cache_hit_tokens\": 576,\n    \"prompt_cache_miss_tokens\": 761\n  }\n}", "test_case_name": "Calculator.txt"}