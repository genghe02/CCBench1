{"response body": "{\n  \"id\": \"34a441e6-95cf-4053-9957-7797cfd2d95a\",\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"message\": {\n        \"content\": \"```python\\n\\\"\\\"\\\"\\nThis class provides functionality to calculate combinations and select subsets from a given list of data.\\nIt includes methods to count combinations, count all possible subsets, and generate specific or all subsets.\\n\\\"\\\"\\\"\\n\\nimport math\\nfrom typing import List\\n\\nclass CombinationCalculator:\\n    \\n    def __init__(self, datas: List[str]):\\n        \\\"\\\"\\\"\\n        Initializes the CombinationCalculator with a list of data.\\n\\n        Parameters:\\n            datas (List[str]): A list of strings from which combinations will be generated.\\n        \\\"\\\"\\\"\\n        self.datas = datas\\n\\n    @staticmethod\\n    def count(n: int, m: int) -> int:\\n        \\\"\\\"\\\"\\n        Calculates the number of combinations of n items taken m at a time.\\n\\n        Parameters:\\n            n (int): The total number of items.\\n            m (int): The number of items to choose.\\n\\n        Returns:\\n            int: The number of combinations.\\n\\n        Test cases:\\n            # Test case 1: Basic combination\\n            assert CombinationCalculator.count(5, 2) == 10\\n            \\n            # Test case 2: Edge case where m is 0\\n            assert CombinationCalculator.count(5, 0) == 1\\n            \\n            # Test case 3: Edge case where n equals m\\n            assert CombinationCalculator.count(5, 5) == 1\\n        \\\"\\\"\\\"\\n        if m == 0 or n == m:\\n            return 1\\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\\n\\n    @staticmethod\\n    def count_all(n: int) -> int:\\n        \\\"\\\"\\\"\\n        Calculates the total number of possible subsets from n items.\\n\\n        Parameters:\\n            n (int): The total number of items.\\n\\n        Returns:\\n            int: The total number of subsets, or False if n is out of range.\\n\\n        Test cases:\\n            # Test case 1: Basic case\\n            assert CombinationCalculator.count_all(3) == 7\\n            \\n            # Test case 2: Edge case where n is 0\\n            assert CombinationCalculator.count_all(0) == 0\\n            \\n            # Test case 3: Edge case where n is 63\\n            assert CombinationCalculator.count_all(63) == float(\\\"inf\\\")\\n        \\\"\\\"\\\"\\n        if n < 0 or n > 63:\\n            return False\\n        return (1 << n) - 1 if n != 63 else float(\\\"inf\\\")\\n\\n    def select(self, m: int) -> List[List[str]]:\\n        \\\"\\\"\\\"\\n        Generates all combinations of the data of size m.\\n\\n        Parameters:\\n            m (int): The size of each combination.\\n\\n        Returns:\\n            List[List[str]]: A list of all combinations of size m.\\n\\n        Test cases:\\n            # Test case 1: Basic selection\\n            calc = CombinationCalculator(['a', 'b', 'c'])\\n            assert calc.select(2) == [['a', 'b'], ['a', 'c'], ['b', 'c']]\\n            \\n            # Test case 2: Edge case where m is 1\\n            calc = CombinationCalculator(['a', 'b', 'c'])\\n            assert calc.select(1) == [['a'], ['b'], ['c']]\\n            \\n            # Test case 3: Edge case where m equals the length of data\\n            calc = CombinationCalculator(['a', 'b', 'c'])\\n            assert calc.select(3) == [['a', 'b', 'c']]\\n        \\\"\\\"\\\"\\n        result = []\\n        self._select(0, [None] * m, 0, result)\\n        return result\\n\\n    def select_all(self) -> List[List[str]]:\\n        \\\"\\\"\\\"\\n        Generates all possible subsets of the data.\\n\\n        Returns:\\n            List[List[str]]: A list of all possible subsets.\\n\\n        Test cases:\\n            # Test case 1: Basic selection\\n            calc = CombinationCalculator(['a', 'b'])\\n            assert calc.select_all() == [['a'], ['b'], ['a', 'b']]\\n            \\n            # Test case 2: Single element data\\n            calc = CombinationCalculator(['a'])\\n            assert calc.select_all() == [['a']]\\n            \\n            # Test case 3: Empty data\\n            calc = CombinationCalculator([])\\n            assert calc.select_all() == []\\n        \\\"\\\"\\\"\\n        result = []\\n        for i in range(1, len(self.datas) + 1):\\n            result.extend(self.select(i))\\n        return result\\n\\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\\n        \\\"\\\"\\\"\\n        Helper method to recursively generate combinations.\\n\\n        Parameters:\\n            dataIndex (int): The current index in the data list.\\n            resultList (List[str]): The current combination being built.\\n            resultIndex (int): The current index in the result list.\\n            result (List[List[str]]): The list to store all combinations.\\n\\n        Returns:\\n            None\\n\\n        Test cases:\\n            # Test case 1: Basic recursion\\n            calc = CombinationCalculator(['a', 'b', 'c'])\\n            result = []\\n            calc._select(0, [None] * 2, 0, result)\\n            assert result == [['a', 'b'], ['a', 'c'], ['b', 'c']]\\n            \\n            # Test case 2: Edge case where resultIndex equals resultLen\\n            calc = CombinationCalculator(['a', 'b', 'c'])\\n            result = []\\n            calc._select(0, [None] * 3, 3, result)\\n            assert result == [['a', 'b', 'c']]\\n            \\n            # Test case 3: Edge case where dataIndex is out of range\\n            calc = CombinationCalculator(['a', 'b', 'c'])\\n            result = []\\n            calc._select(3, [None] * 2, 0, result)\\n            assert result == []\\n        \\\"\\\"\\\"\\n        resultLen = len(resultList)\\n        resultCount = resultIndex + 1\\n        if resultCount > resultLen:\\n            result.append(resultList.copy())\\n            return\\n\\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\\n            resultList[resultIndex] = self.datas[i]\\n            self._select(i + 1, resultList, resultIndex + 1, result)\\n```\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1735193831,\n  \"model\": \"deepseek-chat\",\n  \"object\": \"chat.completion\",\n  \"system_fingerprint\": \"fp_1a5c54ff19\",\n  \"usage\": {\n    \"completion_tokens\": 1322,\n    \"prompt_tokens\": 1466,\n    \"total_tokens\": 2788,\n    \"prompt_cache_hit_tokens\": 960,\n    \"prompt_cache_miss_tokens\": 506\n  }\n}", "test_case_name": "CombinationCalculator.txt"}