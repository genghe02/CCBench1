{"response body": "ChatCompletion(id='chatcmpl-A6GNJTjnPALuhoVb6C3QAJb6Fqww8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```python\\nimport re\\nfrom collections import deque\\nfrom decimal import Decimal\\n\\n# This is a class for evaluating mathematical expressions using the Shunting Yard algorithm to convert infix to postfix notation and calculating the result.\\nclass ExpressionCalculator:\\n    def __init__(self):\\n        # Initialize the calculator with an empty postfix stack and operator priority levels.\\n        self.postfix_stack = deque()\\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\\n\\n    def calculate(self, expression):\\n        # Calculate the result of a given mathematical expression.\\n        # :param expression: str, the mathematical expression to calculate.\\n        # :return: float, the result of the evaluated expression.\\n        # Test cases: \\n        # >>> calc = ExpressionCalculator()\\n        # >>> calc.calculate(\"3 + 5\")\\n        # >>> calc.calculate(\"10 - (2 + 3) * 4\")\\n        # >>> calc.calculate(\"5 * 6 / 2\")\\n        self.prepare(self.transform(expression))\\n\\n        result_stack = deque()\\n        self.postfix_stack.reverse()\\n\\n        while self.postfix_stack:\\n            current_op = self.postfix_stack.pop()\\n            if not self.is_operator(current_op):\\n                current_op = current_op.replace(\"~\", \"-\")\\n                result_stack.append(current_op)\\n            else:\\n                second_value = result_stack.pop()\\n                first_value = result_stack.pop()\\n\\n                first_value = first_value.replace(\"~\", \"-\")\\n                second_value = second_value.replace(\"~\", \"-\")\\n\\n                temp_result = self._calculate(first_value, second_value, current_op)\\n                result_stack.append(str(temp_result))\\n\\n        return float(eval(\"*\".join(result_stack)))\\n\\n    def prepare(self, expression):\\n        # Prepare the expression for evaluation by converting infix notation to postfix notation.\\n        # :param expression: str, the mathematical expression in infix notation.\\n        # Test cases:\\n        # >>> calc = ExpressionCalculator()\\n        # >>> calc.prepare(\"3 + 5 * (2 - 1)\")\\n        # >>> calc.prepare(\"(1 + 2) * 3\")\\n        op_stack = deque([\\',\\'])\\n        arr = list(expression)\\n        current_index = 0\\n        count = 0\\n\\n        for i, current_op in enumerate(arr):\\n            if self.is_operator(current_op):\\n                if count > 0:\\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\\n                peek_op = op_stack[-1]\\n                if current_op == \\')\\':\\n                    while op_stack[-1] != \\'(\\':\\n                        self.postfix_stack.append(str(op_stack.pop()))\\n                    op_stack.pop()\\n                else:\\n                    while current_op != \\'(\\' and peek_op != \\',\\' and self.compare(current_op, peek_op):\\n                        self.postfix_stack.append(str(op_stack.pop()))\\n                        peek_op = op_stack[-1]\\n                    op_stack.append(current_op)\\n\\n                count = 0\\n                current_index = i + 1\\n            else:\\n                count += 1\\n\\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\\n\\n        while op_stack[-1] != \\',\\':\\n            self.postfix_stack.append(str(op_stack.pop()))\\n\\n    @staticmethod\\n    def is_operator(c):\\n        # Check if the character is a valid operator.\\n        # :param c: str, the character to check.\\n        # :return: bool, True if the character is an operator, False otherwise.\\n        # Test cases:\\n        # >>> ExpressionCalculator.is_operator(\\'+\\')\\n        # >>> ExpressionCalculator.is_operator(\\'a\\')\\n        return c in {\\'+\\', \\'-\\', \\'*\\', \\'/\\', \\'(\\', \\')\\', \\'%\\'}\\n\\n    def compare(self, cur, peek):\\n        # Compare the precedence of two operators.\\n        # :param cur: str, the current operator.\\n        # :param peek: str, the operator to compare against.\\n        # :return: bool, True if the current operator has lower or equal precedence than the peek operator.\\n        # Test cases:\\n        # >>> calc = ExpressionCalculator()\\n        # >>> calc.compare(\\'+\\', \\'*\\')\\n        # >>> calc.compare(\\'/\\', \\'+\\')\\n        if cur == \\'%\\':\\n            cur = \\'/\\'\\n        if peek == \\'%\\':\\n            peek = \\'/\\'\\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\\n\\n    @staticmethod\\n    def _calculate(first_value, second_value, current_op):\\n        # Perform a calculation with two operands and an operator.\\n        # :param first_value: str, the first operand.\\n        # :param second_value: str, the second operand.\\n        # :param current_op: str, the operator to apply.\\n        # :return: Decimal, the result of the calculation.\\n        # Test cases:\\n        # >>> ExpressionCalculator._calculate(\\'3\\', \\'2\\', \\'+\\')\\n        # >>> ExpressionCalculator._calculate(\\'5\\', \\'3\\', \\'-\\')\\n        if current_op == \\'+\\':\\n            return Decimal(first_value) + Decimal(second_value)\\n        elif current_op == \\'-\\':\\n            return Decimal(first_value) - Decimal(second_value)\\n        elif current_op == \\'*\\':\\n            return Decimal(first_value) * Decimal(second_value)\\n        elif current_op == \\'/\\':\\n            return Decimal(first_value) / Decimal(second_value)\\n        elif current_op == \\'%\\':\\n            return Decimal(first_value) % Decimal(second_value)\\n        else:\\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))\\n\\n    @staticmethod\\n    def transform(expression):\\n        # Transform the input expression to handle unary operators and remove whitespace.\\n        # :param expression: str, the input expression to transform.\\n        # :return: str, the transformed expression.\\n        # Test cases:\\n        # >>> ExpressionCalculator.transform(\"3 + -2\")\\n        # >>> ExpressionCalculator.transform(\" - ( 2 + 3 ) \")\\n        expression = re.sub(r\"\\\\s+\", \"\", expression)\\n        expression = re.sub(r\"=$\", \"\", expression)\\n        arr = list(expression)\\n\\n        for i, c in enumerate(arr):\\n            if c == \\'-\\':\\n                if i == 0:\\n                    arr[i] = \\'~\\'\\n                else:\\n                    prev_c = arr[i - 1]\\n                    if prev_c in {\\'+\\', \\'-\\', \\'*\\', \\'/\\', \\'(\\', \\'E\\', \\'e\\'}:\\n                        arr[i] = \\'~\\'\\n\\n        if arr[0] == \\'~\\' and (len(arr) > 1 and arr[1] == \\'(\\'):\\n            arr[0] = \\'-\\'\\n            return \"0\" + \"\".join(arr)\\n        else:\\n            return \"\".join(arr)\\n```', refusal=None, role='assistant', function_call=None, tool_calls=None))], created=1726056277, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier=None, system_fingerprint='fp_483d39d857', usage=CompletionUsage(completion_tokens=1374, prompt_tokens=1852, total_tokens=3226))", "test_case_name": "ExpressionCalculator.txt"}