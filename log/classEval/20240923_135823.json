{"response body": {"id": "7be52e26-f5a0-469e-8408-9dec8e8444dc", "object": "chat.completion", "model": "gpt-35-turbo", "created": "2024-09-23 13:58:23", "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "class MetricsCalculator:\n    # Class to calculate various metrics like precision, recall, f1 score, and accuracy based on predicted and true labels.\n\n    def __init__(self):\n        # Initializes the metrics calculator with counts for true positives, false positives, false negatives, and true negatives.\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n    def update(self, predicted_labels, true_labels):\n        # Updates the counts of different metrics based on predicted and true labels.\n        # param predicted_labels: list, predicted labels for the samples\n        # param true_labels: list, true labels for the samples\n        # return: None\n        # Some test cases for the function:\n        # >>> calc = MetricsCalculator()\n        # >>> calc.update([1, 0, 1], [1, 1, 0])\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n    def precision(self, predicted_labels, true_labels):\n        # Calculates the precision metric based on predicted and true labels.\n        # param predicted_labels: list, predicted labels for the samples\n        # param true_labels: list, true labels for the samples\n        # return: float, precision value\n        # Some test cases for the function:\n        # >>> calc = MetricsCalculator()\n        # >>> calc.precision([1, 0, 1], [1, 1, 0])\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n    def recall(self, predicted_labels, true_labels):\n        # Calculates the recall metric based on predicted and true labels.\n        # param predicted_labels: list, predicted labels for the samples\n        # param true_labels: list, true labels for the samples\n        # return: float, recall value\n        # Some test cases for the function:\n        # >>> calc = MetricsCalculator()\n        # >>> calc.recall([1, 0, 1], [1, 1, 0])\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n    def f1_score(self, predicted_labels, true_labels):\n        # Calculates the F1 score metric based on predicted and true labels.\n        # param predicted_labels: list, predicted labels for the samples\n        # param true_labels: list, true labels for the samples\n        # return: float, F1 score value\n        # Some test cases for the function:\n        # >>> calc = MetricsCalculator()\n        # >>> calc.f1_score([1, 0, 1], [1, 1, 0])\n        self.update(predicted_labels, true_labels)\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        if precision + recall == 0.0:\n            return 0.0\n        return (2 * precision * recall) / (precision + recall)\n\n    def accuracy(self, predicted_labels, true_labels):\n        # Calculates the accuracy metric based on predicted and true labels.\n        # param predicted_labels: list, predicted labels for the samples\n        # param true_labels: list, true labels for the samples\n        # return: float, accuracy value\n        # Some test cases for the function:\n        # >>> calc = MetricsCalculator()\n        # >>> calc.accuracy([1, 0, 1], [1, 1, 0])\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total"}}], "usage": {"completion_tokens": 935, "prompt_tokens": 1151, "total_tokens": 2086}, "feeType": "1", "consume": 0.014365612688}, "test_case_name": "MetricsCalculator.txt"}