["Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sina_xml_to_url_list ( xml_data ) : rawurl = [ ] dom = parseString ( xml_data ) for node in dom . getElementsByTagName ( 'durl' ) : url = node . getElementsByTagName ( 'url' ) [ 0 ] rawurl . append ( url . childNodes [ 0 ] . data ) return rawurl\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def makeMimi ( upid ) : strSeed = \"gGddgPfeaf_gzyr\" prehash = upid + \"_\" + strSeed return md5 ( prehash . encode ( 'utf-8' ) ) . hexdigest ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fc2video_download ( url , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : #'http://video.fc2.com/en/content/20151021bTVKnbEw' #'http://xiaojiadianvideo.asia/content/20151021bTVKnbEw' #'http://video.fc2.com/ja/content/20151021bTVKnbEw' #'http://video.fc2.com/tw/content/20151021bTVKnbEw' hostname = urlparse ( url ) . hostname if not ( 'fc2.com' in hostname or 'xiaojiadianvideo.asia' in hostname ) : return False upid = match1 ( url , r'.+/content/(\\w+)' ) fc2video_download_by_upid ( upid , output_dir , merge , info_only )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dailymotion_download ( url , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : html = get_content ( rebuilt_url ( url ) ) info = json . loads ( match1 ( html , r'qualities\":({.+?}),\"' ) ) title = match1 ( html , r'\"video_title\"\\s*:\\s*\"([^\"]+)\"' ) or match1 ( html , r'\"title\"\\s*:\\s*\"([^\"]+)\"' ) title = unicodize ( title ) for quality in [ '1080' , '720' , '480' , '380' , '240' , '144' , 'auto' ] : try : real_url = info [ quality ] [ 1 ] [ \"url\" ] if real_url : break except KeyError : pass mime , ext , size = url_info ( real_url ) print_info ( site_info , title , mime , size ) if not info_only : download_urls ( [ real_url ] , title , ext , size , output_dir = output_dir , merge = merge )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dictify ( r , root = True ) : if root : return { r . tag : dictify ( r , False ) } d = copy ( r . attrib ) if r . text : d [ \"_text\" ] = r . text for x in r . findall ( \"./*\" ) : if x . tag not in d : d [ x . tag ] = [ ] d [ x . tag ] . append ( dictify ( x , False ) ) return d\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ucas_download_single ( url , output_dir = '.' , merge = False , info_only = False , * * kwargs ) : html = get_content ( url ) # resourceID is UUID resourceID = re . findall ( r'resourceID\":\"([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})' , html ) [ 0 ] assert resourceID != '' , 'Cannot find resourceID!' title = match1 ( html , r'<div class=\"bc-h\">(.+)</div>' ) url_lists = _ucas_get_url_lists_by_resourceID ( resourceID ) assert url_lists , 'Cannot find any URL of such class!' for k , part in enumerate ( url_lists ) : part_title = title + '_' + str ( k ) print_info ( site_info , part_title , 'flv' , 0 ) if not info_only : download_urls ( part , part_title , 'flv' , total_size = None , output_dir = output_dir , merge = merge )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ucas_download_playlist ( url , output_dir = '.' , merge = False , info_only = False , * * kwargs ) : html = get_content ( url ) parts = re . findall ( r'(getplaytitle.do\\?.+)\"' , html ) assert parts , 'No part found!' for part_path in parts : ucas_download ( 'http://v.ucas.ac.cn/course/' + part_path , output_dir = output_dir , merge = merge , info_only = info_only )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sina_download_by_vid ( vid , title = None , output_dir = '.' , merge = True , info_only = False ) : xml = api_req ( vid ) urls , name , size = video_info ( xml ) if urls is None : log . wtf ( name ) title = name print_info ( site_info , title , 'flv' , size ) if not info_only : download_urls ( urls , title , 'flv' , size , output_dir = output_dir , merge = merge )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sina_download_by_vkey ( vkey , title = None , output_dir = '.' , merge = True , info_only = False ) : url = 'http://video.sina.com/v/flvideo/%s_0.flv' % vkey type , ext , size = url_info ( url ) print_info ( site_info , title , 'flv' , size ) if not info_only : download_urls ( [ url ] , title , 'flv' , size , output_dir = output_dir , merge = merge )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sina_download ( url , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : if 'news.sina.com.cn/zxt' in url : sina_zxt ( url , output_dir = output_dir , merge = merge , info_only = info_only , * * kwargs ) return vid = match1 ( url , r'vid=(\\d+)' ) if vid is None : video_page = get_content ( url ) vid = hd_vid = match1 ( video_page , r'hd_vid\\s*:\\s*\\'([^\\']+)\\'' ) if hd_vid == '0' : vids = match1 ( video_page , r'[^\\w]vid\\s*:\\s*\\'([^\\']+)\\'' ) . split ( '|' ) vid = vids [ - 1 ] if vid is None : vid = match1 ( video_page , r'vid:\"?(\\d+)\"?' ) if vid : #title = match1(video_page, r'title\\s*:\\s*\\'([^\\']+)\\'') sina_download_by_vid ( vid , output_dir = output_dir , merge = merge , info_only = info_only ) else : vkey = match1 ( video_page , r'vkey\\s*:\\s*\"([^\"]+)\"' ) if vkey is None : vid = match1 ( url , r'#(\\d+)' ) sina_download_by_vid ( vid , output_dir = output_dir , merge = merge , info_only = info_only ) return title = match1 ( video_page , r'title\\s*:\\s*\"([^\"]+)\"' ) sina_download_by_vkey ( vkey , title = title , output_dir = output_dir , merge = merge , info_only = info_only )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def yixia_download ( url , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : hostname = urlparse ( url ) . hostname if 'n.miaopai.com' == hostname : smid = match1 ( url , r'n\\.miaopai\\.com/media/([^.]+)' ) miaopai_download_by_smid ( smid , output_dir , merge , info_only ) return elif 'miaopai.com' in hostname : #Miaopai yixia_download_by_scid = yixia_miaopai_download_by_scid site_info = \"Yixia Miaopai\" scid = match1 ( url , r'miaopai\\.com/show/channel/([^.]+)\\.htm' ) or match1 ( url , r'miaopai\\.com/show/([^.]+)\\.htm' ) or match1 ( url , r'm\\.miaopai\\.com/show/channel/([^.]+)\\.htm' ) or match1 ( url , r'm\\.miaopai\\.com/show/channel/([^.]+)' ) elif 'xiaokaxiu.com' in hostname : #Xiaokaxiu yixia_download_by_scid = yixia_xiaokaxiu_download_by_scid site_info = \"Yixia Xiaokaxiu\" if re . match ( r'http://v.xiaokaxiu.com/v/.+\\.html' , url ) : #PC scid = match1 ( url , r'http://v.xiaokaxiu.com/v/(.+)\\.html' ) elif re . match ( r'http://m.xiaokaxiu.com/m/.+\\.html' , url ) : #Mobile scid = match1 ( url , r'http://m.xiaokaxiu.com/m/(.+)\\.html' ) else : pass yixia_download_by_scid ( scid , output_dir , merge , info_only )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def veoh_download ( url , output_dir = '.' , merge = False , info_only = False , * * kwargs ) : if re . match ( r'http://www.veoh.com/watch/\\w+' , url ) : item_id = match1 ( url , r'http://www.veoh.com/watch/(\\w+)' ) elif re . match ( r'http://www.veoh.com/m/watch.php\\?v=\\.*' , url ) : item_id = match1 ( url , r'http://www.veoh.com/m/watch.php\\?v=(\\w+)' ) else : raise NotImplementedError ( 'Cannot find item ID' ) veoh_download_by_id ( item_id , output_dir = '.' , merge = False , info_only = info_only , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def veoh_download_by_id ( item_id , output_dir = '.' , merge = False , info_only = False , * * kwargs ) : webpage_url = 'http://www.veoh.com/m/watch.php?v={item_id}&quality=1' . format ( item_id = item_id ) #grab download URL a = get_content ( webpage_url , decoded = True ) url = match1 ( a , r'<source src=\"(.*?)\\\"\\W' ) #grab title title = match1 ( a , r'<meta property=\"og:title\" content=\"([^\"]*)\"' ) type_ , ext , size = url_info ( url ) print_info ( site_info , title , type_ , size ) if not info_only : download_urls ( [ url ] , title , ext , total_size = None , output_dir = output_dir , merge = merge )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download_by_id ( self , vid = '' , title = None , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : assert vid self . prepare ( vid = vid , title = title , * * kwargs ) self . extract ( * * kwargs ) self . download ( output_dir = output_dir , merge = merge , info_only = info_only , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_vid_from_url ( self , url ) : hit = re . search ( r'live.qq.com/(\\d+)' , url ) if hit is not None : return hit . group ( 1 ) hit = re . search ( r'live.qq.com/directory/match/(\\d+)' , url ) if hit is not None : return self . get_room_id_from_url ( hit . group ( 1 ) ) html = get_content ( url ) room_id = match1 ( html , r'room_id\\\":(\\d+)' ) if room_id is None : log . wtf ( 'Unknown page {}' . format ( url ) ) return room_id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sprint ( text , * colors ) : return \"\\33[{}m{content}\\33[{}m\" . format ( \";\" . join ( [ str ( color ) for color in colors ] ) , RESET , content = text ) if IS_ANSI_TERMINAL and colors else text\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def print_log ( text , * colors ) : sys . stderr . write ( sprint ( \"{}: {}\" . format ( script_name , text ) , * colors ) + \"\\n\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def e ( message , exit_code = None ) : print_log ( message , YELLOW , BOLD ) if exit_code is not None : sys . exit ( exit_code )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wtf ( message , exit_code = 1 ) : print_log ( message , RED , BOLD ) if exit_code is not None : sys . exit ( exit_code )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def detect_os ( ) : # Inspired by: # https://github.com/scivision/pybashutils/blob/78b7f2b339cb03b1c37df94015098bbe462f8526/pybashutils/windows_linux_detect.py syst = system ( ) . lower ( ) os = 'unknown' if 'cygwin' in syst : os = 'cygwin' elif 'darwin' in syst : os = 'mac' elif 'linux' in syst : os = 'linux' # detect WSL https://github.com/Microsoft/BashOnWindows/issues/423 try : with open ( '/proc/version' , 'r' ) as f : if 'microsoft' in f . read ( ) . lower ( ) : os = 'wsl' except : pass elif 'windows' in syst : os = 'windows' elif 'bsd' in syst : os = 'bsd' return os\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def miaopai_download_by_fid ( fid , output_dir = '.' , merge = False , info_only = False , * * kwargs ) : page_url = 'http://video.weibo.com/show?fid=' + fid + '&type=mp4' mobile_page = get_content ( page_url , headers = fake_headers_mobile ) url = match1 ( mobile_page , r'<video id=.*?src=[\\'\"](.*?)[\\'\"]\\W' ) if url is None : wb_mp = re . search ( r'<script src=([\\'\"])(.+?wb_mp\\.js)\\1>' , mobile_page ) . group ( 2 ) return miaopai_download_by_wbmp ( wb_mp , fid , output_dir = output_dir , merge = merge , info_only = info_only , total_size = None , * * kwargs ) title = match1 ( mobile_page , r'<title>((.|\\n)+?)</title>' ) if not title : title = fid title = title . replace ( '\\n' , '_' ) ext , size = 'mp4' , url_info ( url ) [ 2 ] print_info ( site_info , title , ext , size ) if not info_only : download_urls ( [ url ] , title , ext , total_size = None , output_dir = output_dir , merge = merge )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def vimeo_download_by_channel ( url , output_dir = '.' , merge = False , info_only = False , * * kwargs ) : # https://vimeo.com/channels/464686 channel_id = match1 ( url , r'http://vimeo.com/channels/(\\w+)' ) vimeo_download_by_channel_id ( channel_id , output_dir , merge , info_only , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def vimeo_download_by_channel_id ( channel_id , output_dir = '.' , merge = False , info_only = False , * * kwargs ) : html = get_content ( 'https://api.vimeo.com/channels/{channel_id}/videos?access_token={access_token}' . format ( channel_id = channel_id , access_token = access_token ) ) data = loads ( html ) id_list = [ ] #print(data) for i in data [ 'data' ] : id_list . append ( match1 ( i [ 'uri' ] , r'/videos/(\\w+)' ) ) for id in id_list : try : vimeo_download_by_id ( id , None , output_dir , merge , info_only , * * kwargs ) except urllib . error . URLError as e : log . w ( '{} failed with {}' . format ( id , e ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def vimeo_download_by_id ( id , title = None , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : site = VimeoExtractor ( ) site . download_by_vid ( id , info_only = info_only , output_dir = output_dir , merge = merge , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ckplayer_get_info_by_xml ( ckinfo ) : e = ET . XML ( ckinfo ) video_dict = { 'title' : '' , #'duration': 0, 'links' : [ ] , 'size' : 0 , 'flashvars' : '' , } dictified = dictify ( e ) [ 'ckplayer' ] if 'info' in dictified : if '_text' in dictified [ 'info' ] [ 0 ] [ 'title' ] [ 0 ] : #title video_dict [ 'title' ] = dictified [ 'info' ] [ 0 ] [ 'title' ] [ 0 ] [ '_text' ] . strip ( ) #if dictify(e)['ckplayer']['info'][0]['title'][0]['_text'].strip(): #duration #video_dict['title'] = dictify(e)['ckplayer']['info'][0]['title'][0]['_text'].strip() if '_text' in dictified [ 'video' ] [ 0 ] [ 'size' ] [ 0 ] : #size exists for 1 piece video_dict [ 'size' ] = sum ( [ int ( i [ 'size' ] [ 0 ] [ '_text' ] ) for i in dictified [ 'video' ] ] ) if '_text' in dictified [ 'video' ] [ 0 ] [ 'file' ] [ 0 ] : #link exist video_dict [ 'links' ] = [ i [ 'file' ] [ 0 ] [ '_text' ] . strip ( ) for i in dictified [ 'video' ] ] if '_text' in dictified [ 'flashvars' ] [ 0 ] : video_dict [ 'flashvars' ] = dictified [ 'flashvars' ] [ 0 ] [ '_text' ] . strip ( ) return video_dict\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_video_url_from_video_id ( video_id ) : # from js data = [ \"\" ] * 256 for index , _ in enumerate ( data ) : t = index for i in range ( 8 ) : t = - 306674912 ^ unsigned_right_shitf ( t , 1 ) if 1 & t else unsigned_right_shitf ( t , 1 ) data [ index ] = t def tmp ( ) : rand_num = random . random ( ) path = \"/video/urls/v/1/toutiao/mp4/{video_id}?r={random_num}\" . format ( video_id = video_id , random_num = str ( rand_num ) [ 2 : ] ) e = o = r = - 1 i , a = 0 , len ( path ) while i < a : e = ord ( path [ i ] ) i += 1 if e < 128 : r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ e ) ] else : if e < 2048 : r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 192 | e >> 6 & 31 ) ) ] r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 128 | 63 & e ) ) ] else : if 55296 <= e < 57344 : e = ( 1023 & e ) + 64 i += 1 o = 1023 & t . url ( i ) r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 240 | e >> 8 & 7 ) ) ] r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 128 | e >> 2 & 63 ) ) ] r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 128 | o >> 6 & 15 | ( 3 & e ) << 4 ) ) ] r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 128 | 63 & o ) ) ] else : r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 224 | e >> 12 & 15 ) ) ] r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 128 | e >> 6 & 63 ) ) ] r = unsigned_right_shitf ( r , 8 ) ^ data [ 255 & ( r ^ ( 128 | 63 & e ) ) ] return \"https://ib.365yg.com{path}&s={param}\" . format ( path = path , param = unsigned_right_shitf ( r ^ - 1 , 0 ) ) while 1 : url = tmp ( ) if url . split ( \"=\" ) [ - 1 ] [ 0 ] != \"-\" : # \u53c2\u6570s\u4e0d\u80fd\u4e3a\u8d1f\u6570 return url\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_vid_from_url ( url ) : vid = match1 ( url , 'https?://www.mgtv.com/(?:b|l)/\\d+/(\\d+).html' ) if not vid : vid = match1 ( url , 'https?://www.mgtv.com/hz/bdpz/\\d+/(\\d+).html' ) return vid\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_mgtv_real_url ( url ) : content = loads ( get_content ( url ) ) m3u_url = content [ 'info' ] split = urlsplit ( m3u_url ) base_url = \"{scheme}://{netloc}{path}/\" . format ( scheme = split [ 0 ] , netloc = split [ 1 ] , path = dirname ( split [ 2 ] ) ) content = get_content ( content [ 'info' ] ) #get the REAL M3U url, maybe to be changed later? segment_list = [ ] segments_size = 0 for i in content . split ( ) : if not i . startswith ( '#' ) : #not the best way, better we use the m3u8 package segment_list . append ( base_url + i ) # use ext-info for fast size calculate elif i . startswith ( '#EXT-MGTV-File-SIZE:' ) : segments_size += int ( i [ i . rfind ( ':' ) + 1 : ] ) return m3u_url , segments_size , segment_list\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_head ( repo_path ) : try : ref = open ( os . path . join ( repo_path , '.git' , 'HEAD' ) , 'r' ) . read ( ) . strip ( ) [ 5 : ] . split ( '/' ) branch = ref [ - 1 ] commit = open ( os . path . join ( repo_path , '.git' , * ref ) , 'r' ) . read ( ) . strip ( ) [ : 7 ] return branch , commit except : return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def legitimize ( text , os = detect_os ( ) ) : # POSIX systems text = text . translate ( { 0 : None , ord ( '/' ) : '-' , ord ( '|' ) : '-' , } ) # FIXME: do some filesystem detection if os == 'windows' or os == 'cygwin' or os == 'wsl' : # Windows (non-POSIX namespace) text = text . translate ( { # Reserved in Windows VFAT and NTFS ord ( ':' ) : '-' , ord ( '*' ) : '-' , ord ( '?' ) : '-' , ord ( '\\\\' ) : '-' , ord ( '\\\"' ) : '\\'' , # Reserved in Windows VFAT ord ( '+' ) : '-' , ord ( '<' ) : '-' , ord ( '>' ) : '-' , ord ( '[' ) : '(' , ord ( ']' ) : ')' , ord ( '\\t' ) : ' ' , } ) else : # *nix if os == 'mac' : # Mac OS HFS+ text = text . translate ( { ord ( ':' ) : '-' , } ) # Remove leading . if text . startswith ( \".\" ) : text = text [ 1 : ] text = text [ : 80 ] # Trim to 82 Unicode characters long return text\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_terminal_size ( ) : try : import fcntl , termios , struct # fcntl module only available on Unix return struct . unpack ( 'hh' , fcntl . ioctl ( 1 , termios . TIOCGWINSZ , '1234' ) ) except : return ( 40 , 80 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def cbs_download ( url , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : html = get_content ( url ) pid = match1 ( html , r'video\\.settings\\.pid\\s*=\\s*\\'([^\\']+)\\'' ) title = match1 ( html , r'video\\.settings\\.title\\s*=\\s*\\\"([^\\\"]+)\\\"' ) theplatform_download_by_pid ( pid , title , output_dir = output_dir , merge = merge , info_only = info_only )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download ( self , * * kwargs ) : if 'json_output' in kwargs and kwargs [ 'json_output' ] : json_output . output ( self ) elif 'info_only' in kwargs and kwargs [ 'info_only' ] : if 'stream_id' in kwargs and kwargs [ 'stream_id' ] : # Display the stream stream_id = kwargs [ 'stream_id' ] if 'index' not in kwargs : self . p ( stream_id ) else : self . p_i ( stream_id ) else : # Display all available streams if 'index' not in kwargs : self . p ( [ ] ) else : stream_id = self . streams_sorted [ 0 ] [ 'id' ] if 'id' in self . streams_sorted [ 0 ] else self . streams_sorted [ 0 ] [ 'itag' ] self . p_i ( stream_id ) else : if 'stream_id' in kwargs and kwargs [ 'stream_id' ] : # Download the stream stream_id = kwargs [ 'stream_id' ] else : # Download stream with the best quality stream_id = self . streams_sorted [ 0 ] [ 'id' ] if 'id' in self . streams_sorted [ 0 ] else self . streams_sorted [ 0 ] [ 'itag' ] if 'index' not in kwargs : self . p ( stream_id ) else : self . p_i ( stream_id ) if stream_id in self . streams : urls = self . streams [ stream_id ] [ 'src' ] ext = self . streams [ stream_id ] [ 'container' ] total_size = self . streams [ stream_id ] [ 'size' ] else : urls = self . dash_streams [ stream_id ] [ 'src' ] ext = self . dash_streams [ stream_id ] [ 'container' ] total_size = self . dash_streams [ stream_id ] [ 'size' ] if not urls : log . wtf ( '[Failed] Cannot extract video source.' ) # For legacy main() #Here's the change!! download_url_ffmpeg ( urls [ 0 ] , self . title , 'mp4' , output_dir = kwargs [ 'output_dir' ] , merge = kwargs [ 'merge' ] , stream = False ) if not kwargs [ 'caption' ] : print ( 'Skipping captions.' ) return for lang in self . caption_tracks : filename = '%s.%s.srt' % ( get_filename ( self . title ) , lang ) print ( 'Saving %s ... ' % filename , end = \"\" , flush = True ) srt = self . caption_tracks [ lang ] with open ( os . path . join ( kwargs [ 'output_dir' ] , filename ) , 'w' , encoding = 'utf-8' ) as x : x . write ( srt ) print ( 'Done.' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def acfun_download_by_vid ( vid , title , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : #first call the main parasing API info = json . loads ( get_content ( 'http://www.acfun.cn/video/getVideo.aspx?id=' + vid ) ) sourceType = info [ 'sourceType' ] #decide sourceId to know which extractor to use if 'sourceId' in info : sourceId = info [ 'sourceId' ] # danmakuId = info['danmakuId'] #call extractor decided by sourceId if sourceType == 'sina' : sina_download_by_vid ( sourceId , title , output_dir = output_dir , merge = merge , info_only = info_only ) elif sourceType == 'youku' : youku_download_by_vid ( sourceId , title = title , output_dir = output_dir , merge = merge , info_only = info_only , * * kwargs ) elif sourceType == 'tudou' : tudou_download_by_iid ( sourceId , title , output_dir = output_dir , merge = merge , info_only = info_only ) elif sourceType == 'qq' : qq_download_by_vid ( sourceId , title , True , output_dir = output_dir , merge = merge , info_only = info_only ) elif sourceType == 'letv' : letvcloud_download_by_vu ( sourceId , '2d8c027396' , title , output_dir = output_dir , merge = merge , info_only = info_only ) elif sourceType == 'zhuzhan' : #As in Jul.28.2016, Acfun is using embsig to anti hotlink so we need to pass this #In Mar. 2017 there is a dedicated ``acfun_proxy'' in youku cloud player #old code removed url = 'http://www.acfun.cn/v/ac' + vid yk_streams = youku_acfun_proxy ( info [ 'sourceId' ] , info [ 'encode' ] , url ) seq = [ 'mp4hd3' , 'mp4hd2' , 'mp4hd' , 'flvhd' ] for t in seq : if yk_streams . get ( t ) : preferred = yk_streams [ t ] break #total_size in the json could be incorrect(F.I. 0) size = 0 for url in preferred [ 0 ] : _ , _ , seg_size = url_info ( url ) size += seg_size #fallback to flvhd is not quite possible if re . search ( r'fid=[0-9A-Z\\-]*.flv' , preferred [ 0 ] [ 0 ] ) : ext = 'flv' else : ext = 'mp4' print_info ( site_info , title , ext , size ) if not info_only : download_urls ( preferred [ 0 ] , title , ext , size , output_dir = output_dir , merge = merge ) else : raise NotImplementedError ( sourceType ) if not info_only and not dry_run : if not kwargs [ 'caption' ] : print ( 'Skipping danmaku.' ) return try : title = get_filename ( title ) print ( 'Downloading %s ...\\n' % ( title + '.cmt.json' ) ) cmt = get_srt_json ( vid ) with open ( os . path . join ( output_dir , title + '.cmt.json' ) , 'w' , encoding = 'utf-8' ) as x : x . write ( cmt ) except : pass\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def main_dev ( * * kwargs ) : # Get (branch, commit) if running from a git repo. head = git . get_head ( kwargs [ 'repo_path' ] ) # Get options and arguments. try : opts , args = getopt . getopt ( sys . argv [ 1 : ] , _short_options , _options ) except getopt . GetoptError as e : log . wtf ( \"\"\" [Fatal] {}. Try '{} --help' for more options.\"\"\" . format ( e , script_name ) ) if not opts and not args : # Display help. print ( _help ) # Enter GUI mode. #from .gui import gui_main #gui_main() else : conf = { } for opt , arg in opts : if opt in ( '-h' , '--help' ) : # Display help. print ( _help ) elif opt in ( '-V' , '--version' ) : # Display version. log . println ( \"you-get:\" , log . BOLD ) log . println ( \" version: {}\" . format ( __version__ ) ) if head is not None : log . println ( \" branch: {}\\n commit: {}\" . format ( * head ) ) else : log . println ( \" branch: {}\\n commit: {}\" . format ( \"(stable)\" , \"(tag v{})\" . format ( __version__ ) ) ) log . println ( \" platform: {}\" . format ( platform . platform ( ) ) ) log . println ( \" python: {}\" . format ( sys . version . split ( '\\n' ) [ 0 ] ) ) elif opt in ( '-g' , '--gui' ) : # Run using GUI. conf [ 'gui' ] = True elif opt in ( '-f' , '--force' ) : # Force download. conf [ 'force' ] = True elif opt in ( '-l' , '--playlist' , '--playlists' ) : # Download playlist whenever possible. conf [ 'playlist' ] = True if args : if 'gui' in conf and conf [ 'gui' ] : # Enter GUI mode. from . gui import gui_main gui_main ( * args , * * conf ) else : # Enter console mode. from . console import console_main console_main ( * args , * * conf )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ffmpeg_download_stream ( files , title , ext , params = { } , output_dir = '.' , stream = True ) : output = title + '.' + ext if not ( output_dir == '.' ) : output = output_dir + '/' + output print ( 'Downloading streaming content with FFmpeg, press q to stop recording...' ) if stream : ffmpeg_params = [ FFMPEG ] + [ '-y' , '-re' , '-i' ] else : ffmpeg_params = [ FFMPEG ] + [ '-y' , '-i' ] ffmpeg_params . append ( files ) #not the same here!!!! if FFMPEG == 'avconv' : #who cares? ffmpeg_params += [ '-c' , 'copy' , output ] else : ffmpeg_params += [ '-c' , 'copy' , '-bsf:a' , 'aac_adtstoasc' ] if params is not None : if len ( params ) > 0 : for k , v in params : ffmpeg_params . append ( k ) ffmpeg_params . append ( v ) ffmpeg_params . append ( output ) print ( ' ' . join ( ffmpeg_params ) ) try : a = subprocess . Popen ( ffmpeg_params , stdin = subprocess . PIPE ) a . communicate ( ) except KeyboardInterrupt : try : a . stdin . write ( 'q' . encode ( 'utf-8' ) ) except : pass return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def match1 ( text , * patterns ) : if len ( patterns ) == 1 : pattern = patterns [ 0 ] match = re . search ( pattern , text ) if match : return match . group ( 1 ) else : return None else : ret = [ ] for pattern in patterns : match = re . search ( pattern , text ) if match : ret . append ( match . group ( 1 ) ) return ret\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def matchall ( text , patterns ) : ret = [ ] for pattern in patterns : match = re . findall ( pattern , text ) ret += match return ret\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def parse_query_param ( url , param ) : try : return parse . parse_qs ( parse . urlparse ( url ) . query ) [ param ] [ 0 ] except : return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ungzip ( data ) : from io import BytesIO import gzip buffer = BytesIO ( data ) f = gzip . GzipFile ( fileobj = buffer ) return f . read ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def undeflate ( data ) : import zlib decompressobj = zlib . decompressobj ( - zlib . MAX_WBITS ) return decompressobj . decompress ( data ) + decompressobj . flush ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_content ( url , headers = { } , decoded = True ) : logging . debug ( 'get_content: %s' % url ) req = request . Request ( url , headers = headers ) if cookies : cookies . add_cookie_header ( req ) req . headers . update ( req . unredirected_hdrs ) response = urlopen_with_retry ( req ) data = response . read ( ) # Handle HTTP compression for gzip and deflate (zlib) content_encoding = response . getheader ( 'Content-Encoding' ) if content_encoding == 'gzip' : data = ungzip ( data ) elif content_encoding == 'deflate' : data = undeflate ( data ) # Decode the response body if decoded : charset = match1 ( response . getheader ( 'Content-Type' , '' ) , r'charset=([\\w-]+)' ) if charset is not None : data = data . decode ( charset , 'ignore' ) else : data = data . decode ( 'utf-8' , 'ignore' ) return data\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def post_content ( url , headers = { } , post_data = { } , decoded = True , * * kwargs ) : if kwargs . get ( 'post_data_raw' ) : logging . debug ( 'post_content: %s\\npost_data_raw: %s' % ( url , kwargs [ 'post_data_raw' ] ) ) else : logging . debug ( 'post_content: %s\\npost_data: %s' % ( url , post_data ) ) req = request . Request ( url , headers = headers ) if cookies : cookies . add_cookie_header ( req ) req . headers . update ( req . unredirected_hdrs ) if kwargs . get ( 'post_data_raw' ) : post_data_enc = bytes ( kwargs [ 'post_data_raw' ] , 'utf-8' ) else : post_data_enc = bytes ( parse . urlencode ( post_data ) , 'utf-8' ) response = urlopen_with_retry ( req , data = post_data_enc ) data = response . read ( ) # Handle HTTP compression for gzip and deflate (zlib) content_encoding = response . getheader ( 'Content-Encoding' ) if content_encoding == 'gzip' : data = ungzip ( data ) elif content_encoding == 'deflate' : data = undeflate ( data ) # Decode the response body if decoded : charset = match1 ( response . getheader ( 'Content-Type' ) , r'charset=([\\w-]+)' ) if charset is not None : data = data . decode ( charset ) else : data = data . decode ( 'utf-8' ) return data\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def parse_host ( host ) : if re . match ( r'^(\\d+)$' , host ) is not None : return ( \"0.0.0.0\" , int ( host ) ) if re . match ( r'^(\\w+)://' , host ) is None : host = \"//\" + host o = parse . urlparse ( host ) hostname = o . hostname or \"0.0.0.0\" port = o . port or 0 return ( hostname , port )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def print_more_compatible ( * args , * * kwargs ) : import builtins as __builtin__ # nothing happens on py3.3 and later if sys . version_info [ : 2 ] >= ( 3 , 3 ) : return __builtin__ . print ( * args , * * kwargs ) # in lower pyver (e.g. 3.2.x), remove 'flush' keyword and flush it as requested doFlush = kwargs . pop ( 'flush' , False ) ret = __builtin__ . print ( * args , * * kwargs ) if doFlush : kwargs . get ( 'file' , sys . stdout ) . flush ( ) return ret\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def showroom_get_roomid_by_room_url_key ( room_url_key ) : fake_headers_mobile = { 'Accept' : 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' , 'Accept-Charset' : 'UTF-8,*;q=0.5' , 'Accept-Encoding' : 'gzip,deflate,sdch' , 'Accept-Language' : 'en-US,en;q=0.8' , 'User-Agent' : 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.114 Mobile Safari/537.36' } webpage_url = 'https://www.showroom-live.com/' + room_url_key html = get_content ( webpage_url , headers = fake_headers_mobile ) roomid = match1 ( html , r'room\\?room_id\\=(\\d+)' ) assert roomid return roomid\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def showroom_download_by_room_id ( room_id , output_dir = '.' , merge = False , info_only = False , * * kwargs ) : while True : timestamp = str ( int ( time ( ) * 1000 ) ) api_endpoint = 'https://www.showroom-live.com/api/live/streaming_url?room_id={room_id}&_={timestamp}' . format ( room_id = room_id , timestamp = timestamp ) html = get_content ( api_endpoint ) html = json . loads ( html ) #{'streaming_url_list': [{'url': 'rtmp://52.197.69.198:1935/liveedge', 'id': 1, 'label': 'original spec(low latency)', 'is_default': True, 'type': 'rtmp', 'stream_name': '7656a6d5baa1d77075c971f6d8b6dc61b979fc913dc5fe7cc1318281793436ed'}, {'url': 'http://52.197.69.198:1935/liveedge/7656a6d5baa1d77075c971f6d8b6dc61b979fc913dc5fe7cc1318281793436ed/playlist.m3u8', 'is_default': True, 'id': 2, 'type': 'hls', 'label': 'original spec'}, {'url': 'rtmp://52.197.69.198:1935/liveedge', 'id': 3, 'label': 'low spec(low latency)', 'is_default': False, 'type': 'rtmp', 'stream_name': '7656a6d5baa1d77075c971f6d8b6dc61b979fc913dc5fe7cc1318281793436ed_low'}, {'url': 'http://52.197.69.198:1935/liveedge/7656a6d5baa1d77075c971f6d8b6dc61b979fc913dc5fe7cc1318281793436ed_low/playlist.m3u8', 'is_default': False, 'id': 4, 'type': 'hls', 'label': 'low spec'}]} if len ( html ) >= 1 : break log . w ( 'The live show is currently offline.' ) sleep ( 1 ) #This is mainly for testing the M3U FFmpeg parser so I would ignore any non-m3u ones stream_url = [ i [ 'url' ] for i in html [ 'streaming_url_list' ] if i [ 'is_default' ] and i [ 'type' ] == 'hls' ] [ 0 ] assert stream_url #title title = '' profile_api = 'https://www.showroom-live.com/api/room/profile?room_id={room_id}' . format ( room_id = room_id ) html = loads ( get_content ( profile_api ) ) try : title = html [ 'main_name' ] except KeyError : title = 'Showroom_{room_id}' . format ( room_id = room_id ) type_ , ext , size = url_info ( stream_url ) print_info ( site_info , title , type_ , size ) if not info_only : download_url_ffmpeg ( url = stream_url , title = title , ext = 'mp4' , output_dir = output_dir )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _wanmen_get_title_by_json_topic_part ( json_content , tIndex , pIndex ) : return '_' . join ( [ json_content [ 0 ] [ 'name' ] , json_content [ 0 ] [ 'Topics' ] [ tIndex ] [ 'name' ] , json_content [ 0 ] [ 'Topics' ] [ tIndex ] [ 'Parts' ] [ pIndex ] [ 'name' ] ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wanmen_download_by_course ( json_api_content , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : for tIndex in range ( len ( json_api_content [ 0 ] [ 'Topics' ] ) ) : for pIndex in range ( len ( json_api_content [ 0 ] [ 'Topics' ] [ tIndex ] [ 'Parts' ] ) ) : wanmen_download_by_course_topic_part ( json_api_content , tIndex , pIndex , output_dir = output_dir , merge = merge , info_only = info_only , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wanmen_download_by_course_topic_part ( json_api_content , tIndex , pIndex , output_dir = '.' , merge = True , info_only = False , * * kwargs ) : html = json_api_content title = _wanmen_get_title_by_json_topic_part ( html , tIndex , pIndex ) bokeccID = _wanmen_get_boke_id_by_json_topic_part ( html , tIndex , pIndex ) bokecc_download_by_id ( vid = bokeccID , title = title , output_dir = output_dir , merge = merge , info_only = info_only , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_streams_by_id ( account_number , video_id ) : endpoint = 'https://edge.api.brightcove.com/playback/v1/accounts/{account_number}/videos/{video_id}' . format ( account_number = account_number , video_id = video_id ) fake_header_id = fake_headers #is this somehow related to the time? Magic.... fake_header_id [ 'Accept' ] = 'application/json;pk=BCpkADawqM1cc6wmJQC2tvoXZt4mrB7bFfi6zGt9QnOzprPZcGLE9OMGJwspQwKfuFYuCjAAJ53JdjI8zGFx1ll4rxhYJ255AXH1BQ10rnm34weknpfG-sippyQ' html = get_content ( endpoint , headers = fake_header_id ) html_json = json . loads ( html ) link_list = [ ] for i in html_json [ 'sources' ] : if 'src' in i : #to avoid KeyError if i [ 'src' ] . startswith ( 'https' ) : link_list . append ( ( str ( i [ 'height' ] ) , i [ 'src' ] ) ) return link_list\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def has_task ( self , task_instance ) : if task_instance . key in self . queued_tasks or task_instance . key in self . running : return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_event_buffer ( self , dag_ids = None ) : cleared_events = dict ( ) if dag_ids is None : cleared_events = self . event_buffer self . event_buffer = dict ( ) else : for key in list ( self . event_buffer . keys ( ) ) : dag_id , _ , _ , _ = key if dag_id in dag_ids : cleared_events [ key ] = self . event_buffer . pop ( key ) return cleared_events\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_conn_params ( self ) : conn = self . get_connection ( self . snowflake_conn_id ) account = conn . extra_dejson . get ( 'account' , None ) warehouse = conn . extra_dejson . get ( 'warehouse' , None ) database = conn . extra_dejson . get ( 'database' , None ) region = conn . extra_dejson . get ( \"region\" , None ) role = conn . extra_dejson . get ( 'role' , None ) conn_config = { \"user\" : conn . login , \"password\" : conn . password or '' , \"schema\" : conn . schema or '' , \"database\" : self . database or database or '' , \"account\" : self . account or account or '' , \"warehouse\" : self . warehouse or warehouse or '' , \"region\" : self . region or region or '' , \"role\" : self . role or role or '' , } \"\"\" If private_key_file is specified in the extra json, load the contents of the file as a private key and specify that in the connection configuration. The connection password then becomes the passphrase for the private key. If your private key file is not encrypted (not recommended), then leave the password empty. \"\"\" private_key_file = conn . extra_dejson . get ( 'private_key_file' , None ) if private_key_file : with open ( private_key_file , \"rb\" ) as key : passphrase = None if conn . password : passphrase = conn . password . strip ( ) . encode ( ) p_key = serialization . load_pem_private_key ( key . read ( ) , password = passphrase , backend = default_backend ( ) ) pkb = p_key . private_bytes ( encoding = serialization . Encoding . DER , format = serialization . PrivateFormat . PKCS8 , encryption_algorithm = serialization . NoEncryption ( ) ) conn_config [ 'private_key' ] = pkb conn_config . pop ( 'password' , None ) return conn_config\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_uri ( self ) : conn_config = self . _get_conn_params ( ) uri = 'snowflake://{user}:{password}@{account}/{database}/' uri += '{schema}?warehouse={warehouse}&role={role}' return uri . format ( * * conn_config )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn_config = self . _get_conn_params ( ) conn = snowflake . connector . connect ( * * conn_config ) return conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_aws_credentials ( self ) : if self . snowflake_conn_id : connection_object = self . get_connection ( self . snowflake_conn_id ) if 'aws_secret_access_key' in connection_object . extra_dejson : aws_access_key_id = connection_object . extra_dejson . get ( 'aws_access_key_id' ) aws_secret_access_key = connection_object . extra_dejson . get ( 'aws_secret_access_key' ) return aws_access_key_id , aws_secret_access_key\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_field ( self , field_name , default = None ) : full_field_name = 'extra__grpc__{}' . format ( field_name ) if full_field_name in self . extras : return self . extras [ full_field_name ] else : return default\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def copy_expert ( self , sql , filename , open = open ) : if not os . path . isfile ( filename ) : with open ( filename , 'w' ) : pass with open ( filename , 'r+' ) as f : with closing ( self . get_conn ( ) ) as conn : with closing ( conn . cursor ( ) ) as cur : cur . copy_expert ( sql , f ) f . truncate ( f . tell ( ) ) conn . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bulk_load ( self , table , tmp_file ) : self . copy_expert ( \"COPY {table} FROM STDIN\" . format ( table = table ) , tmp_file )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bulk_dump ( self , table , tmp_file ) : self . copy_expert ( \"COPY {table} TO STDOUT\" . format ( table = table ) , tmp_file )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : hook = GoogleCloudStorageHook ( google_cloud_storage_conn_id = self . google_cloud_storage_conn_id , delegate_to = self . delegate_to ) hook . upload ( bucket_name = self . bucket , object_name = self . dst , mime_type = self . mime_type , filename = self . src , gzip = self . gzip , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def max_partition ( table , schema = \"default\" , field = None , filter_map = None , metastore_conn_id = 'metastore_default' ) : from airflow . hooks . hive_hooks import HiveMetastoreHook if '.' in table : schema , table = table . split ( '.' ) hh = HiveMetastoreHook ( metastore_conn_id = metastore_conn_id ) return hh . max_partition ( schema = schema , table_name = table , field = field , filter_map = filter_map )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _closest_date ( target_dt , date_list , before_target = None ) : fb = lambda d : target_dt - d if d <= target_dt else datetime . timedelta . max fa = lambda d : d - target_dt if d >= target_dt else datetime . timedelta . max fnone = lambda d : target_dt - d if d < target_dt else d - target_dt if before_target is None : return min ( date_list , key = fnone ) . date ( ) if before_target : return min ( date_list , key = fb ) . date ( ) else : return min ( date_list , key = fa ) . date ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def closest_ds_partition ( table , ds , before = True , schema = \"default\" , metastore_conn_id = 'metastore_default' ) : from airflow . hooks . hive_hooks import HiveMetastoreHook if '.' in table : schema , table = table . split ( '.' ) hh = HiveMetastoreHook ( metastore_conn_id = metastore_conn_id ) partitions = hh . get_partitions ( schema = schema , table_name = table ) if not partitions : return None part_vals = [ list ( p . values ( ) ) [ 0 ] for p in partitions ] if ds in part_vals : return ds else : parts = [ datetime . datetime . strptime ( pv , '%Y-%m-%d' ) for pv in part_vals ] target_dt = datetime . datetime . strptime ( ds , '%Y-%m-%d' ) closest_ds = _closest_date ( target_dt , parts , before_target = before ) return closest_ds . isoformat ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . mysql_conn_id ) conn_config = { \"user\" : conn . login , \"passwd\" : conn . password or '' , \"host\" : conn . host or 'localhost' , \"db\" : self . schema or conn . schema or '' } if not conn . port : conn_config [ \"port\" ] = 3306 else : conn_config [ \"port\" ] = int ( conn . port ) if conn . extra_dejson . get ( 'charset' , False ) : conn_config [ \"charset\" ] = conn . extra_dejson [ \"charset\" ] if ( conn_config [ \"charset\" ] ) . lower ( ) == 'utf8' or ( conn_config [ \"charset\" ] ) . lower ( ) == 'utf-8' : conn_config [ \"use_unicode\" ] = True if conn . extra_dejson . get ( 'cursor' , False ) : if ( conn . extra_dejson [ \"cursor\" ] ) . lower ( ) == 'sscursor' : conn_config [ \"cursorclass\" ] = MySQLdb . cursors . SSCursor elif ( conn . extra_dejson [ \"cursor\" ] ) . lower ( ) == 'dictcursor' : conn_config [ \"cursorclass\" ] = MySQLdb . cursors . DictCursor elif ( conn . extra_dejson [ \"cursor\" ] ) . lower ( ) == 'ssdictcursor' : conn_config [ \"cursorclass\" ] = MySQLdb . cursors . SSDictCursor local_infile = conn . extra_dejson . get ( 'local_infile' , False ) if conn . extra_dejson . get ( 'ssl' , False ) : # SSL parameter for MySQL has to be a dictionary and in case # of extra/dejson we can get string if extra is passed via # URL parameters dejson_ssl = conn . extra_dejson [ 'ssl' ] if isinstance ( dejson_ssl , six . string_types ) : dejson_ssl = json . loads ( dejson_ssl ) conn_config [ 'ssl' ] = dejson_ssl if conn . extra_dejson . get ( 'unix_socket' ) : conn_config [ 'unix_socket' ] = conn . extra_dejson [ 'unix_socket' ] if local_infile : conn_config [ \"local_infile\" ] = 1 conn = MySQLdb . connect ( * * conn_config ) return conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bulk_load ( self , table , tmp_file ) : conn = self . get_conn ( ) cur = conn . cursor ( ) cur . execute ( \"\"\" LOAD DATA LOCAL INFILE '{tmp_file}' INTO TABLE {table} \"\"\" . format ( tmp_file = tmp_file , table = table ) ) conn . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_bucket_updated ( self , current_num_objects ) : if current_num_objects > self . previous_num_objects : # When new objects arrived, reset the inactivity_seconds # previous_num_objects for the next poke. self . log . info ( ''' New objects found at {} resetting last_activity_time. ''' . format ( os . path . join ( self . bucket , self . prefix ) ) ) self . last_activity_time = get_time ( ) self . inactivity_seconds = 0 self . previous_num_objects = current_num_objects elif current_num_objects < self . previous_num_objects : # During the last poke interval objects were deleted. if self . allow_delete : self . previous_num_objects = current_num_objects self . last_activity_time = get_time ( ) self . log . warning ( ''' Objects were deleted during the last poke interval. Updating the file counter and resetting last_activity_time. ''' ) else : raise RuntimeError ( ''' Illegal behavior: objects were deleted in {} between pokes. ''' . format ( os . path . join ( self . bucket , self . prefix ) ) ) else : if self . last_activity_time : self . inactivity_seconds = ( get_time ( ) - self . last_activity_time ) . total_seconds ( ) else : # Handles the first poke where last inactivity time is None. self . last_activity_time = get_time ( ) self . inactivity_seconds = 0 if self . inactivity_seconds >= self . inactivity_period : if current_num_objects >= self . min_objects : self . log . info ( ''' SUCCESS: Sensor found {} objects at {}. Waited at least {} seconds, with no new objects dropped. ''' . format ( current_num_objects , os . path . join ( self . bucket , self . prefix ) , self . inactivity_period ) ) return True warn_msg = ''' FAILURE: Inactivity Period passed, not enough objects found in {} ''' . format ( os . path . join ( self . bucket , self . prefix ) ) self . log . warning ( warn_msg ) return False return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sigquit_handler ( sig , frame ) : print ( \"Dumping stack traces for all threads in PID {}\" . format ( os . getpid ( ) ) ) id_to_name = dict ( [ ( th . ident , th . name ) for th in threading . enumerate ( ) ] ) code = [ ] for thread_id , stack in sys . _current_frames ( ) . items ( ) : code . append ( \"\\n# Thread: {}({})\" . format ( id_to_name . get ( thread_id , \"\" ) , thread_id ) ) for filename , line_number , name , line in traceback . extract_stack ( stack ) : code . append ( 'File: \"{}\", line {}, in {}' . format ( filename , line_number , name ) ) if line : code . append ( \" {}\" . format ( line . strip ( ) ) ) print ( \"\\n\" . join ( code ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def trigger_dag ( args ) : log = LoggingMixin ( ) . log try : message = api_client . trigger_dag ( dag_id = args . dag_id , run_id = args . run_id , conf = args . conf , execution_date = args . exec_date ) except IOError as err : log . error ( err ) raise AirflowException ( err ) log . info ( message )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_dag ( args ) : log = LoggingMixin ( ) . log if args . yes or input ( \"This will drop all existing records related to the specified DAG. \" \"Proceed? (y/n)\" ) . upper ( ) == \"Y\" : try : message = api_client . delete_dag ( dag_id = args . dag_id ) except IOError as err : log . error ( err ) raise AirflowException ( err ) log . info ( message ) else : print ( \"Bail.\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def task_failed_deps ( args ) : dag = get_dag ( args ) task = dag . get_task ( task_id = args . task_id ) ti = TaskInstance ( task , args . execution_date ) dep_context = DepContext ( deps = SCHEDULER_DEPS ) failed_deps = list ( ti . get_failed_dep_statuses ( dep_context = dep_context ) ) # TODO, Do we want to print or log this if failed_deps : print ( \"Task instance dependencies not met:\" ) for dep in failed_deps : print ( \"{}: {}\" . format ( dep . dep_name , dep . reason ) ) else : print ( \"Task instance dependencies are all met.\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def task_state ( args ) : dag = get_dag ( args ) task = dag . get_task ( task_id = args . task_id ) ti = TaskInstance ( task , args . execution_date ) print ( ti . current_state ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dag_state ( args ) : dag = get_dag ( args ) dr = DagRun . find ( dag . dag_id , execution_date = args . execution_date ) print ( dr [ 0 ] . state if len ( dr ) > 0 else None )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def next_execution ( args ) : dag = get_dag ( args ) if dag . is_paused : print ( \"[INFO] Please be reminded this DAG is PAUSED now.\" ) if dag . latest_execution_date : next_execution_dttm = dag . following_schedule ( dag . latest_execution_date ) if next_execution_dttm is None : print ( \"[WARN] No following schedule can be found. \" + \"This DAG may have schedule interval '@once' or `None`.\" ) print ( next_execution_dttm ) else : print ( \"[WARN] Only applicable when there is execution record found for the DAG.\" ) print ( None )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def restart_workers ( gunicorn_master_proc , num_workers_expected , master_timeout ) : def wait_until_true ( fn , timeout = 0 ) : \"\"\" Sleeps until fn is true \"\"\" t = time . time ( ) while not fn ( ) : if 0 < timeout <= time . time ( ) - t : raise AirflowWebServerTimeout ( \"No response from gunicorn master within {0} seconds\" . format ( timeout ) ) time . sleep ( 0.1 ) def start_refresh ( gunicorn_master_proc ) : batch_size = conf . getint ( 'webserver' , 'worker_refresh_batch_size' ) log . debug ( '%s doing a refresh of %s workers' , state , batch_size ) sys . stdout . flush ( ) sys . stderr . flush ( ) excess = 0 for _ in range ( batch_size ) : gunicorn_master_proc . send_signal ( signal . SIGTTIN ) excess += 1 wait_until_true ( lambda : num_workers_expected + excess == get_num_workers_running ( gunicorn_master_proc ) , master_timeout ) try : wait_until_true ( lambda : num_workers_expected == get_num_workers_running ( gunicorn_master_proc ) , master_timeout ) while True : num_workers_running = get_num_workers_running ( gunicorn_master_proc ) num_ready_workers_running = get_num_ready_workers_running ( gunicorn_master_proc ) state = '[{0} / {1}]' . format ( num_ready_workers_running , num_workers_running ) # Whenever some workers are not ready, wait until all workers are ready if num_ready_workers_running < num_workers_running : log . debug ( '%s some workers are starting up, waiting...' , state ) sys . stdout . flush ( ) time . sleep ( 1 ) # Kill a worker gracefully by asking gunicorn to reduce number of workers elif num_workers_running > num_workers_expected : excess = num_workers_running - num_workers_expected log . debug ( '%s killing %s workers' , state , excess ) for _ in range ( excess ) : gunicorn_master_proc . send_signal ( signal . SIGTTOU ) excess -= 1 wait_until_true ( lambda : num_workers_expected + excess == get_num_workers_running ( gunicorn_master_proc ) , master_timeout ) # Start a new worker by asking gunicorn to increase number of workers elif num_workers_running == num_workers_expected : refresh_interval = conf . getint ( 'webserver' , 'worker_refresh_interval' ) log . debug ( '%s sleeping for %ss starting doing a refresh...' , state , refresh_interval ) time . sleep ( refresh_interval ) start_refresh ( gunicorn_master_proc ) else : # num_ready_workers_running == num_workers_running < num_workers_expected log . error ( ( \"%s some workers seem to have died and gunicorn\" \"did not restart them as expected\" ) , state ) time . sleep ( 10 ) if len ( psutil . Process ( gunicorn_master_proc . pid ) . children ( ) ) < num_workers_expected : start_refresh ( gunicorn_master_proc ) except ( AirflowWebServerTimeout , OSError ) as err : log . error ( err ) log . error ( \"Shutting down webserver\" ) try : gunicorn_master_proc . terminate ( ) gunicorn_master_proc . wait ( ) finally : sys . exit ( 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . _client : self . _client = Client ( credentials = self . _get_credentials ( ) ) return self . _client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def translate ( self , values , target_language , format_ = None , source_language = None , model = None ) : client = self . get_conn ( ) return client . translate ( values = values , target_language = target_language , format_ = format_ , source_language = source_language , model = model , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . log . info ( 'Tmp dir root location: \\n %s' , gettempdir ( ) ) # Prepare env for child process. if self . env is None : self . env = os . environ . copy ( ) airflow_context_vars = context_to_airflow_vars ( context , in_env_var_format = True ) self . log . info ( 'Exporting the following env vars:\\n%s' , '\\n' . join ( [ \"{}={}\" . format ( k , v ) for k , v in airflow_context_vars . items ( ) ] ) ) self . env . update ( airflow_context_vars ) self . lineage_data = self . bash_command with TemporaryDirectory ( prefix = 'airflowtmp' ) as tmp_dir : with NamedTemporaryFile ( dir = tmp_dir , prefix = self . task_id ) as tmp_file : tmp_file . write ( bytes ( self . bash_command , 'utf_8' ) ) tmp_file . flush ( ) script_location = os . path . abspath ( tmp_file . name ) self . log . info ( 'Temporary script location: %s' , script_location ) def pre_exec ( ) : # Restore default signal disposition and invoke setsid for sig in ( 'SIGPIPE' , 'SIGXFZ' , 'SIGXFSZ' ) : if hasattr ( signal , sig ) : signal . signal ( getattr ( signal , sig ) , signal . SIG_DFL ) os . setsid ( ) self . log . info ( 'Running command: %s' , self . bash_command ) sub_process = Popen ( [ 'bash' , tmp_file . name ] , stdout = PIPE , stderr = STDOUT , cwd = tmp_dir , env = self . env , preexec_fn = pre_exec ) self . sub_process = sub_process self . log . info ( 'Output:' ) line = '' for raw_line in iter ( sub_process . stdout . readline , b'' ) : line = raw_line . decode ( self . output_encoding ) . rstrip ( ) self . log . info ( line ) sub_process . wait ( ) self . log . info ( 'Command exited with return code %s' , sub_process . returncode ) if sub_process . returncode : raise AirflowException ( 'Bash command failed' ) return line\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_instance ( self , instance , project_id = None ) : return self . get_conn ( ) . instances ( ) . get ( project = project_id , instance = instance ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_instance ( self , body , project_id = None ) : response = self . get_conn ( ) . instances ( ) . insert ( project = project_id , body = body ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def patch_instance ( self , body , instance , project_id = None ) : response = self . get_conn ( ) . instances ( ) . patch ( project = project_id , instance = instance , body = body ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_instance ( self , instance , project_id = None ) : response = self . get_conn ( ) . instances ( ) . delete ( project = project_id , instance = instance , ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_database ( self , instance , database , project_id = None ) : return self . get_conn ( ) . databases ( ) . get ( project = project_id , instance = instance , database = database ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_database ( self , instance , body , project_id = None ) : response = self . get_conn ( ) . databases ( ) . insert ( project = project_id , instance = instance , body = body ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def patch_database ( self , instance , database , body , project_id = None ) : response = self . get_conn ( ) . databases ( ) . patch ( project = project_id , instance = instance , database = database , body = body ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_database ( self , instance , database , project_id = None ) : response = self . get_conn ( ) . databases ( ) . delete ( project = project_id , instance = instance , database = database ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def export_instance ( self , instance , body , project_id = None ) : try : response = self . get_conn ( ) . instances ( ) . export ( project = project_id , instance = instance , body = body ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name ) except HttpError as ex : raise AirflowException ( 'Exporting instance {} failed: {}' . format ( instance , ex . content ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _wait_for_operation_to_complete ( self , project_id , operation_name ) : service = self . get_conn ( ) while True : operation_response = service . operations ( ) . get ( project = project_id , operation = operation_name , ) . execute ( num_retries = self . num_retries ) if operation_response . get ( \"status\" ) == CloudSqlOperationStatus . DONE : error = operation_response . get ( \"error\" ) if error : # Extracting the errors list as string and trimming square braces error_msg = str ( error . get ( \"errors\" ) ) [ 1 : - 1 ] raise AirflowException ( error_msg ) # No meaningful info to return from the response in case of success return time . sleep ( TIME_TO_SLEEP_IN_SECONDS )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def start_proxy ( self ) : self . _download_sql_proxy_if_needed ( ) if self . sql_proxy_process : raise AirflowException ( \"The sql proxy is already running: {}\" . format ( self . sql_proxy_process ) ) else : command_to_run = [ self . sql_proxy_path ] command_to_run . extend ( self . command_line_parameters ) try : self . log . info ( \"Creating directory %s\" , self . cloud_sql_proxy_socket_directory ) os . makedirs ( self . cloud_sql_proxy_socket_directory ) except OSError : # Needed for python 2 compatibility (exists_ok missing) pass command_to_run . extend ( self . _get_credential_parameters ( ) ) self . log . info ( \"Running the command: `%s`\" , \" \" . join ( command_to_run ) ) self . sql_proxy_process = Popen ( command_to_run , stdin = PIPE , stdout = PIPE , stderr = PIPE ) self . log . info ( \"The pid of cloud_sql_proxy: %s\" , self . sql_proxy_process . pid ) while True : line = self . sql_proxy_process . stderr . readline ( ) . decode ( 'utf-8' ) return_code = self . sql_proxy_process . poll ( ) if line == '' and return_code is not None : self . sql_proxy_process = None raise AirflowException ( \"The cloud_sql_proxy finished early with return code {}!\" . format ( return_code ) ) if line != '' : self . log . info ( line ) if \"googleapi: Error\" in line or \"invalid instance name:\" in line : self . stop_proxy ( ) raise AirflowException ( \"Error when starting the cloud_sql_proxy {}!\" . format ( line ) ) if \"Ready for new connections\" in line : return\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def stop_proxy ( self ) : if not self . sql_proxy_process : raise AirflowException ( \"The sql proxy is not started yet\" ) else : self . log . info ( \"Stopping the cloud_sql_proxy pid: %s\" , self . sql_proxy_process . pid ) self . sql_proxy_process . kill ( ) self . sql_proxy_process = None # Cleanup! self . log . info ( \"Removing the socket directory: %s\" , self . cloud_sql_proxy_socket_directory ) shutil . rmtree ( self . cloud_sql_proxy_socket_directory , ignore_errors = True ) if self . sql_proxy_was_downloaded : self . log . info ( \"Removing downloaded proxy: %s\" , self . sql_proxy_path ) # Silently ignore if the file has already been removed (concurrency) try : os . remove ( self . sql_proxy_path ) except OSError as e : if not e . errno == errno . ENOENT : raise else : self . log . info ( \"Skipped removing proxy - it was not downloaded: %s\" , self . sql_proxy_path ) if os . path . isfile ( self . credentials_path ) : self . log . info ( \"Removing generated credentials file %s\" , self . credentials_path ) # Here file cannot be delete by concurrent task (each task has its own copy) os . remove ( self . credentials_path )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_proxy_version ( self ) : self . _download_sql_proxy_if_needed ( ) command_to_run = [ self . sql_proxy_path ] command_to_run . extend ( [ '--version' ] ) command_to_run . extend ( self . _get_credential_parameters ( ) ) result = subprocess . check_output ( command_to_run ) . decode ( 'utf-8' ) pattern = re . compile ( \"^.*[V|v]ersion ([^;]*);.*$\" ) m = pattern . match ( result ) if m : return m . group ( 1 ) else : return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_connection ( self , session = None ) : connection = Connection ( conn_id = self . db_conn_id ) uri = self . _generate_connection_uri ( ) self . log . info ( \"Creating connection %s\" , self . db_conn_id ) connection . parse_from_uri ( uri ) session . add ( connection ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def retrieve_connection ( self , session = None ) : self . log . info ( \"Retrieving connection %s\" , self . db_conn_id ) connections = session . query ( Connection ) . filter ( Connection . conn_id == self . db_conn_id ) if connections . count ( ) : return connections [ 0 ] return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_connection ( self , session = None ) : self . log . info ( \"Deleting connection %s\" , self . db_conn_id ) connections = session . query ( Connection ) . filter ( Connection . conn_id == self . db_conn_id ) if connections . count ( ) : connection = connections [ 0 ] session . delete ( connection ) session . commit ( ) else : self . log . info ( \"Connection was already deleted!\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_sqlproxy_runner ( self ) : if not self . use_proxy : raise AirflowException ( \"Proxy runner can only be retrieved in case of use_proxy = True\" ) return CloudSqlProxyRunner ( path_prefix = self . sql_proxy_unique_path , instance_specification = self . _get_sqlproxy_instance_specification ( ) , project_id = self . project_id , sql_proxy_version = self . sql_proxy_version , sql_proxy_binary_path = self . sql_proxy_binary_path )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_database_hook ( self ) : if self . database_type == 'postgres' : self . db_hook = PostgresHook ( postgres_conn_id = self . db_conn_id , schema = self . database ) else : self . db_hook = MySqlHook ( mysql_conn_id = self . db_conn_id , schema = self . database ) return self . db_hook\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def cleanup_database_hook ( self ) : if self . database_type == 'postgres' : if hasattr ( self . db_hook , 'conn' ) and self . db_hook . conn and self . db_hook . conn . notices : for output in self . db_hook . conn . notices : self . log . info ( output )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def reserve_free_tcp_port ( self ) : self . reserved_tcp_socket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) self . reserved_tcp_socket . bind ( ( '127.0.0.1' , 0 ) ) self . sql_proxy_tcp_port = self . reserved_tcp_socket . getsockname ( ) [ 1 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _normalize_mlengine_job_id ( job_id ) : # Add a prefix when a job_id starts with a digit or a template match = re . search ( r'\\d|\\{{2}' , job_id ) if match and match . start ( ) == 0 : job = 'z_{}' . format ( job_id ) else : job = job_id # Clean up 'bad' characters except templates tracker = 0 cleansed_job_id = '' for m in re . finditer ( r'\\{{2}.+?\\}{2}' , job ) : cleansed_job_id += re . sub ( r'[^0-9a-zA-Z]+' , '_' , job [ tracker : m . start ( ) ] ) cleansed_job_id += job [ m . start ( ) : m . end ( ) ] tracker = m . end ( ) # Clean up last substring or the full string if no templates cleansed_job_id += re . sub ( r'[^0-9a-zA-Z]+' , '_' , job [ tracker : ] ) return cleansed_job_id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_error_code ( self , e ) : try : matches = self . error_code_pattern . match ( str ( e ) ) code = int ( matches . group ( 0 ) ) return code except ValueError : return e\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _integrate_plugins ( ) : import sys from airflow . plugins_manager import sensors_modules for sensors_module in sensors_modules : sys . modules [ sensors_module . __name__ ] = sensors_module globals ( ) [ sensors_module . _name ] = sensors_module\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def clear_dag_runs ( ) : session = settings . Session ( ) drs = session . query ( DagRun ) . filter ( DagRun . dag_id . in_ ( DAG_IDS ) , ) . all ( ) for dr in drs : logging . info ( 'Deleting DagRun :: {}' . format ( dr ) ) session . delete ( dr )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def clear_dag_task_instances ( ) : session = settings . Session ( ) TI = TaskInstance tis = ( session . query ( TI ) . filter ( TI . dag_id . in_ ( DAG_IDS ) ) . all ( ) ) for ti in tis : logging . info ( 'Deleting TaskInstance :: {}' . format ( ti ) ) session . delete ( ti ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_dags_paused_state ( is_paused ) : session = settings . Session ( ) dms = session . query ( DagModel ) . filter ( DagModel . dag_id . in_ ( DAG_IDS ) ) for dm in dms : logging . info ( 'Setting DAG :: {} is_paused={}' . format ( dm , is_paused ) ) dm . is_paused = is_paused session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def print_stats ( self ) : session = settings . Session ( ) TI = TaskInstance tis = ( session . query ( TI ) . filter ( TI . dag_id . in_ ( DAG_IDS ) ) . all ( ) ) successful_tis = [ x for x in tis if x . state == State . SUCCESS ] ti_perf = [ ( ti . dag_id , ti . task_id , ti . execution_date , ( ti . queued_dttm - self . start_date ) . total_seconds ( ) , ( ti . start_date - self . start_date ) . total_seconds ( ) , ( ti . end_date - self . start_date ) . total_seconds ( ) , ti . duration ) for ti in successful_tis ] ti_perf_df = pd . DataFrame ( ti_perf , columns = [ 'dag_id' , 'task_id' , 'execution_date' , 'queue_delay' , 'start_delay' , 'land_time' , 'duration' ] ) print ( 'Performance Results' ) print ( '###################' ) for dag_id in DAG_IDS : print ( 'DAG {}' . format ( dag_id ) ) print ( ti_perf_df [ ti_perf_df [ 'dag_id' ] == dag_id ] ) print ( '###################' ) if len ( tis ) > len ( successful_tis ) : print ( \"WARNING!! The following task instances haven't completed\" ) print ( pd . DataFrame ( [ ( ti . dag_id , ti . task_id , ti . execution_date , ti . state ) for ti in filter ( lambda x : x . state != State . SUCCESS , tis ) ] , columns = [ 'dag_id' , 'task_id' , 'execution_date' , 'state' ] ) ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def heartbeat ( self ) : super ( SchedulerMetricsJob , self ) . heartbeat ( ) session = settings . Session ( ) # Get all the relevant task instances TI = TaskInstance successful_tis = ( session . query ( TI ) . filter ( TI . dag_id . in_ ( DAG_IDS ) ) . filter ( TI . state . in_ ( [ State . SUCCESS ] ) ) . all ( ) ) session . commit ( ) dagbag = DagBag ( SUBDIR ) dags = [ dagbag . dags [ dag_id ] for dag_id in DAG_IDS ] # the tasks in perf_dag_1 and per_dag_2 have a daily schedule interval. num_task_instances = sum ( [ ( timezone . utcnow ( ) - task . start_date ) . days for dag in dags for task in dag . tasks ] ) if ( len ( successful_tis ) == num_task_instances or ( timezone . utcnow ( ) - self . start_date ) . total_seconds ( ) > MAX_RUNTIME_SECS ) : if len ( successful_tis ) == num_task_instances : self . log . info ( \"All tasks processed! Printing stats.\" ) else : self . log . info ( \"Test timeout reached. Printing available stats.\" ) self . print_stats ( ) set_dags_paused_state ( True ) sys . exit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def invoke_lambda ( self , payload ) : awslambda_conn = self . get_conn ( ) response = awslambda_conn . invoke ( FunctionName = self . function_name , InvocationType = self . invocation_type , LogType = self . log_type , Payload = payload , Qualifier = self . qualifier ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_dag_run_state ( dag_id , execution_date ) : dagbag = DagBag ( ) # Check DAG exists. if dag_id not in dagbag . dags : error_message = \"Dag id {} not found\" . format ( dag_id ) raise DagNotFound ( error_message ) # Get DAG object and check Task Exists dag = dagbag . get_dag ( dag_id ) # Get DagRun object and check that it exists dagrun = dag . get_dagrun ( execution_date = execution_date ) if not dagrun : error_message = ( 'Dag Run for date {} not found in dag {}' . format ( execution_date , dag_id ) ) raise DagRunNotFound ( error_message ) return { 'state' : dagrun . get_state ( ) }\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_evaluate_ops ( task_prefix , data_format , input_paths , prediction_path , metric_fn_and_keys , validate_fn , batch_prediction_job_id = None , project_id = None , region = None , dataflow_options = None , model_uri = None , model_name = None , version_name = None , dag = None ) : # Verify that task_prefix doesn't have any special characters except hyphen # '-', which is the only allowed non-alphanumeric character by Dataflow. if not re . match ( r\"^[a-zA-Z][-A-Za-z0-9]*$\" , task_prefix ) : raise AirflowException ( \"Malformed task_id for DataFlowPythonOperator (only alphanumeric \" \"and hyphens are allowed but got: \" + task_prefix ) metric_fn , metric_keys = metric_fn_and_keys if not callable ( metric_fn ) : raise AirflowException ( \"`metric_fn` param must be callable.\" ) if not callable ( validate_fn ) : raise AirflowException ( \"`validate_fn` param must be callable.\" ) if dag is not None and dag . default_args is not None : default_args = dag . default_args project_id = project_id or default_args . get ( 'project_id' ) region = region or default_args . get ( 'region' ) model_name = model_name or default_args . get ( 'model_name' ) version_name = version_name or default_args . get ( 'version_name' ) dataflow_options = dataflow_options or default_args . get ( 'dataflow_default_options' ) evaluate_prediction = MLEngineBatchPredictionOperator ( task_id = ( task_prefix + \"-prediction\" ) , project_id = project_id , job_id = batch_prediction_job_id , region = region , data_format = data_format , input_paths = input_paths , output_path = prediction_path , uri = model_uri , model_name = model_name , version_name = version_name , dag = dag ) metric_fn_encoded = base64 . b64encode ( dill . dumps ( metric_fn , recurse = True ) ) evaluate_summary = DataFlowPythonOperator ( task_id = ( task_prefix + \"-summary\" ) , py_options = [ \"-m\" ] , py_file = \"airflow.contrib.utils.mlengine_prediction_summary\" , dataflow_default_options = dataflow_options , options = { \"prediction_path\" : prediction_path , \"metric_fn_encoded\" : metric_fn_encoded , \"metric_keys\" : ',' . join ( metric_keys ) } , dag = dag ) evaluate_summary . set_upstream ( evaluate_prediction ) def apply_validate_fn ( * args , * * kwargs ) : prediction_path = kwargs [ \"templates_dict\" ] [ \"prediction_path\" ] scheme , bucket , obj , _ , _ = urlsplit ( prediction_path ) if scheme != \"gs\" or not bucket or not obj : raise ValueError ( \"Wrong format prediction_path: %s\" , prediction_path ) summary = os . path . join ( obj . strip ( \"/\" ) , \"prediction.summary.json\" ) gcs_hook = GoogleCloudStorageHook ( ) summary = json . loads ( gcs_hook . download ( bucket , summary ) ) return validate_fn ( summary ) evaluate_validation = PythonOperator ( task_id = ( task_prefix + \"-validation\" ) , python_callable = apply_validate_fn , provide_context = True , templates_dict = { \"prediction_path\" : prediction_path } , dag = dag ) evaluate_validation . set_upstream ( evaluate_summary ) return evaluate_prediction , evaluate_summary , evaluate_validation\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def mkdirs ( path , mode ) : try : o_umask = os . umask ( 0 ) os . makedirs ( path , mode ) except OSError : if not os . path . isdir ( path ) : raise finally : os . umask ( o_umask )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def utcnow ( ) : # pendulum utcnow() is not used as that sets a TimezoneInfo object # instead of a Timezone. This is not pickable and also creates issues # when using replace() d = dt . datetime . utcnow ( ) d = d . replace ( tzinfo = utc ) return d\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def utc_epoch ( ) : # pendulum utcnow() is not used as that sets a TimezoneInfo object # instead of a Timezone. This is not pickable and also creates issues # when using replace() d = dt . datetime ( 1970 , 1 , 1 ) d = d . replace ( tzinfo = utc ) return d\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def convert_to_utc ( value ) : if not value : return value if not is_localized ( value ) : value = pendulum . instance ( value , TIMEZONE ) return value . astimezone ( utc )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_aware ( value , timezone = None ) : if timezone is None : timezone = TIMEZONE # Check that we won't overwrite the timezone of an aware datetime. if is_localized ( value ) : raise ValueError ( \"make_aware expects a naive datetime, got %s\" % value ) if hasattr ( value , 'fold' ) : # In case of python 3.6 we want to do the same that pendulum does for python3.5 # i.e in case we move clock back we want to schedule the run at the time of the second # instance of the same clock time rather than the first one. # Fold parameter has no impact in other cases so we can safely set it to 1 here value = value . replace ( fold = 1 ) if hasattr ( timezone , 'localize' ) : # This method is available for pytz time zones. return timezone . localize ( value ) elif hasattr ( timezone , 'convert' ) : # For pendulum return timezone . convert ( value ) else : # This may be wrong around DST changes! return value . replace ( tzinfo = timezone )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_naive ( value , timezone = None ) : if timezone is None : timezone = TIMEZONE # Emulate the behavior of astimezone() on Python < 3.6. if is_naive ( value ) : raise ValueError ( \"make_naive() cannot be applied to a naive datetime\" ) o = value . astimezone ( timezone ) # cross library compatibility naive = dt . datetime ( o . year , o . month , o . day , o . hour , o . minute , o . second , o . microsecond ) return naive\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def datetime ( * args , * * kwargs ) : if 'tzinfo' not in kwargs : kwargs [ 'tzinfo' ] = TIMEZONE return dt . datetime ( * args , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _set_env_from_extras ( self , extras ) : key_path = self . _get_field ( extras , 'key_path' , False ) keyfile_json_str = self . _get_field ( extras , 'keyfile_dict' , False ) if not key_path and not keyfile_json_str : self . log . info ( 'Using gcloud with application default credentials.' ) elif key_path : os . environ [ G_APP_CRED ] = key_path else : # Write service account JSON to secure file for gcloud to reference service_key = tempfile . NamedTemporaryFile ( delete = False ) service_key . write ( keyfile_json_str ) os . environ [ G_APP_CRED ] = service_key . name # Return file object to have a pointer to close after use, # thus deleting from file system. return service_key\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_field ( self , extras , field , default = None ) : long_f = 'extra__google_cloud_platform__{}' . format ( field ) if long_f in extras : return extras [ long_f ] else : self . log . info ( 'Field %s not found in extras.' , field ) return default\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . druid_broker_conn_id ) druid_broker_conn = connect ( host = conn . host , port = conn . port , path = conn . extra_dejson . get ( 'endpoint' , '/druid/v2/sql' ) , scheme = conn . extra_dejson . get ( 'schema' , 'http' ) ) self . log . info ( 'Get the connection to druid broker on %s' , conn . host ) return druid_broker_conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self , headers = None ) : session = requests . Session ( ) if self . http_conn_id : conn = self . get_connection ( self . http_conn_id ) if \"://\" in conn . host : self . base_url = conn . host else : # schema defaults to HTTP schema = conn . schema if conn . schema else \"http\" self . base_url = schema + \"://\" + conn . host if conn . port : self . base_url = self . base_url + \":\" + str ( conn . port ) if conn . login : session . auth = ( conn . login , conn . password ) if conn . extra : try : session . headers . update ( conn . extra_dejson ) except TypeError : self . log . warn ( 'Connection to %s has invalid extra field.' , conn . host ) if headers : session . headers . update ( headers ) return session\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run ( self , endpoint , data = None , headers = None , extra_options = None ) : extra_options = extra_options or { } session = self . get_conn ( headers ) if self . base_url and not self . base_url . endswith ( '/' ) and endpoint and not endpoint . startswith ( '/' ) : url = self . base_url + '/' + endpoint else : url = ( self . base_url or '' ) + ( endpoint or '' ) req = None if self . method == 'GET' : # GET uses params req = requests . Request ( self . method , url , params = data , headers = headers ) elif self . method == 'HEAD' : # HEAD doesn't use params req = requests . Request ( self . method , url , headers = headers ) else : # Others use data req = requests . Request ( self . method , url , data = data , headers = headers ) prepped_request = session . prepare_request ( req ) self . log . info ( \"Sending '%s' to url: %s\" , self . method , url ) return self . run_and_check ( session , prepped_request , extra_options )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_response ( self , response ) : try : response . raise_for_status ( ) except requests . exceptions . HTTPError : self . log . error ( \"HTTP error: %s\" , response . reason ) if self . method not in [ 'GET' , 'HEAD' ] : self . log . error ( response . text ) raise AirflowException ( str ( response . status_code ) + \":\" + response . reason )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_and_check ( self , session , prepped_request , extra_options ) : extra_options = extra_options or { } try : response = session . send ( prepped_request , stream = extra_options . get ( \"stream\" , False ) , verify = extra_options . get ( \"verify\" , True ) , proxies = extra_options . get ( \"proxies\" , { } ) , cert = extra_options . get ( \"cert\" ) , timeout = extra_options . get ( \"timeout\" ) , allow_redirects = extra_options . get ( \"allow_redirects\" , True ) ) if extra_options . get ( 'check_response' , True ) : self . check_response ( response ) return response except requests . exceptions . ConnectionError as ex : self . log . warn ( str ( ex ) + ' Tenacity will retry to execute the operation' ) raise ex\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_with_advanced_retry ( self , _retry_args , * args , * * kwargs ) : self . _retry_obj = tenacity . Retrying ( * * _retry_args ) self . _retry_obj ( self . run , * args , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_session ( ) : session = settings . Session ( ) try : yield session session . commit ( ) except Exception : session . rollback ( ) raise finally : session . close ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def provide_session ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : arg_session = 'session' func_params = func . __code__ . co_varnames session_in_args = arg_session in func_params and func_params . index ( arg_session ) < len ( args ) session_in_kwargs = arg_session in kwargs if session_in_kwargs or session_in_args : return func ( * args , * * kwargs ) else : with create_session ( ) as session : kwargs [ arg_session ] = session return func ( * args , * * kwargs ) return wrapper\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def resetdb ( ) : from airflow import models # alembic adds significant import time, so we import it lazily from alembic . migration import MigrationContext log . info ( \"Dropping tables that exist\" ) models . base . Base . metadata . drop_all ( settings . engine ) mc = MigrationContext . configure ( settings . engine ) if mc . _version . exists ( settings . engine ) : mc . _version . drop ( settings . engine ) from flask_appbuilder . models . sqla import Base Base . metadata . drop_all ( settings . engine ) initdb ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : hook = WasbHook ( wasb_conn_id = self . wasb_conn_id ) self . log . info ( 'Uploading %s to wasb://%s ' 'as %s' . format ( self . file_path , self . container_name , self . blob_name ) ) hook . load_file ( self . file_path , self . container_name , self . blob_name , * * self . load_options )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : db = self . get_connection ( self . presto_conn_id ) reqkwargs = None if db . password is not None : reqkwargs = { 'auth' : HTTPBasicAuth ( db . login , db . password ) } return presto . connect ( host = db . host , port = db . port , username = db . login , source = db . extra_dejson . get ( 'source' , 'airflow' ) , protocol = db . extra_dejson . get ( 'protocol' , 'http' ) , catalog = db . extra_dejson . get ( 'catalog' , 'hive' ) , requests_kwargs = reqkwargs , schema = db . schema )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_pretty_exception_message ( e ) : if ( hasattr ( e , 'message' ) and 'errorName' in e . message and 'message' in e . message ) : return ( '{name}: {message}' . format ( name = e . message [ 'errorName' ] , message = e . message [ 'message' ] ) ) else : return str ( e )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_records ( self , hql , parameters = None ) : try : return super ( ) . get_records ( self . _strip_sql ( hql ) , parameters ) except DatabaseError as e : raise PrestoException ( self . _get_pretty_exception_message ( e ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_pandas_df ( self , hql , parameters = None ) : import pandas cursor = self . get_cursor ( ) try : cursor . execute ( self . _strip_sql ( hql ) , parameters ) data = cursor . fetchall ( ) except DatabaseError as e : raise PrestoException ( self . _get_pretty_exception_message ( e ) ) column_descriptions = cursor . description if data : df = pandas . DataFrame ( data ) df . columns = [ c [ 0 ] for c in column_descriptions ] else : df = pandas . DataFrame ( ) return df\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run ( self , hql , parameters = None ) : return super ( ) . run ( self . _strip_sql ( hql ) , parameters )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_rows ( self , table , rows , target_fields = None ) : super ( ) . insert_rows ( table , rows , target_fields , 0 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if self . cosmos_client is not None : return self . cosmos_client # Initialize the Python Azure Cosmos DB client self . cosmos_client = cosmos_client . CosmosClient ( self . endpoint_uri , { 'masterKey' : self . master_key } ) return self . cosmos_client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def does_collection_exist ( self , collection_name , database_name = None ) : if collection_name is None : raise AirflowBadRequest ( \"Collection name cannot be None.\" ) existing_container = list ( self . get_conn ( ) . QueryContainers ( get_database_link ( self . __get_database_name ( database_name ) ) , { \"query\" : \"SELECT * FROM r WHERE r.id=@id\" , \"parameters\" : [ { \"name\" : \"@id\" , \"value\" : collection_name } ] } ) ) if len ( existing_container ) == 0 : return False return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_collection ( self , collection_name , database_name = None ) : if collection_name is None : raise AirflowBadRequest ( \"Collection name cannot be None.\" ) # We need to check to see if this container already exists so we don't try # to create it twice existing_container = list ( self . get_conn ( ) . QueryContainers ( get_database_link ( self . __get_database_name ( database_name ) ) , { \"query\" : \"SELECT * FROM r WHERE r.id=@id\" , \"parameters\" : [ { \"name\" : \"@id\" , \"value\" : collection_name } ] } ) ) # Only create if we did not find it already existing if len ( existing_container ) == 0 : self . get_conn ( ) . CreateContainer ( get_database_link ( self . __get_database_name ( database_name ) ) , { \"id\" : collection_name } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def does_database_exist ( self , database_name ) : if database_name is None : raise AirflowBadRequest ( \"Database name cannot be None.\" ) existing_database = list ( self . get_conn ( ) . QueryDatabases ( { \"query\" : \"SELECT * FROM r WHERE r.id=@id\" , \"parameters\" : [ { \"name\" : \"@id\" , \"value\" : database_name } ] } ) ) if len ( existing_database ) == 0 : return False return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_database ( self , database_name ) : if database_name is None : raise AirflowBadRequest ( \"Database name cannot be None.\" ) # We need to check to see if this database already exists so we don't try # to create it twice existing_database = list ( self . get_conn ( ) . QueryDatabases ( { \"query\" : \"SELECT * FROM r WHERE r.id=@id\" , \"parameters\" : [ { \"name\" : \"@id\" , \"value\" : database_name } ] } ) ) # Only create if we did not find it already existing if len ( existing_database ) == 0 : self . get_conn ( ) . CreateDatabase ( { \"id\" : database_name } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_database ( self , database_name ) : if database_name is None : raise AirflowBadRequest ( \"Database name cannot be None.\" ) self . get_conn ( ) . DeleteDatabase ( get_database_link ( database_name ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_collection ( self , collection_name , database_name = None ) : if collection_name is None : raise AirflowBadRequest ( \"Collection name cannot be None.\" ) self . get_conn ( ) . DeleteContainer ( get_collection_link ( self . __get_database_name ( database_name ) , collection_name ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def upsert_document ( self , document , database_name = None , collection_name = None , document_id = None ) : # Assign unique ID if one isn't provided if document_id is None : document_id = str ( uuid . uuid4 ( ) ) if document is None : raise AirflowBadRequest ( \"You cannot insert a None document\" ) # Add document id if isn't found if 'id' in document : if document [ 'id' ] is None : document [ 'id' ] = document_id else : document [ 'id' ] = document_id created_document = self . get_conn ( ) . CreateItem ( get_collection_link ( self . __get_database_name ( database_name ) , self . __get_collection_name ( collection_name ) ) , document ) return created_document\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_documents ( self , documents , database_name = None , collection_name = None ) : if documents is None : raise AirflowBadRequest ( \"You cannot insert empty documents\" ) created_documents = [ ] for single_document in documents : created_documents . append ( self . get_conn ( ) . CreateItem ( get_collection_link ( self . __get_database_name ( database_name ) , self . __get_collection_name ( collection_name ) ) , single_document ) ) return created_documents\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_document ( self , document_id , database_name = None , collection_name = None ) : if document_id is None : raise AirflowBadRequest ( \"Cannot delete a document without an id\" ) self . get_conn ( ) . DeleteItem ( get_document_link ( self . __get_database_name ( database_name ) , self . __get_collection_name ( collection_name ) , document_id ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_document ( self , document_id , database_name = None , collection_name = None ) : if document_id is None : raise AirflowBadRequest ( \"Cannot get a document without an id\" ) try : return self . get_conn ( ) . ReadItem ( get_document_link ( self . __get_database_name ( database_name ) , self . __get_collection_name ( collection_name ) , document_id ) ) except HTTPFailure : return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_documents ( self , sql_string , database_name = None , collection_name = None , partition_key = None ) : if sql_string is None : raise AirflowBadRequest ( \"SQL query string cannot be None\" ) # Query them in SQL query = { 'query' : sql_string } try : result_iterable = self . get_conn ( ) . QueryItems ( get_collection_link ( self . __get_database_name ( database_name ) , self . __get_collection_name ( collection_name ) ) , query , partition_key ) return list ( result_iterable ) except HTTPFailure : return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_code ( dag_id ) : session = settings . Session ( ) DM = models . DagModel dag = session . query ( DM ) . filter ( DM . dag_id == dag_id ) . first ( ) session . close ( ) # Check DAG exists. if dag is None : error_message = \"Dag id {} not found\" . format ( dag_id ) raise DagNotFound ( error_message ) try : with wwwutils . open_maybe_zipped ( dag . fileloc , 'r' ) as f : code = f . read ( ) return code except IOError as e : error_message = \"Error {} while reading Dag id {} Code\" . format ( str ( e ) , dag_id ) raise AirflowException ( error_message )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_function ( self , name ) : return self . get_conn ( ) . projects ( ) . locations ( ) . functions ( ) . get ( name = name ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_new_function ( self , location , body , project_id = None ) : response = self . get_conn ( ) . projects ( ) . locations ( ) . functions ( ) . create ( location = self . _full_location ( project_id , location ) , body = body ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_function ( self , name , body , update_mask ) : response = self . get_conn ( ) . projects ( ) . locations ( ) . functions ( ) . patch ( updateMask = \",\" . join ( update_mask ) , name = name , body = body ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def upload_function_zip ( self , location , zip_path , project_id = None ) : response = self . get_conn ( ) . projects ( ) . locations ( ) . functions ( ) . generateUploadUrl ( parent = self . _full_location ( project_id , location ) ) . execute ( num_retries = self . num_retries ) upload_url = response . get ( 'uploadUrl' ) with open ( zip_path , 'rb' ) as fp : requests . put ( url = upload_url , data = fp , # Those two headers needs to be specified according to: # https://cloud.google.com/functions/docs/reference/rest/v1/projects.locations.functions/generateUploadUrl # nopep8 headers = { 'Content-type' : 'application/zip' , 'x-goog-content-length-range' : '0,104857600' , } ) return upload_url\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_function ( self , name ) : response = self . get_conn ( ) . projects ( ) . locations ( ) . functions ( ) . delete ( name = name ) . execute ( num_retries = self . num_retries ) operation_name = response [ \"name\" ] self . _wait_for_operation_to_complete ( operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _wait_for_operation_to_complete ( self , operation_name ) : service = self . get_conn ( ) while True : operation_response = service . operations ( ) . get ( name = operation_name , ) . execute ( num_retries = self . num_retries ) if operation_response . get ( \"done\" ) : response = operation_response . get ( \"response\" ) error = operation_response . get ( \"error\" ) # Note, according to documentation always either response or error is # set when \"done\" == True if error : raise AirflowException ( str ( error ) ) return response time . sleep ( TIME_TO_SLEEP_IN_SECONDS )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def publish ( self , project , topic , messages ) : body = { 'messages' : messages } full_topic = _format_topic ( project , topic ) request = self . get_conn ( ) . projects ( ) . topics ( ) . publish ( topic = full_topic , body = body ) try : request . execute ( num_retries = self . num_retries ) except HttpError as e : raise PubSubException ( 'Error publishing to topic {}' . format ( full_topic ) , e )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_topic ( self , project , topic , fail_if_exists = False ) : service = self . get_conn ( ) full_topic = _format_topic ( project , topic ) try : service . projects ( ) . topics ( ) . create ( name = full_topic , body = { } ) . execute ( num_retries = self . num_retries ) except HttpError as e : # Status code 409 indicates that the topic already exists. if str ( e . resp [ 'status' ] ) == '409' : message = 'Topic already exists: {}' . format ( full_topic ) self . log . warning ( message ) if fail_if_exists : raise PubSubException ( message ) else : raise PubSubException ( 'Error creating topic {}' . format ( full_topic ) , e )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_topic ( self , project , topic , fail_if_not_exists = False ) : service = self . get_conn ( ) full_topic = _format_topic ( project , topic ) try : service . projects ( ) . topics ( ) . delete ( topic = full_topic ) . execute ( num_retries = self . num_retries ) except HttpError as e : # Status code 409 indicates that the topic was not found if str ( e . resp [ 'status' ] ) == '404' : message = 'Topic does not exist: {}' . format ( full_topic ) self . log . warning ( message ) if fail_if_not_exists : raise PubSubException ( message ) else : raise PubSubException ( 'Error deleting topic {}' . format ( full_topic ) , e )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_subscription ( self , topic_project , topic , subscription = None , subscription_project = None , ack_deadline_secs = 10 , fail_if_exists = False ) : service = self . get_conn ( ) full_topic = _format_topic ( topic_project , topic ) if not subscription : subscription = 'sub-{}' . format ( uuid4 ( ) ) if not subscription_project : subscription_project = topic_project full_subscription = _format_subscription ( subscription_project , subscription ) body = { 'topic' : full_topic , 'ackDeadlineSeconds' : ack_deadline_secs } try : service . projects ( ) . subscriptions ( ) . create ( name = full_subscription , body = body ) . execute ( num_retries = self . num_retries ) except HttpError as e : # Status code 409 indicates that the subscription already exists. if str ( e . resp [ 'status' ] ) == '409' : message = 'Subscription already exists: {}' . format ( full_subscription ) self . log . warning ( message ) if fail_if_exists : raise PubSubException ( message ) else : raise PubSubException ( 'Error creating subscription {}' . format ( full_subscription ) , e ) return subscription\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_subscription ( self , project , subscription , fail_if_not_exists = False ) : service = self . get_conn ( ) full_subscription = _format_subscription ( project , subscription ) try : service . projects ( ) . subscriptions ( ) . delete ( subscription = full_subscription ) . execute ( num_retries = self . num_retries ) except HttpError as e : # Status code 404 indicates that the subscription was not found if str ( e . resp [ 'status' ] ) == '404' : message = 'Subscription does not exist: {}' . format ( full_subscription ) self . log . warning ( message ) if fail_if_not_exists : raise PubSubException ( message ) else : raise PubSubException ( 'Error deleting subscription {}' . format ( full_subscription ) , e )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pull ( self , project , subscription , max_messages , return_immediately = False ) : service = self . get_conn ( ) full_subscription = _format_subscription ( project , subscription ) body = { 'maxMessages' : max_messages , 'returnImmediately' : return_immediately } try : response = service . projects ( ) . subscriptions ( ) . pull ( subscription = full_subscription , body = body ) . execute ( num_retries = self . num_retries ) return response . get ( 'receivedMessages' , [ ] ) except HttpError as e : raise PubSubException ( 'Error pulling messages from subscription {}' . format ( full_subscription ) , e )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def acknowledge ( self , project , subscription , ack_ids ) : service = self . get_conn ( ) full_subscription = _format_subscription ( project , subscription ) try : service . projects ( ) . subscriptions ( ) . acknowledge ( subscription = full_subscription , body = { 'ackIds' : ack_ids } ) . execute ( num_retries = self . num_retries ) except HttpError as e : raise PubSubException ( 'Error acknowledging {} messages pulled from subscription {}' . format ( len ( ack_ids ) , full_subscription ) , e )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_dep_statuses ( self , ti , session , dep_context = None ) : # this avoids a circular dependency from airflow . ti_deps . dep_context import DepContext if dep_context is None : dep_context = DepContext ( ) if self . IGNOREABLE and dep_context . ignore_all_deps : yield self . _passing_status ( reason = \"Context specified all dependencies should be ignored.\" ) return if self . IS_TASK_DEP and dep_context . ignore_task_deps : yield self . _passing_status ( reason = \"Context specified all task dependencies should be ignored.\" ) return for dep_status in self . _get_dep_statuses ( ti , session , dep_context ) : yield dep_status\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_met ( self , ti , session , dep_context = None ) : return all ( status . passed for status in self . get_dep_statuses ( ti , session , dep_context ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_failure_reasons ( self , ti , session , dep_context = None ) : for dep_status in self . get_dep_statuses ( ti , session , dep_context ) : if not dep_status . passed : yield dep_status . reason\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _parse_s3_config ( config_file_name , config_format = 'boto' , profile = None ) : config = configparser . ConfigParser ( ) if config . read ( config_file_name ) : # pragma: no cover sections = config . sections ( ) else : raise AirflowException ( \"Couldn't read {0}\" . format ( config_file_name ) ) # Setting option names depending on file format if config_format is None : config_format = 'boto' conf_format = config_format . lower ( ) if conf_format == 'boto' : # pragma: no cover if profile is not None and 'profile ' + profile in sections : cred_section = 'profile ' + profile else : cred_section = 'Credentials' elif conf_format == 'aws' and profile is not None : cred_section = profile else : cred_section = 'default' # Option names if conf_format in ( 'boto' , 'aws' ) : # pragma: no cover key_id_option = 'aws_access_key_id' secret_key_option = 'aws_secret_access_key' # security_token_option = 'aws_security_token' else : key_id_option = 'access_key' secret_key_option = 'secret_key' # Actual Parsing if cred_section not in sections : raise AirflowException ( \"This config file format is not recognized\" ) else : try : access_key = config . get ( cred_section , key_id_option ) secret_key = config . get ( cred_section , secret_key_option ) except Exception : logging . warning ( \"Option Error in parsing s3 config file\" ) raise return access_key , secret_key\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_credentials ( self , region_name = None ) : session , _ = self . _get_credentials ( region_name ) # Credentials are refreshable, so accessing your access key and # secret key separately can lead to a race condition. # See https://stackoverflow.com/a/36291428/8283373 return session . get_credentials ( ) . get_frozen_credentials ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def expand_role ( self , role ) : if '/' in role : return role else : return self . get_client_type ( 'iam' ) . get_role ( RoleName = role ) [ 'Role' ] [ 'Arn' ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . vertica_conn_id ) conn_config = { \"user\" : conn . login , \"password\" : conn . password or '' , \"database\" : conn . schema , \"host\" : conn . host or 'localhost' } if not conn . port : conn_config [ \"port\" ] = 5433 else : conn_config [ \"port\" ] = int ( conn . port ) conn = connect ( * * conn_config ) return conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_context ( logger , value ) : _logger = logger while _logger : for handler in _logger . handlers : try : handler . set_context ( value ) except AttributeError : # Not all handlers need to have context passed in so we ignore # the error when handlers do not have set_context defined. pass if _logger . propagate is True : _logger = _logger . parent else : _logger = None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def write ( self , message ) : if not message . endswith ( \"\\n\" ) : self . _buffer += message else : self . _buffer += message self . logger . log ( self . level , self . _buffer . rstrip ( ) ) self . _buffer = str ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def flush ( self ) : if len ( self . _buffer ) > 0 : self . logger . log ( self . level , self . _buffer ) self . _buffer = str ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def correct_maybe_zipped ( fileloc ) : _ , archive , filename = re . search ( r'((.*\\.zip){})?(.*)' . format ( re . escape ( os . sep ) ) , fileloc ) . groups ( ) if archive and zipfile . is_zipfile ( archive ) : return archive else : return fileloc\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_py_file_paths ( directory , safe_mode = True , include_examples = None ) : if include_examples is None : include_examples = conf . getboolean ( 'core' , 'LOAD_EXAMPLES' ) file_paths = [ ] if directory is None : return [ ] elif os . path . isfile ( directory ) : return [ directory ] elif os . path . isdir ( directory ) : patterns_by_dir = { } for root , dirs , files in os . walk ( directory , followlinks = True ) : patterns = patterns_by_dir . get ( root , [ ] ) ignore_file = os . path . join ( root , '.airflowignore' ) if os . path . isfile ( ignore_file ) : with open ( ignore_file , 'r' ) as f : # If we have new patterns create a copy so we don't change # the previous list (which would affect other subdirs) patterns += [ re . compile ( p ) for p in f . read ( ) . split ( '\\n' ) if p ] # If we can ignore any subdirs entirely we should - fewer paths # to walk is better. We have to modify the ``dirs`` array in # place for this to affect os.walk dirs [ : ] = [ d for d in dirs if not any ( p . search ( os . path . join ( root , d ) ) for p in patterns ) ] # We want patterns defined in a parent folder's .airflowignore to # apply to subdirs too for d in dirs : patterns_by_dir [ os . path . join ( root , d ) ] = patterns for f in files : try : file_path = os . path . join ( root , f ) if not os . path . isfile ( file_path ) : continue mod_name , file_ext = os . path . splitext ( os . path . split ( file_path ) [ - 1 ] ) if file_ext != '.py' and not zipfile . is_zipfile ( file_path ) : continue if any ( [ re . findall ( p , file_path ) for p in patterns ] ) : continue # Heuristic that guesses whether a Python file contains an # Airflow DAG definition. might_contain_dag = True if safe_mode and not zipfile . is_zipfile ( file_path ) : with open ( file_path , 'rb' ) as fp : content = fp . read ( ) might_contain_dag = all ( [ s in content for s in ( b'DAG' , b'airflow' ) ] ) if not might_contain_dag : continue file_paths . append ( file_path ) except Exception : log = LoggingMixin ( ) . log log . exception ( \"Error while examining %s\" , f ) if include_examples : import airflow . example_dags example_dag_folder = airflow . example_dags . __path__ [ 0 ] file_paths . extend ( list_py_file_paths ( example_dag_folder , safe_mode , False ) ) return file_paths\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def construct_task_instance ( self , session = None , lock_for_update = False ) : TI = airflow . models . TaskInstance qry = session . query ( TI ) . filter ( TI . dag_id == self . _dag_id , TI . task_id == self . _task_id , TI . execution_date == self . _execution_date ) if lock_for_update : ti = qry . with_for_update ( ) . first ( ) else : ti = qry . first ( ) return ti\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_dag ( self , dag_id ) : if dag_id not in self . dag_id_to_simple_dag : raise AirflowException ( \"Unknown DAG ID {}\" . format ( dag_id ) ) return self . dag_id_to_simple_dag [ dag_id ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def start ( self ) : self . _process = self . _launch_process ( self . _dag_directory , self . _file_paths , self . _max_runs , self . _processor_factory , self . _child_signal_conn , self . _stat_queue , self . _result_queue , self . _async_mode ) self . log . info ( \"Launched DagFileProcessorManager with pid: %s\" , self . _process . pid )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def harvest_simple_dags ( self ) : # Metadata and results to be harvested can be inconsistent, # but it should not be a big problem. self . _sync_metadata ( ) # Heartbeating after syncing metadata so we do not restart manager # if it processed all files for max_run times and exit normally. self . _heartbeat_manager ( ) simple_dags = [ ] # multiprocessing.Queue().qsize will not work on MacOS. if sys . platform == \"darwin\" : qsize = self . _result_count else : qsize = self . _result_queue . qsize ( ) for _ in range ( qsize ) : simple_dags . append ( self . _result_queue . get ( ) ) self . _result_count = 0 return simple_dags\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _heartbeat_manager ( self ) : if self . _process and not self . _process . is_alive ( ) and not self . done : self . start ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sync_metadata ( self ) : while not self . _stat_queue . empty ( ) : stat = self . _stat_queue . get ( ) self . _file_paths = stat . file_paths self . _all_pids = stat . all_pids self . _done = stat . done self . _all_files_processed = stat . all_files_processed self . _result_count += stat . result_count\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def terminate ( self ) : self . log . info ( \"Sending termination message to manager.\" ) self . _child_signal_conn . send ( DagParsingSignal . TERMINATE_MANAGER )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def end ( self ) : if not self . _process : self . log . warn ( 'Ending without manager process.' ) return this_process = psutil . Process ( os . getpid ( ) ) try : manager_process = psutil . Process ( self . _process . pid ) except psutil . NoSuchProcess : self . log . info ( \"Manager process not running.\" ) return # First try SIGTERM if manager_process . is_running ( ) and manager_process . pid in [ x . pid for x in this_process . children ( ) ] : self . log . info ( \"Terminating manager process: %s\" , manager_process . pid ) manager_process . terminate ( ) # TODO: Remove magic number timeout = 5 self . log . info ( \"Waiting up to %ss for manager process to exit...\" , timeout ) try : psutil . wait_procs ( { manager_process } , timeout ) except psutil . TimeoutExpired : self . log . debug ( \"Ran out of time while waiting for \" \"processes to exit\" ) # Then SIGKILL if manager_process . is_running ( ) and manager_process . pid in [ x . pid for x in this_process . children ( ) ] : self . log . info ( \"Killing manager process: %s\" , manager_process . pid ) manager_process . kill ( ) manager_process . wait ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _exit_gracefully ( self , signum , frame ) : self . log . info ( \"Exiting gracefully upon receiving signal %s\" , signum ) self . terminate ( ) self . end ( ) self . log . debug ( \"Finished terminating DAG processors.\" ) sys . exit ( os . EX_OK )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def start ( self ) : self . log . info ( \"Processing files using up to %s processes at a time \" , self . _parallelism ) self . log . info ( \"Process each file at most once every %s seconds\" , self . _file_process_interval ) self . log . info ( \"Checking for new files in %s every %s seconds\" , self . _dag_directory , self . dag_dir_list_interval ) if self . _async_mode : self . log . debug ( \"Starting DagFileProcessorManager in async mode\" ) self . start_in_async ( ) else : self . log . debug ( \"Starting DagFileProcessorManager in sync mode\" ) self . start_in_sync ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def start_in_async ( self ) : while True : loop_start_time = time . time ( ) if self . _signal_conn . poll ( ) : agent_signal = self . _signal_conn . recv ( ) if agent_signal == DagParsingSignal . TERMINATE_MANAGER : self . terminate ( ) break elif agent_signal == DagParsingSignal . END_MANAGER : self . end ( ) sys . exit ( os . EX_OK ) self . _refresh_dag_dir ( ) simple_dags = self . heartbeat ( ) for simple_dag in simple_dags : self . _result_queue . put ( simple_dag ) self . _print_stat ( ) all_files_processed = all ( self . get_last_finish_time ( x ) is not None for x in self . file_paths ) max_runs_reached = self . max_runs_reached ( ) dag_parsing_stat = DagParsingStat ( self . _file_paths , self . get_all_pids ( ) , max_runs_reached , all_files_processed , len ( simple_dags ) ) self . _stat_queue . put ( dag_parsing_stat ) if max_runs_reached : self . log . info ( \"Exiting dag parsing loop as all files \" \"have been processed %s times\" , self . _max_runs ) break loop_duration = time . time ( ) - loop_start_time if loop_duration < 1 : sleep_length = 1 - loop_duration self . log . debug ( \"Sleeping for %.2f seconds to prevent excessive logging\" , sleep_length ) time . sleep ( sleep_length )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def start_in_sync ( self ) : while True : agent_signal = self . _signal_conn . recv ( ) if agent_signal == DagParsingSignal . TERMINATE_MANAGER : self . terminate ( ) break elif agent_signal == DagParsingSignal . END_MANAGER : self . end ( ) sys . exit ( os . EX_OK ) elif agent_signal == DagParsingSignal . AGENT_HEARTBEAT : self . _refresh_dag_dir ( ) simple_dags = self . heartbeat ( ) for simple_dag in simple_dags : self . _result_queue . put ( simple_dag ) self . _print_stat ( ) all_files_processed = all ( self . get_last_finish_time ( x ) is not None for x in self . file_paths ) max_runs_reached = self . max_runs_reached ( ) dag_parsing_stat = DagParsingStat ( self . _file_paths , self . get_all_pids ( ) , self . max_runs_reached ( ) , all_files_processed , len ( simple_dags ) ) self . _stat_queue . put ( dag_parsing_stat ) self . wait_until_finished ( ) self . _signal_conn . send ( DagParsingSignal . MANAGER_DONE ) if max_runs_reached : self . log . info ( \"Exiting dag parsing loop as all files \" \"have been processed %s times\" , self . _max_runs ) self . _signal_conn . send ( DagParsingSignal . MANAGER_DONE ) break\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _refresh_dag_dir ( self ) : elapsed_time_since_refresh = ( timezone . utcnow ( ) - self . last_dag_dir_refresh_time ) . total_seconds ( ) if elapsed_time_since_refresh > self . dag_dir_list_interval : # Build up a list of Python files that could contain DAGs self . log . info ( \"Searching for files in %s\" , self . _dag_directory ) self . _file_paths = list_py_file_paths ( self . _dag_directory ) self . last_dag_dir_refresh_time = timezone . utcnow ( ) self . log . info ( \"There are %s files in %s\" , len ( self . _file_paths ) , self . _dag_directory ) self . set_file_paths ( self . _file_paths ) try : self . log . debug ( \"Removing old import errors\" ) self . clear_nonexistent_import_errors ( ) except Exception : self . log . exception ( \"Error removing old import errors\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _print_stat ( self ) : if ( ( timezone . utcnow ( ) - self . last_stat_print_time ) . total_seconds ( ) > self . print_stats_interval ) : if len ( self . _file_paths ) > 0 : self . _log_file_processing_stats ( self . _file_paths ) self . last_stat_print_time = timezone . utcnow ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def clear_nonexistent_import_errors ( self , session ) : query = session . query ( errors . ImportError ) if self . _file_paths : query = query . filter ( ~ errors . ImportError . filename . in_ ( self . _file_paths ) ) query . delete ( synchronize_session = 'fetch' ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_file_processing_stats ( self , known_file_paths ) : # File Path: Path to the file containing the DAG definition # PID: PID associated with the process that's processing the file. May # be empty. # Runtime: If the process is currently running, how long it's been # running for in seconds. # Last Runtime: If the process ran before, how long did it take to # finish in seconds # Last Run: When the file finished processing in the previous run. headers = [ \"File Path\" , \"PID\" , \"Runtime\" , \"Last Runtime\" , \"Last Run\" ] rows = [ ] for file_path in known_file_paths : last_runtime = self . get_last_runtime ( file_path ) file_name = os . path . basename ( file_path ) file_name = os . path . splitext ( file_name ) [ 0 ] . replace ( os . sep , '.' ) if last_runtime : Stats . gauge ( 'dag_processing.last_runtime.{}' . format ( file_name ) , last_runtime ) processor_pid = self . get_pid ( file_path ) processor_start_time = self . get_start_time ( file_path ) runtime = ( ( timezone . utcnow ( ) - processor_start_time ) . total_seconds ( ) if processor_start_time else None ) last_run = self . get_last_finish_time ( file_path ) if last_run : seconds_ago = ( timezone . utcnow ( ) - last_run ) . total_seconds ( ) Stats . gauge ( 'dag_processing.last_run.seconds_ago.{}' . format ( file_name ) , seconds_ago ) rows . append ( ( file_path , processor_pid , runtime , last_runtime , last_run ) ) # Sort by longest last runtime. (Can't sort None values in python3) rows = sorted ( rows , key = lambda x : x [ 3 ] or 0.0 ) formatted_rows = [ ] for file_path , pid , runtime , last_runtime , last_run in rows : formatted_rows . append ( ( file_path , pid , \"{:.2f}s\" . format ( runtime ) if runtime else None , \"{:.2f}s\" . format ( last_runtime ) if last_runtime else None , last_run . strftime ( \"%Y-%m-%dT%H:%M:%S\" ) if last_run else None ) ) log_str = ( \"\\n\" + \"=\" * 80 + \"\\n\" + \"DAG File Processing Stats\\n\\n\" + tabulate ( formatted_rows , headers = headers ) + \"\\n\" + \"=\" * 80 ) self . log . info ( log_str )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_pid ( self , file_path ) : if file_path in self . _processors : return self . _processors [ file_path ] . pid return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_runtime ( self , file_path ) : if file_path in self . _processors : return ( timezone . utcnow ( ) - self . _processors [ file_path ] . start_time ) . total_seconds ( ) return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_start_time ( self , file_path ) : if file_path in self . _processors : return self . _processors [ file_path ] . start_time return None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_file_paths ( self , new_file_paths ) : self . _file_paths = new_file_paths self . _file_path_queue = [ x for x in self . _file_path_queue if x in new_file_paths ] # Stop processors that are working on deleted files filtered_processors = { } for file_path , processor in self . _processors . items ( ) : if file_path in new_file_paths : filtered_processors [ file_path ] = processor else : self . log . warning ( \"Stopping processor for %s\" , file_path ) processor . terminate ( ) self . _processors = filtered_processors\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wait_until_finished ( self ) : for file_path , processor in self . _processors . items ( ) : while not processor . done : time . sleep ( 0.1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def heartbeat ( self ) : finished_processors = { } \"\"\":type : dict[unicode, AbstractDagFileProcessor]\"\"\" running_processors = { } \"\"\":type : dict[unicode, AbstractDagFileProcessor]\"\"\" for file_path , processor in self . _processors . items ( ) : if processor . done : self . log . debug ( \"Processor for %s finished\" , file_path ) now = timezone . utcnow ( ) finished_processors [ file_path ] = processor self . _last_runtime [ file_path ] = ( now - processor . start_time ) . total_seconds ( ) self . _last_finish_time [ file_path ] = now self . _run_count [ file_path ] += 1 else : running_processors [ file_path ] = processor self . _processors = running_processors self . log . debug ( \"%s/%s DAG parsing processes running\" , len ( self . _processors ) , self . _parallelism ) self . log . debug ( \"%s file paths queued for processing\" , len ( self . _file_path_queue ) ) # Collect all the DAGs that were found in the processed files simple_dags = [ ] for file_path , processor in finished_processors . items ( ) : if processor . result is None : self . log . warning ( \"Processor for %s exited with return code %s.\" , processor . file_path , processor . exit_code ) else : for simple_dag in processor . result : simple_dags . append ( simple_dag ) # Generate more file paths to process if we processed all the files # already. if len ( self . _file_path_queue ) == 0 : # If the file path is already being processed, or if a file was # processed recently, wait until the next batch file_paths_in_progress = self . _processors . keys ( ) now = timezone . utcnow ( ) file_paths_recently_processed = [ ] for file_path in self . _file_paths : last_finish_time = self . get_last_finish_time ( file_path ) if ( last_finish_time is not None and ( now - last_finish_time ) . total_seconds ( ) < self . _file_process_interval ) : file_paths_recently_processed . append ( file_path ) files_paths_at_run_limit = [ file_path for file_path , num_runs in self . _run_count . items ( ) if num_runs == self . _max_runs ] files_paths_to_queue = list ( set ( self . _file_paths ) - set ( file_paths_in_progress ) - set ( file_paths_recently_processed ) - set ( files_paths_at_run_limit ) ) for file_path , processor in self . _processors . items ( ) : self . log . debug ( \"File path %s is still being processed (started: %s)\" , processor . file_path , processor . start_time . isoformat ( ) ) self . log . debug ( \"Queuing the following files for processing:\\n\\t%s\" , \"\\n\\t\" . join ( files_paths_to_queue ) ) self . _file_path_queue . extend ( files_paths_to_queue ) zombies = self . _find_zombies ( ) # Start more processors if we have enough slots and files to process while ( self . _parallelism - len ( self . _processors ) > 0 and len ( self . _file_path_queue ) > 0 ) : file_path = self . _file_path_queue . pop ( 0 ) processor = self . _processor_factory ( file_path , zombies ) processor . start ( ) self . log . debug ( \"Started a process (PID: %s) to generate tasks for %s\" , processor . pid , file_path ) self . _processors [ file_path ] = processor # Update heartbeat count. self . _run_count [ self . _heart_beat_key ] += 1 return simple_dags\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _find_zombies ( self , session ) : now = timezone . utcnow ( ) zombies = [ ] if ( now - self . _last_zombie_query_time ) . total_seconds ( ) > self . _zombie_query_interval : # to avoid circular imports from airflow . jobs import LocalTaskJob as LJ self . log . info ( \"Finding 'running' jobs without a recent heartbeat\" ) TI = airflow . models . TaskInstance limit_dttm = timezone . utcnow ( ) - timedelta ( seconds = self . _zombie_threshold_secs ) self . log . info ( \"Failing jobs without heartbeat after %s\" , limit_dttm ) tis = ( session . query ( TI ) . join ( LJ , TI . job_id == LJ . id ) . filter ( TI . state == State . RUNNING ) . filter ( or_ ( LJ . state != State . RUNNING , LJ . latest_heartbeat < limit_dttm , ) ) . all ( ) ) self . _last_zombie_query_time = timezone . utcnow ( ) for ti in tis : zombies . append ( SimpleTaskInstance ( ti ) ) return zombies\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def max_runs_reached ( self ) : if self . _max_runs == - 1 : # Unlimited runs. return False for file_path in self . _file_paths : if self . _run_count [ file_path ] < self . _max_runs : return False if self . _run_count [ self . _heart_beat_key ] < self . _max_runs : return False return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def end ( self ) : pids_to_kill = self . get_all_pids ( ) if len ( pids_to_kill ) > 0 : # First try SIGTERM this_process = psutil . Process ( os . getpid ( ) ) # Only check child processes to ensure that we don't have a case # where we kill the wrong process because a child process died # but the PID got reused. child_processes = [ x for x in this_process . children ( recursive = True ) if x . is_running ( ) and x . pid in pids_to_kill ] for child in child_processes : self . log . info ( \"Terminating child PID: %s\" , child . pid ) child . terminate ( ) # TODO: Remove magic number timeout = 5 self . log . info ( \"Waiting up to %s seconds for processes to exit...\" , timeout ) try : psutil . wait_procs ( child_processes , timeout = timeout , callback = lambda x : self . log . info ( 'Terminated PID %s' , x . pid ) ) except psutil . TimeoutExpired : self . log . debug ( \"Ran out of time while waiting for processes to exit\" ) # Then SIGKILL child_processes = [ x for x in this_process . children ( recursive = True ) if x . is_running ( ) and x . pid in pids_to_kill ] if len ( child_processes ) > 0 : self . log . info ( \"SIGKILL processes that did not terminate gracefully\" ) for child in child_processes : self . log . info ( \"Killing child PID: %s\" , child . pid ) child . kill ( ) child . wait ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : self . log . debug ( 'Creating SSH client for conn_id: %s' , self . ssh_conn_id ) client = paramiko . SSHClient ( ) if not self . allow_host_key_change : self . log . warning ( 'Remote Identification Change is not verified. ' 'This wont protect against Man-In-The-Middle attacks' ) client . load_system_host_keys ( ) if self . no_host_key_check : self . log . warning ( 'No Host Key Verification. This wont protect ' 'against Man-In-The-Middle attacks' ) # Default is RejectPolicy client . set_missing_host_key_policy ( paramiko . AutoAddPolicy ( ) ) if self . password and self . password . strip ( ) : client . connect ( hostname = self . remote_host , username = self . username , password = self . password , key_filename = self . key_file , timeout = self . timeout , compress = self . compress , port = self . port , sock = self . host_proxy ) else : client . connect ( hostname = self . remote_host , username = self . username , key_filename = self . key_file , timeout = self . timeout , compress = self . compress , port = self . port , sock = self . host_proxy ) if self . keepalive_interval : client . get_transport ( ) . set_keepalive ( self . keepalive_interval ) self . client = client return client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_tunnel ( self , remote_port , remote_host = \"localhost\" , local_port = None ) : if local_port : local_bind_address = ( 'localhost' , local_port ) else : local_bind_address = ( 'localhost' , ) if self . password and self . password . strip ( ) : client = SSHTunnelForwarder ( self . remote_host , ssh_port = self . port , ssh_username = self . username , ssh_password = self . password , ssh_pkey = self . key_file , ssh_proxy = self . host_proxy , local_bind_address = local_bind_address , remote_bind_address = ( remote_host , remote_port ) , logger = self . log ) else : client = SSHTunnelForwarder ( self . remote_host , ssh_port = self . port , ssh_username = self . username , ssh_pkey = self . key_file , ssh_proxy = self . host_proxy , local_bind_address = local_bind_address , remote_bind_address = ( remote_host , remote_port ) , host_pkey_directories = [ ] , logger = self . log ) return client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_transfer_job ( self , body ) : body = self . _inject_project_id ( body , BODY , PROJECT_ID ) return self . get_conn ( ) . transferJobs ( ) . create ( body = body ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_transfer_job ( self , job_name , project_id = None ) : return ( self . get_conn ( ) . transferJobs ( ) . get ( jobName = job_name , projectId = project_id ) . execute ( num_retries = self . num_retries ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_transfer_job ( self , filter ) : conn = self . get_conn ( ) filter = self . _inject_project_id ( filter , FILTER , FILTER_PROJECT_ID ) request = conn . transferJobs ( ) . list ( filter = json . dumps ( filter ) ) jobs = [ ] while request is not None : response = request . execute ( num_retries = self . num_retries ) jobs . extend ( response [ TRANSFER_JOBS ] ) request = conn . transferJobs ( ) . list_next ( previous_request = request , previous_response = response ) return jobs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_transfer_job ( self , job_name , body ) : body = self . _inject_project_id ( body , BODY , PROJECT_ID ) return ( self . get_conn ( ) . transferJobs ( ) . patch ( jobName = job_name , body = body ) . execute ( num_retries = self . num_retries ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_transfer_job ( self , job_name , project_id ) : return ( self . get_conn ( ) . transferJobs ( ) . patch ( jobName = job_name , body = { PROJECT_ID : project_id , TRANSFER_JOB : { STATUS1 : GcpTransferJobsStatus . DELETED } , TRANSFER_JOB_FIELD_MASK : STATUS1 , } , ) . execute ( num_retries = self . num_retries ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def cancel_transfer_operation ( self , operation_name ) : self . get_conn ( ) . transferOperations ( ) . cancel ( name = operation_name ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_transfer_operation ( self , operation_name ) : return ( self . get_conn ( ) . transferOperations ( ) . get ( name = operation_name ) . execute ( num_retries = self . num_retries ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_transfer_operations ( self , filter ) : conn = self . get_conn ( ) filter = self . _inject_project_id ( filter , FILTER , FILTER_PROJECT_ID ) operations = [ ] request = conn . transferOperations ( ) . list ( name = TRANSFER_OPERATIONS , filter = json . dumps ( filter ) ) while request is not None : response = request . execute ( num_retries = self . num_retries ) if OPERATIONS in response : operations . extend ( response [ OPERATIONS ] ) request = conn . transferOperations ( ) . list_next ( previous_request = request , previous_response = response ) return operations\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pause_transfer_operation ( self , operation_name ) : self . get_conn ( ) . transferOperations ( ) . pause ( name = operation_name ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def resume_transfer_operation ( self , operation_name ) : self . get_conn ( ) . transferOperations ( ) . resume ( name = operation_name ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wait_for_transfer_job ( self , job , expected_statuses = ( GcpTransferOperationStatus . SUCCESS , ) , timeout = 60 ) : while timeout > 0 : operations = self . list_transfer_operations ( filter = { FILTER_PROJECT_ID : job [ PROJECT_ID ] , FILTER_JOB_NAMES : [ job [ NAME ] ] } ) if GCPTransferServiceHook . operations_contain_expected_statuses ( operations , expected_statuses ) : return time . sleep ( TIME_TO_SLEEP_IN_SECONDS ) timeout -= TIME_TO_SLEEP_IN_SECONDS raise AirflowException ( \"Timeout. The operation could not be completed within the allotted time.\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def operations_contain_expected_statuses ( operations , expected_statuses ) : expected_statuses = ( { expected_statuses } if isinstance ( expected_statuses , six . string_types ) else set ( expected_statuses ) ) if len ( operations ) == 0 : return False current_statuses = { operation [ METADATA ] [ STATUS ] for operation in operations } if len ( current_statuses - set ( expected_statuses ) ) != len ( current_statuses ) : return True if len ( NEGATIVE_STATUSES - current_statuses ) != len ( NEGATIVE_STATUSES ) : raise AirflowException ( 'An unexpected operation status was encountered. Expected: {}' . format ( \", \" . join ( expected_statuses ) ) ) return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def find_for_task_instance ( task_instance , session ) : TR = TaskReschedule return ( session . query ( TR ) . filter ( TR . dag_id == task_instance . dag_id , TR . task_id == task_instance . task_id , TR . execution_date == task_instance . execution_date , TR . try_number == task_instance . try_number ) . order_by ( asc ( TR . id ) ) . all ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _strip_unsafe_kubernetes_special_chars ( string ) : return '' . join ( ch . lower ( ) for ind , ch in enumerate ( string ) if ch . isalnum ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_safe_pod_id ( safe_dag_id , safe_task_id , safe_uuid ) : MAX_POD_ID_LEN = 253 safe_key = safe_dag_id + safe_task_id safe_pod_id = safe_key [ : MAX_POD_ID_LEN - len ( safe_uuid ) - 1 ] + \"-\" + safe_uuid return safe_pod_id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_safe_label_value ( string ) : MAX_LABEL_LEN = 63 safe_label = re . sub ( r'^[^a-z0-9A-Z]*|[^a-zA-Z0-9_\\-\\.]|[^a-z0-9A-Z]*$' , '' , string ) if len ( safe_label ) > MAX_LABEL_LEN or string != safe_label : safe_hash = hashlib . md5 ( string . encode ( ) ) . hexdigest ( ) [ : 9 ] safe_label = safe_label [ : MAX_LABEL_LEN - len ( safe_hash ) - 1 ] + \"-\" + safe_hash return safe_label\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def clear_not_launched_queued_tasks ( self , session = None ) : queued_tasks = session . query ( TaskInstance ) . filter ( TaskInstance . state == State . QUEUED ) . all ( ) self . log . info ( 'When executor started up, found %s queued task instances' , len ( queued_tasks ) ) for task in queued_tasks : dict_string = ( \"dag_id={},task_id={},execution_date={},airflow-worker={}\" . format ( AirflowKubernetesScheduler . _make_safe_label_value ( task . dag_id ) , AirflowKubernetesScheduler . _make_safe_label_value ( task . task_id ) , AirflowKubernetesScheduler . _datetime_to_label_safe_datestring ( task . execution_date ) , self . worker_uuid ) ) kwargs = dict ( label_selector = dict_string ) pod_list = self . kube_client . list_namespaced_pod ( self . kube_config . kube_namespace , * * kwargs ) if len ( pod_list . items ) == 0 : self . log . info ( 'TaskInstance: %s found in queued state but was not launched, ' 'rescheduling' , task ) session . query ( TaskInstance ) . filter ( TaskInstance . dag_id == task . dag_id , TaskInstance . task_id == task . task_id , TaskInstance . execution_date == task . execution_date ) . update ( { TaskInstance . state : State . NONE } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def open_slots ( self , session ) : from airflow . models . taskinstance import TaskInstance as TI # Avoid circular import used_slots = session . query ( func . count ( ) ) . filter ( TI . pool == self . pool ) . filter ( TI . state . in_ ( [ State . RUNNING , State . QUEUED ] ) ) . scalar ( ) return self . slots - used_slots\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def expand_env_var ( env_var ) : if not env_var : return env_var while True : interpolated = os . path . expanduser ( os . path . expandvars ( str ( env_var ) ) ) if interpolated == env_var : return interpolated else : env_var = interpolated\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_command ( command ) : process = subprocess . Popen ( shlex . split ( command ) , stdout = subprocess . PIPE , stderr = subprocess . PIPE , close_fds = True ) output , stderr = [ stream . decode ( sys . getdefaultencoding ( ) , 'ignore' ) for stream in process . communicate ( ) ] if process . returncode != 0 : raise AirflowConfigException ( \"Cannot execute {}. Error code is: {}. Output: {}, Stderr: {}\" . format ( command , process . returncode , output , stderr ) ) return output\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def parameterized_config ( template ) : all_vars = { k : v for d in [ globals ( ) , locals ( ) ] for k , v in d . items ( ) } return template . format ( * * all_vars )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def remove_option ( self , section , option , remove_default = True ) : if super ( ) . has_option ( section , option ) : super ( ) . remove_option ( section , option ) if self . airflow_defaults . has_option ( section , option ) and remove_default : self . airflow_defaults . remove_option ( section , option )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def getsection ( self , section ) : if ( section not in self . _sections and section not in self . airflow_defaults . _sections ) : return None _section = copy . deepcopy ( self . airflow_defaults . _sections [ section ] ) if section in self . _sections : _section . update ( copy . deepcopy ( self . _sections [ section ] ) ) section_prefix = 'AIRFLOW__{S}__' . format ( S = section . upper ( ) ) for env_var in sorted ( os . environ . keys ( ) ) : if env_var . startswith ( section_prefix ) : key = env_var . replace ( section_prefix , '' ) . lower ( ) _section [ key ] = self . _get_env_var_option ( section , key ) for key , val in iteritems ( _section ) : try : val = int ( val ) except ValueError : try : val = float ( val ) except ValueError : if val . lower ( ) in ( 't' , 'true' ) : val = True elif val . lower ( ) in ( 'f' , 'false' ) : val = False _section [ key ] = val return _section\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def as_dict ( self , display_source = False , display_sensitive = False , raw = False ) : cfg = { } configs = [ ( 'default' , self . airflow_defaults ) , ( 'airflow.cfg' , self ) , ] for ( source_name , config ) in configs : for section in config . sections ( ) : sect = cfg . setdefault ( section , OrderedDict ( ) ) for ( k , val ) in config . items ( section = section , raw = raw ) : if display_source : val = ( val , source_name ) sect [ k ] = val # add env vars and overwrite because they have priority for ev in [ ev for ev in os . environ if ev . startswith ( 'AIRFLOW__' ) ] : try : _ , section , key = ev . split ( '__' ) opt = self . _get_env_var_option ( section , key ) except ValueError : continue if not display_sensitive and ev != 'AIRFLOW__CORE__UNIT_TEST_MODE' : opt = '< hidden >' elif raw : opt = opt . replace ( '%' , '%%' ) if display_source : opt = ( opt , 'env var' ) cfg . setdefault ( section . lower ( ) , OrderedDict ( ) ) . update ( { key . lower ( ) : opt } ) # add bash commands for ( section , key ) in self . as_command_stdout : opt = self . _get_cmd_option ( section , key ) if opt : if not display_sensitive : opt = '< hidden >' if display_source : opt = ( opt , 'cmd' ) elif raw : opt = opt . replace ( '%' , '%%' ) cfg . setdefault ( section , OrderedDict ( ) ) . update ( { key : opt } ) del cfg [ section ] [ key + '_cmd' ] return cfg\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def allocate_ids ( self , partial_keys ) : conn = self . get_conn ( ) resp = ( conn . projects ( ) . allocateIds ( projectId = self . project_id , body = { 'keys' : partial_keys } ) . execute ( num_retries = self . num_retries ) ) return resp [ 'keys' ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def begin_transaction ( self ) : conn = self . get_conn ( ) resp = ( conn . projects ( ) . beginTransaction ( projectId = self . project_id , body = { } ) . execute ( num_retries = self . num_retries ) ) return resp [ 'transaction' ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def commit ( self , body ) : conn = self . get_conn ( ) resp = ( conn . projects ( ) . commit ( projectId = self . project_id , body = body ) . execute ( num_retries = self . num_retries ) ) return resp\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def lookup ( self , keys , read_consistency = None , transaction = None ) : conn = self . get_conn ( ) body = { 'keys' : keys } if read_consistency : body [ 'readConsistency' ] = read_consistency if transaction : body [ 'transaction' ] = transaction resp = ( conn . projects ( ) . lookup ( projectId = self . project_id , body = body ) . execute ( num_retries = self . num_retries ) ) return resp\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def rollback ( self , transaction ) : conn = self . get_conn ( ) conn . projects ( ) . rollback ( projectId = self . project_id , body = { 'transaction' : transaction } ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_query ( self , body ) : conn = self . get_conn ( ) resp = ( conn . projects ( ) . runQuery ( projectId = self . project_id , body = body ) . execute ( num_retries = self . num_retries ) ) return resp [ 'batch' ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_operation ( self , name ) : conn = self . get_conn ( ) resp = ( conn . projects ( ) . operations ( ) . get ( name = name ) . execute ( num_retries = self . num_retries ) ) return resp\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_operation ( self , name ) : conn = self . get_conn ( ) resp = ( conn . projects ( ) . operations ( ) . delete ( name = name ) . execute ( num_retries = self . num_retries ) ) return resp\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poll_operation_until_done ( self , name , polling_interval_in_seconds ) : while True : result = self . get_operation ( name ) state = result [ 'metadata' ] [ 'common' ] [ 'state' ] if state == 'PROCESSING' : self . log . info ( 'Operation is processing. Re-polling state in {} seconds' . format ( polling_interval_in_seconds ) ) time . sleep ( polling_interval_in_seconds ) else : return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def export_to_storage_bucket ( self , bucket , namespace = None , entity_filter = None , labels = None ) : admin_conn = self . get_conn ( ) output_uri_prefix = 'gs://' + '/' . join ( filter ( None , [ bucket , namespace ] ) ) if not entity_filter : entity_filter = { } if not labels : labels = { } body = { 'outputUrlPrefix' : output_uri_prefix , 'entityFilter' : entity_filter , 'labels' : labels , } resp = ( admin_conn . projects ( ) . export ( projectId = self . project_id , body = body ) . execute ( num_retries = self . num_retries ) ) return resp\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def import_from_storage_bucket ( self , bucket , file , namespace = None , entity_filter = None , labels = None ) : admin_conn = self . get_conn ( ) input_url = 'gs://' + '/' . join ( filter ( None , [ bucket , namespace , file ] ) ) if not entity_filter : entity_filter = { } if not labels : labels = { } body = { 'inputUrl' : input_url , 'entityFilter' : entity_filter , 'labels' : labels , } resp = ( admin_conn . projects ( ) . import_ ( projectId = self . project_id , body = body ) . execute ( num_retries = self . num_retries ) ) return resp\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def publish_to_target ( self , target_arn , message ) : conn = self . get_conn ( ) messages = { 'default' : message } return conn . publish ( TargetArn = target_arn , Message = json . dumps ( messages ) , MessageStructure = 'json' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_hostname ( ) : # First we attempt to fetch the callable path from the config. try : callable_path = conf . get ( 'core' , 'hostname_callable' ) except AirflowConfigException : callable_path = None # Then we handle the case when the config is missing or empty. This is the # default behavior. if not callable_path : return socket . getfqdn ( ) # Since we have a callable path, we try to import and run it next. module_path , attr_name = callable_path . split ( ':' ) module = importlib . import_module ( module_path ) callable = getattr ( module , attr_name ) return callable ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . _conn : self . _conn = LanguageServiceClient ( credentials = self . _get_credentials ( ) ) return self . _conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def analyze_entities ( self , document , encoding_type = None , retry = None , timeout = None , metadata = None ) : client = self . get_conn ( ) return client . analyze_entities ( document = document , encoding_type = encoding_type , retry = retry , timeout = timeout , metadata = metadata )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def annotate_text ( self , document , features , encoding_type = None , retry = None , timeout = None , metadata = None ) : client = self . get_conn ( ) return client . annotate_text ( document = document , features = features , encoding_type = encoding_type , retry = retry , timeout = timeout , metadata = metadata , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def classify_text ( self , document , retry = None , timeout = None , metadata = None ) : client = self . get_conn ( ) return client . classify_text ( document = document , retry = retry , timeout = timeout , metadata = metadata )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_task ( dag_id , task_id ) : dagbag = DagBag ( ) # Check DAG exists. if dag_id not in dagbag . dags : error_message = \"Dag id {} not found\" . format ( dag_id ) raise DagNotFound ( error_message ) # Get DAG object and check Task Exists dag = dagbag . get_dag ( dag_id ) if not dag . has_task ( task_id ) : error_message = 'Task {} not found in dag {}' . format ( task_id , dag_id ) raise TaskNotFound ( error_message ) # Return the task. return dag . get_task ( task_id )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_template_field ( env , fullname ) : modname , classname = fullname . rsplit ( \".\" , 1 ) try : with mock ( env . config . autodoc_mock_imports ) : mod = import_module ( modname ) except ImportError : raise RoleException ( \"Error loading %s module.\" % ( modname , ) ) clazz = getattr ( mod , classname ) if not clazz : raise RoleException ( \"Error finding %s class in %s module.\" % ( classname , modname ) ) template_fields = getattr ( clazz , \"template_fields\" ) if not template_fields : raise RoleException ( \"Could not find the template fields for %s class in %s module.\" % ( classname , modname ) ) return list ( template_fields )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def template_field_role ( app , typ , rawtext , text , lineno , inliner , options = { } , content = [ ] ) : text = utils . unescape ( text ) try : template_fields = get_template_field ( app . env , text ) except RoleException as e : msg = inliner . reporter . error ( \"invalid class name %s \\n%s\" % ( text , e , ) , line = lineno ) prb = inliner . problematic ( rawtext , rawtext , msg ) return [ prb ] , [ msg ] node = nodes . inline ( rawtext = rawtext ) for i , field in enumerate ( template_fields ) : if i != 0 : node += nodes . Text ( \", \" ) node += nodes . literal ( field , \"\" , nodes . Text ( field ) ) return [ node ] , [ ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dispose_orm ( ) : log . debug ( \"Disposing DB connection pool (PID %s)\" , os . getpid ( ) ) global engine global Session if Session : Session . remove ( ) Session = None if engine : engine . dispose ( ) engine = None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def prepare_classpath ( ) : if DAGS_FOLDER not in sys . path : sys . path . append ( DAGS_FOLDER ) # Add ./config/ for loading custom log parsers etc, or # airflow_local_settings etc. config_path = os . path . join ( AIRFLOW_HOME , 'config' ) if config_path not in sys . path : sys . path . append ( config_path ) if PLUGINS_FOLDER not in sys . path : sys . path . append ( PLUGINS_FOLDER )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _check_task_id ( self , context ) : ti = context [ 'ti' ] celery_result = ti . xcom_pull ( task_ids = self . target_task_id ) return celery_result . ready ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def detect_conf_var ( ) : ticket_cache = configuration . conf . get ( 'kerberos' , 'ccache' ) with open ( ticket_cache , 'rb' ) as f : # Note: this file is binary, so we check against a bytearray. return b'X-CACHECONF:' in f . read ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def alchemy_to_dict ( obj ) : if not obj : return None d = { } for c in obj . __table__ . columns : value = getattr ( obj , c . name ) if type ( value ) == datetime : value = value . isoformat ( ) d [ c . name ] = value return d\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def chunks ( items , chunk_size ) : if chunk_size <= 0 : raise ValueError ( 'Chunk size must be a positive integer' ) for i in range ( 0 , len ( items ) , chunk_size ) : yield items [ i : i + chunk_size ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def reduce_in_chunks ( fn , iterable , initializer , chunk_size = 0 ) : if len ( iterable ) == 0 : return initializer if chunk_size == 0 : chunk_size = len ( iterable ) return reduce ( fn , chunks ( iterable , chunk_size ) , initializer )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def chain ( * tasks ) : for up_task , down_task in zip ( tasks [ : - 1 ] , tasks [ 1 : ] ) : up_task . set_downstream ( down_task )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pprinttable ( rows ) : if not rows : return if hasattr ( rows [ 0 ] , '_fields' ) : # if namedtuple headers = rows [ 0 ] . _fields else : headers = [ \"col{}\" . format ( i ) for i in range ( len ( rows [ 0 ] ) ) ] lens = [ len ( s ) for s in headers ] for row in rows : for i in range ( len ( rows [ 0 ] ) ) : slenght = len ( \"{}\" . format ( row [ i ] ) ) if slenght > lens [ i ] : lens [ i ] = slenght formats = [ ] hformats = [ ] for i in range ( len ( rows [ 0 ] ) ) : if isinstance ( rows [ 0 ] [ i ] , int ) : formats . append ( \"%%%dd\" % lens [ i ] ) else : formats . append ( \"%%-%ds\" % lens [ i ] ) hformats . append ( \"%%-%ds\" % lens [ i ] ) pattern = \" | \" . join ( formats ) hpattern = \" | \" . join ( hformats ) separator = \"-+-\" . join ( [ '-' * n for n in lens ] ) s = \"\" s += separator + '\\n' s += ( hpattern % tuple ( headers ) ) + '\\n' s += separator + '\\n' def f ( t ) : return \"{}\" . format ( t ) if isinstance ( t , basestring ) else t for line in rows : s += pattern % tuple ( f ( t ) for t in line ) + '\\n' s += separator + '\\n' return s\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def reap_process_group ( pid , log , sig = signal . SIGTERM , timeout = DEFAULT_TIME_TO_WAIT_AFTER_SIGTERM ) : def on_terminate ( p ) : log . info ( \"Process %s (%s) terminated with exit code %s\" , p , p . pid , p . returncode ) if pid == os . getpid ( ) : raise RuntimeError ( \"I refuse to kill myself\" ) parent = psutil . Process ( pid ) children = parent . children ( recursive = True ) children . append ( parent ) try : pg = os . getpgid ( pid ) except OSError as err : # Skip if not such process - we experience a race and it just terminated if err . errno == errno . ESRCH : return raise log . info ( \"Sending %s to GPID %s\" , sig , pg ) os . killpg ( os . getpgid ( pid ) , sig ) gone , alive = psutil . wait_procs ( children , timeout = timeout , callback = on_terminate ) if alive : for p in alive : log . warn ( \"process %s (%s) did not respond to SIGTERM. Trying SIGKILL\" , p , pid ) os . killpg ( os . getpgid ( pid ) , signal . SIGKILL ) gone , alive = psutil . wait_procs ( alive , timeout = timeout , callback = on_terminate ) if alive : for p in alive : log . error ( \"Process %s (%s) could not be killed. Giving up.\" , p , p . pid )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def render_log_filename ( ti , try_number , filename_template ) : filename_template , filename_jinja_template = parse_template_string ( filename_template ) if filename_jinja_template : jinja_context = ti . get_template_context ( ) jinja_context [ 'try_number' ] = try_number return filename_jinja_template . render ( * * jinja_context ) return filename_template . format ( dag_id = ti . dag_id , task_id = ti . task_id , execution_date = ti . execution_date . isoformat ( ) , try_number = try_number )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_task_instance ( dag_id , task_id , execution_date ) : dagbag = DagBag ( ) # Check DAG exists. if dag_id not in dagbag . dags : error_message = \"Dag id {} not found\" . format ( dag_id ) raise DagNotFound ( error_message ) # Get DAG object and check Task Exists dag = dagbag . get_dag ( dag_id ) if not dag . has_task ( task_id ) : error_message = 'Task {} not found in dag {}' . format ( task_id , dag_id ) raise TaskNotFound ( error_message ) # Get DagRun object and check that it exists dagrun = dag . get_dagrun ( execution_date = execution_date ) if not dagrun : error_message = ( 'Dag Run for date {} not found in dag {}' . format ( execution_date , dag_id ) ) raise DagRunNotFound ( error_message ) # Get task instance object and check that it exists task_instance = dagrun . get_task_instance ( task_id ) if not task_instance : error_message = ( 'Task {} instance for date {} not found' . format ( task_id , execution_date ) ) raise TaskInstanceNotFound ( error_message ) return task_instance\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _integrate_plugins ( ) : import sys from airflow . plugins_manager import operators_modules for operators_module in operators_modules : sys . modules [ operators_module . __name__ ] = operators_module globals ( ) [ operators_module . _name ] = operators_module\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : http_authorized = self . _authorize ( ) return build ( 'dataproc' , self . api_version , http = http_authorized , cache_discovery = False )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wait ( self , operation ) : submitted = _DataProcOperation ( self . get_conn ( ) , operation , self . num_retries ) submitted . wait_for_done ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _deep_string_coerce ( content , json_path = 'json' ) : c = _deep_string_coerce if isinstance ( content , six . string_types ) : return content elif isinstance ( content , six . integer_types + ( float , ) ) : # Databricks can tolerate either numeric or string types in the API backend. return str ( content ) elif isinstance ( content , ( list , tuple ) ) : return [ c ( e , '{0}[{1}]' . format ( json_path , i ) ) for i , e in enumerate ( content ) ] elif isinstance ( content , dict ) : return { k : c ( v , '{0}[{1}]' . format ( json_path , k ) ) for k , v in list ( content . items ( ) ) } else : param_type = type ( content ) msg = 'Type {0} used for parameter {1} is not a number or a string' . format ( param_type , json_path ) raise AirflowException ( msg )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _handle_databricks_operator_execution ( operator , hook , log , context ) : if operator . do_xcom_push : context [ 'ti' ] . xcom_push ( key = XCOM_RUN_ID_KEY , value = operator . run_id ) log . info ( 'Run submitted with run_id: %s' , operator . run_id ) run_page_url = hook . get_run_page_url ( operator . run_id ) if operator . do_xcom_push : context [ 'ti' ] . xcom_push ( key = XCOM_RUN_PAGE_URL_KEY , value = run_page_url ) log . info ( 'View run status, Spark UI, and logs at %s' , run_page_url ) while True : run_state = hook . get_run_state ( operator . run_id ) if run_state . is_terminal : if run_state . is_successful : log . info ( '%s completed successfully.' , operator . task_id ) log . info ( 'View run status, Spark UI, and logs at %s' , run_page_url ) return else : error_message = '{t} failed with terminal state: {s}' . format ( t = operator . task_id , s = run_state ) raise AirflowException ( error_message ) else : log . info ( '%s in run state: %s' , operator . task_id , run_state ) log . info ( 'View run status, Spark UI, and logs at %s' , run_page_url ) log . info ( 'Sleeping for %s seconds.' , operator . polling_period_seconds ) time . sleep ( operator . polling_period_seconds )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_cli ( self , pig , verbose = True ) : with TemporaryDirectory ( prefix = 'airflow_pigop_' ) as tmp_dir : with NamedTemporaryFile ( dir = tmp_dir ) as f : f . write ( pig . encode ( 'utf-8' ) ) f . flush ( ) fname = f . name pig_bin = 'pig' cmd_extra = [ ] pig_cmd = [ pig_bin , '-f' , fname ] + cmd_extra if self . pig_properties : pig_properties_list = self . pig_properties . split ( ) pig_cmd . extend ( pig_properties_list ) if verbose : self . log . info ( \"%s\" , \" \" . join ( pig_cmd ) ) sp = subprocess . Popen ( pig_cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , cwd = tmp_dir , close_fds = True ) self . sp = sp stdout = '' for line in iter ( sp . stdout . readline , b'' ) : stdout += line . decode ( 'utf-8' ) if verbose : self . log . info ( line . strip ( ) ) sp . wait ( ) if sp . returncode : raise AirflowException ( stdout ) return stdout\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fetch_celery_task_state ( celery_task ) : try : with timeout ( seconds = 2 ) : # Accessing state property of celery task will make actual network request # to get the current state of the task. res = ( celery_task [ 0 ] , celery_task [ 1 ] . state ) except Exception as e : exception_traceback = \"Celery Task ID: {}\\n{}\" . format ( celery_task [ 0 ] , traceback . format_exc ( ) ) res = ExceptionWithTraceback ( e , exception_traceback ) return res\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _num_tasks_per_send_process ( self , to_send_count ) : return max ( 1 , int ( math . ceil ( 1.0 * to_send_count / self . _sync_parallelism ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _num_tasks_per_fetch_process ( self ) : return max ( 1 , int ( math . ceil ( 1.0 * len ( self . tasks ) / self . _sync_parallelism ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def setdefault ( cls , key , default , deserialize_json = False ) : obj = Variable . get ( key , default_var = None , deserialize_json = deserialize_json ) if obj is None : if default is not None : Variable . set ( key , default , serialize_json = deserialize_json ) return default else : raise ValueError ( 'Default Value must be set' ) else : return obj\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : authed_http = self . _authorize ( ) return build ( 'ml' , 'v1' , http = authed_http , cache_discovery = False )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_job ( self , project_id , job , use_existing_job_fn = None ) : request = self . _mlengine . projects ( ) . jobs ( ) . create ( parent = 'projects/{}' . format ( project_id ) , body = job ) job_id = job [ 'jobId' ] try : request . execute ( ) except HttpError as e : # 409 means there is an existing job with the same job ID. if e . resp . status == 409 : if use_existing_job_fn is not None : existing_job = self . _get_job ( project_id , job_id ) if not use_existing_job_fn ( existing_job ) : self . log . error ( 'Job with job_id %s already exist, but it does ' 'not match our expectation: %s' , job_id , existing_job ) raise self . log . info ( 'Job with job_id %s already exist. Will waiting for it to finish' , job_id ) else : self . log . error ( 'Failed to create MLEngine job: {}' . format ( e ) ) raise return self . _wait_for_job_done ( project_id , job_id )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_job ( self , project_id , job_id ) : job_name = 'projects/{}/jobs/{}' . format ( project_id , job_id ) request = self . _mlengine . projects ( ) . jobs ( ) . get ( name = job_name ) while True : try : return request . execute ( ) except HttpError as e : if e . resp . status == 429 : # polling after 30 seconds when quota failure occurs time . sleep ( 30 ) else : self . log . error ( 'Failed to get MLEngine job: {}' . format ( e ) ) raise\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _wait_for_job_done ( self , project_id , job_id , interval = 30 ) : if interval <= 0 : raise ValueError ( \"Interval must be > 0\" ) while True : job = self . _get_job ( project_id , job_id ) if job [ 'state' ] in [ 'SUCCEEDED' , 'FAILED' , 'CANCELLED' ] : return job time . sleep ( interval )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_version ( self , project_id , model_name , version_spec ) : parent_name = 'projects/{}/models/{}' . format ( project_id , model_name ) create_request = self . _mlengine . projects ( ) . models ( ) . versions ( ) . create ( parent = parent_name , body = version_spec ) response = create_request . execute ( ) get_request = self . _mlengine . projects ( ) . operations ( ) . get ( name = response [ 'name' ] ) return _poll_with_exponential_delay ( request = get_request , max_n = 9 , is_done_func = lambda resp : resp . get ( 'done' , False ) , is_error_func = lambda resp : resp . get ( 'error' , None ) is not None )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_default_version ( self , project_id , model_name , version_name ) : full_version_name = 'projects/{}/models/{}/versions/{}' . format ( project_id , model_name , version_name ) request = self . _mlengine . projects ( ) . models ( ) . versions ( ) . setDefault ( name = full_version_name , body = { } ) try : response = request . execute ( ) self . log . info ( 'Successfully set version: %s to default' , response ) return response except HttpError as e : self . log . error ( 'Something went wrong: %s' , e ) raise\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_versions ( self , project_id , model_name ) : result = [ ] full_parent_name = 'projects/{}/models/{}' . format ( project_id , model_name ) request = self . _mlengine . projects ( ) . models ( ) . versions ( ) . list ( parent = full_parent_name , pageSize = 100 ) response = request . execute ( ) next_page_token = response . get ( 'nextPageToken' , None ) result . extend ( response . get ( 'versions' , [ ] ) ) while next_page_token is not None : next_request = self . _mlengine . projects ( ) . models ( ) . versions ( ) . list ( parent = full_parent_name , pageToken = next_page_token , pageSize = 100 ) response = next_request . execute ( ) next_page_token = response . get ( 'nextPageToken' , None ) result . extend ( response . get ( 'versions' , [ ] ) ) time . sleep ( 5 ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_version ( self , project_id , model_name , version_name ) : full_name = 'projects/{}/models/{}/versions/{}' . format ( project_id , model_name , version_name ) delete_request = self . _mlengine . projects ( ) . models ( ) . versions ( ) . delete ( name = full_name ) response = delete_request . execute ( ) get_request = self . _mlengine . projects ( ) . operations ( ) . get ( name = response [ 'name' ] ) return _poll_with_exponential_delay ( request = get_request , max_n = 9 , is_done_func = lambda resp : resp . get ( 'done' , False ) , is_error_func = lambda resp : resp . get ( 'error' , None ) is not None )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_model ( self , project_id , model ) : if not model [ 'name' ] : raise ValueError ( \"Model name must be provided and \" \"could not be an empty string\" ) project = 'projects/{}' . format ( project_id ) request = self . _mlengine . projects ( ) . models ( ) . create ( parent = project , body = model ) return request . execute ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_model ( self , project_id , model_name ) : if not model_name : raise ValueError ( \"Model name must be provided and \" \"it could not be an empty string\" ) full_model_name = 'projects/{}/models/{}' . format ( project_id , model_name ) request = self . _mlengine . projects ( ) . models ( ) . get ( name = full_model_name ) try : return request . execute ( ) except HttpError as e : if e . resp . status == 404 : self . log . error ( 'Model was not found: %s' , e ) return None raise\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute_work ( self , key , command ) : if key is None : return self . log . info ( \"%s running %s\" , self . __class__ . __name__ , command ) try : subprocess . check_call ( command , close_fds = True ) state = State . SUCCESS except subprocess . CalledProcessError as e : state = State . FAILED self . log . error ( \"Failed to execute task %s.\" , str ( e ) ) # TODO: Why is this commented out? # raise e self . result_queue . put ( ( key , state ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def write_batch_data ( self , items ) : dynamodb_conn = self . get_conn ( ) try : table = dynamodb_conn . Table ( self . table_name ) with table . batch_writer ( overwrite_by_pkeys = self . table_keys ) as batch : for item in items : batch . put_item ( Item = item ) return True except Exception as general_error : raise AirflowException ( 'Failed to insert items in dynamodb, error: {error}' . format ( error = str ( general_error ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _integrate_plugins ( ) : from airflow . plugins_manager import executors_modules for executors_module in executors_modules : sys . modules [ executors_module . __name__ ] = executors_module globals ( ) [ executors_module . _name ] = executors_module\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_default_executor ( ) : global DEFAULT_EXECUTOR if DEFAULT_EXECUTOR is not None : return DEFAULT_EXECUTOR executor_name = configuration . conf . get ( 'core' , 'EXECUTOR' ) DEFAULT_EXECUTOR = _get_executor ( executor_name ) log = LoggingMixin ( ) . log log . info ( \"Using executor %s\" , executor_name ) return DEFAULT_EXECUTOR\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_executor ( executor_name ) : if executor_name == Executors . LocalExecutor : return LocalExecutor ( ) elif executor_name == Executors . SequentialExecutor : return SequentialExecutor ( ) elif executor_name == Executors . CeleryExecutor : from airflow . executors . celery_executor import CeleryExecutor return CeleryExecutor ( ) elif executor_name == Executors . DaskExecutor : from airflow . executors . dask_executor import DaskExecutor return DaskExecutor ( ) elif executor_name == Executors . KubernetesExecutor : from airflow . contrib . executors . kubernetes_executor import KubernetesExecutor return KubernetesExecutor ( ) else : # Loading plugins _integrate_plugins ( ) executor_path = executor_name . split ( '.' ) if len ( executor_path ) != 2 : raise AirflowException ( \"Executor {0} not supported: \" \"please specify in format plugin_module.executor\" . format ( executor_name ) ) if executor_path [ 0 ] in globals ( ) : return globals ( ) [ executor_path [ 0 ] ] . __dict__ [ executor_path [ 1 ] ] ( ) else : raise AirflowException ( \"Executor {0} not supported.\" . format ( executor_name ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def on_error ( self , error , items ) : self . log . error ( 'Encountered Segment error: {segment_error} with ' 'items: {with_items}' . format ( segment_error = error , with_items = items ) ) raise AirflowException ( 'Segment error: {}' . format ( error ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_pod ( self , pod , startup_timeout = 120 , get_logs = True ) : # type: (Pod, int, bool) -> Tuple[State, Optional[str]] resp = self . run_pod_async ( pod ) curr_time = dt . now ( ) if resp . status . start_time is None : while self . pod_not_started ( pod ) : delta = dt . now ( ) - curr_time if delta . seconds >= startup_timeout : raise AirflowException ( \"Pod took too long to start\" ) time . sleep ( 1 ) self . log . debug ( 'Pod not yet started' ) return self . _monitor_pod ( pod , get_logs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . mssql_conn_id ) conn = pymssql . connect ( server = conn . host , user = conn . login , password = conn . password , database = self . schema or conn . schema , port = conn . port ) return conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . _hook = SparkSubmitHook ( conf = self . _conf , conn_id = self . _conn_id , files = self . _files , py_files = self . _py_files , archives = self . _archives , driver_class_path = self . _driver_class_path , jars = self . _jars , java_class = self . _java_class , packages = self . _packages , exclude_packages = self . _exclude_packages , repositories = self . _repositories , total_executor_cores = self . _total_executor_cores , executor_cores = self . _executor_cores , executor_memory = self . _executor_memory , driver_memory = self . _driver_memory , keytab = self . _keytab , principal = self . _principal , name = self . _name , num_executors = self . _num_executors , application_args = self . _application_args , env_vars = self . _env_vars , verbose = self . _verbose , spark_binary = self . _spark_binary ) self . _hook . submit ( self . _application )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def trigger_dag ( dag_id ) : data = request . get_json ( force = True ) run_id = None if 'run_id' in data : run_id = data [ 'run_id' ] conf = None if 'conf' in data : conf = data [ 'conf' ] execution_date = None if 'execution_date' in data and data [ 'execution_date' ] is not None : execution_date = data [ 'execution_date' ] # Convert string datetime into actual datetime try : execution_date = timezone . parse ( execution_date ) except ValueError : error_message = ( 'Given execution date, {}, could not be identified ' 'as a date. Example date format: 2015-11-16T14:34:15+00:00' . format ( execution_date ) ) _log . info ( error_message ) response = jsonify ( { 'error' : error_message } ) response . status_code = 400 return response try : dr = trigger . trigger_dag ( dag_id , run_id , conf , execution_date ) except AirflowException as err : _log . error ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response if getattr ( g , 'user' , None ) : _log . info ( \"User %s created %s\" , g . user , dr ) response = jsonify ( message = \"Created {}\" . format ( dr ) ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_dag ( dag_id ) : try : count = delete . delete_dag ( dag_id ) except AirflowException as err : _log . error ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response return jsonify ( message = \"Removed {} record(s)\" . format ( count ) , count = count )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dag_runs ( dag_id ) : try : state = request . args . get ( 'state' ) dagruns = get_dag_runs ( dag_id , state ) except AirflowException as err : _log . info ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = 400 return response return jsonify ( dagruns )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_dag_code ( dag_id ) : try : return get_code ( dag_id ) except AirflowException as err : _log . info ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def task_info ( dag_id , task_id ) : try : info = get_task ( dag_id , task_id ) except AirflowException as err : _log . info ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response # JSONify and return. fields = { k : str ( v ) for k , v in vars ( info ) . items ( ) if not k . startswith ( '_' ) } return jsonify ( fields )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dag_paused ( dag_id , paused ) : DagModel = models . DagModel with create_session ( ) as session : orm_dag = ( session . query ( DagModel ) . filter ( DagModel . dag_id == dag_id ) . first ( ) ) if paused == 'true' : orm_dag . is_paused = True else : orm_dag . is_paused = False session . merge ( orm_dag ) session . commit ( ) return jsonify ( { 'response' : 'ok' } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def task_instance_info ( dag_id , execution_date , task_id ) : # Convert string datetime into actual datetime try : execution_date = timezone . parse ( execution_date ) except ValueError : error_message = ( 'Given execution date, {}, could not be identified ' 'as a date. Example date format: 2015-11-16T14:34:15+00:00' . format ( execution_date ) ) _log . info ( error_message ) response = jsonify ( { 'error' : error_message } ) response . status_code = 400 return response try : info = get_task_instance ( dag_id , task_id , execution_date ) except AirflowException as err : _log . info ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response # JSONify and return. fields = { k : str ( v ) for k , v in vars ( info ) . items ( ) if not k . startswith ( '_' ) } return jsonify ( fields )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dag_run_status ( dag_id , execution_date ) : # Convert string datetime into actual datetime try : execution_date = timezone . parse ( execution_date ) except ValueError : error_message = ( 'Given execution date, {}, could not be identified ' 'as a date. Example date format: 2015-11-16T14:34:15+00:00' . format ( execution_date ) ) _log . info ( error_message ) response = jsonify ( { 'error' : error_message } ) response . status_code = 400 return response try : info = get_dag_run_state ( dag_id , execution_date ) except AirflowException as err : _log . info ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response return jsonify ( info )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_pools ( ) : try : pools = pool_api . get_pools ( ) except AirflowException as err : _log . error ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response else : return jsonify ( [ p . to_json ( ) for p in pools ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_pool ( ) : params = request . get_json ( force = True ) try : pool = pool_api . create_pool ( * * params ) except AirflowException as err : _log . error ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response else : return jsonify ( pool . to_json ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_pool ( name ) : try : pool = pool_api . delete_pool ( name = name ) except AirflowException as err : _log . error ( err ) response = jsonify ( error = \"{}\" . format ( err ) ) response . status_code = err . status_code return response else : return jsonify ( pool . to_json ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_or_update ( self , resource_group , name , container_group ) : self . connection . container_groups . create_or_update ( resource_group , name , container_group )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_state_exitcode_details ( self , resource_group , name ) : current_state = self . _get_instance_view ( resource_group , name ) . current_state return ( current_state . state , current_state . exit_code , current_state . detail_status )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_messages ( self , resource_group , name ) : instance_view = self . _get_instance_view ( resource_group , name ) return [ event . message for event in instance_view . events ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_logs ( self , resource_group , name , tail = 1000 ) : logs = self . connection . container . list_logs ( resource_group , name , name , tail = tail ) return logs . content . splitlines ( True )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete ( self , resource_group , name ) : self . connection . container_groups . delete ( resource_group , name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def exists ( self , resource_group , name ) : for container in self . connection . container_groups . list_by_resource_group ( resource_group ) : if container . name == name : return True return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def apply_defaults ( func ) : # Cache inspect.signature for the wrapper closure to avoid calling it # at every decorated invocation. This is separate sig_cache created # per decoration, i.e. each function decorated using apply_defaults will # have a different sig_cache. sig_cache = signature ( func ) non_optional_args = { name for ( name , param ) in sig_cache . parameters . items ( ) if param . default == param . empty and param . name != 'self' and param . kind not in ( param . VAR_POSITIONAL , param . VAR_KEYWORD ) } @ wraps ( func ) def wrapper ( * args , * * kwargs ) : if len ( args ) > 1 : raise AirflowException ( \"Use keyword arguments when initializing operators\" ) dag_args = { } dag_params = { } dag = kwargs . get ( 'dag' , None ) or settings . CONTEXT_MANAGER_DAG if dag : dag_args = copy ( dag . default_args ) or { } dag_params = copy ( dag . params ) or { } params = { } if 'params' in kwargs : params = kwargs [ 'params' ] dag_params . update ( params ) default_args = { } if 'default_args' in kwargs : default_args = kwargs [ 'default_args' ] if 'params' in default_args : dag_params . update ( default_args [ 'params' ] ) del default_args [ 'params' ] dag_args . update ( default_args ) default_args = dag_args for arg in sig_cache . parameters : if arg not in kwargs and arg in default_args : kwargs [ arg ] = default_args [ arg ] missing_args = list ( non_optional_args - set ( kwargs ) ) if missing_args : msg = \"Argument {0} is required\" . format ( missing_args ) raise AirflowException ( msg ) kwargs [ 'params' ] = dag_params result = func ( * args , * * kwargs ) return result return wrapper\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def construct_ingest_query ( self , static_path , columns ) : # backward compatibility for num_shards, # but target_partition_size is the default setting # and overwrites the num_shards num_shards = self . num_shards target_partition_size = self . target_partition_size if self . target_partition_size == - 1 : if self . num_shards == - 1 : target_partition_size = DEFAULT_TARGET_PARTITION_SIZE else : num_shards = - 1 metric_names = [ m [ 'fieldName' ] for m in self . metric_spec if m [ 'type' ] != 'count' ] # Take all the columns, which are not the time dimension # or a metric, as the dimension columns dimensions = [ c for c in columns if c not in metric_names and c != self . ts_dim ] ingest_query_dict = { \"type\" : \"index_hadoop\" , \"spec\" : { \"dataSchema\" : { \"metricsSpec\" : self . metric_spec , \"granularitySpec\" : { \"queryGranularity\" : self . query_granularity , \"intervals\" : self . intervals , \"type\" : \"uniform\" , \"segmentGranularity\" : self . segment_granularity , } , \"parser\" : { \"type\" : \"string\" , \"parseSpec\" : { \"columns\" : columns , \"dimensionsSpec\" : { \"dimensionExclusions\" : [ ] , \"dimensions\" : dimensions , # list of names \"spatialDimensions\" : [ ] } , \"timestampSpec\" : { \"column\" : self . ts_dim , \"format\" : \"auto\" } , \"format\" : \"tsv\" } } , \"dataSource\" : self . druid_datasource } , \"tuningConfig\" : { \"type\" : \"hadoop\" , \"jobProperties\" : { \"mapreduce.job.user.classpath.first\" : \"false\" , \"mapreduce.map.output.compress\" : \"false\" , \"mapreduce.output.fileoutputformat.compress\" : \"false\" , } , \"partitionsSpec\" : { \"type\" : \"hashed\" , \"targetPartitionSize\" : target_partition_size , \"numShards\" : num_shards , } , } , \"ioConfig\" : { \"inputSpec\" : { \"paths\" : static_path , \"type\" : \"static\" } , \"type\" : \"hadoop\" } } } if self . job_properties : ingest_query_dict [ 'spec' ] [ 'tuningConfig' ] [ 'jobProperties' ] . update ( self . job_properties ) if self . hadoop_dependency_coordinates : ingest_query_dict [ 'hadoopDependencyCoordinates' ] = self . hadoop_dependency_coordinates return ingest_query_dict\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . log . info ( 'Transferring mail attachment %s from mail server via imap to s3 key %s...' , self . imap_attachment_name , self . s3_key ) with ImapHook ( imap_conn_id = self . imap_conn_id ) as imap_hook : imap_mail_attachments = imap_hook . retrieve_mail_attachments ( name = self . imap_attachment_name , mail_folder = self . imap_mail_folder , check_regex = self . imap_check_regex , latest_only = True ) s3_hook = S3Hook ( aws_conn_id = self . s3_conn_id ) s3_hook . load_bytes ( bytes_data = imap_mail_attachments [ 0 ] [ 1 ] , key = self . s3_key )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poke ( self , context ) : self . log . info ( 'RedisPubSubSensor checking for message on channels: %s' , self . channels ) message = self . pubsub . get_message ( ) self . log . info ( 'Message %s from channel %s' , message , self . channels ) # Process only message types if message and message [ 'type' ] == 'message' : context [ 'ti' ] . xcom_push ( key = 'message' , value = message ) self . pubsub . unsubscribe ( self . channels ) return True return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def refresh_from_db ( self , session = None ) : DR = DagRun exec_date = func . cast ( self . execution_date , DateTime ) dr = session . query ( DR ) . filter ( DR . dag_id == self . dag_id , func . cast ( DR . execution_date , DateTime ) == exec_date , DR . run_id == self . run_id ) . one ( ) self . id = dr . id self . state = dr . state\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def find ( dag_id = None , run_id = None , execution_date = None , state = None , external_trigger = None , no_backfills = False , session = None ) : DR = DagRun qry = session . query ( DR ) if dag_id : qry = qry . filter ( DR . dag_id == dag_id ) if run_id : qry = qry . filter ( DR . run_id == run_id ) if execution_date : if isinstance ( execution_date , list ) : qry = qry . filter ( DR . execution_date . in_ ( execution_date ) ) else : qry = qry . filter ( DR . execution_date == execution_date ) if state : qry = qry . filter ( DR . state == state ) if external_trigger is not None : qry = qry . filter ( DR . external_trigger == external_trigger ) if no_backfills : # in order to prevent a circular dependency from airflow . jobs import BackfillJob qry = qry . filter ( DR . run_id . notlike ( BackfillJob . ID_PREFIX + '%' ) ) dr = qry . order_by ( DR . execution_date ) . all ( ) return dr\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_task_instances ( self , state = None , session = None ) : from airflow . models . taskinstance import TaskInstance # Avoid circular import tis = session . query ( TaskInstance ) . filter ( TaskInstance . dag_id == self . dag_id , TaskInstance . execution_date == self . execution_date , ) if state : if isinstance ( state , six . string_types ) : tis = tis . filter ( TaskInstance . state == state ) else : # this is required to deal with NULL values if None in state : tis = tis . filter ( or_ ( TaskInstance . state . in_ ( state ) , TaskInstance . state . is_ ( None ) ) ) else : tis = tis . filter ( TaskInstance . state . in_ ( state ) ) if self . dag and self . dag . partial : tis = tis . filter ( TaskInstance . task_id . in_ ( self . dag . task_ids ) ) return tis . all ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_task_instance ( self , task_id , session = None ) : from airflow . models . taskinstance import TaskInstance # Avoid circular import TI = TaskInstance ti = session . query ( TI ) . filter ( TI . dag_id == self . dag_id , TI . execution_date == self . execution_date , TI . task_id == task_id ) . first ( ) return ti\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_previous_dagrun ( self , session = None ) : return session . query ( DagRun ) . filter ( DagRun . dag_id == self . dag_id , DagRun . execution_date < self . execution_date ) . order_by ( DagRun . execution_date . desc ( ) ) . first ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_previous_scheduled_dagrun ( self , session = None ) : dag = self . get_dag ( ) return session . query ( DagRun ) . filter ( DagRun . dag_id == self . dag_id , DagRun . execution_date == dag . previous_schedule ( self . execution_date ) ) . first ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_state ( self , session = None ) : dag = self . get_dag ( ) tis = self . get_task_instances ( session = session ) self . log . debug ( \"Updating state for %s considering %s task(s)\" , self , len ( tis ) ) for ti in list ( tis ) : # skip in db? if ti . state == State . REMOVED : tis . remove ( ti ) else : ti . task = dag . get_task ( ti . task_id ) # pre-calculate # db is faster start_dttm = timezone . utcnow ( ) unfinished_tasks = self . get_task_instances ( state = State . unfinished ( ) , session = session ) none_depends_on_past = all ( not t . task . depends_on_past for t in unfinished_tasks ) none_task_concurrency = all ( t . task . task_concurrency is None for t in unfinished_tasks ) # small speed up if unfinished_tasks and none_depends_on_past and none_task_concurrency : # todo: this can actually get pretty slow: one task costs between 0.01-015s no_dependencies_met = True for ut in unfinished_tasks : # We need to flag upstream and check for changes because upstream # failures/re-schedules can result in deadlock false positives old_state = ut . state deps_met = ut . are_dependencies_met ( dep_context = DepContext ( flag_upstream_failed = True , ignore_in_retry_period = True , ignore_in_reschedule_period = True ) , session = session ) if deps_met or old_state != ut . current_state ( session = session ) : no_dependencies_met = False break duration = ( timezone . utcnow ( ) - start_dttm ) . total_seconds ( ) * 1000 Stats . timing ( \"dagrun.dependency-check.{}\" . format ( self . dag_id ) , duration ) root_ids = [ t . task_id for t in dag . roots ] roots = [ t for t in tis if t . task_id in root_ids ] # if all roots finished and at least one failed, the run failed if ( not unfinished_tasks and any ( r . state in ( State . FAILED , State . UPSTREAM_FAILED ) for r in roots ) ) : self . log . info ( 'Marking run %s failed' , self ) self . set_state ( State . FAILED ) dag . handle_callback ( self , success = False , reason = 'task_failure' , session = session ) # if all roots succeeded and no unfinished tasks, the run succeeded elif not unfinished_tasks and all ( r . state in ( State . SUCCESS , State . SKIPPED ) for r in roots ) : self . log . info ( 'Marking run %s successful' , self ) self . set_state ( State . SUCCESS ) dag . handle_callback ( self , success = True , reason = 'success' , session = session ) # if *all tasks* are deadlocked, the run failed elif ( unfinished_tasks and none_depends_on_past and none_task_concurrency and no_dependencies_met ) : self . log . info ( 'Deadlock; marking run %s failed' , self ) self . set_state ( State . FAILED ) dag . handle_callback ( self , success = False , reason = 'all_tasks_deadlocked' , session = session ) # finally, if the roots aren't done, the dag is still running else : self . set_state ( State . RUNNING ) self . _emit_duration_stats_for_finished_state ( ) # todo: determine we want to use with_for_update to make sure to lock the run session . merge ( self ) session . commit ( ) return self . state\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def verify_integrity ( self , session = None ) : from airflow . models . taskinstance import TaskInstance # Avoid circular import dag = self . get_dag ( ) tis = self . get_task_instances ( session = session ) # check for removed or restored tasks task_ids = [ ] for ti in tis : task_ids . append ( ti . task_id ) task = None try : task = dag . get_task ( ti . task_id ) except AirflowException : if ti . state == State . REMOVED : pass # ti has already been removed, just ignore it elif self . state is not State . RUNNING and not dag . partial : self . log . warning ( \"Failed to get task '{}' for dag '{}'. \" \"Marking it as removed.\" . format ( ti , dag ) ) Stats . incr ( \"task_removed_from_dag.{}\" . format ( dag . dag_id ) , 1 , 1 ) ti . state = State . REMOVED is_task_in_dag = task is not None should_restore_task = is_task_in_dag and ti . state == State . REMOVED if should_restore_task : self . log . info ( \"Restoring task '{}' which was previously \" \"removed from DAG '{}'\" . format ( ti , dag ) ) Stats . incr ( \"task_restored_to_dag.{}\" . format ( dag . dag_id ) , 1 , 1 ) ti . state = State . NONE # check for missing tasks for task in six . itervalues ( dag . task_dict ) : if task . start_date > self . execution_date and not self . is_backfill : continue if task . task_id not in task_ids : Stats . incr ( \"task_instance_created-{}\" . format ( task . __class__ . __name__ ) , 1 , 1 ) ti = TaskInstance ( task , self . execution_date ) session . add ( ti ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_run ( session , dag_id , execution_date ) : qry = session . query ( DagRun ) . filter ( DagRun . dag_id == dag_id , DagRun . external_trigger == False , # noqa DagRun . execution_date == execution_date , ) return qry . first ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def jenkins_request_with_headers ( jenkins_server , req ) : try : response = jenkins_server . jenkins_request ( req ) response_body = response . content response_headers = response . headers if response_body is None : raise jenkins . EmptyResponseException ( \"Error communicating with server[%s]: \" \"empty response\" % jenkins_server . server ) return { 'body' : response_body . decode ( 'utf-8' ) , 'headers' : response_headers } except HTTPError as e : # Jenkins's funky authentication means its nigh impossible to # distinguish errors. if e . code in [ 401 , 403 , 500 ] : # six.moves.urllib.error.HTTPError provides a 'reason' # attribute for all python version except for ver 2.6 # Falling back to HTTPError.msg since it contains the # same info as reason raise JenkinsException ( 'Error in request. ' + 'Possibly authentication failed [%s]: %s' % ( e . code , e . msg ) ) elif e . code == 404 : raise jenkins . NotFoundException ( 'Requested item could not be found' ) else : raise except socket . timeout as e : raise jenkins . TimeoutException ( 'Error in request: %s' % e ) except URLError as e : # python 2.6 compatibility to ensure same exception raised # since URLError wraps a socket timeout on python 2.6. if str ( e . reason ) == \"timed out\" : raise jenkins . TimeoutException ( 'Error in request: %s' % e . reason ) raise JenkinsException ( 'Error in request: %s' % e . reason )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_job ( self , jenkins_server ) : # Warning if the parameter is too long, the URL can be longer than # the maximum allowed size if self . parameters and isinstance ( self . parameters , six . string_types ) : import ast self . parameters = ast . literal_eval ( self . parameters ) if not self . parameters : # We need a None to call the non parametrized jenkins api end point self . parameters = None request = Request ( jenkins_server . build_job_url ( self . job_name , self . parameters , None ) ) return jenkins_request_with_headers ( jenkins_server , request )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poll_job_in_queue ( self , location , jenkins_server ) : try_count = 0 location = location + '/api/json' # TODO Use get_queue_info instead # once it will be available in python-jenkins (v > 0.4.15) self . log . info ( 'Polling jenkins queue at the url %s' , location ) while try_count < self . max_try_before_job_appears : location_answer = jenkins_request_with_headers ( jenkins_server , Request ( location ) ) if location_answer is not None : json_response = json . loads ( location_answer [ 'body' ] ) if 'executable' in json_response : build_number = json_response [ 'executable' ] [ 'number' ] self . log . info ( 'Job executed on Jenkins side with the build number %s' , build_number ) return build_number try_count += 1 time . sleep ( self . sleep_time ) raise AirflowException ( \"The job hasn't been executed\" \" after polling the queue %d times\" , self . max_try_before_job_appears )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def context_to_airflow_vars ( context , in_env_var_format = False ) : params = dict ( ) if in_env_var_format : name_format = 'env_var_format' else : name_format = 'default' task_instance = context . get ( 'task_instance' ) if task_instance and task_instance . dag_id : params [ AIRFLOW_VAR_NAME_FORMAT_MAPPING [ 'AIRFLOW_CONTEXT_DAG_ID' ] [ name_format ] ] = task_instance . dag_id if task_instance and task_instance . task_id : params [ AIRFLOW_VAR_NAME_FORMAT_MAPPING [ 'AIRFLOW_CONTEXT_TASK_ID' ] [ name_format ] ] = task_instance . task_id if task_instance and task_instance . execution_date : params [ AIRFLOW_VAR_NAME_FORMAT_MAPPING [ 'AIRFLOW_CONTEXT_EXECUTION_DATE' ] [ name_format ] ] = task_instance . execution_date . isoformat ( ) dag_run = context . get ( 'dag_run' ) if dag_run and dag_run . run_id : params [ AIRFLOW_VAR_NAME_FORMAT_MAPPING [ 'AIRFLOW_CONTEXT_DAG_RUN_ID' ] [ name_format ] ] = dag_run . run_id return params\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def on_pre_execution ( * * kwargs ) : logging . debug ( \"Calling callbacks: %s\" , __pre_exec_callbacks ) for cb in __pre_exec_callbacks : try : cb ( * * kwargs ) except Exception : logging . exception ( 'Failed on pre-execution callback using %s' , cb )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def on_post_execution ( * * kwargs ) : logging . debug ( \"Calling callbacks: %s\" , __post_exec_callbacks ) for cb in __post_exec_callbacks : try : cb ( * * kwargs ) except Exception : logging . exception ( 'Failed on post-execution callback using %s' , cb )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def conditionally_trigger ( context , dag_run_obj ) : c_p = context [ 'params' ] [ 'condition_param' ] print ( \"Controller DAG : conditionally_trigger = {}\" . format ( c_p ) ) if context [ 'params' ] [ 'condition_param' ] : dag_run_obj . payload = { 'message' : context [ 'params' ] [ 'message' ] } pp . pprint ( dag_run_obj . payload ) return dag_run_obj\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def send_metric ( self , metric_name , datapoint , tags = None , type_ = None , interval = None ) : response = api . Metric . send ( metric = metric_name , points = datapoint , host = self . host , tags = tags , type = type_ , interval = interval ) self . validate_response ( response ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def query_metric ( self , query , from_seconds_ago , to_seconds_ago ) : now = int ( time . time ( ) ) response = api . Metric . query ( start = now - from_seconds_ago , end = now - to_seconds_ago , query = query ) self . validate_response ( response ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def post_event ( self , title , text , aggregation_key = None , alert_type = None , date_happened = None , handle = None , priority = None , related_event_id = None , tags = None , device_name = None ) : response = api . Event . create ( title = title , text = text , aggregation_key = aggregation_key , alert_type = alert_type , date_happened = date_happened , handle = handle , priority = priority , related_event_id = related_event_id , tags = tags , host = self . host , device_name = device_name , source_type_name = self . source_type_name ) self . validate_response ( response ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_token ( self , token , http_conn_id ) : if token : return token elif http_conn_id : conn = self . get_connection ( http_conn_id ) extra = conn . extra_dejson return extra . get ( 'webhook_token' , '' ) else : raise AirflowException ( 'Cannot get token: No valid Slack ' 'webhook token nor conn_id supplied' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_slack_message ( self ) : cmd = { } if self . channel : cmd [ 'channel' ] = self . channel if self . username : cmd [ 'username' ] = self . username if self . icon_emoji : cmd [ 'icon_emoji' ] = self . icon_emoji if self . link_names : cmd [ 'link_names' ] = 1 if self . attachments : cmd [ 'attachments' ] = self . attachments cmd [ 'text' ] = self . message return json . dumps ( cmd )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self ) : proxies = { } if self . proxy : # we only need https proxy for Slack, as the endpoint is https proxies = { 'https' : self . proxy } slack_message = self . _build_slack_message ( ) self . run ( endpoint = self . webhook_token , data = slack_message , headers = { 'Content-type' : 'application/json' } , extra_options = { 'proxies' : proxies } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_dag ( self , dag_id ) : from airflow . models . dag import DagModel # Avoid circular import # If asking for a known subdag, we want to refresh the parent root_dag_id = dag_id if dag_id in self . dags : dag = self . dags [ dag_id ] if dag . is_subdag : root_dag_id = dag . parent_dag . dag_id # If the dag corresponding to root_dag_id is absent or expired orm_dag = DagModel . get_current ( root_dag_id ) if orm_dag and ( root_dag_id not in self . dags or ( orm_dag . last_expired and dag . last_loaded < orm_dag . last_expired ) ) : # Reprocess source file found_dags = self . process_file ( filepath = orm_dag . fileloc , only_if_updated = False ) # If the source file no longer exports `dag_id`, delete it from self.dags if found_dags and dag_id in [ found_dag . dag_id for found_dag in found_dags ] : return self . dags [ dag_id ] elif dag_id in self . dags : del self . dags [ dag_id ] return self . dags . get ( dag_id )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def process_file ( self , filepath , only_if_updated = True , safe_mode = True ) : from airflow . models . dag import DAG # Avoid circular import found_dags = [ ] # if the source file no longer exists in the DB or in the filesystem, # return an empty list # todo: raise exception? if filepath is None or not os . path . isfile ( filepath ) : return found_dags try : # This failed before in what may have been a git sync # race condition file_last_changed_on_disk = datetime . fromtimestamp ( os . path . getmtime ( filepath ) ) if only_if_updated and filepath in self . file_last_changed and file_last_changed_on_disk == self . file_last_changed [ filepath ] : return found_dags except Exception as e : self . log . exception ( e ) return found_dags mods = [ ] is_zipfile = zipfile . is_zipfile ( filepath ) if not is_zipfile : if safe_mode : with open ( filepath , 'rb' ) as f : content = f . read ( ) if not all ( [ s in content for s in ( b'DAG' , b'airflow' ) ] ) : self . file_last_changed [ filepath ] = file_last_changed_on_disk # Don't want to spam user with skip messages if not self . has_logged : self . has_logged = True self . log . info ( \"File %s assumed to contain no DAGs. Skipping.\" , filepath ) return found_dags self . log . debug ( \"Importing %s\" , filepath ) org_mod_name , _ = os . path . splitext ( os . path . split ( filepath ) [ - 1 ] ) mod_name = ( 'unusual_prefix_' + hashlib . sha1 ( filepath . encode ( 'utf-8' ) ) . hexdigest ( ) + '_' + org_mod_name ) if mod_name in sys . modules : del sys . modules [ mod_name ] with timeout ( configuration . conf . getint ( 'core' , \"DAGBAG_IMPORT_TIMEOUT\" ) ) : try : m = imp . load_source ( mod_name , filepath ) mods . append ( m ) except Exception as e : self . log . exception ( \"Failed to import: %s\" , filepath ) self . import_errors [ filepath ] = str ( e ) self . file_last_changed [ filepath ] = file_last_changed_on_disk else : zip_file = zipfile . ZipFile ( filepath ) for mod in zip_file . infolist ( ) : head , _ = os . path . split ( mod . filename ) mod_name , ext = os . path . splitext ( mod . filename ) if not head and ( ext == '.py' or ext == '.pyc' ) : if mod_name == '__init__' : self . log . warning ( \"Found __init__.%s at root of %s\" , ext , filepath ) if safe_mode : with zip_file . open ( mod . filename ) as zf : self . log . debug ( \"Reading %s from %s\" , mod . filename , filepath ) content = zf . read ( ) if not all ( [ s in content for s in ( b'DAG' , b'airflow' ) ] ) : self . file_last_changed [ filepath ] = ( file_last_changed_on_disk ) # todo: create ignore list # Don't want to spam user with skip messages if not self . has_logged : self . has_logged = True self . log . info ( \"File %s assumed to contain no DAGs. Skipping.\" , filepath ) if mod_name in sys . modules : del sys . modules [ mod_name ] try : sys . path . insert ( 0 , filepath ) m = importlib . import_module ( mod_name ) mods . append ( m ) except Exception as e : self . log . exception ( \"Failed to import: %s\" , filepath ) self . import_errors [ filepath ] = str ( e ) self . file_last_changed [ filepath ] = file_last_changed_on_disk for m in mods : for dag in list ( m . __dict__ . values ( ) ) : if isinstance ( dag , DAG ) : if not dag . full_filepath : dag . full_filepath = filepath if dag . fileloc != filepath and not is_zipfile : dag . fileloc = filepath try : dag . is_subdag = False self . bag_dag ( dag , parent_dag = dag , root_dag = dag ) if isinstance ( dag . _schedule_interval , six . string_types ) : croniter ( dag . _schedule_interval ) found_dags . append ( dag ) found_dags += dag . subdags except ( CroniterBadCronError , CroniterBadDateError , CroniterNotAlphaError ) as cron_e : self . log . exception ( \"Failed to bag_dag: %s\" , dag . full_filepath ) self . import_errors [ dag . full_filepath ] = \"Invalid Cron expression: \" + str ( cron_e ) self . file_last_changed [ dag . full_filepath ] = file_last_changed_on_disk except AirflowDagCycleException as cycle_exception : self . log . exception ( \"Failed to bag_dag: %s\" , dag . full_filepath ) self . import_errors [ dag . full_filepath ] = str ( cycle_exception ) self . file_last_changed [ dag . full_filepath ] = file_last_changed_on_disk self . file_last_changed [ filepath ] = file_last_changed_on_disk return found_dags\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def kill_zombies ( self , zombies , session = None ) : from airflow . models . taskinstance import TaskInstance # Avoid circular import for zombie in zombies : if zombie . dag_id in self . dags : dag = self . dags [ zombie . dag_id ] if zombie . task_id in dag . task_ids : task = dag . get_task ( zombie . task_id ) ti = TaskInstance ( task , zombie . execution_date ) # Get properties needed for failure handling from SimpleTaskInstance. ti . start_date = zombie . start_date ti . end_date = zombie . end_date ti . try_number = zombie . try_number ti . state = zombie . state ti . test_mode = configuration . getboolean ( 'core' , 'unit_test_mode' ) ti . handle_failure ( \"{} detected as zombie\" . format ( ti ) , ti . test_mode , ti . get_template_context ( ) ) self . log . info ( 'Marked zombie job %s as %s' , ti , ti . state ) Stats . incr ( 'zombies_killed' ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bag_dag ( self , dag , parent_dag , root_dag ) : dag . test_cycle ( ) # throws if a task cycle is found dag . resolve_template_files ( ) dag . last_loaded = timezone . utcnow ( ) for task in dag . tasks : settings . policy ( task ) subdags = dag . subdags try : for subdag in subdags : subdag . full_filepath = dag . full_filepath subdag . parent_dag = dag subdag . is_subdag = True self . bag_dag ( subdag , parent_dag = dag , root_dag = root_dag ) self . dags [ dag . dag_id ] = dag self . log . debug ( 'Loaded DAG %s' , dag ) except AirflowDagCycleException as cycle_exception : # There was an error in bagging the dag. Remove it from the list of dags self . log . exception ( 'Exception bagging dag: %s' , dag . dag_id ) # Only necessary at the root level since DAG.subdags automatically # performs DFS to search through all subdags if dag == root_dag : for subdag in subdags : if subdag . dag_id in self . dags : del self . dags [ subdag . dag_id ] raise cycle_exception\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def collect_dags ( self , dag_folder = None , only_if_updated = True , include_examples = configuration . conf . getboolean ( 'core' , 'LOAD_EXAMPLES' ) , safe_mode = configuration . conf . getboolean ( 'core' , 'DAG_DISCOVERY_SAFE_MODE' ) ) : start_dttm = timezone . utcnow ( ) dag_folder = dag_folder or self . dag_folder # Used to store stats around DagBag processing stats = [ ] FileLoadStat = namedtuple ( 'FileLoadStat' , \"file duration dag_num task_num dags\" ) dag_folder = correct_maybe_zipped ( dag_folder ) for filepath in list_py_file_paths ( dag_folder , safe_mode = safe_mode , include_examples = include_examples ) : try : ts = timezone . utcnow ( ) found_dags = self . process_file ( filepath , only_if_updated = only_if_updated , safe_mode = safe_mode ) td = timezone . utcnow ( ) - ts td = td . total_seconds ( ) + ( float ( td . microseconds ) / 1000000 ) stats . append ( FileLoadStat ( filepath . replace ( dag_folder , '' ) , td , len ( found_dags ) , sum ( [ len ( dag . tasks ) for dag in found_dags ] ) , str ( [ dag . dag_id for dag in found_dags ] ) , ) ) except Exception as e : self . log . exception ( e ) Stats . gauge ( 'collect_dags' , ( timezone . utcnow ( ) - start_dttm ) . total_seconds ( ) , 1 ) Stats . gauge ( 'dagbag_size' , len ( self . dags ) , 1 ) Stats . gauge ( 'dagbag_import_errors' , len ( self . import_errors ) , 1 ) self . dagbag_stats = sorted ( stats , key = lambda x : x . duration , reverse = True )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dagbag_report ( self ) : report = textwrap . dedent ( \"\"\"\\n ------------------------------------------------------------------- DagBag loading stats for {dag_folder} ------------------------------------------------------------------- Number of DAGs: {dag_num} Total task number: {task_num} DagBag parsing time: {duration} {table} \"\"\" ) stats = self . dagbag_stats return report . format ( dag_folder = self . dag_folder , duration = sum ( [ o . duration for o in stats ] ) , dag_num = sum ( [ o . dag_num for o in stats ] ) , task_num = sum ( [ o . task_num for o in stats ] ) , table = pprinttable ( stats ) , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . _hook = SparkJDBCHook ( spark_app_name = self . _spark_app_name , spark_conn_id = self . _spark_conn_id , spark_conf = self . _spark_conf , spark_py_files = self . _spark_py_files , spark_files = self . _spark_files , spark_jars = self . _spark_jars , num_executors = self . _num_executors , executor_cores = self . _executor_cores , executor_memory = self . _executor_memory , driver_memory = self . _driver_memory , verbose = self . _verbose , keytab = self . _keytab , principal = self . _principal , cmd_type = self . _cmd_type , jdbc_table = self . _jdbc_table , jdbc_conn_id = self . _jdbc_conn_id , jdbc_driver = self . _jdbc_driver , metastore_table = self . _metastore_table , jdbc_truncate = self . _jdbc_truncate , save_mode = self . _save_mode , save_format = self . _save_format , batch_size = self . _batch_size , fetch_size = self . _fetch_size , num_partitions = self . _num_partitions , partition_column = self . _partition_column , lower_bound = self . _lower_bound , upper_bound = self . _upper_bound , create_table_column_types = self . _create_table_column_types ) self . _hook . submit_jdbc_job ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ds_add ( ds , days ) : ds = datetime . strptime ( ds , '%Y-%m-%d' ) if days : ds = ds + timedelta ( days ) return ds . isoformat ( ) [ : 10 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ds_format ( ds , input_format , output_format ) : return datetime . strptime ( ds , input_format ) . strftime ( output_format )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _integrate_plugins ( ) : import sys from airflow . plugins_manager import macros_modules for macros_module in macros_modules : sys . modules [ macros_module . __name__ ] = macros_module globals ( ) [ macros_module . _name ] = macros_module\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poke ( self , context ) : sb = self . hook ( self . hdfs_conn_id ) . get_conn ( ) self . log . info ( 'Poking for %s to be a directory with files matching %s' , self . filepath , self . regex . pattern ) result = [ f for f in sb . ls ( [ self . filepath ] , include_toplevel = False ) if f [ 'file_type' ] == 'f' and self . regex . match ( f [ 'path' ] . replace ( '%s/' % self . filepath , '' ) ) ] result = self . filter_for_ignored_ext ( result , self . ignored_ext , self . ignore_copying ) result = self . filter_for_filesize ( result , self . file_size ) return bool ( result )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poke ( self , context ) : sb = self . hook ( self . hdfs_conn_id ) . get_conn ( ) result = [ f for f in sb . ls ( [ self . filepath ] , include_toplevel = True ) ] result = self . filter_for_ignored_ext ( result , self . ignored_ext , self . ignore_copying ) result = self . filter_for_filesize ( result , self . file_size ) if self . be_empty : self . log . info ( 'Poking for filepath %s to a empty directory' , self . filepath ) return len ( result ) == 1 and result [ 0 ] [ 'path' ] == self . filepath else : self . log . info ( 'Poking for filepath %s to a non empty directory' , self . filepath ) result . pop ( 0 ) return bool ( result ) and result [ 0 ] [ 'file_type' ] == 'f'\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def clear_task_instances ( tis , session , activate_dag_runs = True , dag = None , ) : job_ids = [ ] for ti in tis : if ti . state == State . RUNNING : if ti . job_id : ti . state = State . SHUTDOWN job_ids . append ( ti . job_id ) else : task_id = ti . task_id if dag and dag . has_task ( task_id ) : task = dag . get_task ( task_id ) task_retries = task . retries ti . max_tries = ti . try_number + task_retries - 1 else : # Ignore errors when updating max_tries if dag is None or # task not found in dag since database records could be # outdated. We make max_tries the maximum value of its # original max_tries or the current task try number. ti . max_tries = max ( ti . max_tries , ti . try_number - 1 ) ti . state = State . NONE session . merge ( ti ) if job_ids : from airflow . jobs import BaseJob as BJ for job in session . query ( BJ ) . filter ( BJ . id . in_ ( job_ids ) ) . all ( ) : job . state = State . SHUTDOWN if activate_dag_runs and tis : from airflow . models . dagrun import DagRun # Avoid circular import drs = session . query ( DagRun ) . filter ( DagRun . dag_id . in_ ( { ti . dag_id for ti in tis } ) , DagRun . execution_date . in_ ( { ti . execution_date for ti in tis } ) , ) . all ( ) for dr in drs : dr . state = State . RUNNING dr . start_date = timezone . utcnow ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def try_number ( self ) : # This is designed so that task logs end up in the right file. if self . state == State . RUNNING : return self . _try_number return self . _try_number + 1\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def command ( self , mark_success = False , ignore_all_deps = False , ignore_depends_on_past = False , ignore_task_deps = False , ignore_ti_state = False , local = False , pickle_id = None , raw = False , job_id = None , pool = None , cfg_path = None ) : return \" \" . join ( self . command_as_list ( mark_success = mark_success , ignore_all_deps = ignore_all_deps , ignore_depends_on_past = ignore_depends_on_past , ignore_task_deps = ignore_task_deps , ignore_ti_state = ignore_ti_state , local = local , pickle_id = pickle_id , raw = raw , job_id = job_id , pool = pool , cfg_path = cfg_path ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def command_as_list ( self , mark_success = False , ignore_all_deps = False , ignore_task_deps = False , ignore_depends_on_past = False , ignore_ti_state = False , local = False , pickle_id = None , raw = False , job_id = None , pool = None , cfg_path = None ) : dag = self . task . dag should_pass_filepath = not pickle_id and dag if should_pass_filepath and dag . full_filepath != dag . filepath : path = \"DAGS_FOLDER/{}\" . format ( dag . filepath ) elif should_pass_filepath and dag . full_filepath : path = dag . full_filepath else : path = None return TaskInstance . generate_command ( self . dag_id , self . task_id , self . execution_date , mark_success = mark_success , ignore_all_deps = ignore_all_deps , ignore_task_deps = ignore_task_deps , ignore_depends_on_past = ignore_depends_on_past , ignore_ti_state = ignore_ti_state , local = local , pickle_id = pickle_id , file_path = path , raw = raw , job_id = job_id , pool = pool , cfg_path = cfg_path )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def generate_command ( dag_id , task_id , execution_date , mark_success = False , ignore_all_deps = False , ignore_depends_on_past = False , ignore_task_deps = False , ignore_ti_state = False , local = False , pickle_id = None , file_path = None , raw = False , job_id = None , pool = None , cfg_path = None ) : iso = execution_date . isoformat ( ) cmd = [ \"airflow\" , \"run\" , str ( dag_id ) , str ( task_id ) , str ( iso ) ] cmd . extend ( [ \"--mark_success\" ] ) if mark_success else None cmd . extend ( [ \"--pickle\" , str ( pickle_id ) ] ) if pickle_id else None cmd . extend ( [ \"--job_id\" , str ( job_id ) ] ) if job_id else None cmd . extend ( [ \"-A\" ] ) if ignore_all_deps else None cmd . extend ( [ \"-i\" ] ) if ignore_task_deps else None cmd . extend ( [ \"-I\" ] ) if ignore_depends_on_past else None cmd . extend ( [ \"--force\" ] ) if ignore_ti_state else None cmd . extend ( [ \"--local\" ] ) if local else None cmd . extend ( [ \"--pool\" , pool ] ) if pool else None cmd . extend ( [ \"--raw\" ] ) if raw else None cmd . extend ( [ \"-sd\" , file_path ] ) if file_path else None cmd . extend ( [ \"--cfg_path\" , cfg_path ] ) if cfg_path else None return cmd\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def current_state ( self , session = None ) : TI = TaskInstance ti = session . query ( TI ) . filter ( TI . dag_id == self . dag_id , TI . task_id == self . task_id , TI . execution_date == self . execution_date , ) . all ( ) if ti : state = ti [ 0 ] . state else : state = None return state\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def error ( self , session = None ) : self . log . error ( \"Recording the task instance as FAILED\" ) self . state = State . FAILED session . merge ( self ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def refresh_from_db ( self , session = None , lock_for_update = False ) : TI = TaskInstance qry = session . query ( TI ) . filter ( TI . dag_id == self . dag_id , TI . task_id == self . task_id , TI . execution_date == self . execution_date ) if lock_for_update : ti = qry . with_for_update ( ) . first ( ) else : ti = qry . first ( ) if ti : self . state = ti . state self . start_date = ti . start_date self . end_date = ti . end_date # Get the raw value of try_number column, don't read through the # accessor here otherwise it will be incremeneted by one already. self . try_number = ti . _try_number self . max_tries = ti . max_tries self . hostname = ti . hostname self . pid = ti . pid self . executor_config = ti . executor_config else : self . state = None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def clear_xcom_data ( self , session = None ) : session . query ( XCom ) . filter ( XCom . dag_id == self . dag_id , XCom . task_id == self . task_id , XCom . execution_date == self . execution_date ) . delete ( ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def key ( self ) : return self . dag_id , self . task_id , self . execution_date , self . try_number\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def are_dependents_done ( self , session = None ) : task = self . task if not task . downstream_task_ids : return True ti = session . query ( func . count ( TaskInstance . task_id ) ) . filter ( TaskInstance . dag_id == self . dag_id , TaskInstance . task_id . in_ ( task . downstream_task_ids ) , TaskInstance . execution_date == self . execution_date , TaskInstance . state == State . SUCCESS , ) count = ti [ 0 ] [ 0 ] return count == len ( task . downstream_task_ids )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def are_dependencies_met ( self , dep_context = None , session = None , verbose = False ) : dep_context = dep_context or DepContext ( ) failed = False verbose_aware_logger = self . log . info if verbose else self . log . debug for dep_status in self . get_failed_dep_statuses ( dep_context = dep_context , session = session ) : failed = True verbose_aware_logger ( \"Dependencies not met for %s, dependency '%s' FAILED: %s\" , self , dep_status . dep_name , dep_status . reason ) if failed : return False verbose_aware_logger ( \"Dependencies all met for %s\" , self ) return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def next_retry_datetime ( self ) : delay = self . task . retry_delay if self . task . retry_exponential_backoff : min_backoff = int ( delay . total_seconds ( ) * ( 2 ** ( self . try_number - 2 ) ) ) # deterministic per task instance hash = int ( hashlib . sha1 ( \"{}#{}#{}#{}\" . format ( self . dag_id , self . task_id , self . execution_date , self . try_number ) . encode ( 'utf-8' ) ) . hexdigest ( ) , 16 ) # between 0.5 * delay * (2^retry_number) and 1.0 * delay * (2^retry_number) modded_hash = min_backoff + hash % min_backoff # timedelta has a maximum representable value. The exponentiation # here means this value can be exceeded after a certain number # of tries (around 50 if the initial delay is 1s, even fewer if # the delay is larger). Cap the value here before creating a # timedelta object so the operation doesn't fail. delay_backoff_in_seconds = min ( modded_hash , timedelta . max . total_seconds ( ) - 1 ) delay = timedelta ( seconds = delay_backoff_in_seconds ) if self . task . max_retry_delay : delay = min ( self . task . max_retry_delay , delay ) return self . end_date + delay\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ready_for_retry ( self ) : return ( self . state == State . UP_FOR_RETRY and self . next_retry_datetime ( ) < timezone . utcnow ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pool_full ( self , session ) : if not self . task . pool : return False pool = ( session . query ( Pool ) . filter ( Pool . pool == self . task . pool ) . first ( ) ) if not pool : return False open_slots = pool . open_slots ( session = session ) return open_slots <= 0\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_dagrun ( self , session ) : from airflow . models . dagrun import DagRun # Avoid circular import dr = session . query ( DagRun ) . filter ( DagRun . dag_id == self . dag_id , DagRun . execution_date == self . execution_date ) . first ( ) return dr\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _check_and_change_state_before_execution ( self , verbose = True , ignore_all_deps = False , ignore_depends_on_past = False , ignore_task_deps = False , ignore_ti_state = False , mark_success = False , test_mode = False , job_id = None , pool = None , session = None ) : task = self . task self . pool = pool or task . pool self . test_mode = test_mode self . refresh_from_db ( session = session , lock_for_update = True ) self . job_id = job_id self . hostname = get_hostname ( ) self . operator = task . __class__ . __name__ if not ignore_all_deps and not ignore_ti_state and self . state == State . SUCCESS : Stats . incr ( 'previously_succeeded' , 1 , 1 ) queue_dep_context = DepContext ( deps = QUEUE_DEPS , ignore_all_deps = ignore_all_deps , ignore_ti_state = ignore_ti_state , ignore_depends_on_past = ignore_depends_on_past , ignore_task_deps = ignore_task_deps ) if not self . are_dependencies_met ( dep_context = queue_dep_context , session = session , verbose = True ) : session . commit ( ) return False # TODO: Logging needs cleanup, not clear what is being printed hr = \"\\n\" + ( \"-\" * 80 ) # Line break # For reporting purposes, we report based on 1-indexed, # not 0-indexed lists (i.e. Attempt 1 instead of # Attempt 0 for the first attempt). # Set the task start date. In case it was re-scheduled use the initial # start date that is recorded in task_reschedule table self . start_date = timezone . utcnow ( ) task_reschedules = TaskReschedule . find_for_task_instance ( self , session ) if task_reschedules : self . start_date = task_reschedules [ 0 ] . start_date dep_context = DepContext ( deps = RUN_DEPS - QUEUE_DEPS , ignore_all_deps = ignore_all_deps , ignore_depends_on_past = ignore_depends_on_past , ignore_task_deps = ignore_task_deps , ignore_ti_state = ignore_ti_state ) runnable = self . are_dependencies_met ( dep_context = dep_context , session = session , verbose = True ) if not runnable and not mark_success : # FIXME: we might have hit concurrency limits, which means we probably # have been running prematurely. This should be handled in the # scheduling mechanism. self . state = State . NONE self . log . warning ( hr ) self . log . warning ( \"FIXME: Rescheduling due to concurrency limits reached at task runtime. Attempt %s of \" \"%s. State set to NONE.\" , self . try_number , self . max_tries + 1 ) self . log . warning ( hr ) self . queued_dttm = timezone . utcnow ( ) self . log . info ( \"Queuing into pool %s\" , self . pool ) session . merge ( self ) session . commit ( ) return False # Another worker might have started running this task instance while # the current worker process was blocked on refresh_from_db if self . state == State . RUNNING : self . log . warning ( \"Task Instance already running %s\" , self ) session . commit ( ) return False # print status message self . log . info ( hr ) self . log . info ( \"Starting attempt %s of %s\" , self . try_number , self . max_tries + 1 ) self . log . info ( hr ) self . _try_number += 1 if not test_mode : session . add ( Log ( State . RUNNING , self ) ) self . state = State . RUNNING self . pid = os . getpid ( ) self . end_date = None if not test_mode : session . merge ( self ) session . commit ( ) # Closing all pooled connections to prevent # \"max number of connections reached\" settings . engine . dispose ( ) if verbose : if mark_success : self . log . info ( \"Marking success for %s on %s\" , self . task , self . execution_date ) else : self . log . info ( \"Executing %s on %s\" , self . task , self . execution_date ) return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _run_raw_task ( self , mark_success = False , test_mode = False , job_id = None , pool = None , session = None ) : task = self . task self . pool = pool or task . pool self . test_mode = test_mode self . refresh_from_db ( session = session ) self . job_id = job_id self . hostname = get_hostname ( ) self . operator = task . __class__ . __name__ context = { } actual_start_date = timezone . utcnow ( ) try : if not mark_success : context = self . get_template_context ( ) task_copy = copy . copy ( task ) self . task = task_copy def signal_handler ( signum , frame ) : self . log . error ( \"Received SIGTERM. Terminating subprocesses.\" ) task_copy . on_kill ( ) raise AirflowException ( \"Task received SIGTERM signal\" ) signal . signal ( signal . SIGTERM , signal_handler ) # Don't clear Xcom until the task is certain to execute self . clear_xcom_data ( ) start_time = time . time ( ) self . render_templates ( ) task_copy . pre_execute ( context = context ) # If a timeout is specified for the task, make it fail # if it goes beyond result = None if task_copy . execution_timeout : try : with timeout ( int ( task_copy . execution_timeout . total_seconds ( ) ) ) : result = task_copy . execute ( context = context ) except AirflowTaskTimeout : task_copy . on_kill ( ) raise else : result = task_copy . execute ( context = context ) # If the task returns a result, push an XCom containing it if task_copy . do_xcom_push and result is not None : self . xcom_push ( key = XCOM_RETURN_KEY , value = result ) task_copy . post_execute ( context = context , result = result ) end_time = time . time ( ) duration = end_time - start_time Stats . timing ( 'dag.{dag_id}.{task_id}.duration' . format ( dag_id = task_copy . dag_id , task_id = task_copy . task_id ) , duration ) Stats . incr ( 'operator_successes_{}' . format ( self . task . __class__ . __name__ ) , 1 , 1 ) Stats . incr ( 'ti_successes' ) self . refresh_from_db ( lock_for_update = True ) self . state = State . SUCCESS except AirflowSkipException : self . refresh_from_db ( lock_for_update = True ) self . state = State . SKIPPED except AirflowRescheduleException as reschedule_exception : self . refresh_from_db ( ) self . _handle_reschedule ( actual_start_date , reschedule_exception , test_mode , context ) return except AirflowException as e : self . refresh_from_db ( ) # for case when task is marked as success/failed externally # current behavior doesn't hit the success callback if self . state in { State . SUCCESS , State . FAILED } : return else : self . handle_failure ( e , test_mode , context ) raise except ( Exception , KeyboardInterrupt ) as e : self . handle_failure ( e , test_mode , context ) raise # Success callback try : if task . on_success_callback : task . on_success_callback ( context ) except Exception as e3 : self . log . error ( \"Failed when executing success callback\" ) self . log . exception ( e3 ) # Recording SUCCESS self . end_date = timezone . utcnow ( ) self . set_duration ( ) if not test_mode : session . add ( Log ( self . state , self ) ) session . merge ( self ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def xcom_push ( self , key , value , execution_date = None ) : if execution_date and execution_date < self . execution_date : raise ValueError ( 'execution_date can not be in the past (current ' 'execution_date is {}; received {})' . format ( self . execution_date , execution_date ) ) XCom . set ( key = key , value = value , task_id = self . task_id , dag_id = self . dag_id , execution_date = execution_date or self . execution_date )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def xcom_pull ( self , task_ids = None , dag_id = None , key = XCOM_RETURN_KEY , include_prior_dates = False ) : if dag_id is None : dag_id = self . dag_id pull_fn = functools . partial ( XCom . get_one , execution_date = self . execution_date , key = key , dag_id = dag_id , include_prior_dates = include_prior_dates ) if is_container ( task_ids ) : return tuple ( pull_fn ( task_id = t ) for t in task_ids ) else : return pull_fn ( task_id = task_ids )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def init_run_context ( self , raw = False ) : self . raw = raw self . _set_context ( self )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def close ( self ) : # When application exit, system shuts down all handlers by # calling close method. Here we check if logger is already # closed to prevent uploading the log to remote storage multiple # times when `logging.shutdown` is called. if self . closed : return super ( ) . close ( ) if not self . upload_on_close : return local_loc = os . path . join ( self . local_base , self . log_relative_path ) remote_loc = os . path . join ( self . remote_base , self . log_relative_path ) if os . path . exists ( local_loc ) : # read log and remove old logs to get just the latest additions with open ( local_loc , 'r' ) as logfile : log = logfile . read ( ) self . wasb_write ( log , remote_loc , append = True ) if self . delete_local_copy : shutil . rmtree ( os . path . dirname ( local_loc ) ) # Mark closed so we don't double write if close is called twice self . closed = True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _read ( self , ti , try_number , metadata = None ) : # Explicitly getting log relative path is necessary as the given # task instance might be different than task instance passed in # in set_context method. log_relative_path = self . _render_filename ( ti , try_number ) remote_loc = os . path . join ( self . remote_base , log_relative_path ) if self . wasb_log_exists ( remote_loc ) : # If Wasb remote file exists, we do not fetch logs from task instance # local machine even if there are errors reading remote logs, as # returned remote_log will contain error messages. remote_log = self . wasb_read ( remote_loc , return_error = True ) log = '*** Reading remote log from {}.\\n{}\\n' . format ( remote_loc , remote_log ) return log , { 'end_of_log' : True } else : return super ( ) . _read ( ti , try_number )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wasb_log_exists ( self , remote_log_location ) : try : return self . hook . check_for_blob ( self . wasb_container , remote_log_location ) except Exception : pass return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wasb_read ( self , remote_log_location , return_error = False ) : try : return self . hook . read_file ( self . wasb_container , remote_log_location ) except AzureHttpError : msg = 'Could not read logs from {}' . format ( remote_log_location ) self . log . exception ( msg ) # return error if needed if return_error : return msg\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wasb_write ( self , log , remote_log_location , append = True ) : if append and self . wasb_log_exists ( remote_log_location ) : old_log = self . wasb_read ( remote_log_location ) log = '\\n' . join ( [ old_log , log ] ) if old_log else log try : self . hook . load_string ( log , self . wasb_container , remote_log_location , ) except AzureHttpError : self . log . exception ( 'Could not write logs to %s' , remote_log_location )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . _conn : http_authorized = self . _authorize ( ) self . _conn = build ( 'compute' , self . api_version , http = http_authorized , cache_discovery = False ) return self . _conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def start_instance ( self , zone , resource_id , project_id = None ) : response = self . get_conn ( ) . instances ( ) . start ( project = project_id , zone = zone , instance = resource_id ) . execute ( num_retries = self . num_retries ) try : operation_name = response [ \"name\" ] except KeyError : raise AirflowException ( \"Wrong response '{}' returned - it should contain \" \"'name' field\" . format ( response ) ) self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name , zone = zone )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_machine_type ( self , zone , resource_id , body , project_id = None ) : response = self . _execute_set_machine_type ( zone , resource_id , body , project_id ) try : operation_name = response [ \"name\" ] except KeyError : raise AirflowException ( \"Wrong response '{}' returned - it should contain \" \"'name' field\" . format ( response ) ) self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name , zone = zone )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_instance_template ( self , resource_id , project_id = None ) : response = self . get_conn ( ) . instanceTemplates ( ) . get ( project = project_id , instanceTemplate = resource_id ) . execute ( num_retries = self . num_retries ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_instance_template ( self , body , request_id = None , project_id = None ) : response = self . get_conn ( ) . instanceTemplates ( ) . insert ( project = project_id , body = body , requestId = request_id ) . execute ( num_retries = self . num_retries ) try : operation_name = response [ \"name\" ] except KeyError : raise AirflowException ( \"Wrong response '{}' returned - it should contain \" \"'name' field\" . format ( response ) ) self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_instance_group_manager ( self , zone , resource_id , project_id = None ) : response = self . get_conn ( ) . instanceGroupManagers ( ) . get ( project = project_id , zone = zone , instanceGroupManager = resource_id ) . execute ( num_retries = self . num_retries ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def patch_instance_group_manager ( self , zone , resource_id , body , request_id = None , project_id = None ) : response = self . get_conn ( ) . instanceGroupManagers ( ) . patch ( project = project_id , zone = zone , instanceGroupManager = resource_id , body = body , requestId = request_id ) . execute ( num_retries = self . num_retries ) try : operation_name = response [ \"name\" ] except KeyError : raise AirflowException ( \"Wrong response '{}' returned - it should contain \" \"'name' field\" . format ( response ) ) self . _wait_for_operation_to_complete ( project_id = project_id , operation_name = operation_name , zone = zone )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _wait_for_operation_to_complete ( self , project_id , operation_name , zone = None ) : service = self . get_conn ( ) while True : if zone is None : # noinspection PyTypeChecker operation_response = self . _check_global_operation_status ( service , operation_name , project_id ) else : # noinspection PyTypeChecker operation_response = self . _check_zone_operation_status ( service , operation_name , project_id , zone , self . num_retries ) if operation_response . get ( \"status\" ) == GceOperationStatus . DONE : error = operation_response . get ( \"error\" ) if error : code = operation_response . get ( \"httpErrorStatusCode\" ) msg = operation_response . get ( \"httpErrorMessage\" ) # Extracting the errors list as string and trimming square braces error_msg = str ( error . get ( \"errors\" ) ) [ 1 : - 1 ] raise AirflowException ( \"{} {}: \" . format ( code , msg ) + error_msg ) # No meaningful info to return from the response in case of success return time . sleep ( TIME_TO_SLEEP_IN_SECONDS )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_bucket ( self , bucket_name ) : try : self . get_conn ( ) . head_bucket ( Bucket = bucket_name ) return True except ClientError as e : self . log . info ( e . response [ \"Error\" ] [ \"Message\" ] ) return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_bucket ( self , bucket_name , region_name = None ) : s3_conn = self . get_conn ( ) if not region_name : region_name = s3_conn . meta . region_name if region_name == 'us-east-1' : self . get_conn ( ) . create_bucket ( Bucket = bucket_name ) else : self . get_conn ( ) . create_bucket ( Bucket = bucket_name , CreateBucketConfiguration = { 'LocationConstraint' : region_name } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_prefix ( self , bucket_name , prefix , delimiter ) : prefix = prefix + delimiter if prefix [ - 1 ] != delimiter else prefix prefix_split = re . split ( r'(\\w+[{d}])$' . format ( d = delimiter ) , prefix , 1 ) previous_level = prefix_split [ 0 ] plist = self . list_prefixes ( bucket_name , previous_level , delimiter ) return False if plist is None else prefix in plist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_prefixes ( self , bucket_name , prefix = '' , delimiter = '' , page_size = None , max_items = None ) : config = { 'PageSize' : page_size , 'MaxItems' : max_items , } paginator = self . get_conn ( ) . get_paginator ( 'list_objects_v2' ) response = paginator . paginate ( Bucket = bucket_name , Prefix = prefix , Delimiter = delimiter , PaginationConfig = config ) has_results = False prefixes = [ ] for page in response : if 'CommonPrefixes' in page : has_results = True for p in page [ 'CommonPrefixes' ] : prefixes . append ( p [ 'Prefix' ] ) if has_results : return prefixes\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_keys ( self , bucket_name , prefix = '' , delimiter = '' , page_size = None , max_items = None ) : config = { 'PageSize' : page_size , 'MaxItems' : max_items , } paginator = self . get_conn ( ) . get_paginator ( 'list_objects_v2' ) response = paginator . paginate ( Bucket = bucket_name , Prefix = prefix , Delimiter = delimiter , PaginationConfig = config ) has_results = False keys = [ ] for page in response : if 'Contents' in page : has_results = True for k in page [ 'Contents' ] : keys . append ( k [ 'Key' ] ) if has_results : return keys\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_key ( self , key , bucket_name = None ) : if not bucket_name : ( bucket_name , key ) = self . parse_s3_url ( key ) try : self . get_conn ( ) . head_object ( Bucket = bucket_name , Key = key ) return True except ClientError as e : self . log . info ( e . response [ \"Error\" ] [ \"Message\" ] ) return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_key ( self , key , bucket_name = None ) : if not bucket_name : ( bucket_name , key ) = self . parse_s3_url ( key ) obj = self . get_resource_type ( 's3' ) . Object ( bucket_name , key ) obj . load ( ) return obj\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def select_key ( self , key , bucket_name = None , expression = 'SELECT * FROM S3Object' , expression_type = 'SQL' , input_serialization = None , output_serialization = None ) : if input_serialization is None : input_serialization = { 'CSV' : { } } if output_serialization is None : output_serialization = { 'CSV' : { } } if not bucket_name : ( bucket_name , key ) = self . parse_s3_url ( key ) response = self . get_conn ( ) . select_object_content ( Bucket = bucket_name , Key = key , Expression = expression , ExpressionType = expression_type , InputSerialization = input_serialization , OutputSerialization = output_serialization ) return '' . join ( event [ 'Records' ] [ 'Payload' ] . decode ( 'utf-8' ) for event in response [ 'Payload' ] if 'Records' in event )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_wildcard_key ( self , wildcard_key , bucket_name = None , delimiter = '' ) : return self . get_wildcard_key ( wildcard_key = wildcard_key , bucket_name = bucket_name , delimiter = delimiter ) is not None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_wildcard_key ( self , wildcard_key , bucket_name = None , delimiter = '' ) : if not bucket_name : ( bucket_name , wildcard_key ) = self . parse_s3_url ( wildcard_key ) prefix = re . split ( r'[*]' , wildcard_key , 1 ) [ 0 ] klist = self . list_keys ( bucket_name , prefix = prefix , delimiter = delimiter ) if klist : key_matches = [ k for k in klist if fnmatch . fnmatch ( k , wildcard_key ) ] if key_matches : return self . get_key ( key_matches [ 0 ] , bucket_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_file ( self , filename , key , bucket_name = None , replace = False , encrypt = False ) : if not bucket_name : ( bucket_name , key ) = self . parse_s3_url ( key ) if not replace and self . check_for_key ( key , bucket_name ) : raise ValueError ( \"The key {key} already exists.\" . format ( key = key ) ) extra_args = { } if encrypt : extra_args [ 'ServerSideEncryption' ] = \"AES256\" client = self . get_conn ( ) client . upload_file ( filename , bucket_name , key , ExtraArgs = extra_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_string ( self , string_data , key , bucket_name = None , replace = False , encrypt = False , encoding = 'utf-8' ) : self . load_bytes ( string_data . encode ( encoding ) , key = key , bucket_name = bucket_name , replace = replace , encrypt = encrypt )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_bytes ( self , bytes_data , key , bucket_name = None , replace = False , encrypt = False ) : if not bucket_name : ( bucket_name , key ) = self . parse_s3_url ( key ) if not replace and self . check_for_key ( key , bucket_name ) : raise ValueError ( \"The key {key} already exists.\" . format ( key = key ) ) extra_args = { } if encrypt : extra_args [ 'ServerSideEncryption' ] = \"AES256\" filelike_buffer = BytesIO ( bytes_data ) client = self . get_conn ( ) client . upload_fileobj ( filelike_buffer , bucket_name , key , ExtraArgs = extra_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_file_obj ( self , file_obj , key , bucket_name = None , replace = False , encrypt = False ) : if not bucket_name : ( bucket_name , key ) = self . parse_s3_url ( key ) if not replace and self . check_for_key ( key , bucket_name ) : raise ValueError ( \"The key {key} already exists.\" . format ( key = key ) ) extra_args = { } if encrypt : extra_args [ 'ServerSideEncryption' ] = \"AES256\" client = self . get_conn ( ) client . upload_fileobj ( file_obj , bucket_name , key , ExtraArgs = extra_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def copy_object ( self , source_bucket_key , dest_bucket_key , source_bucket_name = None , dest_bucket_name = None , source_version_id = None ) : if dest_bucket_name is None : dest_bucket_name , dest_bucket_key = self . parse_s3_url ( dest_bucket_key ) else : parsed_url = urlparse ( dest_bucket_key ) if parsed_url . scheme != '' or parsed_url . netloc != '' : raise AirflowException ( 'If dest_bucket_name is provided, ' + 'dest_bucket_key should be relative path ' + 'from root level, rather than a full s3:// url' ) if source_bucket_name is None : source_bucket_name , source_bucket_key = self . parse_s3_url ( source_bucket_key ) else : parsed_url = urlparse ( source_bucket_key ) if parsed_url . scheme != '' or parsed_url . netloc != '' : raise AirflowException ( 'If source_bucket_name is provided, ' + 'source_bucket_key should be relative path ' + 'from root level, rather than a full s3:// url' ) CopySource = { 'Bucket' : source_bucket_name , 'Key' : source_bucket_key , 'VersionId' : source_version_id } response = self . get_conn ( ) . copy_object ( Bucket = dest_bucket_name , Key = dest_bucket_key , CopySource = CopySource ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_objects ( self , bucket , keys ) : if isinstance ( keys , list ) : keys = keys else : keys = [ keys ] delete_dict = { \"Objects\" : [ { \"Key\" : k } for k in keys ] } response = self . get_conn ( ) . delete_objects ( Bucket = bucket , Delete = delete_dict ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _query_cassandra ( self ) : self . hook = CassandraHook ( cassandra_conn_id = self . cassandra_conn_id ) session = self . hook . get_conn ( ) cursor = session . execute ( self . cql ) return cursor\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _write_local_data_files ( self , cursor ) : file_no = 0 tmp_file_handle = NamedTemporaryFile ( delete = True ) tmp_file_handles = { self . filename . format ( file_no ) : tmp_file_handle } for row in cursor : row_dict = self . generate_data_dict ( row . _fields , row ) s = json . dumps ( row_dict ) . encode ( 'utf-8' ) tmp_file_handle . write ( s ) # Append newline to make dumps BigQuery compatible. tmp_file_handle . write ( b'\\n' ) if tmp_file_handle . tell ( ) >= self . approx_max_file_size_bytes : file_no += 1 tmp_file_handle = NamedTemporaryFile ( delete = True ) tmp_file_handles [ self . filename . format ( file_no ) ] = tmp_file_handle return tmp_file_handles\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _write_local_schema_file ( self , cursor ) : schema = [ ] tmp_schema_file_handle = NamedTemporaryFile ( delete = True ) for name , type in zip ( cursor . column_names , cursor . column_types ) : schema . append ( self . generate_schema_dict ( name , type ) ) json_serialized_schema = json . dumps ( schema ) . encode ( 'utf-8' ) tmp_schema_file_handle . write ( json_serialized_schema ) return { self . schema_filename : tmp_schema_file_handle }\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def convert_user_type ( cls , name , value ) : names = value . _fields values = [ cls . convert_value ( name , getattr ( value , name ) ) for name in names ] return cls . generate_data_dict ( names , values )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def convert_tuple_type ( cls , name , value ) : names = [ 'field_' + str ( i ) for i in range ( len ( value ) ) ] values = [ cls . convert_value ( name , value ) for name , value in zip ( names , value ) ] return cls . generate_data_dict ( names , values )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def convert_map_type ( cls , name , value ) : converted_map = [ ] for k , v in zip ( value . keys ( ) , value . values ( ) ) : converted_map . append ( { 'key' : cls . convert_value ( 'key' , k ) , 'value' : cls . convert_value ( 'value' , v ) } ) return converted_map\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def send_email ( to , subject , html_content , files = None , dryrun = False , cc = None , bcc = None , mime_subtype = 'mixed' , sandbox_mode = False , * * kwargs ) : if files is None : files = [ ] mail = Mail ( ) from_email = kwargs . get ( 'from_email' ) or os . environ . get ( 'SENDGRID_MAIL_FROM' ) from_name = kwargs . get ( 'from_name' ) or os . environ . get ( 'SENDGRID_MAIL_SENDER' ) mail . from_email = Email ( from_email , from_name ) mail . subject = subject mail . mail_settings = MailSettings ( ) if sandbox_mode : mail . mail_settings . sandbox_mode = SandBoxMode ( enable = True ) # Add the recipient list of to emails. personalization = Personalization ( ) to = get_email_address_list ( to ) for to_address in to : personalization . add_to ( Email ( to_address ) ) if cc : cc = get_email_address_list ( cc ) for cc_address in cc : personalization . add_cc ( Email ( cc_address ) ) if bcc : bcc = get_email_address_list ( bcc ) for bcc_address in bcc : personalization . add_bcc ( Email ( bcc_address ) ) # Add custom_args to personalization if present pers_custom_args = kwargs . get ( 'personalization_custom_args' , None ) if isinstance ( pers_custom_args , dict ) : for key in pers_custom_args . keys ( ) : personalization . add_custom_arg ( CustomArg ( key , pers_custom_args [ key ] ) ) mail . add_personalization ( personalization ) mail . add_content ( Content ( 'text/html' , html_content ) ) categories = kwargs . get ( 'categories' , [ ] ) for cat in categories : mail . add_category ( Category ( cat ) ) # Add email attachment. for fname in files : basename = os . path . basename ( fname ) attachment = Attachment ( ) attachment . type = mimetypes . guess_type ( basename ) [ 0 ] attachment . filename = basename attachment . disposition = \"attachment\" attachment . content_id = '<{0}>' . format ( basename ) with open ( fname , \"rb\" ) as f : attachment . content = base64 . b64encode ( f . read ( ) ) . decode ( 'utf-8' ) mail . add_attachment ( attachment ) _post_sendgrid_mail ( mail . get ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . _client : self . _client = SpeechClient ( credentials = self . _get_credentials ( ) ) return self . _client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def recognize_speech ( self , config , audio , retry = None , timeout = None ) : client = self . get_conn ( ) response = client . recognize ( config = config , audio = audio , retry = retry , timeout = timeout ) self . log . info ( \"Recognised speech: %s\" % response ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . _hook = SparkSqlHook ( sql = self . _sql , conf = self . _conf , conn_id = self . _conn_id , total_executor_cores = self . _total_executor_cores , executor_cores = self . _executor_cores , executor_memory = self . _executor_memory , keytab = self . _keytab , principal = self . _principal , name = self . _name , num_executors = self . _num_executors , master = self . _master , yarn_queue = self . _yarn_queue ) self . _hook . run_query ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_context ( self , ti ) : local_loc = self . _init_file ( ti ) self . handler = logging . FileHandler ( local_loc ) self . handler . setFormatter ( self . formatter ) self . handler . setLevel ( self . level )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _read ( self , ti , try_number , metadata = None ) : # Task instance here might be different from task instance when # initializing the handler. Thus explicitly getting log location # is needed to get correct log path. log_relative_path = self . _render_filename ( ti , try_number ) location = os . path . join ( self . local_base , log_relative_path ) log = \"\" if os . path . exists ( location ) : try : with open ( location ) as f : log += \"*** Reading local file: {}\\n\" . format ( location ) log += \"\" . join ( f . readlines ( ) ) except Exception as e : log = \"*** Failed to load local log file: {}\\n\" . format ( location ) log += \"*** {}\\n\" . format ( str ( e ) ) else : url = os . path . join ( \"http://{ti.hostname}:{worker_log_server_port}/log\" , log_relative_path ) . format ( ti = ti , worker_log_server_port = conf . get ( 'celery' , 'WORKER_LOG_SERVER_PORT' ) ) log += \"*** Log file does not exist: {}\\n\" . format ( location ) log += \"*** Fetching from: {}\\n\" . format ( url ) try : timeout = None # No timeout try : timeout = conf . getint ( 'webserver' , 'log_fetch_timeout_sec' ) except ( AirflowConfigException , ValueError ) : pass response = requests . get ( url , timeout = timeout ) # Check if the resource was properly fetched response . raise_for_status ( ) log += '\\n' + response . text except Exception as e : log += \"*** Failed to fetch log file from worker. {}\\n\" . format ( str ( e ) ) return log , { 'end_of_log' : True }\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def read ( self , task_instance , try_number = None , metadata = None ) : # Task instance increments its try number when it starts to run. # So the log for a particular task try will only show up when # try number gets incremented in DB, i.e logs produced the time # after cli run and before try_number + 1 in DB will not be displayed. if try_number is None : next_try = task_instance . next_try_number try_numbers = list ( range ( 1 , next_try ) ) elif try_number < 1 : logs = [ 'Error fetching the logs. Try number {} is invalid.' . format ( try_number ) , ] return logs else : try_numbers = [ try_number ] logs = [ '' ] * len ( try_numbers ) metadatas = [ { } ] * len ( try_numbers ) for i , try_number in enumerate ( try_numbers ) : log , metadata = self . _read ( task_instance , try_number , metadata ) logs [ i ] += log metadatas [ i ] = metadata return logs , metadatas\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _init_file ( self , ti ) : # To handle log writing when tasks are impersonated, the log files need to # be writable by the user that runs the Airflow command and the user # that is impersonated. This is mainly to handle corner cases with the # SubDagOperator. When the SubDagOperator is run, all of the operators # run under the impersonated user and create appropriate log files # as the impersonated user. However, if the user manually runs tasks # of the SubDagOperator through the UI, then the log files are created # by the user that runs the Airflow command. For example, the Airflow # run command may be run by the `airflow_sudoable` user, but the Airflow # tasks may be run by the `airflow` user. If the log files are not # writable by both users, then it's possible that re-running a task # via the UI (or vice versa) results in a permission error as the task # tries to write to a log file created by the other user. relative_path = self . _render_filename ( ti , ti . try_number ) full_path = os . path . join ( self . local_base , relative_path ) directory = os . path . dirname ( full_path ) # Create the log file and give it group writable permissions # TODO(aoen): Make log dirs and logs globally readable for now since the SubDag # operator is not compatible with impersonation (e.g. if a Celery executor is used # for a SubDag operator and the SubDag operator has a different owner than the # parent DAG) if not os . path . exists ( directory ) : # Create the directory as globally writable using custom mkdirs # as os.makedirs doesn't set mode properly. mkdirs ( directory , 0o777 ) if not os . path . exists ( full_path ) : open ( full_path , \"a\" ) . close ( ) # TODO: Investigate using 444 instead of 666. os . chmod ( full_path , 0o666 ) return full_path\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_entrypoint_plugins ( entry_points , airflow_plugins ) : for entry_point in entry_points : log . debug ( 'Importing entry_point plugin %s' , entry_point . name ) plugin_obj = entry_point . load ( ) if is_valid_plugin ( plugin_obj , airflow_plugins ) : if callable ( getattr ( plugin_obj , 'on_load' , None ) ) : plugin_obj . on_load ( ) airflow_plugins . append ( plugin_obj ) return airflow_plugins\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_valid_plugin ( plugin_obj , existing_plugins ) : if ( inspect . isclass ( plugin_obj ) and issubclass ( plugin_obj , AirflowPlugin ) and ( plugin_obj is not AirflowPlugin ) ) : plugin_obj . validate ( ) return plugin_obj not in existing_plugins return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def skip ( self , dag_run , execution_date , tasks , session = None ) : if not tasks : return task_ids = [ d . task_id for d in tasks ] now = timezone . utcnow ( ) if dag_run : session . query ( TaskInstance ) . filter ( TaskInstance . dag_id == dag_run . dag_id , TaskInstance . execution_date == dag_run . execution_date , TaskInstance . task_id . in_ ( task_ids ) ) . update ( { TaskInstance . state : State . SKIPPED , TaskInstance . start_date : now , TaskInstance . end_date : now } , synchronize_session = False ) session . commit ( ) else : assert execution_date is not None , \"Execution date is None and no dag run\" self . log . warning ( \"No DAG RUN present this should not happen\" ) # this is defensive against dag runs that are not complete for task in tasks : ti = TaskInstance ( task , execution_date = execution_date ) ti . state = State . SKIPPED ti . start_date = now ti . end_date = now session . merge ( ti ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . conn_id ) service_options = conn . extra_dejson self . account_name = service_options . get ( 'account_name' ) adlCreds = lib . auth ( tenant_id = service_options . get ( 'tenant' ) , client_secret = conn . password , client_id = conn . login ) adlsFileSystemClient = core . AzureDLFileSystem ( adlCreds , store_name = self . account_name ) adlsFileSystemClient . connect ( ) return adlsFileSystemClient\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_file ( self , file_path ) : try : files = self . connection . glob ( file_path , details = False , invalidate_cache = True ) return len ( files ) == 1 except FileNotFoundError : return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def upload_file ( self , local_path , remote_path , nthreads = 64 , overwrite = True , buffersize = 4194304 , blocksize = 4194304 ) : multithread . ADLUploader ( self . connection , lpath = local_path , rpath = remote_path , nthreads = nthreads , overwrite = overwrite , buffersize = buffersize , blocksize = blocksize )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download_file ( self , local_path , remote_path , nthreads = 64 , overwrite = True , buffersize = 4194304 , blocksize = 4194304 ) : multithread . ADLDownloader ( self . connection , lpath = local_path , rpath = remote_path , nthreads = nthreads , overwrite = overwrite , buffersize = buffersize , blocksize = blocksize )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list ( self , path ) : if \"*\" in path : return self . connection . glob ( path ) else : return self . connection . walk ( path )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . hook = self . get_hook ( ) self . hook . get_conn ( ) self . query_execution_context [ 'Database' ] = self . database self . result_configuration [ 'OutputLocation' ] = self . output_location self . query_execution_id = self . hook . run_query ( self . query , self . query_execution_context , self . result_configuration , self . client_request_token ) query_status = self . hook . poll_query_status ( self . query_execution_id , self . max_tries ) if query_status in AWSAthenaHook . FAILURE_STATES : raise Exception ( 'Final state of Athena job is {}, query_execution_id is {}.' . format ( query_status , self . query_execution_id ) ) elif not query_status or query_status in AWSAthenaHook . INTERMEDIATE_STATES : raise Exception ( 'Final state of Athena job is {}. ' 'Max tries of poll status exceeded, query_execution_id is {}.' . format ( query_status , self . query_execution_id ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def on_kill ( self ) : if self . query_execution_id : self . log . info ( '\u26b0\ufe0f\u26b0\ufe0f\u26b0\ufe0f Received a kill Signal. Time to Die') self . log . info ( 'Stopping Query with executionId - %s' , self . query_execution_id ) response = self . hook . stop_query ( self . query_execution_id ) http_status_code = None try : http_status_code = response [ 'ResponseMetadata' ] [ 'HTTPStatusCode' ] except Exception as ex : self . log . error ( 'Exception while cancelling query' , ex ) finally : if http_status_code is None or http_status_code != 200 : self . log . error ( 'Unable to request query cancel on athena. Exiting' ) else : self . log . info ( 'Polling Athena for query with id %s to reach final state' , self . query_execution_id ) self . hook . poll_query_status ( self . query_execution_id )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def uncompress_file ( input_file_name , file_extension , dest_dir ) : if file_extension . lower ( ) not in ( '.gz' , '.bz2' ) : raise NotImplementedError ( \"Received {} format. Only gz and bz2 \" \"files can currently be uncompressed.\" . format ( file_extension ) ) if file_extension . lower ( ) == '.gz' : fmodule = gzip . GzipFile elif file_extension . lower ( ) == '.bz2' : fmodule = bz2 . BZ2File with fmodule ( input_file_name , mode = 'rb' ) as f_compressed , NamedTemporaryFile ( dir = dest_dir , mode = 'wb' , delete = False ) as f_uncompressed : shutil . copyfileobj ( f_compressed , f_uncompressed ) return f_uncompressed . name\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _query_mssql ( self ) : mssql = MsSqlHook ( mssql_conn_id = self . mssql_conn_id ) conn = mssql . get_conn ( ) cursor = conn . cursor ( ) cursor . execute ( self . sql ) return cursor\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _write_local_data_files ( self , cursor ) : schema = list ( map ( lambda schema_tuple : schema_tuple [ 0 ] . replace ( ' ' , '_' ) , cursor . description ) ) file_no = 0 tmp_file_handle = NamedTemporaryFile ( delete = True ) tmp_file_handles = { self . filename . format ( file_no ) : tmp_file_handle } for row in cursor : # Convert if needed row = map ( self . convert_types , row ) row_dict = dict ( zip ( schema , row ) ) s = json . dumps ( row_dict , sort_keys = True ) s = s . encode ( 'utf-8' ) tmp_file_handle . write ( s ) # Append newline to make dumps BQ compatible tmp_file_handle . write ( b'\\n' ) # Stop if the file exceeds the file size limit if tmp_file_handle . tell ( ) >= self . approx_max_file_size_bytes : file_no += 1 tmp_file_handle = NamedTemporaryFile ( delete = True ) tmp_file_handles [ self . filename . format ( file_no ) ] = tmp_file_handle return tmp_file_handles\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _upload_to_gcs ( self , files_to_upload ) : hook = GoogleCloudStorageHook ( google_cloud_storage_conn_id = self . google_cloud_storage_conn_id , delegate_to = self . delegate_to ) for object_name , tmp_file_handle in files_to_upload . items ( ) : hook . upload ( self . bucket , object_name , tmp_file_handle . name , 'application/json' , ( self . gzip if object_name != self . schema_filename else False ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def convert_types ( cls , value ) : if isinstance ( value , decimal . Decimal ) : return float ( value ) else : return value\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def action_logging ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : \"\"\" An wrapper for cli functions. It assumes to have Namespace instance at 1st positional argument :param args: Positional argument. It assumes to have Namespace instance at 1st positional argument :param kwargs: A passthrough keyword argument \"\"\" assert args assert isinstance ( args [ 0 ] , Namespace ) , \"1st positional argument should be argparse.Namespace instance, \" \"but {}\" . format ( args [ 0 ] ) metrics = _build_metrics ( f . __name__ , args [ 0 ] ) cli_action_loggers . on_pre_execution ( * * metrics ) try : return f ( * args , * * kwargs ) except Exception as e : metrics [ 'error' ] = e raise finally : metrics [ 'end_datetime' ] = datetime . utcnow ( ) cli_action_loggers . on_post_execution ( * * metrics ) return wrapper\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_metrics ( func_name , namespace ) : metrics = { 'sub_command' : func_name , 'start_datetime' : datetime . utcnow ( ) , 'full_command' : '{}' . format ( list ( sys . argv ) ) , 'user' : getpass . getuser ( ) } assert isinstance ( namespace , Namespace ) tmp_dic = vars ( namespace ) metrics [ 'dag_id' ] = tmp_dic . get ( 'dag_id' ) metrics [ 'task_id' ] = tmp_dic . get ( 'task_id' ) metrics [ 'execution_date' ] = tmp_dic . get ( 'execution_date' ) metrics [ 'host_name' ] = socket . gethostname ( ) extra = json . dumps ( dict ( ( k , metrics [ k ] ) for k in ( 'host_name' , 'full_command' ) ) ) log = Log ( event = 'cli_{}' . format ( func_name ) , task_instance = None , owner = metrics [ 'user' ] , extra = extra , task_id = metrics . get ( 'task_id' ) , dag_id = metrics . get ( 'dag_id' ) , execution_date = metrics . get ( 'execution_date' ) ) metrics [ 'log' ] = log return metrics\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _evaluate_trigger_rule ( self , ti , successes , skipped , failed , upstream_failed , done , flag_upstream_failed , session ) : TR = airflow . utils . trigger_rule . TriggerRule task = ti . task upstream = len ( task . upstream_task_ids ) tr = task . trigger_rule upstream_done = done >= upstream upstream_tasks_state = { \"total\" : upstream , \"successes\" : successes , \"skipped\" : skipped , \"failed\" : failed , \"upstream_failed\" : upstream_failed , \"done\" : done } # TODO(aoen): Ideally each individual trigger rules would be its own class, but # this isn't very feasible at the moment since the database queries need to be # bundled together for efficiency. # handling instant state assignment based on trigger rules if flag_upstream_failed : if tr == TR . ALL_SUCCESS : if upstream_failed or failed : ti . set_state ( State . UPSTREAM_FAILED , session ) elif skipped : ti . set_state ( State . SKIPPED , session ) elif tr == TR . ALL_FAILED : if successes or skipped : ti . set_state ( State . SKIPPED , session ) elif tr == TR . ONE_SUCCESS : if upstream_done and not successes : ti . set_state ( State . SKIPPED , session ) elif tr == TR . ONE_FAILED : if upstream_done and not ( failed or upstream_failed ) : ti . set_state ( State . SKIPPED , session ) elif tr == TR . NONE_FAILED : if upstream_failed or failed : ti . set_state ( State . UPSTREAM_FAILED , session ) elif skipped == upstream : ti . set_state ( State . SKIPPED , session ) elif tr == TR . NONE_SKIPPED : if skipped : ti . set_state ( State . SKIPPED , session ) if tr == TR . ONE_SUCCESS : if successes <= 0 : yield self . _failing_status ( reason = \"Task's trigger rule '{0}' requires one upstream \" \"task success, but none were found. \" \"upstream_tasks_state={1}, upstream_task_ids={2}\" . format ( tr , upstream_tasks_state , task . upstream_task_ids ) ) elif tr == TR . ONE_FAILED : if not failed and not upstream_failed : yield self . _failing_status ( reason = \"Task's trigger rule '{0}' requires one upstream \" \"task failure, but none were found. \" \"upstream_tasks_state={1}, upstream_task_ids={2}\" . format ( tr , upstream_tasks_state , task . upstream_task_ids ) ) elif tr == TR . ALL_SUCCESS : num_failures = upstream - successes if num_failures > 0 : yield self . _failing_status ( reason = \"Task's trigger rule '{0}' requires all upstream \" \"tasks to have succeeded, but found {1} non-success(es). \" \"upstream_tasks_state={2}, upstream_task_ids={3}\" . format ( tr , num_failures , upstream_tasks_state , task . upstream_task_ids ) ) elif tr == TR . ALL_FAILED : num_successes = upstream - failed - upstream_failed if num_successes > 0 : yield self . _failing_status ( reason = \"Task's trigger rule '{0}' requires all upstream \" \"tasks to have failed, but found {1} non-failure(s). \" \"upstream_tasks_state={2}, upstream_task_ids={3}\" . format ( tr , num_successes , upstream_tasks_state , task . upstream_task_ids ) ) elif tr == TR . ALL_DONE : if not upstream_done : yield self . _failing_status ( reason = \"Task's trigger rule '{0}' requires all upstream \" \"tasks to have completed, but found {1} task(s) that \" \"weren't done. upstream_tasks_state={2}, \" \"upstream_task_ids={3}\" . format ( tr , upstream_done , upstream_tasks_state , task . upstream_task_ids ) ) elif tr == TR . NONE_FAILED : num_failures = upstream - successes - skipped if num_failures > 0 : yield self . _failing_status ( reason = \"Task's trigger rule '{0}' requires all upstream \" \"tasks to have succeeded or been skipped, but found {1} non-success(es). \" \"upstream_tasks_state={2}, upstream_task_ids={3}\" . format ( tr , num_failures , upstream_tasks_state , task . upstream_task_ids ) ) elif tr == TR . NONE_SKIPPED : if skipped > 0 : yield self . _failing_status ( reason = \"Task's trigger rule '{0}' requires all upstream \" \"tasks to not have been skipped, but found {1} task(s) skipped. \" \"upstream_tasks_state={2}, upstream_task_ids={3}\" . format ( tr , skipped , upstream_tasks_state , task . upstream_task_ids ) ) else : yield self . _failing_status ( reason = \"No strategy to evaluate trigger rule '{0}'.\" . format ( tr ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _create_cgroup ( self , path ) : node = trees . Tree ( ) . root path_split = path . split ( os . sep ) for path_element in path_split : name_to_node = { x . name : x for x in node . children } if path_element not in name_to_node : self . log . debug ( \"Creating cgroup %s in %s\" , path_element , node . path ) node = node . create_cgroup ( path_element ) else : self . log . debug ( \"Not creating cgroup %s in %s since it already exists\" , path_element , node . path ) node = name_to_node [ path_element ] return node\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _delete_cgroup ( self , path ) : node = trees . Tree ( ) . root path_split = path . split ( \"/\" ) for path_element in path_split : name_to_node = { x . name : x for x in node . children } if path_element not in name_to_node : self . log . warning ( \"Cgroup does not exist: %s\" , path ) return else : node = name_to_node [ path_element ] # node is now the leaf node parent = node . parent self . log . debug ( \"Deleting cgroup %s/%s\" , parent , node . name ) parent . delete_cgroup ( node . name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_cgroup_names ( ) : with open ( \"/proc/self/cgroup\" ) as f : lines = f . readlines ( ) d = { } for line in lines : line_split = line . rstrip ( ) . split ( \":\" ) subsystem = line_split [ 1 ] group_name = line_split [ 2 ] d [ subsystem ] = group_name return d\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _parse_host ( host ) : urlparse_host = urlparse . urlparse ( host ) . hostname if urlparse_host : # In this case, host = https://xx.cloud.databricks.com return urlparse_host else : # In this case, host = xx.cloud.databricks.com return host\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _do_api_call ( self , endpoint_info , json ) : method , endpoint = endpoint_info url = 'https://{host}/{endpoint}' . format ( host = self . _parse_host ( self . databricks_conn . host ) , endpoint = endpoint ) if 'token' in self . databricks_conn . extra_dejson : self . log . info ( 'Using token auth.' ) auth = _TokenAuth ( self . databricks_conn . extra_dejson [ 'token' ] ) else : self . log . info ( 'Using basic auth.' ) auth = ( self . databricks_conn . login , self . databricks_conn . password ) if method == 'GET' : request_func = requests . get elif method == 'POST' : request_func = requests . post else : raise AirflowException ( 'Unexpected HTTP Method: ' + method ) attempt_num = 1 while True : try : response = request_func ( url , json = json , auth = auth , headers = USER_AGENT_HEADER , timeout = self . timeout_seconds ) response . raise_for_status ( ) return response . json ( ) except requests_exceptions . RequestException as e : if not _retryable_error ( e ) : # In this case, the user probably made a mistake. # Don't retry. raise AirflowException ( 'Response: {0}, Status Code: {1}' . format ( e . response . content , e . response . status_code ) ) self . _log_request_error ( attempt_num , e ) if attempt_num == self . retry_limit : raise AirflowException ( ( 'API requests to Databricks failed {} times. ' + 'Giving up.' ) . format ( self . retry_limit ) ) attempt_num += 1 sleep ( self . retry_delay )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . conn : connection = self . get_connection ( self . conn_id ) extras = connection . extra_dejson self . conn = Salesforce ( username = connection . login , password = connection . password , security_token = extras [ 'security_token' ] , instance_url = connection . host , sandbox = extras . get ( 'sandbox' , False ) ) return self . conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_query ( self , query ) : conn = self . get_conn ( ) self . log . info ( \"Querying for all objects\" ) query_results = conn . query_all ( query ) self . log . info ( \"Received results: Total size: %s; Done: %s\" , query_results [ 'totalSize' ] , query_results [ 'done' ] ) return query_results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def describe_object ( self , obj ) : conn = self . get_conn ( ) return conn . __getattr__ ( obj ) . describe ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_available_fields ( self , obj ) : self . get_conn ( ) obj_description = self . describe_object ( obj ) return [ field [ 'name' ] for field in obj_description [ 'fields' ] ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_object_from_salesforce ( self , obj , fields ) : query = \"SELECT {} FROM {}\" . format ( \",\" . join ( fields ) , obj ) self . log . info ( \"Making query to Salesforce: %s\" , query if len ( query ) < 30 else \" ... \" . join ( [ query [ : 15 ] , query [ - 15 : ] ] ) ) return self . make_query ( query )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _to_timestamp ( cls , column ) : # try and convert the column to datetimes # the column MUST have a four digit year somewhere in the string # there should be a better way to do this, # but just letting pandas try and convert every column without a format # caused it to convert floats as well # For example, a column of integers # between 0 and 10 are turned into timestamps # if the column cannot be converted, # just return the original column untouched try : column = pd . to_datetime ( column ) except ValueError : log = LoggingMixin ( ) . log log . warning ( \"Could not convert field to timestamps: %s\" , column . name ) return column # now convert the newly created datetimes into timestamps # we have to be careful here # because NaT cannot be converted to a timestamp # so we have to return NaN converted = [ ] for value in column : try : converted . append ( value . timestamp ( ) ) except ( ValueError , AttributeError ) : converted . append ( pd . np . NaN ) return pd . Series ( converted , index = column . index )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def write_object_to_file ( self , query_results , filename , fmt = \"csv\" , coerce_to_timestamp = False , record_time_added = False ) : fmt = fmt . lower ( ) if fmt not in [ 'csv' , 'json' , 'ndjson' ] : raise ValueError ( \"Format value is not recognized: {}\" . format ( fmt ) ) # this line right here will convert all integers to floats # if there are any None/np.nan values in the column # that's because None/np.nan cannot exist in an integer column # we should write all of our timestamps as FLOATS in our final schema df = pd . DataFrame . from_records ( query_results , exclude = [ \"attributes\" ] ) df . columns = [ column . lower ( ) for column in df . columns ] # convert columns with datetime strings to datetimes # not all strings will be datetimes, so we ignore any errors that occur # we get the object's definition at this point and only consider # features that are DATE or DATETIME if coerce_to_timestamp and df . shape [ 0 ] > 0 : # get the object name out of the query results # it's stored in the \"attributes\" dictionary # for each returned record object_name = query_results [ 0 ] [ 'attributes' ] [ 'type' ] self . log . info ( \"Coercing timestamps for: %s\" , object_name ) schema = self . describe_object ( object_name ) # possible columns that can be converted to timestamps # are the ones that are either date or datetime types # strings are too general and we risk unintentional conversion possible_timestamp_cols = [ field [ 'name' ] . lower ( ) for field in schema [ 'fields' ] if field [ 'type' ] in [ \"date\" , \"datetime\" ] and field [ 'name' ] . lower ( ) in df . columns ] df [ possible_timestamp_cols ] = df [ possible_timestamp_cols ] . apply ( self . _to_timestamp ) if record_time_added : fetched_time = time . time ( ) df [ \"time_fetched_from_salesforce\" ] = fetched_time # write the CSV or JSON file depending on the option # NOTE: # datetimes here are an issue. # There is no good way to manage the difference # for to_json, the options are an epoch or a ISO string # but for to_csv, it will be a string output by datetime # For JSON we decided to output the epoch timestamp in seconds # (as is fairly standard for JavaScript) # And for csv, we do a string if fmt == \"csv\" : # there are also a ton of newline objects that mess up our ability to write to csv # we remove these newlines so that the output is a valid CSV format self . log . info ( \"Cleaning data and writing to CSV\" ) possible_strings = df . columns [ df . dtypes == \"object\" ] df [ possible_strings ] = df [ possible_strings ] . apply ( lambda x : x . str . replace ( \"\\r\\n\" , \"\" ) . str . replace ( \"\\n\" , \"\" ) ) # write the dataframe df . to_csv ( filename , index = False ) elif fmt == \"json\" : df . to_json ( filename , \"records\" , date_unit = \"s\" ) elif fmt == \"ndjson\" : df . to_json ( filename , \"records\" , lines = True , date_unit = \"s\" ) return df\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _read ( self , ti , try_number , metadata = None ) : # Explicitly getting log relative path is necessary as the given # task instance might be different than task instance passed in # in set_context method. log_relative_path = self . _render_filename ( ti , try_number ) remote_loc = os . path . join ( self . remote_base , log_relative_path ) try : remote_log = self . gcs_read ( remote_loc ) log = '*** Reading remote log from {}.\\n{}\\n' . format ( remote_loc , remote_log ) return log , { 'end_of_log' : True } except Exception as e : log = '*** Unable to read remote log from {}\\n*** {}\\n\\n' . format ( remote_loc , str ( e ) ) self . log . error ( log ) local_log , metadata = super ( ) . _read ( ti , try_number ) log += local_log return log , metadata\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def gcs_read ( self , remote_log_location ) : bkt , blob = self . parse_gcs_url ( remote_log_location ) return self . hook . download ( bkt , blob ) . decode ( 'utf-8' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def gcs_write ( self , log , remote_log_location , append = True ) : if append : try : old_log = self . gcs_read ( remote_log_location ) log = '\\n' . join ( [ old_log , log ] ) if old_log else log except Exception as e : if not hasattr ( e , 'resp' ) or e . resp . get ( 'status' ) != '404' : log = '*** Previous log discarded: {}\\n\\n' . format ( str ( e ) ) + log try : bkt , blob = self . parse_gcs_url ( remote_log_location ) from tempfile import NamedTemporaryFile with NamedTemporaryFile ( mode = 'w+' ) as tmpfile : tmpfile . write ( log ) # Force the file to be flushed, since we're doing the # upload from within the file context (it hasn't been # closed). tmpfile . flush ( ) self . hook . upload ( bkt , blob , tmpfile . name ) except Exception as e : self . log . error ( 'Could not write logs to %s: %s' , remote_log_location , e )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def parse_gcs_url ( gsurl ) : parsed_url = urlparse ( gsurl ) if not parsed_url . netloc : raise AirflowException ( 'Please provide a bucket name' ) else : bucket = parsed_url . netloc blob = parsed_url . path . strip ( '/' ) return bucket , blob\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if self . client is not None : return self . client # Mongo Connection Options dict that is unpacked when passed to MongoClient options = self . extras # If we are using SSL disable requiring certs from specific hostname if options . get ( 'ssl' , False ) : options . update ( { 'ssl_cert_reqs' : CERT_NONE } ) self . client = MongoClient ( self . uri , * * options ) return self . client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_collection ( self , mongo_collection , mongo_db = None ) : mongo_db = mongo_db if mongo_db is not None else self . connection . schema mongo_conn = self . get_conn ( ) return mongo_conn . get_database ( mongo_db ) . get_collection ( mongo_collection )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def aggregate ( self , mongo_collection , aggregate_query , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) return collection . aggregate ( aggregate_query , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def find ( self , mongo_collection , query , find_one = False , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) if find_one : return collection . find_one ( query , * * kwargs ) else : return collection . find ( query , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_one ( self , mongo_collection , doc , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) return collection . insert_one ( doc , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_many ( self , mongo_collection , docs , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) return collection . insert_many ( docs , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_one ( self , mongo_collection , filter_doc , update_doc , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) return collection . update_one ( filter_doc , update_doc , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def replace_one ( self , mongo_collection , doc , filter_doc = None , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) if not filter_doc : filter_doc = { '_id' : doc [ '_id' ] } return collection . replace_one ( filter_doc , doc , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def replace_many ( self , mongo_collection , docs , filter_docs = None , mongo_db = None , upsert = False , collation = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) if not filter_docs : filter_docs = [ { '_id' : doc [ '_id' ] } for doc in docs ] requests = [ ReplaceOne ( filter_docs [ i ] , docs [ i ] , upsert = upsert , collation = collation ) for i in range ( len ( docs ) ) ] return collection . bulk_write ( requests , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_one ( self , mongo_collection , filter_doc , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) return collection . delete_one ( filter_doc , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_many ( self , mongo_collection , filter_doc , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) return collection . delete_many ( filter_doc , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def has_mail_attachment ( self , name , mail_folder = 'INBOX' , check_regex = False ) : mail_attachments = self . _retrieve_mails_attachments_by_name ( name , mail_folder , check_regex , latest_only = True ) return len ( mail_attachments ) > 0\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def retrieve_mail_attachments ( self , name , mail_folder = 'INBOX' , check_regex = False , latest_only = False , not_found_mode = 'raise' ) : mail_attachments = self . _retrieve_mails_attachments_by_name ( name , mail_folder , check_regex , latest_only ) if not mail_attachments : self . _handle_not_found_mode ( not_found_mode ) return mail_attachments\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download_mail_attachments ( self , name , local_output_directory , mail_folder = 'INBOX' , check_regex = False , latest_only = False , not_found_mode = 'raise' ) : mail_attachments = self . _retrieve_mails_attachments_by_name ( name , mail_folder , check_regex , latest_only ) if not mail_attachments : self . _handle_not_found_mode ( not_found_mode ) self . _create_files ( mail_attachments , local_output_directory )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_attachments_by_name ( self , name , check_regex , find_first = False ) : attachments = [ ] for part in self . mail . walk ( ) : mail_part = MailPart ( part ) if mail_part . is_attachment ( ) : found_attachment = mail_part . has_matching_name ( name ) if check_regex else mail_part . has_equal_name ( name ) if found_attachment : file_name , file_payload = mail_part . get_file ( ) self . log . info ( 'Found attachment: {}' . format ( file_name ) ) attachments . append ( ( file_name , file_payload ) ) if find_first : break return attachments\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_file ( self ) : return self . part . get_filename ( ) , self . part . get_payload ( decode = True )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def put_records ( self , records ) : firehose_conn = self . get_conn ( ) response = firehose_conn . put_record_batch ( DeliveryStreamName = self . delivery_stream , Records = records ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_dep_statuses ( self , ti , session , dep_context ) : if dep_context . ignore_in_reschedule_period : yield self . _passing_status ( reason = \"The context specified that being in a reschedule period was \" \"permitted.\" ) return if ti . state not in self . RESCHEDULEABLE_STATES : yield self . _passing_status ( reason = \"The task instance is not in State_UP_FOR_RESCHEDULE or NONE state.\" ) return task_reschedules = TaskReschedule . find_for_task_instance ( task_instance = ti ) if not task_reschedules : yield self . _passing_status ( reason = \"There is no reschedule request for this task instance.\" ) return now = timezone . utcnow ( ) next_reschedule_date = task_reschedules [ - 1 ] . reschedule_date if now >= next_reschedule_date : yield self . _passing_status ( reason = \"Task instance id ready for reschedule.\" ) return yield self . _failing_status ( reason = \"Task is not ready for reschedule yet but will be rescheduled \" \"automatically. Current date is {0} and task will be rescheduled \" \"at {1}.\" . format ( now . isoformat ( ) , next_reschedule_date . isoformat ( ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def send_email ( to , subject , html_content , files = None , dryrun = False , cc = None , bcc = None , mime_subtype = 'mixed' , mime_charset = 'utf-8' , * * kwargs ) : path , attr = configuration . conf . get ( 'email' , 'EMAIL_BACKEND' ) . rsplit ( '.' , 1 ) module = importlib . import_module ( path ) backend = getattr ( module , attr ) to = get_email_address_list ( to ) to = \", \" . join ( to ) return backend ( to , subject , html_content , files = files , dryrun = dryrun , cc = cc , bcc = bcc , mime_subtype = mime_subtype , mime_charset = mime_charset , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def send_email_smtp ( to , subject , html_content , files = None , dryrun = False , cc = None , bcc = None , mime_subtype = 'mixed' , mime_charset = 'utf-8' , * * kwargs ) : smtp_mail_from = configuration . conf . get ( 'smtp' , 'SMTP_MAIL_FROM' ) to = get_email_address_list ( to ) msg = MIMEMultipart ( mime_subtype ) msg [ 'Subject' ] = subject msg [ 'From' ] = smtp_mail_from msg [ 'To' ] = \", \" . join ( to ) recipients = to if cc : cc = get_email_address_list ( cc ) msg [ 'CC' ] = \", \" . join ( cc ) recipients = recipients + cc if bcc : # don't add bcc in header bcc = get_email_address_list ( bcc ) recipients = recipients + bcc msg [ 'Date' ] = formatdate ( localtime = True ) mime_text = MIMEText ( html_content , 'html' , mime_charset ) msg . attach ( mime_text ) for fname in files or [ ] : basename = os . path . basename ( fname ) with open ( fname , \"rb\" ) as f : part = MIMEApplication ( f . read ( ) , Name = basename ) part [ 'Content-Disposition' ] = 'attachment; filename=\"%s\"' % basename part [ 'Content-ID' ] = '<%s>' % basename msg . attach ( part ) send_MIME_email ( smtp_mail_from , recipients , msg , dryrun )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def process_result_value ( self , value , dialect ) : if value is not None : if value . tzinfo is None : value = value . replace ( tzinfo = utc ) else : value = value . astimezone ( utc ) return value\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_blob ( self , container_name , blob_name , * * kwargs ) : return self . connection . exists ( container_name , blob_name , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_prefix ( self , container_name , prefix , * * kwargs ) : matches = self . connection . list_blobs ( container_name , prefix , num_results = 1 , * * kwargs ) return len ( list ( matches ) ) > 0\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_file ( self , file_path , container_name , blob_name , * * kwargs ) : # Reorder the argument order from airflow.hooks.S3_hook.load_file. self . connection . create_blob_from_path ( container_name , blob_name , file_path , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_string ( self , string_data , container_name , blob_name , * * kwargs ) : # Reorder the argument order from airflow.hooks.S3_hook.load_string. self . connection . create_blob_from_text ( container_name , blob_name , string_data , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_file ( self , file_path , container_name , blob_name , * * kwargs ) : return self . connection . get_blob_to_path ( container_name , blob_name , file_path , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def read_file ( self , container_name , blob_name , * * kwargs ) : return self . connection . get_blob_to_text ( container_name , blob_name , * * kwargs ) . content\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_file ( self , container_name , blob_name , is_prefix = False , ignore_if_missing = False , * * kwargs ) : if is_prefix : blobs_to_delete = [ blob . name for blob in self . connection . list_blobs ( container_name , prefix = blob_name , * * kwargs ) ] elif self . check_for_blob ( container_name , blob_name ) : blobs_to_delete = [ blob_name ] else : blobs_to_delete = [ ] if not ignore_if_missing and len ( blobs_to_delete ) == 0 : raise AirflowException ( 'Blob(s) not found: {}' . format ( blob_name ) ) for blob_uri in blobs_to_delete : self . log . info ( \"Deleting blob: \" + blob_uri ) self . connection . delete_blob ( container_name , blob_uri , delete_snapshots = 'include' , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def mlsd ( conn , path = \"\" , facts = None ) : facts = facts or [ ] if facts : conn . sendcmd ( \"OPTS MLST \" + \";\" . join ( facts ) + \";\" ) if path : cmd = \"MLSD %s\" % path else : cmd = \"MLSD\" lines = [ ] conn . retrlines ( cmd , lines . append ) for line in lines : facts_found , _ , name = line . rstrip ( ftplib . CRLF ) . partition ( ' ' ) entry = { } for fact in facts_found [ : - 1 ] . split ( \";\" ) : key , _ , value = fact . partition ( \"=\" ) entry [ key . lower ( ) ] = value yield ( name , entry )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if self . conn is None : params = self . get_connection ( self . ftp_conn_id ) pasv = params . extra_dejson . get ( \"passive\" , True ) self . conn = ftplib . FTP ( params . host , params . login , params . password ) self . conn . set_pasv ( pasv ) return self . conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def describe_directory ( self , path ) : conn = self . get_conn ( ) conn . cwd ( path ) try : # only works in Python 3 files = dict ( conn . mlsd ( ) ) except AttributeError : files = dict ( mlsd ( conn ) ) return files\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_directory ( self , path , nlst = False ) : conn = self . get_conn ( ) conn . cwd ( path ) files = conn . nlst ( ) return files\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def retrieve_file ( self , remote_full_path , local_full_path_or_buffer , callback = None ) : conn = self . get_conn ( ) is_path = isinstance ( local_full_path_or_buffer , basestring ) # without a callback, default to writing to a user-provided file or # file-like buffer if not callback : if is_path : output_handle = open ( local_full_path_or_buffer , 'wb' ) else : output_handle = local_full_path_or_buffer callback = output_handle . write else : output_handle = None remote_path , remote_file_name = os . path . split ( remote_full_path ) conn . cwd ( remote_path ) self . log . info ( 'Retrieving file from FTP: %s' , remote_full_path ) conn . retrbinary ( 'RETR %s' % remote_file_name , callback ) self . log . info ( 'Finished retrieving file from FTP: %s' , remote_full_path ) if is_path and output_handle : output_handle . close ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def store_file ( self , remote_full_path , local_full_path_or_buffer ) : conn = self . get_conn ( ) is_path = isinstance ( local_full_path_or_buffer , basestring ) if is_path : input_handle = open ( local_full_path_or_buffer , 'rb' ) else : input_handle = local_full_path_or_buffer remote_path , remote_file_name = os . path . split ( remote_full_path ) conn . cwd ( remote_path ) conn . storbinary ( 'STOR %s' % remote_file_name , input_handle ) if is_path : input_handle . close ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def rename ( self , from_name , to_name ) : conn = self . get_conn ( ) return conn . rename ( from_name , to_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_mod_time ( self , path ) : conn = self . get_conn ( ) ftp_mdtm = conn . sendcmd ( 'MDTM ' + path ) time_val = ftp_mdtm [ 4 : ] # time_val optionally has microseconds try : return datetime . datetime . strptime ( time_val , \"%Y%m%d%H%M%S.%f\" ) except ValueError : return datetime . datetime . strptime ( time_val , '%Y%m%d%H%M%S' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _create_dagruns ( dag , execution_dates , state , run_id_template ) : # find out if we need to create any dag runs drs = DagRun . find ( dag_id = dag . dag_id , execution_date = execution_dates ) dates_to_create = list ( set ( execution_dates ) - set ( [ dr . execution_date for dr in drs ] ) ) for date in dates_to_create : dr = dag . create_dagrun ( run_id = run_id_template . format ( date . isoformat ( ) ) , execution_date = date , start_date = timezone . utcnow ( ) , external_trigger = False , state = state , ) drs . append ( dr ) return drs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_state ( task , execution_date , upstream = False , downstream = False , future = False , past = False , state = State . SUCCESS , commit = False , session = None ) : assert timezone . is_localized ( execution_date ) assert task . dag is not None dag = task . dag latest_execution_date = dag . latest_execution_date assert latest_execution_date is not None # determine date range of dag runs and tasks to consider end_date = latest_execution_date if future else execution_date if 'start_date' in dag . default_args : start_date = dag . default_args [ 'start_date' ] elif dag . start_date : start_date = dag . start_date else : start_date = execution_date start_date = execution_date if not past else start_date if dag . schedule_interval == '@once' : dates = [ start_date ] else : dates = dag . date_range ( start_date = start_date , end_date = end_date ) # find relatives (siblings = downstream, parents = upstream) if needed task_ids = [ task . task_id ] if downstream : relatives = task . get_flat_relatives ( upstream = False ) task_ids += [ t . task_id for t in relatives ] if upstream : relatives = task . get_flat_relatives ( upstream = True ) task_ids += [ t . task_id for t in relatives ] # verify the integrity of the dag runs in case a task was added or removed # set the confirmed execution dates as they might be different # from what was provided confirmed_dates = [ ] drs = DagRun . find ( dag_id = dag . dag_id , execution_date = dates ) for dr in drs : dr . dag = dag dr . verify_integrity ( ) confirmed_dates . append ( dr . execution_date ) # go through subdagoperators and create dag runs. We will only work # within the scope of the subdag. We wont propagate to the parent dag, # but we will propagate from parent to subdag. dags = [ dag ] sub_dag_ids = [ ] while len ( dags ) > 0 : current_dag = dags . pop ( ) for task_id in task_ids : if not current_dag . has_task ( task_id ) : continue current_task = current_dag . get_task ( task_id ) if isinstance ( current_task , SubDagOperator ) : # this works as a kind of integrity check # it creates missing dag runs for subdagoperators, # maybe this should be moved to dagrun.verify_integrity drs = _create_dagruns ( current_task . subdag , execution_dates = confirmed_dates , state = State . RUNNING , run_id_template = BackfillJob . ID_FORMAT_PREFIX ) for dr in drs : dr . dag = current_task . subdag dr . verify_integrity ( ) if commit : dr . state = state session . merge ( dr ) dags . append ( current_task . subdag ) sub_dag_ids . append ( current_task . subdag . dag_id ) # now look for the task instances that are affected TI = TaskInstance # get all tasks of the main dag that will be affected by a state change qry_dag = session . query ( TI ) . filter ( TI . dag_id == dag . dag_id , TI . execution_date . in_ ( confirmed_dates ) , TI . task_id . in_ ( task_ids ) ) . filter ( or_ ( TI . state . is_ ( None ) , TI . state != state ) ) # get *all* tasks of the sub dags if len ( sub_dag_ids ) > 0 : qry_sub_dag = session . query ( TI ) . filter ( TI . dag_id . in_ ( sub_dag_ids ) , TI . execution_date . in_ ( confirmed_dates ) ) . filter ( or_ ( TI . state . is_ ( None ) , TI . state != state ) ) if commit : tis_altered = qry_dag . with_for_update ( ) . all ( ) if len ( sub_dag_ids ) > 0 : tis_altered += qry_sub_dag . with_for_update ( ) . all ( ) for ti in tis_altered : ti . state = state else : tis_altered = qry_dag . all ( ) if len ( sub_dag_ids ) > 0 : tis_altered += qry_sub_dag . all ( ) return tis_altered\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _set_dag_run_state ( dag_id , execution_date , state , session = None ) : DR = DagRun dr = session . query ( DR ) . filter ( DR . dag_id == dag_id , DR . execution_date == execution_date ) . one ( ) dr . state = state if state == State . RUNNING : dr . start_date = timezone . utcnow ( ) dr . end_date = None else : dr . end_date = timezone . utcnow ( ) session . merge ( dr )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_dag_run_state_to_success ( dag , execution_date , commit = False , session = None ) : res = [ ] if not dag or not execution_date : return res # Mark the dag run to success. if commit : _set_dag_run_state ( dag . dag_id , execution_date , State . SUCCESS , session ) # Mark all task instances of the dag run to success. for task in dag . tasks : task . dag = dag new_state = set_state ( task = task , execution_date = execution_date , state = State . SUCCESS , commit = commit ) res . extend ( new_state ) return res\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_dag_run_state_to_failed ( dag , execution_date , commit = False , session = None ) : res = [ ] if not dag or not execution_date : return res # Mark the dag run to failed. if commit : _set_dag_run_state ( dag . dag_id , execution_date , State . FAILED , session ) # Mark only RUNNING task instances. TI = TaskInstance task_ids = [ task . task_id for task in dag . tasks ] tis = session . query ( TI ) . filter ( TI . dag_id == dag . dag_id , TI . execution_date == execution_date , TI . task_id . in_ ( task_ids ) ) . filter ( TI . state == State . RUNNING ) task_ids_of_running_tis = [ ti . task_id for ti in tis ] for task in dag . tasks : if task . task_id not in task_ids_of_running_tis : continue task . dag = dag new_state = set_state ( task = task , execution_date = execution_date , state = State . FAILED , commit = commit ) res . extend ( new_state ) return res\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_dag_run_state_to_running ( dag , execution_date , commit = False , session = None ) : res = [ ] if not dag or not execution_date : return res # Mark the dag run to running. if commit : _set_dag_run_state ( dag . dag_id , execution_date , State . RUNNING , session ) # To keep the return type consistent with the other similar functions. return res\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def git_version ( version ) : repo = None try : import git repo = git . Repo ( '.git' ) except ImportError : logger . warning ( 'gitpython not found: Cannot compute the git version.' ) return '' except Exception as e : logger . warning ( 'Cannot compute the git version. {}' . format ( e ) ) return '' if repo : sha = repo . head . commit . hexsha if repo . is_dirty ( ) : return '.dev0+{sha}.dirty' . format ( sha = sha ) # commit is clean return '.release:{version}+{sha}' . format ( version = version , sha = sha ) else : return 'no_git_version'\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . hook = DiscordWebhookHook ( self . http_conn_id , self . webhook_endpoint , self . message , self . username , self . avatar_url , self . tts , self . proxy ) self . hook . execute ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _validate_field ( self , validation_spec , dictionary_to_validate , parent = None , force_optional = False ) : field_name = validation_spec [ 'name' ] field_type = validation_spec . get ( 'type' ) optional = validation_spec . get ( 'optional' ) regexp = validation_spec . get ( 'regexp' ) allow_empty = validation_spec . get ( 'allow_empty' ) children_validation_specs = validation_spec . get ( 'fields' ) required_api_version = validation_spec . get ( 'api_version' ) custom_validation = validation_spec . get ( 'custom_validation' ) full_field_path = self . _get_field_name_with_parent ( field_name = field_name , parent = parent ) if required_api_version and required_api_version != self . _api_version : self . log . debug ( \"Skipping validation of the field '%s' for API version '%s' \" \"as it is only valid for API version '%s'\" , field_name , self . _api_version , required_api_version ) return False value = dictionary_to_validate . get ( field_name ) if ( optional or force_optional ) and value is None : self . log . debug ( \"The optional field '%s' is missing. That's perfectly OK.\" , full_field_path ) return False # Certainly down from here the field is present (value is not None) # so we should only return True from now on self . _sanity_checks ( children_validation_specs = children_validation_specs , field_type = field_type , full_field_path = full_field_path , regexp = regexp , allow_empty = allow_empty , custom_validation = custom_validation , value = value ) if allow_empty is False : self . _validate_is_empty ( full_field_path , value ) if regexp : self . _validate_regexp ( full_field_path , regexp , value ) elif field_type == 'dict' : if not isinstance ( value , dict ) : raise GcpFieldValidationException ( \"The field '{}' should be of dictionary type according to the \" \"specification '{}' but it is '{}'\" . format ( full_field_path , validation_spec , value ) ) if children_validation_specs is None : self . log . debug ( \"The dict field '%s' has no nested fields defined in the \" \"specification '%s'. That's perfectly ok - it's content will \" \"not be validated.\" , full_field_path , validation_spec ) else : self . _validate_dict ( children_validation_specs , full_field_path , value ) elif field_type == 'union' : if not children_validation_specs : raise GcpValidationSpecificationException ( \"The union field '%s' has no nested fields \" \"defined in specification '%s'. Unions should have at least one \" \"nested field defined.\" , full_field_path , validation_spec ) self . _validate_union ( children_validation_specs , full_field_path , dictionary_to_validate ) elif field_type == 'list' : if not isinstance ( value , list ) : raise GcpFieldValidationException ( \"The field '{}' should be of list type according to the \" \"specification '{}' but it is '{}'\" . format ( full_field_path , validation_spec , value ) ) elif custom_validation : try : custom_validation ( value ) except Exception as e : raise GcpFieldValidationException ( \"Error while validating custom field '{}' specified by '{}': '{}'\" . format ( full_field_path , validation_spec , e ) ) elif field_type is None : self . log . debug ( \"The type of field '%s' is not specified in '%s'. \" \"Not validating its content.\" , full_field_path , validation_spec ) else : raise GcpValidationSpecificationException ( \"The field '{}' is of type '{}' in specification '{}'.\" \"This type is unknown to validation!\" . format ( full_field_path , field_type , validation_spec ) ) return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def validate ( self , body_to_validate ) : try : for validation_spec in self . _validation_specs : self . _validate_field ( validation_spec = validation_spec , dictionary_to_validate = body_to_validate ) except GcpFieldValidationException as e : raise GcpFieldValidationException ( \"There was an error when validating: body '{}': '{}'\" . format ( body_to_validate , e ) ) all_field_names = [ spec [ 'name' ] for spec in self . _validation_specs if spec . get ( 'type' ) != 'union' and spec . get ( 'api_version' ) != self . _api_version ] all_union_fields = [ spec for spec in self . _validation_specs if spec . get ( 'type' ) == 'union' ] for union_field in all_union_fields : all_field_names . extend ( [ nested_union_spec [ 'name' ] for nested_union_spec in union_field [ 'fields' ] if nested_union_spec . get ( 'type' ) != 'union' and nested_union_spec . get ( 'api_version' ) != self . _api_version ] ) for field_name in body_to_validate . keys ( ) : if field_name not in all_field_names : self . log . warning ( \"The field '%s' is in the body, but is not specified in the \" \"validation specification '%s'. \" \"This might be because you are using newer API version and \" \"new field names defined for that version. Then the warning \" \"can be safely ignored, or you might want to upgrade the operator\" \"to the version that supports the new API version.\" , field_name , self . _validation_specs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . conn_id ) service_options = conn . extra_dejson return FileService ( account_name = conn . login , account_key = conn . password , * * service_options )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_directory ( self , share_name , directory_name , * * kwargs ) : return self . connection . exists ( share_name , directory_name , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_file ( self , share_name , directory_name , file_name , * * kwargs ) : return self . connection . exists ( share_name , directory_name , file_name , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_directories_and_files ( self , share_name , directory_name = None , * * kwargs ) : return self . connection . list_directories_and_files ( share_name , directory_name , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_directory ( self , share_name , directory_name , * * kwargs ) : return self . connection . create_directory ( share_name , directory_name , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_file ( self , file_path , share_name , directory_name , file_name , * * kwargs ) : self . connection . get_file_to_path ( share_name , directory_name , file_name , file_path , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_file_to_stream ( self , stream , share_name , directory_name , file_name , * * kwargs ) : self . connection . get_file_to_stream ( share_name , directory_name , file_name , stream , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_file ( self , file_path , share_name , directory_name , file_name , * * kwargs ) : self . connection . create_file_from_path ( share_name , directory_name , file_name , file_path , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_string ( self , string_data , share_name , directory_name , file_name , * * kwargs ) : self . connection . create_file_from_text ( share_name , directory_name , file_name , string_data , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_stream ( self , stream , share_name , directory_name , file_name , count , * * kwargs ) : self . connection . create_file_from_stream ( share_name , directory_name , file_name , stream , count , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_context ( self , filename ) : local_loc = self . _init_file ( filename ) self . handler = logging . FileHandler ( local_loc ) self . handler . setFormatter ( self . formatter ) self . handler . setLevel ( self . level ) if self . _cur_date < datetime . today ( ) : self . _symlink_latest_log_directory ( ) self . _cur_date = datetime . today ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _init_file ( self , filename ) : relative_path = self . _render_filename ( filename ) full_path = os . path . join ( self . _get_log_directory ( ) , relative_path ) directory = os . path . dirname ( full_path ) if not os . path . exists ( directory ) : try : os . makedirs ( directory ) except OSError : if not os . path . isdir ( directory ) : raise if not os . path . exists ( full_path ) : open ( full_path , \"a\" ) . close ( ) return full_path\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _parse_gcs_url ( gsurl ) : parsed_url = urlparse ( gsurl ) if not parsed_url . netloc : raise AirflowException ( 'Please provide a bucket name' ) else : bucket = parsed_url . netloc # Remove leading '/' but NOT trailing one blob = parsed_url . path . lstrip ( '/' ) return bucket , blob\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . _conn : self . _conn = storage . Client ( credentials = self . _get_credentials ( ) ) return self . _conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def copy ( self , source_bucket , source_object , destination_bucket = None , destination_object = None ) : destination_bucket = destination_bucket or source_bucket destination_object = destination_object or source_object if source_bucket == destination_bucket and source_object == destination_object : raise ValueError ( 'Either source/destination bucket or source/destination object ' 'must be different, not both the same: bucket=%s, object=%s' % ( source_bucket , source_object ) ) if not source_bucket or not source_object : raise ValueError ( 'source_bucket and source_object cannot be empty.' ) client = self . get_conn ( ) source_bucket = client . get_bucket ( source_bucket ) source_object = source_bucket . blob ( source_object ) destination_bucket = client . get_bucket ( destination_bucket ) destination_object = source_bucket . copy_blob ( blob = source_object , destination_bucket = destination_bucket , new_name = destination_object ) self . log . info ( 'Object %s in bucket %s copied to object %s in bucket %s' , source_object . name , source_bucket . name , destination_object . name , destination_bucket . name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def rewrite ( self , source_bucket , source_object , destination_bucket , destination_object = None ) : destination_object = destination_object or source_object if ( source_bucket == destination_bucket and source_object == destination_object ) : raise ValueError ( 'Either source/destination bucket or source/destination object ' 'must be different, not both the same: bucket=%s, object=%s' % ( source_bucket , source_object ) ) if not source_bucket or not source_object : raise ValueError ( 'source_bucket and source_object cannot be empty.' ) client = self . get_conn ( ) source_bucket = client . get_bucket ( bucket_name = source_bucket ) source_object = source_bucket . blob ( blob_name = source_object ) destination_bucket = client . get_bucket ( bucket_name = destination_bucket ) token , bytes_rewritten , total_bytes = destination_bucket . blob ( blob_name = destination_object ) . rewrite ( source = source_object ) self . log . info ( 'Total Bytes: %s | Bytes Written: %s' , total_bytes , bytes_rewritten ) while token is not None : token , bytes_rewritten , total_bytes = destination_bucket . blob ( blob_name = destination_object ) . rewrite ( source = source_object , token = token ) self . log . info ( 'Total Bytes: %s | Bytes Written: %s' , total_bytes , bytes_rewritten ) self . log . info ( 'Object %s in bucket %s copied to object %s in bucket %s' , source_object . name , source_bucket . name , destination_object , destination_bucket . name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download ( self , bucket_name , object_name , filename = None ) : client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name ) blob = bucket . blob ( blob_name = object_name ) if filename : blob . download_to_filename ( filename ) self . log . info ( 'File downloaded to %s' , filename ) return blob . download_as_string ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def upload ( self , bucket_name , object_name , filename , mime_type = 'application/octet-stream' , gzip = False ) : if gzip : filename_gz = filename + '.gz' with open ( filename , 'rb' ) as f_in : with gz . open ( filename_gz , 'wb' ) as f_out : shutil . copyfileobj ( f_in , f_out ) filename = filename_gz client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name = bucket_name ) blob = bucket . blob ( blob_name = object_name ) blob . upload_from_filename ( filename = filename , content_type = mime_type ) if gzip : os . remove ( filename ) self . log . info ( 'File %s uploaded to %s in %s bucket' , filename , object_name , bucket_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def exists ( self , bucket_name , object_name ) : client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name = bucket_name ) blob = bucket . blob ( blob_name = object_name ) return blob . exists ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_updated_after ( self , bucket_name , object_name , ts ) : client = self . get_conn ( ) bucket = storage . Bucket ( client = client , name = bucket_name ) blob = bucket . get_blob ( blob_name = object_name ) blob . reload ( ) blob_update_time = blob . updated if blob_update_time is not None : import dateutil . tz if not ts . tzinfo : ts = ts . replace ( tzinfo = dateutil . tz . tzutc ( ) ) self . log . info ( \"Verify object date: %s > %s\" , blob_update_time , ts ) if blob_update_time > ts : return True return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete ( self , bucket_name , object_name ) : client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name = bucket_name ) blob = bucket . blob ( blob_name = object_name ) blob . delete ( ) self . log . info ( 'Blob %s deleted.' , object_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list ( self , bucket_name , versions = None , max_results = None , prefix = None , delimiter = None ) : client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name = bucket_name ) ids = [ ] pageToken = None while True : blobs = bucket . list_blobs ( max_results = max_results , page_token = pageToken , prefix = prefix , delimiter = delimiter , versions = versions ) blob_names = [ ] for blob in blobs : blob_names . append ( blob . name ) prefixes = blobs . prefixes if prefixes : ids += list ( prefixes ) else : ids += blob_names pageToken = blobs . next_page_token if pageToken is None : # empty next page token break return ids\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_size ( self , bucket_name , object_name ) : self . log . info ( 'Checking the file size of object: %s in bucket_name: %s' , object_name , bucket_name ) client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name = bucket_name ) blob = bucket . get_blob ( blob_name = object_name ) blob . reload ( ) blob_size = blob . size self . log . info ( 'The file size of %s is %s bytes.' , object_name , blob_size ) return blob_size\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_crc32c ( self , bucket_name , object_name ) : self . log . info ( 'Retrieving the crc32c checksum of ' 'object_name: %s in bucket_name: %s' , object_name , bucket_name ) client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name = bucket_name ) blob = bucket . get_blob ( blob_name = object_name ) blob . reload ( ) blob_crc32c = blob . crc32c self . log . info ( 'The crc32c checksum of %s is %s' , object_name , blob_crc32c ) return blob_crc32c\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_md5hash ( self , bucket_name , object_name ) : self . log . info ( 'Retrieving the MD5 hash of ' 'object: %s in bucket: %s' , object_name , bucket_name ) client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name = bucket_name ) blob = bucket . get_blob ( blob_name = object_name ) blob . reload ( ) blob_md5hash = blob . md5_hash self . log . info ( 'The md5Hash of %s is %s' , object_name , blob_md5hash ) return blob_md5hash\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_bucket ( self , bucket_name , resource = None , storage_class = 'MULTI_REGIONAL' , location = 'US' , project_id = None , labels = None ) : self . log . info ( 'Creating Bucket: %s; Location: %s; Storage Class: %s' , bucket_name , location , storage_class ) client = self . get_conn ( ) bucket = client . bucket ( bucket_name = bucket_name ) bucket_resource = resource or { } for item in bucket_resource : if item != \"name\" : bucket . _patch_property ( name = item , value = resource [ item ] ) bucket . storage_class = storage_class bucket . labels = labels or { } bucket . create ( project = project_id , location = location ) return bucket . id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_bucket_acl ( self , bucket_name , entity , role , user_project = None ) : self . log . info ( 'Creating a new ACL entry in bucket: %s' , bucket_name ) client = self . get_conn ( ) bucket = client . bucket ( bucket_name = bucket_name ) bucket . acl . reload ( ) bucket . acl . entity_from_dict ( entity_dict = { \"entity\" : entity , \"role\" : role } ) if user_project : bucket . acl . user_project = user_project bucket . acl . save ( ) self . log . info ( 'A new ACL entry created in bucket: %s' , bucket_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_object_acl ( self , bucket_name , object_name , entity , role , user_project = None ) : self . log . info ( 'Creating a new ACL entry for object: %s in bucket: %s' , object_name , bucket_name ) client = self . get_conn ( ) bucket = client . bucket ( bucket_name = bucket_name ) blob = bucket . blob ( object_name ) # Reload fetches the current ACL from Cloud Storage. blob . acl . reload ( ) blob . acl . entity_from_dict ( entity_dict = { \"entity\" : entity , \"role\" : role } ) if user_project : blob . acl . user_project = user_project blob . acl . save ( ) self . log . info ( 'A new ACL entry created for object: %s in bucket: %s' , object_name , bucket_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def compose ( self , bucket_name , source_objects , destination_object ) : if not source_objects or not len ( source_objects ) : raise ValueError ( 'source_objects cannot be empty.' ) if not bucket_name or not destination_object : raise ValueError ( 'bucket_name and destination_object cannot be empty.' ) self . log . info ( \"Composing %s to %s in the bucket %s\" , source_objects , destination_object , bucket_name ) client = self . get_conn ( ) bucket = client . get_bucket ( bucket_name ) destination_blob = bucket . blob ( destination_object ) destination_blob . compose ( sources = [ bucket . blob ( blob_name = source_object ) for source_object in source_objects ] ) self . log . info ( \"Completed successfully.\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def argmin ( arr , f ) : m = None i = None for idx , item in enumerate ( arr ) : if item is not None : if m is None or f ( item ) < m : m = f ( item ) i = idx return i\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def secondary_training_status_changed ( current_job_description , prev_job_description ) : current_secondary_status_transitions = current_job_description . get ( 'SecondaryStatusTransitions' ) if current_secondary_status_transitions is None or len ( current_secondary_status_transitions ) == 0 : return False prev_job_secondary_status_transitions = prev_job_description . get ( 'SecondaryStatusTransitions' ) if prev_job_description is not None else None last_message = prev_job_secondary_status_transitions [ - 1 ] [ 'StatusMessage' ] if prev_job_secondary_status_transitions is not None and len ( prev_job_secondary_status_transitions ) > 0 else '' message = current_job_description [ 'SecondaryStatusTransitions' ] [ - 1 ] [ 'StatusMessage' ] return message != last_message\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def secondary_training_status_message ( job_description , prev_description ) : if job_description is None or job_description . get ( 'SecondaryStatusTransitions' ) is None or len ( job_description . get ( 'SecondaryStatusTransitions' ) ) == 0 : return '' prev_description_secondary_transitions = prev_description . get ( 'SecondaryStatusTransitions' ) if prev_description is not None else None prev_transitions_num = len ( prev_description [ 'SecondaryStatusTransitions' ] ) if prev_description_secondary_transitions is not None else 0 current_transitions = job_description [ 'SecondaryStatusTransitions' ] transitions_to_print = current_transitions [ - 1 : ] if len ( current_transitions ) == prev_transitions_num else current_transitions [ prev_transitions_num - len ( current_transitions ) : ] status_strs = [ ] for transition in transitions_to_print : message = transition [ 'StatusMessage' ] time_str = timezone . convert_to_utc ( job_description [ 'LastModifiedTime' ] ) . strftime ( '%Y-%m-%d %H:%M:%S' ) status_strs . append ( '{} {} - {}' . format ( time_str , transition [ 'Status' ] , message ) ) return '\\n' . join ( status_strs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def tar_and_s3_upload ( self , path , key , bucket ) : with tempfile . TemporaryFile ( ) as temp_file : if os . path . isdir ( path ) : files = [ os . path . join ( path , name ) for name in os . listdir ( path ) ] else : files = [ path ] with tarfile . open ( mode = 'w:gz' , fileobj = temp_file ) as tar_file : for f in files : tar_file . add ( f , arcname = os . path . basename ( f ) ) temp_file . seek ( 0 ) self . s3_hook . load_file_obj ( temp_file , key , bucket , replace = True )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def configure_s3_resources ( self , config ) : s3_operations = config . pop ( 'S3Operations' , None ) if s3_operations is not None : create_bucket_ops = s3_operations . get ( 'S3CreateBucket' , [ ] ) upload_ops = s3_operations . get ( 'S3Upload' , [ ] ) for op in create_bucket_ops : self . s3_hook . create_bucket ( bucket_name = op [ 'Bucket' ] ) for op in upload_ops : if op [ 'Tar' ] : self . tar_and_s3_upload ( op [ 'Path' ] , op [ 'Key' ] , op [ 'Bucket' ] ) else : self . s3_hook . load_file ( op [ 'Path' ] , op [ 'Key' ] , op [ 'Bucket' ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_s3_url ( self , s3url ) : bucket , key = S3Hook . parse_s3_url ( s3url ) if not self . s3_hook . check_for_bucket ( bucket_name = bucket ) : raise AirflowException ( \"The input S3 Bucket {} does not exist \" . format ( bucket ) ) if key and not self . s3_hook . check_for_key ( key = key , bucket_name = bucket ) and not self . s3_hook . check_for_prefix ( prefix = key , bucket_name = bucket , delimiter = '/' ) : # check if s3 key exists in the case user provides a single file # or if s3 prefix exists in the case user provides multiple files in # a prefix raise AirflowException ( \"The input S3 Key \" \"or Prefix {} does not exist in the Bucket {}\" . format ( s3url , bucket ) ) return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_log_conn ( self ) : config = botocore . config . Config ( retries = { 'max_attempts' : 15 } ) return self . get_client_type ( 'logs' , config = config )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_training_job ( self , config , wait_for_completion = True , print_log = True , check_interval = 30 , max_ingestion_time = None ) : self . check_training_config ( config ) response = self . get_conn ( ) . create_training_job ( * * config ) if print_log : self . check_training_status_with_log ( config [ 'TrainingJobName' ] , self . non_terminal_states , self . failed_states , wait_for_completion , check_interval , max_ingestion_time ) elif wait_for_completion : describe_response = self . check_status ( config [ 'TrainingJobName' ] , 'TrainingJobStatus' , self . describe_training_job , check_interval , max_ingestion_time ) billable_time = ( describe_response [ 'TrainingEndTime' ] - describe_response [ 'TrainingStartTime' ] ) * describe_response [ 'ResourceConfig' ] [ 'InstanceCount' ] self . log . info ( 'Billable seconds:{}' . format ( int ( billable_time . total_seconds ( ) ) + 1 ) ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_tuning_job ( self , config , wait_for_completion = True , check_interval = 30 , max_ingestion_time = None ) : self . check_tuning_config ( config ) response = self . get_conn ( ) . create_hyper_parameter_tuning_job ( * * config ) if wait_for_completion : self . check_status ( config [ 'HyperParameterTuningJobName' ] , 'HyperParameterTuningJobStatus' , self . describe_tuning_job , check_interval , max_ingestion_time ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_transform_job ( self , config , wait_for_completion = True , check_interval = 30 , max_ingestion_time = None ) : self . check_s3_url ( config [ 'TransformInput' ] [ 'DataSource' ] [ 'S3DataSource' ] [ 'S3Uri' ] ) response = self . get_conn ( ) . create_transform_job ( * * config ) if wait_for_completion : self . check_status ( config [ 'TransformJobName' ] , 'TransformJobStatus' , self . describe_transform_job , check_interval , max_ingestion_time ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_endpoint ( self , config , wait_for_completion = True , check_interval = 30 , max_ingestion_time = None ) : response = self . get_conn ( ) . create_endpoint ( * * config ) if wait_for_completion : self . check_status ( config [ 'EndpointName' ] , 'EndpointStatus' , self . describe_endpoint , check_interval , max_ingestion_time , non_terminal_states = self . endpoint_non_terminal_states ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def describe_training_job_with_log ( self , job_name , positions , stream_names , instance_count , state , last_description , last_describe_job_call ) : log_group = '/aws/sagemaker/TrainingJobs' if len ( stream_names ) < instance_count : # Log streams are created whenever a container starts writing to stdout/err, so this list # may be dynamic until we have a stream for every instance. logs_conn = self . get_log_conn ( ) try : streams = logs_conn . describe_log_streams ( logGroupName = log_group , logStreamNamePrefix = job_name + '/' , orderBy = 'LogStreamName' , limit = instance_count ) stream_names = [ s [ 'logStreamName' ] for s in streams [ 'logStreams' ] ] positions . update ( [ ( s , Position ( timestamp = 0 , skip = 0 ) ) for s in stream_names if s not in positions ] ) except logs_conn . exceptions . ResourceNotFoundException : # On the very first training job run on an account, there's no log group until # the container starts logging, so ignore any errors thrown about that pass if len ( stream_names ) > 0 : for idx , event in self . multi_stream_iter ( log_group , stream_names , positions ) : self . log . info ( event [ 'message' ] ) ts , count = positions [ stream_names [ idx ] ] if event [ 'timestamp' ] == ts : positions [ stream_names [ idx ] ] = Position ( timestamp = ts , skip = count + 1 ) else : positions [ stream_names [ idx ] ] = Position ( timestamp = event [ 'timestamp' ] , skip = 1 ) if state == LogState . COMPLETE : return state , last_description , last_describe_job_call if state == LogState . JOB_COMPLETE : state = LogState . COMPLETE elif time . time ( ) - last_describe_job_call >= 30 : description = self . describe_training_job ( job_name ) last_describe_job_call = time . time ( ) if secondary_training_status_changed ( description , last_description ) : self . log . info ( secondary_training_status_message ( description , last_description ) ) last_description = description status = description [ 'TrainingJobStatus' ] if status not in self . non_terminal_states : state = LogState . JOB_COMPLETE return state , last_description , last_describe_job_call\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_status ( self , job_name , key , describe_function , check_interval , max_ingestion_time , non_terminal_states = None ) : if not non_terminal_states : non_terminal_states = self . non_terminal_states sec = 0 running = True while running : time . sleep ( check_interval ) sec = sec + check_interval try : response = describe_function ( job_name ) status = response [ key ] self . log . info ( 'Job still running for %s seconds... ' 'current status is %s' % ( sec , status ) ) except KeyError : raise AirflowException ( 'Could not get status of the SageMaker job' ) except ClientError : raise AirflowException ( 'AWS request failed, check logs for more info' ) if status in non_terminal_states : running = True elif status in self . failed_states : raise AirflowException ( 'SageMaker job failed because %s' % response [ 'FailureReason' ] ) else : running = False if max_ingestion_time and sec > max_ingestion_time : # ensure that the job gets killed if the max ingestion time is exceeded raise AirflowException ( 'SageMaker job took more than %s seconds' , max_ingestion_time ) self . log . info ( 'SageMaker Job Compeleted' ) response = describe_function ( job_name ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_training_status_with_log ( self , job_name , non_terminal_states , failed_states , wait_for_completion , check_interval , max_ingestion_time ) : sec = 0 description = self . describe_training_job ( job_name ) self . log . info ( secondary_training_status_message ( description , None ) ) instance_count = description [ 'ResourceConfig' ] [ 'InstanceCount' ] status = description [ 'TrainingJobStatus' ] stream_names = [ ] # The list of log streams positions = { } # The current position in each stream, map of stream name -> position job_already_completed = status not in non_terminal_states state = LogState . TAILING if wait_for_completion and not job_already_completed else LogState . COMPLETE # The loop below implements a state machine that alternates between checking the job status and # reading whatever is available in the logs at this point. Note, that if we were called with # wait_for_completion == False, we never check the job status. # # If wait_for_completion == TRUE and job is not completed, the initial state is TAILING # If wait_for_completion == FALSE, the initial state is COMPLETE # (doesn't matter if the job really is complete). # # The state table: # # STATE ACTIONS CONDITION NEW STATE # ---------------- ---------------- ----------------- ---------------- # TAILING Read logs, Pause, Get status Job complete JOB_COMPLETE # Else TAILING # JOB_COMPLETE Read logs, Pause Any COMPLETE # COMPLETE Read logs, Exit N/A # # Notes: # - The JOB_COMPLETE state forces us to do an extra pause and read any items that # got to Cloudwatch after the job was marked complete. last_describe_job_call = time . time ( ) last_description = description while True : time . sleep ( check_interval ) sec = sec + check_interval state , last_description , last_describe_job_call = self . describe_training_job_with_log ( job_name , positions , stream_names , instance_count , state , last_description , last_describe_job_call ) if state == LogState . COMPLETE : break if max_ingestion_time and sec > max_ingestion_time : # ensure that the job gets killed if the max ingestion time is exceeded raise AirflowException ( 'SageMaker job took more than %s seconds' , max_ingestion_time ) if wait_for_completion : status = last_description [ 'TrainingJobStatus' ] if status in failed_states : reason = last_description . get ( 'FailureReason' , '(No reason provided)' ) raise AirflowException ( 'Error training {}: {} Reason: {}' . format ( job_name , status , reason ) ) billable_time = ( last_description [ 'TrainingEndTime' ] - last_description [ 'TrainingStartTime' ] ) * instance_count self . log . info ( 'Billable seconds:{}' . format ( int ( billable_time . total_seconds ( ) ) + 1 ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : bucket_helper = GoogleCloudBucketHelper ( self . gcp_conn_id , self . delegate_to ) self . py_file = bucket_helper . google_cloud_to_local ( self . py_file ) hook = DataFlowHook ( gcp_conn_id = self . gcp_conn_id , delegate_to = self . delegate_to , poll_sleep = self . poll_sleep ) dataflow_options = self . dataflow_default_options . copy ( ) dataflow_options . update ( self . options ) # Convert argument names from lowerCamelCase to snake case. camel_to_snake = lambda name : re . sub ( r'[A-Z]' , lambda x : '_' + x . group ( 0 ) . lower ( ) , name ) formatted_options = { camel_to_snake ( key ) : dataflow_options [ key ] for key in dataflow_options } hook . start_python_dataflow ( self . job_name , formatted_options , self . py_file , self . py_options )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def google_cloud_to_local ( self , file_name ) : if not file_name . startswith ( 'gs://' ) : return file_name # Extracts bucket_id and object_id by first removing 'gs://' prefix and # then split the remaining by path delimiter '/'. path_components = file_name [ self . GCS_PREFIX_LENGTH : ] . split ( '/' ) if len ( path_components ) < 2 : raise Exception ( 'Invalid Google Cloud Storage (GCS) object path: {}' . format ( file_name ) ) bucket_id = path_components [ 0 ] object_id = '/' . join ( path_components [ 1 : ] ) local_file = '/tmp/dataflow{}-{}' . format ( str ( uuid . uuid4 ( ) ) [ : 8 ] , path_components [ - 1 ] ) self . _gcs_hook . download ( bucket_id , object_id , local_file ) if os . stat ( local_file ) . st_size > 0 : return local_file raise Exception ( 'Failed to download Google Cloud Storage (GCS) object: {}' . format ( file_name ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_migrations_offline ( ) : context . configure ( url = settings . SQL_ALCHEMY_CONN , target_metadata = target_metadata , literal_binds = True , compare_type = COMPARE_TYPE ) with context . begin_transaction ( ) : context . run_migrations ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_migrations_online ( ) : connectable = settings . engine with connectable . connect ( ) as connection : context . configure ( connection = connection , transaction_per_migration = True , target_metadata = target_metadata , compare_type = COMPARE_TYPE , ) with context . begin_transaction ( ) : context . run_migrations ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_instance ( self , instance_id , project_id = None ) : instance = self . get_instance ( instance_id = instance_id , project_id = project_id ) if instance : instance . delete ( ) else : self . log . info ( \"The instance '%s' does not exist in project '%s'. Exiting\" , instance_id , project_id )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_instance ( self , instance_id , main_cluster_id , main_cluster_zone , project_id = None , replica_cluster_id = None , replica_cluster_zone = None , instance_display_name = None , instance_type = enums . Instance . Type . TYPE_UNSPECIFIED , instance_labels = None , cluster_nodes = None , cluster_storage_type = enums . StorageType . STORAGE_TYPE_UNSPECIFIED , timeout = None ) : cluster_storage_type = enums . StorageType ( cluster_storage_type ) instance_type = enums . Instance . Type ( instance_type ) instance = Instance ( instance_id , self . _get_client ( project_id = project_id ) , instance_display_name , instance_type , instance_labels , ) clusters = [ instance . cluster ( main_cluster_id , main_cluster_zone , cluster_nodes , cluster_storage_type ) ] if replica_cluster_id and replica_cluster_zone : clusters . append ( instance . cluster ( replica_cluster_id , replica_cluster_zone , cluster_nodes , cluster_storage_type ) ) operation = instance . create ( clusters = clusters ) operation . result ( timeout ) return instance\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_table ( instance , table_id , initial_split_keys = None , column_families = None ) : if column_families is None : column_families = { } if initial_split_keys is None : initial_split_keys = [ ] table = Table ( table_id , instance ) table . create ( initial_split_keys , column_families )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_table ( self , instance_id , table_id , project_id = None ) : table = self . get_instance ( instance_id = instance_id , project_id = project_id ) . table ( table_id = table_id ) table . delete ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_cluster ( instance , cluster_id , nodes ) : cluster = Cluster ( cluster_id , instance ) cluster . serve_nodes = nodes cluster . update ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_cli_cmd ( self ) : conn = self . conn hive_bin = 'hive' cmd_extra = [ ] if self . use_beeline : hive_bin = 'beeline' jdbc_url = \"jdbc:hive2://{host}:{port}/{schema}\" . format ( host = conn . host , port = conn . port , schema = conn . schema ) if configuration . conf . get ( 'core' , 'security' ) == 'kerberos' : template = conn . extra_dejson . get ( 'principal' , \"hive/_HOST@EXAMPLE.COM\" ) if \"_HOST\" in template : template = utils . replace_hostname_pattern ( utils . get_components ( template ) ) proxy_user = \"\" # noqa if conn . extra_dejson . get ( 'proxy_user' ) == \"login\" and conn . login : proxy_user = \"hive.server2.proxy.user={0}\" . format ( conn . login ) elif conn . extra_dejson . get ( 'proxy_user' ) == \"owner\" and self . run_as : proxy_user = \"hive.server2.proxy.user={0}\" . format ( self . run_as ) jdbc_url += \";principal={template};{proxy_user}\" . format ( template = template , proxy_user = proxy_user ) elif self . auth : jdbc_url += \";auth=\" + self . auth jdbc_url = '\"{}\"' . format ( jdbc_url ) cmd_extra += [ '-u' , jdbc_url ] if conn . login : cmd_extra += [ '-n' , conn . login ] if conn . password : cmd_extra += [ '-p' , conn . password ] hive_params_list = self . hive_cli_params . split ( ) return [ hive_bin ] + cmd_extra + hive_params_list\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_hiveconf ( d ) : if not d : return [ ] return as_flattened_list ( zip ( [ \"-hiveconf\" ] * len ( d ) , [ \"{}={}\" . format ( k , v ) for k , v in d . items ( ) ] ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_cli ( self , hql , schema = None , verbose = True , hive_conf = None ) : conn = self . conn schema = schema or conn . schema if schema : hql = \"USE {schema};\\n{hql}\" . format ( schema = schema , hql = hql ) with TemporaryDirectory ( prefix = 'airflow_hiveop_' ) as tmp_dir : with NamedTemporaryFile ( dir = tmp_dir ) as f : hql = hql + '\\n' f . write ( hql . encode ( 'UTF-8' ) ) f . flush ( ) hive_cmd = self . _prepare_cli_cmd ( ) env_context = get_context_from_env_var ( ) # Only extend the hive_conf if it is defined. if hive_conf : env_context . update ( hive_conf ) hive_conf_params = self . _prepare_hiveconf ( env_context ) if self . mapred_queue : hive_conf_params . extend ( [ '-hiveconf' , 'mapreduce.job.queuename={}' . format ( self . mapred_queue ) , '-hiveconf' , 'mapred.job.queue.name={}' . format ( self . mapred_queue ) , '-hiveconf' , 'tez.job.queue.name={}' . format ( self . mapred_queue ) ] ) if self . mapred_queue_priority : hive_conf_params . extend ( [ '-hiveconf' , 'mapreduce.job.priority={}' . format ( self . mapred_queue_priority ) ] ) if self . mapred_job_name : hive_conf_params . extend ( [ '-hiveconf' , 'mapred.job.name={}' . format ( self . mapred_job_name ) ] ) hive_cmd . extend ( hive_conf_params ) hive_cmd . extend ( [ '-f' , f . name ] ) if verbose : self . log . info ( \"%s\" , \" \" . join ( hive_cmd ) ) sp = subprocess . Popen ( hive_cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , cwd = tmp_dir , close_fds = True ) self . sp = sp stdout = '' while True : line = sp . stdout . readline ( ) if not line : break stdout += line . decode ( 'UTF-8' ) if verbose : self . log . info ( line . decode ( 'UTF-8' ) . strip ( ) ) sp . wait ( ) if sp . returncode : raise AirflowException ( stdout ) return stdout\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_df ( self , df , table , field_dict = None , delimiter = ',' , encoding = 'utf8' , pandas_kwargs = None , * * kwargs ) : def _infer_field_types_from_df ( df ) : DTYPE_KIND_HIVE_TYPE = { 'b' : 'BOOLEAN' , # boolean 'i' : 'BIGINT' , # signed integer 'u' : 'BIGINT' , # unsigned integer 'f' : 'DOUBLE' , # floating-point 'c' : 'STRING' , # complex floating-point 'M' : 'TIMESTAMP' , # datetime 'O' : 'STRING' , # object 'S' : 'STRING' , # (byte-)string 'U' : 'STRING' , # Unicode 'V' : 'STRING' # void } d = OrderedDict ( ) for col , dtype in df . dtypes . iteritems ( ) : d [ col ] = DTYPE_KIND_HIVE_TYPE [ dtype . kind ] return d if pandas_kwargs is None : pandas_kwargs = { } with TemporaryDirectory ( prefix = 'airflow_hiveop_' ) as tmp_dir : with NamedTemporaryFile ( dir = tmp_dir , mode = \"w\" ) as f : if field_dict is None : field_dict = _infer_field_types_from_df ( df ) df . to_csv ( path_or_buf = f , sep = delimiter , header = False , index = False , encoding = encoding , date_format = \"%Y-%m-%d %H:%M:%S\" , * * pandas_kwargs ) f . flush ( ) return self . load_file ( filepath = f . name , table = table , delimiter = delimiter , field_dict = field_dict , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_file ( self , filepath , table , delimiter = \",\" , field_dict = None , create = True , overwrite = True , partition = None , recreate = False , tblproperties = None ) : hql = '' if recreate : hql += \"DROP TABLE IF EXISTS {table};\\n\" . format ( table = table ) if create or recreate : if field_dict is None : raise ValueError ( \"Must provide a field dict when creating a table\" ) fields = \",\\n \" . join ( [ k + ' ' + v for k , v in field_dict . items ( ) ] ) hql += \"CREATE TABLE IF NOT EXISTS {table} (\\n{fields})\\n\" . format ( table = table , fields = fields ) if partition : pfields = \",\\n \" . join ( [ p + \" STRING\" for p in partition ] ) hql += \"PARTITIONED BY ({pfields})\\n\" . format ( pfields = pfields ) hql += \"ROW FORMAT DELIMITED\\n\" hql += \"FIELDS TERMINATED BY '{delimiter}'\\n\" . format ( delimiter = delimiter ) hql += \"STORED AS textfile\\n\" if tblproperties is not None : tprops = \", \" . join ( [ \"'{0}'='{1}'\" . format ( k , v ) for k , v in tblproperties . items ( ) ] ) hql += \"TBLPROPERTIES({tprops})\\n\" . format ( tprops = tprops ) hql += \";\" self . log . info ( hql ) self . run_cli ( hql ) hql = \"LOAD DATA LOCAL INPATH '{filepath}' \" . format ( filepath = filepath ) if overwrite : hql += \"OVERWRITE \" hql += \"INTO TABLE {table} \" . format ( table = table ) if partition : pvals = \", \" . join ( [ \"{0}='{1}'\" . format ( k , v ) for k , v in partition . items ( ) ] ) hql += \"PARTITION ({pvals})\" . format ( pvals = pvals ) # As a workaround for HIVE-10541, add a newline character # at the end of hql (AIRFLOW-2412). hql += ';\\n' self . log . info ( hql ) self . run_cli ( hql )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_metastore_client ( self ) : import hmsclient from thrift . transport import TSocket , TTransport from thrift . protocol import TBinaryProtocol ms = self . metastore_conn auth_mechanism = ms . extra_dejson . get ( 'authMechanism' , 'NOSASL' ) if configuration . conf . get ( 'core' , 'security' ) == 'kerberos' : auth_mechanism = ms . extra_dejson . get ( 'authMechanism' , 'GSSAPI' ) kerberos_service_name = ms . extra_dejson . get ( 'kerberos_service_name' , 'hive' ) socket = TSocket . TSocket ( ms . host , ms . port ) if configuration . conf . get ( 'core' , 'security' ) == 'kerberos' and auth_mechanism == 'GSSAPI' : try : import saslwrapper as sasl except ImportError : import sasl def sasl_factory ( ) : sasl_client = sasl . Client ( ) sasl_client . setAttr ( \"host\" , ms . host ) sasl_client . setAttr ( \"service\" , kerberos_service_name ) sasl_client . init ( ) return sasl_client from thrift_sasl import TSaslClientTransport transport = TSaslClientTransport ( sasl_factory , \"GSSAPI\" , socket ) else : transport = TTransport . TBufferedTransport ( socket ) protocol = TBinaryProtocol . TBinaryProtocol ( transport ) return hmsclient . HMSClient ( iprot = protocol )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_partition ( self , schema , table , partition ) : with self . metastore as client : partitions = client . get_partitions_by_filter ( schema , table , partition , 1 ) if partitions : return True else : return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_named_partition ( self , schema , table , partition_name ) : with self . metastore as client : return client . check_for_named_partition ( schema , table , partition_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_table ( self , table_name , db = 'default' ) : if db == 'default' and '.' in table_name : db , table_name = table_name . split ( '.' ) [ : 2 ] with self . metastore as client : return client . get_table ( dbname = db , tbl_name = table_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_tables ( self , db , pattern = '*' ) : with self . metastore as client : tables = client . get_tables ( db_name = db , pattern = pattern ) return client . get_table_objects_by_name ( db , tables )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_partitions ( self , schema , table_name , filter = None ) : with self . metastore as client : table = client . get_table ( dbname = schema , tbl_name = table_name ) if len ( table . partitionKeys ) == 0 : raise AirflowException ( \"The table isn't partitioned\" ) else : if filter : parts = client . get_partitions_by_filter ( db_name = schema , tbl_name = table_name , filter = filter , max_parts = HiveMetastoreHook . MAX_PART_COUNT ) else : parts = client . get_partitions ( db_name = schema , tbl_name = table_name , max_parts = HiveMetastoreHook . MAX_PART_COUNT ) pnames = [ p . name for p in table . partitionKeys ] return [ dict ( zip ( pnames , p . values ) ) for p in parts ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_max_partition_from_part_specs ( part_specs , partition_key , filter_map ) : if not part_specs : return None # Assuming all specs have the same keys. if partition_key not in part_specs [ 0 ] . keys ( ) : raise AirflowException ( \"Provided partition_key {} \" \"is not in part_specs.\" . format ( partition_key ) ) if filter_map : is_subset = set ( filter_map . keys ( ) ) . issubset ( set ( part_specs [ 0 ] . keys ( ) ) ) if filter_map and not is_subset : raise AirflowException ( \"Keys in provided filter_map {} \" \"are not subset of part_spec keys: {}\" . format ( ', ' . join ( filter_map . keys ( ) ) , ', ' . join ( part_specs [ 0 ] . keys ( ) ) ) ) candidates = [ p_dict [ partition_key ] for p_dict in part_specs if filter_map is None or all ( item in p_dict . items ( ) for item in filter_map . items ( ) ) ] if not candidates : return None else : return max ( candidates ) . encode ( 'utf-8' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def max_partition ( self , schema , table_name , field = None , filter_map = None ) : with self . metastore as client : table = client . get_table ( dbname = schema , tbl_name = table_name ) key_name_set = set ( key . name for key in table . partitionKeys ) if len ( table . partitionKeys ) == 1 : field = table . partitionKeys [ 0 ] . name elif not field : raise AirflowException ( \"Please specify the field you want the max \" \"value for.\" ) elif field not in key_name_set : raise AirflowException ( \"Provided field is not a partition key.\" ) if filter_map and not set ( filter_map . keys ( ) ) . issubset ( key_name_set ) : raise AirflowException ( \"Provided filter_map contains keys \" \"that are not partition key.\" ) part_names = client . get_partition_names ( schema , table_name , max_parts = HiveMetastoreHook . MAX_PART_COUNT ) part_specs = [ client . partition_name_to_spec ( part_name ) for part_name in part_names ] return HiveMetastoreHook . _get_max_partition_from_part_specs ( part_specs , field , filter_map )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def table_exists ( self , table_name , db = 'default' ) : try : self . get_table ( table_name , db ) return True except Exception : return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self , schema = None ) : db = self . get_connection ( self . hiveserver2_conn_id ) auth_mechanism = db . extra_dejson . get ( 'authMechanism' , 'NONE' ) if auth_mechanism == 'NONE' and db . login is None : # we need to give a username username = 'airflow' kerberos_service_name = None if configuration . conf . get ( 'core' , 'security' ) == 'kerberos' : auth_mechanism = db . extra_dejson . get ( 'authMechanism' , 'KERBEROS' ) kerberos_service_name = db . extra_dejson . get ( 'kerberos_service_name' , 'hive' ) # pyhive uses GSSAPI instead of KERBEROS as a auth_mechanism identifier if auth_mechanism == 'GSSAPI' : self . log . warning ( \"Detected deprecated 'GSSAPI' for authMechanism \" \"for %s. Please use 'KERBEROS' instead\" , self . hiveserver2_conn_id ) auth_mechanism = 'KERBEROS' from pyhive . hive import connect return connect ( host = db . host , port = db . port , auth = auth_mechanism , kerberos_service_name = kerberos_service_name , username = db . login or username , password = db . password , database = schema or db . schema or 'default' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_results ( self , hql , schema = 'default' , fetch_size = None , hive_conf = None ) : results_iter = self . _get_results ( hql , schema , fetch_size = fetch_size , hive_conf = hive_conf ) header = next ( results_iter ) results = { 'data' : list ( results_iter ) , 'header' : header } return results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def to_csv ( self , hql , csv_filepath , schema = 'default' , delimiter = ',' , lineterminator = '\\r\\n' , output_header = True , fetch_size = 1000 , hive_conf = None ) : results_iter = self . _get_results ( hql , schema , fetch_size = fetch_size , hive_conf = hive_conf ) header = next ( results_iter ) message = None i = 0 with open ( csv_filepath , 'wb' ) as f : writer = csv . writer ( f , delimiter = delimiter , lineterminator = lineterminator , encoding = 'utf-8' ) try : if output_header : self . log . debug ( 'Cursor description is %s' , header ) writer . writerow ( [ c [ 0 ] for c in header ] ) for i , row in enumerate ( results_iter , 1 ) : writer . writerow ( row ) if i % fetch_size == 0 : self . log . info ( \"Written %s rows so far.\" , i ) except ValueError as exception : message = str ( exception ) if message : # need to clean up the file first os . remove ( csv_filepath ) raise ValueError ( message ) self . log . info ( \"Done. Loaded a total of %s rows.\" , i )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_records ( self , hql , schema = 'default' , hive_conf = None ) : return self . get_results ( hql , schema = schema , hive_conf = hive_conf ) [ 'data' ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_pandas_df ( self , hql , schema = 'default' ) : import pandas as pd res = self . get_results ( hql , schema = schema ) df = pd . DataFrame ( res [ 'data' ] ) df . columns = [ c [ 0 ] for c in res [ 'header' ] ] return df\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . _client : self . _client = ProductSearchClient ( credentials = self . _get_credentials ( ) ) return self . _client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_product_set ( self , location , product_set , project_id = None , product_set_id = None , retry = None , timeout = None , metadata = None , ) : client = self . get_conn ( ) parent = ProductSearchClient . location_path ( project_id , location ) self . log . info ( 'Creating a new ProductSet under the parent: %s' , parent ) response = client . create_product_set ( parent = parent , product_set = product_set , product_set_id = product_set_id , retry = retry , timeout = timeout , metadata = metadata , ) self . log . info ( 'ProductSet created: %s' , response . name if response else '' ) self . log . debug ( 'ProductSet created:\\n%s' , response ) if not product_set_id : # Product set id was generated by the API product_set_id = self . _get_autogenerated_id ( response ) self . log . info ( 'Extracted autogenerated ProductSet ID from the response: %s' , product_set_id ) return product_set_id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_product_set ( self , location , product_set_id , project_id = None , retry = None , timeout = None , metadata = None ) : client = self . get_conn ( ) name = ProductSearchClient . product_set_path ( project_id , location , product_set_id ) self . log . info ( 'Retrieving ProductSet: %s' , name ) response = client . get_product_set ( name = name , retry = retry , timeout = timeout , metadata = metadata ) self . log . info ( 'ProductSet retrieved.' ) self . log . debug ( 'ProductSet retrieved:\\n%s' , response ) return MessageToDict ( response )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_product_set ( self , product_set , location = None , product_set_id = None , update_mask = None , project_id = None , retry = None , timeout = None , metadata = None , ) : client = self . get_conn ( ) product_set = self . product_set_name_determiner . get_entity_with_name ( product_set , product_set_id , location , project_id ) self . log . info ( 'Updating ProductSet: %s' , product_set . name ) response = client . update_product_set ( product_set = product_set , update_mask = update_mask , retry = retry , timeout = timeout , metadata = metadata ) self . log . info ( 'ProductSet updated: %s' , response . name if response else '' ) self . log . debug ( 'ProductSet updated:\\n%s' , response ) return MessageToDict ( response )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_product_set ( self , location , product_set_id , project_id = None , retry = None , timeout = None , metadata = None ) : client = self . get_conn ( ) name = ProductSearchClient . product_set_path ( project_id , location , product_set_id ) self . log . info ( 'Deleting ProductSet: %s' , name ) client . delete_product_set ( name = name , retry = retry , timeout = timeout , metadata = metadata ) self . log . info ( 'ProductSet with the name [%s] deleted.' , name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_product ( self , location , product , project_id = None , product_id = None , retry = None , timeout = None , metadata = None ) : client = self . get_conn ( ) parent = ProductSearchClient . location_path ( project_id , location ) self . log . info ( 'Creating a new Product under the parent: %s' , parent ) response = client . create_product ( parent = parent , product = product , product_id = product_id , retry = retry , timeout = timeout , metadata = metadata , ) self . log . info ( 'Product created: %s' , response . name if response else '' ) self . log . debug ( 'Product created:\\n%s' , response ) if not product_id : # Product id was generated by the API product_id = self . _get_autogenerated_id ( response ) self . log . info ( 'Extracted autogenerated Product ID from the response: %s' , product_id ) return product_id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_product ( self , location , product_id , project_id = None , retry = None , timeout = None , metadata = None ) : client = self . get_conn ( ) name = ProductSearchClient . product_path ( project_id , location , product_id ) self . log . info ( 'Retrieving Product: %s' , name ) response = client . get_product ( name = name , retry = retry , timeout = timeout , metadata = metadata ) self . log . info ( 'Product retrieved.' ) self . log . debug ( 'Product retrieved:\\n%s' , response ) return MessageToDict ( response )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_product ( self , product , location = None , product_id = None , update_mask = None , project_id = None , retry = None , timeout = None , metadata = None , ) : client = self . get_conn ( ) product = self . product_name_determiner . get_entity_with_name ( product , product_id , location , project_id ) self . log . info ( 'Updating ProductSet: %s' , product . name ) response = client . update_product ( product = product , update_mask = update_mask , retry = retry , timeout = timeout , metadata = metadata ) self . log . info ( 'Product updated: %s' , response . name if response else '' ) self . log . debug ( 'Product updated:\\n%s' , response ) return MessageToDict ( response )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_product ( self , location , product_id , project_id = None , retry = None , timeout = None , metadata = None ) : client = self . get_conn ( ) name = ProductSearchClient . product_path ( project_id , location , product_id ) self . log . info ( 'Deleting ProductSet: %s' , name ) client . delete_product ( name = name , retry = retry , timeout = timeout , metadata = metadata ) self . log . info ( 'Product with the name [%s] deleted:' , name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_reference_image ( self , location , product_id , reference_image , reference_image_id = None , project_id = None , retry = None , timeout = None , metadata = None , ) : client = self . get_conn ( ) self . log . info ( 'Creating ReferenceImage' ) parent = ProductSearchClient . product_path ( project = project_id , location = location , product = product_id ) response = client . create_reference_image ( parent = parent , reference_image = reference_image , reference_image_id = reference_image_id , retry = retry , timeout = timeout , metadata = metadata , ) self . log . info ( 'ReferenceImage created: %s' , response . name if response else '' ) self . log . debug ( 'ReferenceImage created:\\n%s' , response ) if not reference_image_id : # Refernece image id was generated by the API reference_image_id = self . _get_autogenerated_id ( response ) self . log . info ( 'Extracted autogenerated ReferenceImage ID from the response: %s' , reference_image_id ) return reference_image_id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_reference_image ( self , location , product_id , reference_image_id , project_id = None , retry = None , timeout = None , metadata = None , ) : client = self . get_conn ( ) self . log . info ( 'Deleting ReferenceImage' ) name = ProductSearchClient . reference_image_path ( project = project_id , location = location , product = product_id , reference_image = reference_image_id ) response = client . delete_reference_image ( name = name , retry = retry , timeout = timeout , metadata = metadata ) self . log . info ( 'ReferenceImage with the name [%s] deleted.' , name ) return MessageToDict ( response )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def add_product_to_product_set ( self , product_set_id , product_id , location = None , project_id = None , retry = None , timeout = None , metadata = None , ) : client = self . get_conn ( ) product_name = ProductSearchClient . product_path ( project_id , location , product_id ) product_set_name = ProductSearchClient . product_set_path ( project_id , location , product_set_id ) self . log . info ( 'Add Product[name=%s] to Product Set[name=%s]' , product_name , product_set_name ) client . add_product_to_product_set ( name = product_set_name , product = product_name , retry = retry , timeout = timeout , metadata = metadata ) self . log . info ( 'Product added to Product Set' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def annotate_image ( self , request , retry = None , timeout = None ) : client = self . annotator_client self . log . info ( 'Annotating image' ) response = client . annotate_image ( request = request , retry = retry , timeout = timeout ) self . log . info ( 'Image annotated' ) return MessageToDict ( response )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def safe_search_detection ( self , image , max_results = None , retry = None , timeout = None , additional_properties = None ) : client = self . annotator_client self . log . info ( \"Detecting safe search\" ) if additional_properties is None : additional_properties = { } response = client . safe_search_detection ( image = image , max_results = max_results , retry = retry , timeout = timeout , * * additional_properties ) response = MessageToDict ( response ) self . _check_for_error ( response ) self . log . info ( \"Safe search detection finished\" ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_endpoint ( self ) : conn = self . get_connection ( self . http_conn_id ) token = conn . password if not token : raise AirflowException ( 'Dingding token is requests but get nothing, ' 'check you conn_id configuration.' ) return 'robot/send?access_token={}' . format ( token )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_message ( self ) : if self . message_type in [ 'text' , 'markdown' ] : data = { 'msgtype' : self . message_type , self . message_type : { 'content' : self . message } if self . message_type == 'text' else self . message , 'at' : { 'atMobiles' : self . at_mobiles , 'isAtAll' : self . at_all } } else : data = { 'msgtype' : self . message_type , self . message_type : self . message } return json . dumps ( data )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def send ( self ) : support_type = [ 'text' , 'link' , 'markdown' , 'actionCard' , 'feedCard' ] if self . message_type not in support_type : raise ValueError ( 'DingdingWebhookHook only support {} ' 'so far, but receive {}' . format ( support_type , self . message_type ) ) data = self . _build_message ( ) self . log . info ( 'Sending Dingding type %s message %s' , self . message_type , data ) resp = self . run ( endpoint = self . _get_endpoint ( ) , data = data , headers = { 'Content-Type' : 'application/json' } ) # Dingding success send message will with errcode equal to 0 if int ( resp . json ( ) . get ( 'errcode' ) ) != 0 : raise AirflowException ( 'Send Dingding message failed, receive error ' 'message %s' , resp . text ) self . log . info ( 'Success Send Dingding message' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _read ( self , ti , try_number , metadata = None ) : if not metadata : metadata = { 'offset' : 0 } if 'offset' not in metadata : metadata [ 'offset' ] = 0 offset = metadata [ 'offset' ] log_id = self . _render_log_id ( ti , try_number ) logs = self . es_read ( log_id , offset ) next_offset = offset if not logs else logs [ - 1 ] . offset metadata [ 'offset' ] = next_offset # end_of_log_mark may contain characters like '\\n' which is needed to # have the log uploaded but will not be stored in elasticsearch. metadata [ 'end_of_log' ] = False if not logs else logs [ - 1 ] . message == self . end_of_log_mark . strip ( ) cur_ts = pendulum . now ( ) # Assume end of log after not receiving new log for 5 min, # as executor heartbeat is 1 min and there might be some # delay before Elasticsearch makes the log available. if 'last_log_timestamp' in metadata : last_log_ts = timezone . parse ( metadata [ 'last_log_timestamp' ] ) if cur_ts . diff ( last_log_ts ) . in_minutes ( ) >= 5 : metadata [ 'end_of_log' ] = True if offset != next_offset or 'last_log_timestamp' not in metadata : metadata [ 'last_log_timestamp' ] = str ( cur_ts ) message = '\\n' . join ( [ log . message for log in logs ] ) return message , metadata\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def es_read ( self , log_id , offset ) : # Offset is the unique key for sorting logs given log_id. s = Search ( using = self . client ) . query ( 'match_phrase' , log_id = log_id ) . sort ( 'offset' ) s = s . filter ( 'range' , offset = { 'gt' : offset } ) logs = [ ] if s . count ( ) != 0 : try : logs = s [ self . MAX_LINE_PER_PAGE * self . PAGE : self . MAX_LINE_PER_PAGE ] . execute ( ) except Exception as e : self . log . exception ( 'Could not read log with log_id: %s, error: %s' , log_id , str ( e ) ) return logs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _bind_parameters ( operation , parameters ) : # inspired by MySQL Python Connector (conversion.py) string_parameters = { } for ( name , value ) in iteritems ( parameters ) : if value is None : string_parameters [ name ] = 'NULL' elif isinstance ( value , basestring ) : string_parameters [ name ] = \"'\" + _escape ( value ) + \"'\" else : string_parameters [ name ] = str ( value ) return operation % string_parameters\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _bq_cast ( string_field , bq_type ) : if string_field is None : return None elif bq_type == 'INTEGER' : return int ( string_field ) elif bq_type == 'FLOAT' or bq_type == 'TIMESTAMP' : return float ( string_field ) elif bq_type == 'BOOLEAN' : if string_field not in [ 'true' , 'false' ] : raise ValueError ( \"{} must have value 'true' or 'false'\" . format ( string_field ) ) return string_field == 'true' else : return string_field\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _validate_value ( key , value , expected_type ) : if not isinstance ( value , expected_type ) : raise TypeError ( \"{} argument must have a type {} not {}\" . format ( key , expected_type , type ( value ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : service = self . get_service ( ) project = self . _get_field ( 'project' ) return BigQueryConnection ( service = service , project_id = project , use_legacy_sql = self . use_legacy_sql , location = self . location , num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_service ( self ) : http_authorized = self . _authorize ( ) return build ( 'bigquery' , 'v2' , http = http_authorized , cache_discovery = False )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_pandas_df ( self , sql , parameters = None , dialect = None ) : private_key = self . _get_field ( 'key_path' , None ) or self . _get_field ( 'keyfile_dict' , None ) if dialect is None : dialect = 'legacy' if self . use_legacy_sql else 'standard' return read_gbq ( sql , project_id = self . _get_field ( 'project' ) , dialect = dialect , verbose = False , private_key = private_key )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def table_exists ( self , project_id , dataset_id , table_id ) : service = self . get_service ( ) try : service . tables ( ) . get ( projectId = project_id , datasetId = dataset_id , tableId = table_id ) . execute ( num_retries = self . num_retries ) return True except HttpError as e : if e . resp [ 'status' ] == '404' : return False raise\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_empty_table ( self , project_id , dataset_id , table_id , schema_fields = None , time_partitioning = None , cluster_fields = None , labels = None , view = None , num_retries = None ) : project_id = project_id if project_id is not None else self . project_id table_resource = { 'tableReference' : { 'tableId' : table_id } } if schema_fields : table_resource [ 'schema' ] = { 'fields' : schema_fields } if time_partitioning : table_resource [ 'timePartitioning' ] = time_partitioning if cluster_fields : table_resource [ 'clustering' ] = { 'fields' : cluster_fields } if labels : table_resource [ 'labels' ] = labels if view : table_resource [ 'view' ] = view num_retries = num_retries if num_retries else self . num_retries self . log . info ( 'Creating Table %s:%s.%s' , project_id , dataset_id , table_id ) try : self . service . tables ( ) . insert ( projectId = project_id , datasetId = dataset_id , body = table_resource ) . execute ( num_retries = num_retries ) self . log . info ( 'Table created successfully: %s:%s.%s' , project_id , dataset_id , table_id ) except HttpError as err : raise AirflowException ( 'BigQuery job failed. Error was: {}' . format ( err . content ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_external_table ( self , external_project_dataset_table , schema_fields , source_uris , source_format = 'CSV' , autodetect = False , compression = 'NONE' , ignore_unknown_values = False , max_bad_records = 0 , skip_leading_rows = 0 , field_delimiter = ',' , quote_character = None , allow_quoted_newlines = False , allow_jagged_rows = False , src_fmt_configs = None , labels = None ) : if src_fmt_configs is None : src_fmt_configs = { } project_id , dataset_id , external_table_id = _split_tablename ( table_input = external_project_dataset_table , default_project_id = self . project_id , var_name = 'external_project_dataset_table' ) # bigquery only allows certain source formats # we check to make sure the passed source format is valid # if it's not, we raise a ValueError # Refer to this link for more details: # https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#externalDataConfiguration.sourceFormat source_format = source_format . upper ( ) allowed_formats = [ \"CSV\" , \"NEWLINE_DELIMITED_JSON\" , \"AVRO\" , \"GOOGLE_SHEETS\" , \"DATASTORE_BACKUP\" , \"PARQUET\" ] if source_format not in allowed_formats : raise ValueError ( \"{0} is not a valid source format. \" \"Please use one of the following types: {1}\" . format ( source_format , allowed_formats ) ) compression = compression . upper ( ) allowed_compressions = [ 'NONE' , 'GZIP' ] if compression not in allowed_compressions : raise ValueError ( \"{0} is not a valid compression format. \" \"Please use one of the following types: {1}\" . format ( compression , allowed_compressions ) ) table_resource = { 'externalDataConfiguration' : { 'autodetect' : autodetect , 'sourceFormat' : source_format , 'sourceUris' : source_uris , 'compression' : compression , 'ignoreUnknownValues' : ignore_unknown_values } , 'tableReference' : { 'projectId' : project_id , 'datasetId' : dataset_id , 'tableId' : external_table_id , } } if schema_fields : table_resource [ 'externalDataConfiguration' ] . update ( { 'schema' : { 'fields' : schema_fields } } ) self . log . info ( 'Creating external table: %s' , external_project_dataset_table ) if max_bad_records : table_resource [ 'externalDataConfiguration' ] [ 'maxBadRecords' ] = max_bad_records # if following fields are not specified in src_fmt_configs, # honor the top-level params for backward-compatibility if 'skipLeadingRows' not in src_fmt_configs : src_fmt_configs [ 'skipLeadingRows' ] = skip_leading_rows if 'fieldDelimiter' not in src_fmt_configs : src_fmt_configs [ 'fieldDelimiter' ] = field_delimiter if 'quote_character' not in src_fmt_configs : src_fmt_configs [ 'quote' ] = quote_character if 'allowQuotedNewlines' not in src_fmt_configs : src_fmt_configs [ 'allowQuotedNewlines' ] = allow_quoted_newlines if 'allowJaggedRows' not in src_fmt_configs : src_fmt_configs [ 'allowJaggedRows' ] = allow_jagged_rows src_fmt_to_param_mapping = { 'CSV' : 'csvOptions' , 'GOOGLE_SHEETS' : 'googleSheetsOptions' } src_fmt_to_configs_mapping = { 'csvOptions' : [ 'allowJaggedRows' , 'allowQuotedNewlines' , 'fieldDelimiter' , 'skipLeadingRows' , 'quote' ] , 'googleSheetsOptions' : [ 'skipLeadingRows' ] } if source_format in src_fmt_to_param_mapping . keys ( ) : valid_configs = src_fmt_to_configs_mapping [ src_fmt_to_param_mapping [ source_format ] ] src_fmt_configs = { k : v for k , v in src_fmt_configs . items ( ) if k in valid_configs } table_resource [ 'externalDataConfiguration' ] [ src_fmt_to_param_mapping [ source_format ] ] = src_fmt_configs if labels : table_resource [ 'labels' ] = labels try : self . service . tables ( ) . insert ( projectId = project_id , datasetId = dataset_id , body = table_resource ) . execute ( num_retries = self . num_retries ) self . log . info ( 'External table created successfully: %s' , external_project_dataset_table ) except HttpError as err : raise Exception ( 'BigQuery job failed. Error was: {}' . format ( err . content ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def patch_table ( self , dataset_id , table_id , project_id = None , description = None , expiration_time = None , external_data_configuration = None , friendly_name = None , labels = None , schema = None , time_partitioning = None , view = None , require_partition_filter = None ) : project_id = project_id if project_id is not None else self . project_id table_resource = { } if description is not None : table_resource [ 'description' ] = description if expiration_time is not None : table_resource [ 'expirationTime' ] = expiration_time if external_data_configuration : table_resource [ 'externalDataConfiguration' ] = external_data_configuration if friendly_name is not None : table_resource [ 'friendlyName' ] = friendly_name if labels : table_resource [ 'labels' ] = labels if schema : table_resource [ 'schema' ] = { 'fields' : schema } if time_partitioning : table_resource [ 'timePartitioning' ] = time_partitioning if view : table_resource [ 'view' ] = view if require_partition_filter is not None : table_resource [ 'requirePartitionFilter' ] = require_partition_filter self . log . info ( 'Patching Table %s:%s.%s' , project_id , dataset_id , table_id ) try : self . service . tables ( ) . patch ( projectId = project_id , datasetId = dataset_id , tableId = table_id , body = table_resource ) . execute ( num_retries = self . num_retries ) self . log . info ( 'Table patched successfully: %s:%s.%s' , project_id , dataset_id , table_id ) except HttpError as err : raise AirflowException ( 'BigQuery job failed. Error was: {}' . format ( err . content ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_query ( self , sql , destination_dataset_table = None , write_disposition = 'WRITE_EMPTY' , allow_large_results = False , flatten_results = None , udf_config = None , use_legacy_sql = None , maximum_billing_tier = None , maximum_bytes_billed = None , create_disposition = 'CREATE_IF_NEEDED' , query_params = None , labels = None , schema_update_options = ( ) , priority = 'INTERACTIVE' , time_partitioning = None , api_resource_configs = None , cluster_fields = None , location = None ) : if time_partitioning is None : time_partitioning = { } if location : self . location = location if not api_resource_configs : api_resource_configs = self . api_resource_configs else : _validate_value ( 'api_resource_configs' , api_resource_configs , dict ) configuration = deepcopy ( api_resource_configs ) if 'query' not in configuration : configuration [ 'query' ] = { } else : _validate_value ( \"api_resource_configs['query']\" , configuration [ 'query' ] , dict ) if sql is None and not configuration [ 'query' ] . get ( 'query' , None ) : raise TypeError ( '`BigQueryBaseCursor.run_query` ' 'missing 1 required positional argument: `sql`' ) # BigQuery also allows you to define how you want a table's schema to change # as a side effect of a query job # for more details: # https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.query.schemaUpdateOptions allowed_schema_update_options = [ 'ALLOW_FIELD_ADDITION' , \"ALLOW_FIELD_RELAXATION\" ] if not set ( allowed_schema_update_options ) . issuperset ( set ( schema_update_options ) ) : raise ValueError ( \"{0} contains invalid schema update options. \" \"Please only use one or more of the following \" \"options: {1}\" . format ( schema_update_options , allowed_schema_update_options ) ) if schema_update_options : if write_disposition not in [ \"WRITE_APPEND\" , \"WRITE_TRUNCATE\" ] : raise ValueError ( \"schema_update_options is only \" \"allowed if write_disposition is \" \"'WRITE_APPEND' or 'WRITE_TRUNCATE'.\" ) if destination_dataset_table : destination_project , destination_dataset , destination_table = _split_tablename ( table_input = destination_dataset_table , default_project_id = self . project_id ) destination_dataset_table = { 'projectId' : destination_project , 'datasetId' : destination_dataset , 'tableId' : destination_table , } if cluster_fields : cluster_fields = { 'fields' : cluster_fields } query_param_list = [ ( sql , 'query' , None , six . string_types ) , ( priority , 'priority' , 'INTERACTIVE' , six . string_types ) , ( use_legacy_sql , 'useLegacySql' , self . use_legacy_sql , bool ) , ( query_params , 'queryParameters' , None , list ) , ( udf_config , 'userDefinedFunctionResources' , None , list ) , ( maximum_billing_tier , 'maximumBillingTier' , None , int ) , ( maximum_bytes_billed , 'maximumBytesBilled' , None , float ) , ( time_partitioning , 'timePartitioning' , { } , dict ) , ( schema_update_options , 'schemaUpdateOptions' , None , tuple ) , ( destination_dataset_table , 'destinationTable' , None , dict ) , ( cluster_fields , 'clustering' , None , dict ) , ] for param_tuple in query_param_list : param , param_name , param_default , param_type = param_tuple if param_name not in configuration [ 'query' ] and param in [ None , { } , ( ) ] : if param_name == 'timePartitioning' : param_default = _cleanse_time_partitioning ( destination_dataset_table , time_partitioning ) param = param_default if param not in [ None , { } , ( ) ] : _api_resource_configs_duplication_check ( param_name , param , configuration [ 'query' ] ) configuration [ 'query' ] [ param_name ] = param # check valid type of provided param, # it last step because we can get param from 2 sources, # and first of all need to find it _validate_value ( param_name , configuration [ 'query' ] [ param_name ] , param_type ) if param_name == 'schemaUpdateOptions' and param : self . log . info ( \"Adding experimental 'schemaUpdateOptions': \" \"%s\" , schema_update_options ) if param_name == 'destinationTable' : for key in [ 'projectId' , 'datasetId' , 'tableId' ] : if key not in configuration [ 'query' ] [ 'destinationTable' ] : raise ValueError ( \"Not correct 'destinationTable' in \" \"api_resource_configs. 'destinationTable' \" \"must be a dict with {'projectId':'', \" \"'datasetId':'', 'tableId':''}\" ) configuration [ 'query' ] . update ( { 'allowLargeResults' : allow_large_results , 'flattenResults' : flatten_results , 'writeDisposition' : write_disposition , 'createDisposition' : create_disposition , } ) if 'useLegacySql' in configuration [ 'query' ] and configuration [ 'query' ] [ 'useLegacySql' ] and 'queryParameters' in configuration [ 'query' ] : raise ValueError ( \"Query parameters are not allowed \" \"when using legacy SQL\" ) if labels : _api_resource_configs_duplication_check ( 'labels' , labels , configuration ) configuration [ 'labels' ] = labels return self . run_with_configuration ( configuration )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_extract ( # noqa self , source_project_dataset_table , destination_cloud_storage_uris , compression = 'NONE' , export_format = 'CSV' , field_delimiter = ',' , print_header = True , labels = None ) : source_project , source_dataset , source_table = _split_tablename ( table_input = source_project_dataset_table , default_project_id = self . project_id , var_name = 'source_project_dataset_table' ) configuration = { 'extract' : { 'sourceTable' : { 'projectId' : source_project , 'datasetId' : source_dataset , 'tableId' : source_table , } , 'compression' : compression , 'destinationUris' : destination_cloud_storage_uris , 'destinationFormat' : export_format , } } if labels : configuration [ 'labels' ] = labels if export_format == 'CSV' : # Only set fieldDelimiter and printHeader fields if using CSV. # Google does not like it if you set these fields for other export # formats. configuration [ 'extract' ] [ 'fieldDelimiter' ] = field_delimiter configuration [ 'extract' ] [ 'printHeader' ] = print_header return self . run_with_configuration ( configuration )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_copy ( self , source_project_dataset_tables , destination_project_dataset_table , write_disposition = 'WRITE_EMPTY' , create_disposition = 'CREATE_IF_NEEDED' , labels = None ) : source_project_dataset_tables = ( [ source_project_dataset_tables ] if not isinstance ( source_project_dataset_tables , list ) else source_project_dataset_tables ) source_project_dataset_tables_fixup = [ ] for source_project_dataset_table in source_project_dataset_tables : source_project , source_dataset , source_table = _split_tablename ( table_input = source_project_dataset_table , default_project_id = self . project_id , var_name = 'source_project_dataset_table' ) source_project_dataset_tables_fixup . append ( { 'projectId' : source_project , 'datasetId' : source_dataset , 'tableId' : source_table } ) destination_project , destination_dataset , destination_table = _split_tablename ( table_input = destination_project_dataset_table , default_project_id = self . project_id ) configuration = { 'copy' : { 'createDisposition' : create_disposition , 'writeDisposition' : write_disposition , 'sourceTables' : source_project_dataset_tables_fixup , 'destinationTable' : { 'projectId' : destination_project , 'datasetId' : destination_dataset , 'tableId' : destination_table } } } if labels : configuration [ 'labels' ] = labels return self . run_with_configuration ( configuration )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_load ( self , destination_project_dataset_table , source_uris , schema_fields = None , source_format = 'CSV' , create_disposition = 'CREATE_IF_NEEDED' , skip_leading_rows = 0 , write_disposition = 'WRITE_EMPTY' , field_delimiter = ',' , max_bad_records = 0 , quote_character = None , ignore_unknown_values = False , allow_quoted_newlines = False , allow_jagged_rows = False , schema_update_options = ( ) , src_fmt_configs = None , time_partitioning = None , cluster_fields = None , autodetect = False ) : # bigquery only allows certain source formats # we check to make sure the passed source format is valid # if it's not, we raise a ValueError # Refer to this link for more details: # https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.query.tableDefinitions.(key).sourceFormat if schema_fields is None and not autodetect : raise ValueError ( 'You must either pass a schema or autodetect=True.' ) if src_fmt_configs is None : src_fmt_configs = { } source_format = source_format . upper ( ) allowed_formats = [ \"CSV\" , \"NEWLINE_DELIMITED_JSON\" , \"AVRO\" , \"GOOGLE_SHEETS\" , \"DATASTORE_BACKUP\" , \"PARQUET\" ] if source_format not in allowed_formats : raise ValueError ( \"{0} is not a valid source format. \" \"Please use one of the following types: {1}\" . format ( source_format , allowed_formats ) ) # bigquery also allows you to define how you want a table's schema to change # as a side effect of a load # for more details: # https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.load.schemaUpdateOptions allowed_schema_update_options = [ 'ALLOW_FIELD_ADDITION' , \"ALLOW_FIELD_RELAXATION\" ] if not set ( allowed_schema_update_options ) . issuperset ( set ( schema_update_options ) ) : raise ValueError ( \"{0} contains invalid schema update options.\" \"Please only use one or more of the following options: {1}\" . format ( schema_update_options , allowed_schema_update_options ) ) destination_project , destination_dataset , destination_table = _split_tablename ( table_input = destination_project_dataset_table , default_project_id = self . project_id , var_name = 'destination_project_dataset_table' ) configuration = { 'load' : { 'autodetect' : autodetect , 'createDisposition' : create_disposition , 'destinationTable' : { 'projectId' : destination_project , 'datasetId' : destination_dataset , 'tableId' : destination_table , } , 'sourceFormat' : source_format , 'sourceUris' : source_uris , 'writeDisposition' : write_disposition , 'ignoreUnknownValues' : ignore_unknown_values } } time_partitioning = _cleanse_time_partitioning ( destination_project_dataset_table , time_partitioning ) if time_partitioning : configuration [ 'load' ] . update ( { 'timePartitioning' : time_partitioning } ) if cluster_fields : configuration [ 'load' ] . update ( { 'clustering' : { 'fields' : cluster_fields } } ) if schema_fields : configuration [ 'load' ] [ 'schema' ] = { 'fields' : schema_fields } if schema_update_options : if write_disposition not in [ \"WRITE_APPEND\" , \"WRITE_TRUNCATE\" ] : raise ValueError ( \"schema_update_options is only \" \"allowed if write_disposition is \" \"'WRITE_APPEND' or 'WRITE_TRUNCATE'.\" ) else : self . log . info ( \"Adding experimental 'schemaUpdateOptions': %s\" , schema_update_options ) configuration [ 'load' ] [ 'schemaUpdateOptions' ] = schema_update_options if max_bad_records : configuration [ 'load' ] [ 'maxBadRecords' ] = max_bad_records # if following fields are not specified in src_fmt_configs, # honor the top-level params for backward-compatibility if 'skipLeadingRows' not in src_fmt_configs : src_fmt_configs [ 'skipLeadingRows' ] = skip_leading_rows if 'fieldDelimiter' not in src_fmt_configs : src_fmt_configs [ 'fieldDelimiter' ] = field_delimiter if 'ignoreUnknownValues' not in src_fmt_configs : src_fmt_configs [ 'ignoreUnknownValues' ] = ignore_unknown_values if quote_character is not None : src_fmt_configs [ 'quote' ] = quote_character if allow_quoted_newlines : src_fmt_configs [ 'allowQuotedNewlines' ] = allow_quoted_newlines src_fmt_to_configs_mapping = { 'CSV' : [ 'allowJaggedRows' , 'allowQuotedNewlines' , 'autodetect' , 'fieldDelimiter' , 'skipLeadingRows' , 'ignoreUnknownValues' , 'nullMarker' , 'quote' ] , 'DATASTORE_BACKUP' : [ 'projectionFields' ] , 'NEWLINE_DELIMITED_JSON' : [ 'autodetect' , 'ignoreUnknownValues' ] , 'PARQUET' : [ 'autodetect' , 'ignoreUnknownValues' ] , 'AVRO' : [ 'useAvroLogicalTypes' ] , } valid_configs = src_fmt_to_configs_mapping [ source_format ] src_fmt_configs = { k : v for k , v in src_fmt_configs . items ( ) if k in valid_configs } configuration [ 'load' ] . update ( src_fmt_configs ) if allow_jagged_rows : configuration [ 'load' ] [ 'allowJaggedRows' ] = allow_jagged_rows return self . run_with_configuration ( configuration )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_with_configuration ( self , configuration ) : jobs = self . service . jobs ( ) job_data = { 'configuration' : configuration } # Send query and wait for reply. query_reply = jobs . insert ( projectId = self . project_id , body = job_data ) . execute ( num_retries = self . num_retries ) self . running_job_id = query_reply [ 'jobReference' ] [ 'jobId' ] if 'location' in query_reply [ 'jobReference' ] : location = query_reply [ 'jobReference' ] [ 'location' ] else : location = self . location # Wait for query to finish. keep_polling_job = True while keep_polling_job : try : if location : job = jobs . get ( projectId = self . project_id , jobId = self . running_job_id , location = location ) . execute ( num_retries = self . num_retries ) else : job = jobs . get ( projectId = self . project_id , jobId = self . running_job_id ) . execute ( num_retries = self . num_retries ) if job [ 'status' ] [ 'state' ] == 'DONE' : keep_polling_job = False # Check if job had errors. if 'errorResult' in job [ 'status' ] : raise Exception ( 'BigQuery job failed. Final error was: {}. The job was: {}' . format ( job [ 'status' ] [ 'errorResult' ] , job ) ) else : self . log . info ( 'Waiting for job to complete : %s, %s' , self . project_id , self . running_job_id ) time . sleep ( 5 ) except HttpError as err : if err . resp . status in [ 500 , 503 ] : self . log . info ( '%s: Retryable error, waiting for job to complete: %s' , err . resp . status , self . running_job_id ) time . sleep ( 5 ) else : raise Exception ( 'BigQuery job status check failed. Final error was: {}' . format ( err . resp . status ) ) return self . running_job_id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def cancel_query ( self ) : jobs = self . service . jobs ( ) if ( self . running_job_id and not self . poll_job_complete ( self . running_job_id ) ) : self . log . info ( 'Attempting to cancel job : %s, %s' , self . project_id , self . running_job_id ) if self . location : jobs . cancel ( projectId = self . project_id , jobId = self . running_job_id , location = self . location ) . execute ( num_retries = self . num_retries ) else : jobs . cancel ( projectId = self . project_id , jobId = self . running_job_id ) . execute ( num_retries = self . num_retries ) else : self . log . info ( 'No running BigQuery jobs to cancel.' ) return # Wait for all the calls to cancel to finish max_polling_attempts = 12 polling_attempts = 0 job_complete = False while polling_attempts < max_polling_attempts and not job_complete : polling_attempts = polling_attempts + 1 job_complete = self . poll_job_complete ( self . running_job_id ) if job_complete : self . log . info ( 'Job successfully canceled: %s, %s' , self . project_id , self . running_job_id ) elif polling_attempts == max_polling_attempts : self . log . info ( \"Stopping polling due to timeout. Job with id %s \" \"has not completed cancel and may or may not finish.\" , self . running_job_id ) else : self . log . info ( 'Waiting for canceled job with id %s to finish.' , self . running_job_id ) time . sleep ( 5 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_schema ( self , dataset_id , table_id ) : tables_resource = self . service . tables ( ) . get ( projectId = self . project_id , datasetId = dataset_id , tableId = table_id ) . execute ( num_retries = self . num_retries ) return tables_resource [ 'schema' ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_tabledata ( self , dataset_id , table_id , max_results = None , selected_fields = None , page_token = None , start_index = None ) : optional_params = { } if max_results : optional_params [ 'maxResults' ] = max_results if selected_fields : optional_params [ 'selectedFields' ] = selected_fields if page_token : optional_params [ 'pageToken' ] = page_token if start_index : optional_params [ 'startIndex' ] = start_index return ( self . service . tabledata ( ) . list ( projectId = self . project_id , datasetId = dataset_id , tableId = table_id , * * optional_params ) . execute ( num_retries = self . num_retries ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_table_delete ( self , deletion_dataset_table , ignore_if_missing = False ) : deletion_project , deletion_dataset , deletion_table = _split_tablename ( table_input = deletion_dataset_table , default_project_id = self . project_id ) try : self . service . tables ( ) . delete ( projectId = deletion_project , datasetId = deletion_dataset , tableId = deletion_table ) . execute ( num_retries = self . num_retries ) self . log . info ( 'Deleted table %s:%s.%s.' , deletion_project , deletion_dataset , deletion_table ) except HttpError : if not ignore_if_missing : raise Exception ( 'Table deletion failed. Table does not exist.' ) else : self . log . info ( 'Table does not exist. Skipping.' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_table_upsert ( self , dataset_id , table_resource , project_id = None ) : # check to see if the table exists table_id = table_resource [ 'tableReference' ] [ 'tableId' ] project_id = project_id if project_id is not None else self . project_id tables_list_resp = self . service . tables ( ) . list ( projectId = project_id , datasetId = dataset_id ) . execute ( num_retries = self . num_retries ) while True : for table in tables_list_resp . get ( 'tables' , [ ] ) : if table [ 'tableReference' ] [ 'tableId' ] == table_id : # found the table, do update self . log . info ( 'Table %s:%s.%s exists, updating.' , project_id , dataset_id , table_id ) return self . service . tables ( ) . update ( projectId = project_id , datasetId = dataset_id , tableId = table_id , body = table_resource ) . execute ( num_retries = self . num_retries ) # If there is a next page, we need to check the next page. if 'nextPageToken' in tables_list_resp : tables_list_resp = self . service . tables ( ) . list ( projectId = project_id , datasetId = dataset_id , pageToken = tables_list_resp [ 'nextPageToken' ] ) . execute ( num_retries = self . num_retries ) # If there is no next page, then the table doesn't exist. else : # do insert self . log . info ( 'Table %s:%s.%s does not exist. creating.' , project_id , dataset_id , table_id ) return self . service . tables ( ) . insert ( projectId = project_id , datasetId = dataset_id , body = table_resource ) . execute ( num_retries = self . num_retries )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_grant_dataset_view_access ( self , source_dataset , view_dataset , view_table , source_project = None , view_project = None ) : # Apply default values to projects source_project = source_project if source_project else self . project_id view_project = view_project if view_project else self . project_id # we don't want to clobber any existing accesses, so we have to get # info on the dataset before we can add view access source_dataset_resource = self . service . datasets ( ) . get ( projectId = source_project , datasetId = source_dataset ) . execute ( num_retries = self . num_retries ) access = source_dataset_resource [ 'access' ] if 'access' in source_dataset_resource else [ ] view_access = { 'view' : { 'projectId' : view_project , 'datasetId' : view_dataset , 'tableId' : view_table } } # check to see if the view we want to add already exists. if view_access not in access : self . log . info ( 'Granting table %s:%s.%s authorized view access to %s:%s dataset.' , view_project , view_dataset , view_table , source_project , source_dataset ) access . append ( view_access ) return self . service . datasets ( ) . patch ( projectId = source_project , datasetId = source_dataset , body = { 'access' : access } ) . execute ( num_retries = self . num_retries ) else : # if view is already in access, do nothing. self . log . info ( 'Table %s:%s.%s already has authorized view access to %s:%s dataset.' , view_project , view_dataset , view_table , source_project , source_dataset ) return source_dataset_resource\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_empty_dataset ( self , dataset_id = \"\" , project_id = \"\" , dataset_reference = None ) : if dataset_reference : _validate_value ( 'dataset_reference' , dataset_reference , dict ) else : dataset_reference = { } if \"datasetReference\" not in dataset_reference : dataset_reference [ \"datasetReference\" ] = { } if not dataset_reference [ \"datasetReference\" ] . get ( \"datasetId\" ) and not dataset_id : raise ValueError ( \"{} not provided datasetId. Impossible to create dataset\" ) dataset_required_params = [ ( dataset_id , \"datasetId\" , \"\" ) , ( project_id , \"projectId\" , self . project_id ) ] for param_tuple in dataset_required_params : param , param_name , param_default = param_tuple if param_name not in dataset_reference [ 'datasetReference' ] : if param_default and not param : self . log . info ( \"%s was not specified. Will be used default value %s.\" , param_name , param_default ) param = param_default dataset_reference [ 'datasetReference' ] . update ( { param_name : param } ) elif param : _api_resource_configs_duplication_check ( param_name , param , dataset_reference [ 'datasetReference' ] , 'dataset_reference' ) dataset_id = dataset_reference . get ( \"datasetReference\" ) . get ( \"datasetId\" ) dataset_project_id = dataset_reference . get ( \"datasetReference\" ) . get ( \"projectId\" ) self . log . info ( 'Creating Dataset: %s in project: %s ' , dataset_id , dataset_project_id ) try : self . service . datasets ( ) . insert ( projectId = dataset_project_id , body = dataset_reference ) . execute ( num_retries = self . num_retries ) self . log . info ( 'Dataset created successfully: In project %s ' 'Dataset %s' , dataset_project_id , dataset_id ) except HttpError as err : raise AirflowException ( 'BigQuery job failed. Error was: {}' . format ( err . content ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_dataset ( self , project_id , dataset_id ) : project_id = project_id if project_id is not None else self . project_id self . log . info ( 'Deleting from project: %s Dataset:%s' , project_id , dataset_id ) try : self . service . datasets ( ) . delete ( projectId = project_id , datasetId = dataset_id ) . execute ( num_retries = self . num_retries ) self . log . info ( 'Dataset deleted successfully: In project %s ' 'Dataset %s' , project_id , dataset_id ) except HttpError as err : raise AirflowException ( 'BigQuery job failed. Error was: {}' . format ( err . content ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_dataset ( self , dataset_id , project_id = None ) : if not dataset_id or not isinstance ( dataset_id , str ) : raise ValueError ( \"dataset_id argument must be provided and has \" \"a type 'str'. You provided: {}\" . format ( dataset_id ) ) dataset_project_id = project_id if project_id else self . project_id try : dataset_resource = self . service . datasets ( ) . get ( datasetId = dataset_id , projectId = dataset_project_id ) . execute ( num_retries = self . num_retries ) self . log . info ( \"Dataset Resource: %s\" , dataset_resource ) except HttpError as err : raise AirflowException ( 'BigQuery job failed. Error was: {}' . format ( err . content ) ) return dataset_resource\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_datasets_list ( self , project_id = None ) : dataset_project_id = project_id if project_id else self . project_id try : datasets_list = self . service . datasets ( ) . list ( projectId = dataset_project_id ) . execute ( num_retries = self . num_retries ) [ 'datasets' ] self . log . info ( \"Datasets List: %s\" , datasets_list ) except HttpError as err : raise AirflowException ( 'BigQuery job failed. Error was: {}' . format ( err . content ) ) return datasets_list\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_all ( self , project_id , dataset_id , table_id , rows , ignore_unknown_values = False , skip_invalid_rows = False , fail_on_error = False ) : dataset_project_id = project_id if project_id else self . project_id body = { \"rows\" : rows , \"ignoreUnknownValues\" : ignore_unknown_values , \"kind\" : \"bigquery#tableDataInsertAllRequest\" , \"skipInvalidRows\" : skip_invalid_rows , } try : self . log . info ( 'Inserting %s row(s) into Table %s:%s.%s' , len ( rows ) , dataset_project_id , dataset_id , table_id ) resp = self . service . tabledata ( ) . insertAll ( projectId = dataset_project_id , datasetId = dataset_id , tableId = table_id , body = body ) . execute ( num_retries = self . num_retries ) if 'insertErrors' not in resp : self . log . info ( 'All row(s) inserted successfully: %s:%s.%s' , dataset_project_id , dataset_id , table_id ) else : error_msg = '{} insert error(s) occurred: {}:{}.{}. Details: {}' . format ( len ( resp [ 'insertErrors' ] ) , dataset_project_id , dataset_id , table_id , resp [ 'insertErrors' ] ) if fail_on_error : raise AirflowException ( 'BigQuery job failed. Error was: {}' . format ( error_msg ) ) self . log . info ( error_msg ) except HttpError as err : raise AirflowException ( 'BigQuery job failed. Error was: {}' . format ( err . content ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , operation , parameters = None ) : sql = _bind_parameters ( operation , parameters ) if parameters else operation self . job_id = self . run_query ( sql )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def executemany ( self , operation , seq_of_parameters ) : for parameters in seq_of_parameters : self . execute ( operation , parameters )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def next ( self ) : if not self . job_id : return None if len ( self . buffer ) == 0 : if self . all_pages_loaded : return None query_results = ( self . service . jobs ( ) . getQueryResults ( projectId = self . project_id , jobId = self . job_id , pageToken = self . page_token ) . execute ( num_retries = self . num_retries ) ) if 'rows' in query_results and query_results [ 'rows' ] : self . page_token = query_results . get ( 'pageToken' ) fields = query_results [ 'schema' ] [ 'fields' ] col_types = [ field [ 'type' ] for field in fields ] rows = query_results [ 'rows' ] for dict_row in rows : typed_row = ( [ _bq_cast ( vs [ 'v' ] , col_types [ idx ] ) for idx , vs in enumerate ( dict_row [ 'f' ] ) ] ) self . buffer . append ( typed_row ) if not self . page_token : self . all_pages_loaded = True else : # Reset all state since we've exhausted the results. self . page_token = None self . job_id = None self . page_token = None return None return self . buffer . pop ( 0 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fetchmany ( self , size = None ) : if size is None : size = self . arraysize result = [ ] for _ in range ( size ) : one = self . fetchone ( ) if one is None : break else : result . append ( one ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fetchall ( self ) : result = [ ] while True : one = self . fetchone ( ) if one is None : break else : result . append ( one ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def configure_manifest_files ( app ) : def parse_manifest_json ( ) : # noinspection PyBroadException try : global manifest manifest_file = os . path . join ( os . path . dirname ( __file__ ) , 'static/dist/manifest.json' ) with open ( manifest_file , 'r' ) as f : manifest . update ( json . load ( f ) ) for k in manifest . keys ( ) : manifest [ k ] = os . path . join ( \"dist\" , manifest [ k ] ) except Exception : print ( \"Please make sure to build the frontend in \" \"static/ directory and restart the server\" ) pass def get_asset_url ( filename ) : if app . debug : parse_manifest_json ( ) return url_for ( 'static' , filename = manifest . get ( filename , '' ) ) parse_manifest_json ( ) @ app . context_processor def get_url_for_asset ( ) : \"\"\" Template tag to return the asset URL. WebPack renders the assets after minification and modification under the static/dist folder. This template tag reads the asset name in manifest.json and returns the appropriate file. \"\"\" return dict ( url_for_asset = get_asset_url )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _query_postgres ( self ) : postgres = PostgresHook ( postgres_conn_id = self . postgres_conn_id ) conn = postgres . get_conn ( ) cursor = conn . cursor ( ) cursor . execute ( self . sql , self . parameters ) return cursor\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _write_local_data_files ( self , cursor ) : schema = list ( map ( lambda schema_tuple : schema_tuple [ 0 ] , cursor . description ) ) tmp_file_handles = { } row_no = 0 def _create_new_file ( ) : handle = NamedTemporaryFile ( delete = True ) filename = self . filename . format ( len ( tmp_file_handles ) ) tmp_file_handles [ filename ] = handle return handle # Don't create a file if there is nothing to write if cursor . rowcount > 0 : tmp_file_handle = _create_new_file ( ) for row in cursor : # Convert datetime objects to utc seconds, and decimals to floats row = map ( self . convert_types , row ) row_dict = dict ( zip ( schema , row ) ) s = json . dumps ( row_dict , sort_keys = True ) . encode ( 'utf-8' ) tmp_file_handle . write ( s ) # Append newline to make dumps BigQuery compatible. tmp_file_handle . write ( b'\\n' ) # Stop if the file exceeds the file size limit. if tmp_file_handle . tell ( ) >= self . approx_max_file_size_bytes : tmp_file_handle = _create_new_file ( ) row_no += 1 self . log . info ( 'Received %s rows over %s files' , row_no , len ( tmp_file_handles ) ) return tmp_file_handles\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _write_local_schema_file ( self , cursor ) : schema = [ ] for field in cursor . description : # See PEP 249 for details about the description tuple. field_name = field [ 0 ] field_type = self . type_map ( field [ 1 ] ) field_mode = 'REPEATED' if field [ 1 ] in ( 1009 , 1005 , 1007 , 1016 ) else 'NULLABLE' schema . append ( { 'name' : field_name , 'type' : field_type , 'mode' : field_mode , } ) self . log . info ( 'Using schema for %s: %s' , self . schema_filename , schema ) tmp_schema_file_handle = NamedTemporaryFile ( delete = True ) s = json . dumps ( schema , sort_keys = True ) . encode ( 'utf-8' ) tmp_schema_file_handle . write ( s ) return { self . schema_filename : tmp_schema_file_handle }\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def convert_types ( cls , value ) : if type ( value ) in ( datetime . datetime , datetime . date ) : return time . mktime ( value . timetuple ( ) ) elif type ( value ) == datetime . time : formated_time = time . strptime ( str ( value ) , \"%H:%M:%S\" ) return datetime . timedelta ( hours = formated_time . tm_hour , minutes = formated_time . tm_min , seconds = formated_time . tm_sec ) . seconds elif isinstance ( value , Decimal ) : return float ( value ) else : return value\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_intermediate_dirs ( sftp_client , remote_directory ) : if remote_directory == '/' : sftp_client . chdir ( '/' ) return if remote_directory == '' : return try : sftp_client . chdir ( remote_directory ) except IOError : dirname , basename = os . path . split ( remote_directory . rstrip ( '/' ) ) _make_intermediate_dirs ( sftp_client , dirname ) sftp_client . mkdir ( basename ) sftp_client . chdir ( basename ) return\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_queue ( self , queue_name , attributes = None ) : return self . get_conn ( ) . create_queue ( QueueName = queue_name , Attributes = attributes or { } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def send_message ( self , queue_url , message_body , delay_seconds = 0 , message_attributes = None ) : return self . get_conn ( ) . send_message ( QueueUrl = queue_url , MessageBody = message_body , DelaySeconds = delay_seconds , MessageAttributes = message_attributes or { } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _integrate_plugins ( ) : from airflow . plugins_manager import hooks_modules for hooks_module in hooks_modules : sys . modules [ hooks_module . __name__ ] = hooks_module globals ( ) [ hooks_module . _name ] = hooks_module\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_command ( self , run_with = None , join_args = False ) : run_with = run_with or [ ] cmd = [ \" \" . join ( self . _command ) ] if join_args else self . _command full_cmd = run_with + cmd self . log . info ( 'Running: %s' , full_cmd ) proc = subprocess . Popen ( full_cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = True , close_fds = True , env = os . environ . copy ( ) , preexec_fn = os . setsid ) # Start daemon thread to read subprocess logging output log_reader = threading . Thread ( target = self . _read_task_logs , args = ( proc . stdout , ) , ) log_reader . daemon = True log_reader . start ( ) return proc\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def on_finish ( self ) : if self . _cfg_path and os . path . isfile ( self . _cfg_path ) : if self . run_as_user : subprocess . call ( [ 'sudo' , 'rm' , self . _cfg_path ] , close_fds = True ) else : os . remove ( self . _cfg_path )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _main ( ) : # Parse arguments usage = \"usage: nvd3.py [options]\" parser = OptionParser ( usage = usage , version = ( \"python-nvd3 - Charts generator with \" \"nvd3.js and d3.js\" ) ) parser . add_option ( \"-q\" , \"--quiet\" , action = \"store_false\" , dest = \"verbose\" , default = True , help = \"don't print messages to stdout\" ) ( options , args ) = parser . parse_args ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def add_serie ( self , y , x , name = None , extra = None , * * kwargs ) : if not name : name = \"Serie %d\" % ( self . serie_no ) # For scatterChart shape & size fields are added in serie if 'shape' in kwargs or 'size' in kwargs : csize = kwargs . get ( 'size' , 1 ) cshape = kwargs . get ( 'shape' , 'circle' ) serie = [ { 'x' : x [ i ] , 'y' : j , 'shape' : cshape , 'size' : csize [ i ] if isinstance ( csize , list ) else csize } for i , j in enumerate ( y ) ] else : if self . model == 'pieChart' : serie = [ { 'label' : x [ i ] , 'value' : y } for i , y in enumerate ( y ) ] else : serie = [ { 'x' : x [ i ] , 'y' : y } for i , y in enumerate ( y ) ] data_keyvalue = { 'values' : serie , 'key' : name } # multiChart # Histogram type='bar' for the series if 'type' in kwargs and kwargs [ 'type' ] : data_keyvalue [ 'type' ] = kwargs [ 'type' ] # Define on which Y axis the serie is related # a chart can have 2 Y axis, left and right, by default only one Y Axis is used if 'yaxis' in kwargs and kwargs [ 'yaxis' ] : data_keyvalue [ 'yAxis' ] = kwargs [ 'yaxis' ] else : if self . model != 'pieChart' : data_keyvalue [ 'yAxis' ] = '1' if 'bar' in kwargs and kwargs [ 'bar' ] : data_keyvalue [ 'bar' ] = 'true' if 'disabled' in kwargs and kwargs [ 'disabled' ] : data_keyvalue [ 'disabled' ] = 'true' if 'color' in kwargs and kwargs [ 'color' ] : data_keyvalue [ 'color' ] = kwargs [ 'color' ] if extra : if self . model == 'pieChart' : if 'color_list' in extra and extra [ 'color_list' ] : self . color_list = extra [ 'color_list' ] if extra . get ( 'date_format' ) : self . charttooltip_dateformat = extra [ 'date_format' ] if extra . get ( 'tooltip' ) : self . custom_tooltip_flag = True if self . model != 'pieChart' : _start = extra [ 'tooltip' ] [ 'y_start' ] _end = extra [ 'tooltip' ] [ 'y_end' ] _start = ( \"'\" + str ( _start ) + \"' + \" ) if _start else '' _end = ( \" + '\" + str ( _end ) + \"'\" ) if _end else '' if self . model == 'linePlusBarChart' : if self . tooltip_condition_string : self . tooltip_condition_string += stab ( 5 ) self . tooltip_condition_string += stab ( 0 ) + \"if(key.indexOf('\" + name + \"') > -1 ){\\n\" + stab ( 6 ) + \"var y = \" + _start + \" String(graph.point.y) \" + _end + \";\\n\" + stab ( 5 ) + \"}\\n\" elif self . model == 'cumulativeLineChart' : self . tooltip_condition_string += stab ( 0 ) + \"if(key == '\" + name + \"'){\\n\" + stab ( 6 ) + \"var y = \" + _start + \" String(e) \" + _end + \";\\n\" + stab ( 5 ) + \"}\\n\" else : self . tooltip_condition_string += stab ( 5 ) + \"if(key == '\" + name + \"'){\\n\" + stab ( 6 ) + \"var y = \" + _start + \" String(graph.point.y) \" + _end + \";\\n\" + stab ( 5 ) + \"}\\n\" if self . model == 'pieChart' : _start = extra [ 'tooltip' ] [ 'y_start' ] _end = extra [ 'tooltip' ] [ 'y_end' ] _start = ( \"'\" + str ( _start ) + \"' + \" ) if _start else '' _end = ( \" + '\" + str ( _end ) + \"'\" ) if _end else '' self . tooltip_condition_string += \"var y = \" + _start + \" String(y) \" + _end + \";\\n\" # Increment series counter & append self . serie_no += 1 self . series . append ( data_keyvalue )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def buildcontent ( self ) : self . buildcontainer ( ) # if the subclass has a method buildjs this method will be # called instead of the method defined here # when this subclass method is entered it does call # the method buildjschart defined here self . buildjschart ( ) self . htmlcontent = self . template_content_nvd3 . render ( chart = self )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def buildhtml ( self ) : self . buildcontent ( ) self . content = self . htmlcontent self . htmlcontent = self . template_page_nvd3 . render ( chart = self )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def buildhtmlheader ( self ) : self . htmlheader = '' # If the JavaScript assets have already been injected, don't bother re-sourcing them. global _js_initialized if '_js_initialized' not in globals ( ) or not _js_initialized : for css in self . header_css : self . htmlheader += css for js in self . header_js : self . htmlheader += js\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def buildcontainer ( self ) : if self . container : return # Create SVG div with style if self . width : if self . width [ - 1 ] != '%' : self . style += 'width:%spx;' % self . width else : self . style += 'width:%s;' % self . width if self . height : if self . height [ - 1 ] != '%' : self . style += 'height:%spx;' % self . height else : self . style += 'height:%s;' % self . height if self . style : self . style = 'style=\"%s\"' % self . style self . container = self . containerheader + '<div id=\"%s\"><svg %s></svg></div>\\n' % ( self . name , self . style )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def buildjschart ( self ) : self . jschart = '' # add custom tooltip string in jschart # default condition (if build_custom_tooltip is not called explicitly with date_flag=True) if self . tooltip_condition_string == '' : self . tooltip_condition_string = 'var y = String(graph.point.y);\\n' # Include data self . series_js = json . dumps ( self . series )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_x_axis ( self , name , label = None , format = None , date = False , custom_format = False ) : axis = { } if custom_format and format : axis [ 'tickFormat' ] = format elif format : if format == 'AM_PM' : axis [ 'tickFormat' ] = \"function(d) { return get_am_pm(parseInt(d)); }\" else : axis [ 'tickFormat' ] = \"d3.format(',%s')\" % format if label : axis [ 'axisLabel' ] = \"'\" + label + \"'\" # date format : see https://github.com/mbostock/d3/wiki/Time-Formatting if date : self . dateformat = format axis [ 'tickFormat' ] = ( \"function(d) { return d3.time.format('%s')\" \"(new Date(parseInt(d))) }\\n\" \"\" % self . dateformat ) # flag is the x Axis is a date if name [ 0 ] == 'x' : self . x_axis_date = True # Add new axis to list of axis self . axislist [ name ] = axis # Create x2Axis if focus_enable if name == \"xAxis\" and self . focus_enable : self . axislist [ 'x2Axis' ] = axis\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_y_axis ( self , name , label = None , format = None , custom_format = False ) : axis = { } if custom_format and format : axis [ 'tickFormat' ] = format elif format : axis [ 'tickFormat' ] = \"d3.format(',%s')\" % format if label : axis [ 'axisLabel' ] = \"'\" + label + \"'\" # Add new axis to list of axis self . axislist [ name ] = axis\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def buildcontent ( self ) : self . buildcontainer ( ) # if the subclass has a method buildjs this method will be # called instead of the method defined here # when this subclass method is entered it does call # the method buildjschart defined here self . buildjschart ( ) self . htmlcontent = self . template_chart_nvd3 . render ( chart = self )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . sqlite_conn_id ) conn = sqlite3 . connect ( conn . host ) return conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def action_logging ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : with create_session ( ) as session : if g . user . is_anonymous : user = 'anonymous' else : user = g . user . username log = Log ( event = f . __name__ , task_instance = None , owner = user , extra = str ( list ( request . args . items ( ) ) ) , task_id = request . args . get ( 'task_id' ) , dag_id = request . args . get ( 'dag_id' ) ) if 'execution_date' in request . args : log . execution_date = pendulum . parse ( request . args . get ( 'execution_date' ) ) session . add ( log ) return f ( * args , * * kwargs ) return wrapper\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def gzipped ( f ) : @ functools . wraps ( f ) def view_func ( * args , * * kwargs ) : @ after_this_request def zipper ( response ) : accept_encoding = request . headers . get ( 'Accept-Encoding' , '' ) if 'gzip' not in accept_encoding . lower ( ) : return response response . direct_passthrough = False if ( response . status_code < 200 or response . status_code >= 300 or 'Content-Encoding' in response . headers ) : return response gzip_buffer = IO ( ) gzip_file = gzip . GzipFile ( mode = 'wb' , fileobj = gzip_buffer ) gzip_file . write ( response . data ) gzip_file . close ( ) response . data = gzip_buffer . getvalue ( ) response . headers [ 'Content-Encoding' ] = 'gzip' response . headers [ 'Vary' ] = 'Accept-Encoding' response . headers [ 'Content-Length' ] = len ( response . data ) return response return f ( * args , * * kwargs ) return view_func\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def has_dag_access ( * * dag_kwargs ) : def decorator ( f ) : @ functools . wraps ( f ) def wrapper ( self , * args , * * kwargs ) : has_access = self . appbuilder . sm . has_access dag_id = request . args . get ( 'dag_id' ) # if it is false, we need to check whether user has write access on the dag can_dag_edit = dag_kwargs . get ( 'can_dag_edit' , False ) # 1. check whether the user has can_dag_edit permissions on all_dags # 2. if 1 false, check whether the user # has can_dag_edit permissions on the dag # 3. if 2 false, check whether it is can_dag_read view, # and whether user has the permissions if ( has_access ( 'can_dag_edit' , 'all_dags' ) or has_access ( 'can_dag_edit' , dag_id ) or ( not can_dag_edit and ( has_access ( 'can_dag_read' , 'all_dags' ) or has_access ( 'can_dag_read' , dag_id ) ) ) ) : return f ( self , * args , * * kwargs ) else : flash ( \"Access is Denied\" , \"danger\" ) return redirect ( url_for ( self . appbuilder . sm . auth_view . __class__ . __name__ + \".login\" ) ) return wrapper return decorator\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_last_dagrun ( dag_id , session , include_externally_triggered = False ) : DR = DagRun query = session . query ( DR ) . filter ( DR . dag_id == dag_id ) if not include_externally_triggered : query = query . filter ( DR . external_trigger == False ) # noqa query = query . order_by ( DR . execution_date . desc ( ) ) return query . first ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_dagrun ( self , run_id , state , execution_date , start_date = None , external_trigger = False , conf = None , session = None ) : return self . get_dag ( ) . create_dagrun ( run_id = run_id , state = state , execution_date = execution_date , start_date = start_date , external_trigger = external_trigger , conf = conf , session = session )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : hook = SQSHook ( aws_conn_id = self . aws_conn_id ) result = hook . send_message ( queue_url = self . sqs_queue , message_body = self . message_content , delay_seconds = self . delay_seconds , message_attributes = self . message_attributes ) self . log . info ( 'result is send_message is %s' , result ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def generate_pages ( current_page , num_of_pages , search = None , showPaused = None , window = 7 ) : void_link = 'javascript:void(0)' first_node = Markup ( \"\"\"<li class=\"paginate_button {disabled}\" id=\"dags_first\"> <a href=\"{href_link}\" aria-controls=\"dags\" data-dt-idx=\"0\" tabindex=\"0\">&laquo;</a> </li>\"\"\" ) previous_node = Markup ( \"\"\"<li class=\"paginate_button previous {disabled}\" id=\"dags_previous\"> <a href=\"{href_link}\" aria-controls=\"dags\" data-dt-idx=\"0\" tabindex=\"0\">&lt;</a> </li>\"\"\" ) next_node = Markup ( \"\"\"<li class=\"paginate_button next {disabled}\" id=\"dags_next\"> <a href=\"{href_link}\" aria-controls=\"dags\" data-dt-idx=\"3\" tabindex=\"0\">&gt;</a> </li>\"\"\" ) last_node = Markup ( \"\"\"<li class=\"paginate_button {disabled}\" id=\"dags_last\"> <a href=\"{href_link}\" aria-controls=\"dags\" data-dt-idx=\"3\" tabindex=\"0\">&raquo;</a> </li>\"\"\" ) page_node = Markup ( \"\"\"<li class=\"paginate_button {is_active}\"> <a href=\"{href_link}\" aria-controls=\"dags\" data-dt-idx=\"2\" tabindex=\"0\">{page_num}</a> </li>\"\"\" ) output = [ Markup ( '<ul class=\"pagination\" style=\"margin-top:0px;\">' ) ] is_disabled = 'disabled' if current_page <= 0 else '' output . append ( first_node . format ( href_link = \"?{}\" . format ( get_params ( page = 0 , search = search , showPaused = showPaused ) ) , disabled = is_disabled ) ) page_link = void_link if current_page > 0 : page_link = '?{}' . format ( get_params ( page = ( current_page - 1 ) , search = search , showPaused = showPaused ) ) output . append ( previous_node . format ( href_link = page_link , disabled = is_disabled ) ) mid = int ( window / 2 ) last_page = num_of_pages - 1 if current_page <= mid or num_of_pages < window : pages = [ i for i in range ( 0 , min ( num_of_pages , window ) ) ] elif mid < current_page < last_page - mid : pages = [ i for i in range ( current_page - mid , current_page + mid + 1 ) ] else : pages = [ i for i in range ( num_of_pages - window , last_page + 1 ) ] def is_current ( current , page ) : return page == current for page in pages : vals = { 'is_active' : 'active' if is_current ( current_page , page ) else '' , 'href_link' : void_link if is_current ( current_page , page ) else '?{}' . format ( get_params ( page = page , search = search , showPaused = showPaused ) ) , 'page_num' : page + 1 } output . append ( page_node . format ( * * vals ) ) is_disabled = 'disabled' if current_page >= num_of_pages - 1 else '' page_link = ( void_link if current_page >= num_of_pages - 1 else '?{}' . format ( get_params ( page = current_page + 1 , search = search , showPaused = showPaused ) ) ) output . append ( next_node . format ( href_link = page_link , disabled = is_disabled ) ) output . append ( last_node . format ( href_link = \"?{}\" . format ( get_params ( page = last_page , search = search , showPaused = showPaused ) ) , disabled = is_disabled ) ) output . append ( Markup ( '</ul>' ) ) return Markup ( '\\n' . join ( output ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def json_response ( obj ) : return Response ( response = json . dumps ( obj , indent = 4 , cls = AirflowJsonEncoder ) , status = 200 , mimetype = \"application/json\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def open_maybe_zipped ( f , mode = 'r' ) : _ , archive , filename = ZIP_REGEX . search ( f ) . groups ( ) if archive and zipfile . is_zipfile ( archive ) : return zipfile . ZipFile ( archive , mode = mode ) . open ( filename ) else : return io . open ( f , mode = mode )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_cache_key ( * args , * * kwargs ) : path = request . path args = str ( hash ( frozenset ( request . args . items ( ) ) ) ) return ( path + args ) . encode ( 'ascii' , 'ignore' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . _conn : self . _conn = VideoIntelligenceServiceClient ( credentials = self . _get_credentials ( ) ) return self . _conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def annotate_video ( self , input_uri = None , input_content = None , features = None , video_context = None , output_uri = None , location = None , retry = None , timeout = None , metadata = None , ) : client = self . get_conn ( ) return client . annotate_video ( input_uri = input_uri , input_content = input_content , features = features , video_context = video_context , output_uri = output_uri , location_id = location , retry = retry , timeout = timeout , metadata = metadata , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_api_key ( self ) : conn = self . get_connection ( self . http_conn_id ) api_key = conn . password if not api_key : raise AirflowException ( 'Opsgenie API Key is required for this hook, ' 'please check your conn_id configuration.' ) return api_key\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self , headers = None ) : conn = self . get_connection ( self . http_conn_id ) self . base_url = conn . host if conn . host else 'https://api.opsgenie.com' session = requests . Session ( ) if headers : session . headers . update ( headers ) return session\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , payload = { } ) : api_key = self . _get_api_key ( ) return self . run ( endpoint = 'v2/alerts' , data = json . dumps ( payload ) , headers = { 'Content-Type' : 'application/json' , 'Authorization' : 'GenieKey %s' % api_key } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poke ( self , context ) : bash_command = self . bash_command self . log . info ( \"Tmp dir root location: \\n %s\" , gettempdir ( ) ) with TemporaryDirectory ( prefix = 'airflowtmp' ) as tmp_dir : with NamedTemporaryFile ( dir = tmp_dir , prefix = self . task_id ) as f : f . write ( bytes ( bash_command , 'utf_8' ) ) f . flush ( ) fname = f . name script_location = tmp_dir + \"/\" + fname self . log . info ( \"Temporary script location: %s\" , script_location ) self . log . info ( \"Running command: %s\" , bash_command ) sp = Popen ( [ 'bash' , fname ] , stdout = PIPE , stderr = STDOUT , close_fds = True , cwd = tmp_dir , env = self . env , preexec_fn = os . setsid ) self . sp = sp self . log . info ( \"Output:\" ) line = '' for line in iter ( sp . stdout . readline , b'' ) : line = line . decode ( self . output_encoding ) . strip ( ) self . log . info ( line ) sp . wait ( ) self . log . info ( \"Command exited with return code %s\" , sp . returncode ) return not sp . returncode\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_opsgenie_payload ( self ) : payload = { } for key in [ \"message\" , \"alias\" , \"description\" , \"responders\" , \"visibleTo\" , \"actions\" , \"tags\" , \"details\" , \"entity\" , \"source\" , \"priority\" , \"user\" , \"note\" ] : val = getattr ( self , key ) if val : payload [ key ] = val return payload\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . hook = OpsgenieAlertHook ( self . opsgenie_conn_id ) self . hook . execute ( self . _build_opsgenie_payload ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . conn : self . conn = self . get_client_type ( 'athena' ) return self . conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_query ( self , query , query_context , result_configuration , client_request_token = None ) : response = self . conn . start_query_execution ( QueryString = query , ClientRequestToken = client_request_token , QueryExecutionContext = query_context , ResultConfiguration = result_configuration ) query_execution_id = response [ 'QueryExecutionId' ] return query_execution_id\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_query_status ( self , query_execution_id ) : response = self . conn . get_query_execution ( QueryExecutionId = query_execution_id ) state = None try : state = response [ 'QueryExecution' ] [ 'Status' ] [ 'State' ] except Exception as ex : self . log . error ( 'Exception while getting query state' , ex ) finally : return state\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_query_results ( self , query_execution_id ) : query_state = self . check_query_status ( query_execution_id ) if query_state is None : self . log . error ( 'Invalid Query state' ) return None elif query_state in self . INTERMEDIATE_STATES or query_state in self . FAILURE_STATES : self . log . error ( 'Query is in {state} state. Cannot fetch results' . format ( state = query_state ) ) return None return self . conn . get_query_results ( QueryExecutionId = query_execution_id )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poll_query_status ( self , query_execution_id , max_tries = None ) : try_number = 1 final_query_state = None # Query state when query reaches final state or max_tries reached while True : query_state = self . check_query_status ( query_execution_id ) if query_state is None : self . log . info ( 'Trial {try_number}: Invalid query state. Retrying again' . format ( try_number = try_number ) ) elif query_state in self . INTERMEDIATE_STATES : self . log . info ( 'Trial {try_number}: Query is still in an intermediate state - {state}' . format ( try_number = try_number , state = query_state ) ) else : self . log . info ( 'Trial {try_number}: Query execution completed. Final state is {state}' . format ( try_number = try_number , state = query_state ) ) final_query_state = query_state break if max_tries and try_number >= max_tries : # Break loop if max_tries reached final_query_state = query_state break try_number += 1 sleep ( self . sleep_time ) return final_query_state\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if self . conn is None : cnopts = pysftp . CnOpts ( ) if self . no_host_key_check : cnopts . hostkeys = None cnopts . compression = self . compress conn_params = { 'host' : self . remote_host , 'port' : self . port , 'username' : self . username , 'cnopts' : cnopts } if self . password and self . password . strip ( ) : conn_params [ 'password' ] = self . password if self . key_file : conn_params [ 'private_key' ] = self . key_file if self . private_key_pass : conn_params [ 'private_key_pass' ] = self . private_key_pass self . conn = pysftp . Connection ( * * conn_params ) return self . conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def describe_directory ( self , path ) : conn = self . get_conn ( ) flist = conn . listdir_attr ( path ) files = { } for f in flist : modify = datetime . datetime . fromtimestamp ( f . st_mtime ) . strftime ( '%Y%m%d%H%M%S' ) files [ f . filename ] = { 'size' : f . st_size , 'type' : 'dir' if stat . S_ISDIR ( f . st_mode ) else 'file' , 'modify' : modify } return files\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_directory ( self , path ) : conn = self . get_conn ( ) files = conn . listdir ( path ) return files\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_directory ( self , path , mode = 777 ) : conn = self . get_conn ( ) conn . mkdir ( path , mode )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def retrieve_file ( self , remote_full_path , local_full_path ) : conn = self . get_conn ( ) self . log . info ( 'Retrieving file from FTP: %s' , remote_full_path ) conn . get ( remote_full_path , local_full_path ) self . log . info ( 'Finished retrieving file from FTP: %s' , remote_full_path )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def store_file ( self , remote_full_path , local_full_path ) : conn = self . get_conn ( ) conn . put ( local_full_path , remote_full_path )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def __handle_rate_limit_exception ( self , rate_limit_exception ) : retry_after = int ( rate_limit_exception . response . headers . get ( 'Retry-After' , 60 ) ) self . log . info ( \"Hit Zendesk API rate limit. Pausing for %s seconds\" , retry_after ) time . sleep ( retry_after )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call ( self , path , query = None , get_all_pages = True , side_loading = False ) : zendesk = self . get_conn ( ) first_request_successful = False while not first_request_successful : try : results = zendesk . call ( path , query ) first_request_successful = True except RateLimitError as rle : self . __handle_rate_limit_exception ( rle ) # Find the key with the results keys = [ path . split ( \"/\" ) [ - 1 ] . split ( \".json\" ) [ 0 ] ] next_page = results [ 'next_page' ] if side_loading : keys += query [ 'include' ] . split ( ',' ) results = { key : results [ key ] for key in keys } if get_all_pages : while next_page is not None : try : # Need to split because the next page URL has # `github.zendesk...` # in it, but the call function needs it removed. next_url = next_page . split ( self . __url ) [ 1 ] self . log . info ( \"Calling %s\" , next_url ) more_res = zendesk . call ( next_url ) for key in results : results [ key ] . extend ( more_res [ key ] ) if next_page == more_res [ 'next_page' ] : # Unfortunately zdesk doesn't always throw ZendeskError # when we are done getting all the data. Sometimes the # next just refers to the current set of results. # Hence, need to deal with this special case break else : next_page = more_res [ 'next_page' ] except RateLimitError as rle : self . __handle_rate_limit_exception ( rle ) except ZendeskError as ze : if b\"Use a start_time older than 5 minutes\" in ze . msg : # We have pretty up to date data break else : raise ze return results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_partitions ( self , database_name , table_name , expression = '' , page_size = None , max_items = None ) : config = { 'PageSize' : page_size , 'MaxItems' : max_items , } paginator = self . get_conn ( ) . get_paginator ( 'get_partitions' ) response = paginator . paginate ( DatabaseName = database_name , TableName = table_name , Expression = expression , PaginationConfig = config ) partitions = set ( ) for page in response : for p in page [ 'Partitions' ] : partitions . add ( tuple ( p [ 'Values' ] ) ) return partitions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_partition ( self , database_name , table_name , expression ) : partitions = self . get_partitions ( database_name , table_name , expression , max_items = 1 ) if partitions : return True else : return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_table ( self , database_name , table_name ) : result = self . get_conn ( ) . get_table ( DatabaseName = database_name , Name = table_name ) return result [ 'Table' ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_table_location ( self , database_name , table_name ) : table = self . get_table ( database_name , table_name ) return table [ 'StorageDescriptor' ] [ 'Location' ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def cluster_status ( self , cluster_identifier ) : conn = self . get_conn ( ) try : response = conn . describe_clusters ( ClusterIdentifier = cluster_identifier ) [ 'Clusters' ] return response [ 0 ] [ 'ClusterStatus' ] if response else None except conn . exceptions . ClusterNotFoundFault : return 'cluster_not_found'\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_cluster ( self , cluster_identifier , skip_final_cluster_snapshot = True , final_cluster_snapshot_identifier = '' ) : response = self . get_conn ( ) . delete_cluster ( ClusterIdentifier = cluster_identifier , SkipFinalClusterSnapshot = skip_final_cluster_snapshot , FinalClusterSnapshotIdentifier = final_cluster_snapshot_identifier ) return response [ 'Cluster' ] if response [ 'Cluster' ] else None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def describe_cluster_snapshots ( self , cluster_identifier ) : response = self . get_conn ( ) . describe_cluster_snapshots ( ClusterIdentifier = cluster_identifier ) if 'Snapshots' not in response : return None snapshots = response [ 'Snapshots' ] snapshots = filter ( lambda x : x [ 'Status' ] , snapshots ) snapshots . sort ( key = lambda x : x [ 'SnapshotCreateTime' ] , reverse = True ) return snapshots\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def restore_from_cluster_snapshot ( self , cluster_identifier , snapshot_identifier ) : response = self . get_conn ( ) . restore_from_cluster_snapshot ( ClusterIdentifier = cluster_identifier , SnapshotIdentifier = snapshot_identifier ) return response [ 'Cluster' ] if response [ 'Cluster' ] else None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_cluster_snapshot ( self , snapshot_identifier , cluster_identifier ) : response = self . get_conn ( ) . create_cluster_snapshot ( SnapshotIdentifier = snapshot_identifier , ClusterIdentifier = cluster_identifier , ) return response [ 'Snapshot' ] if response [ 'Snapshot' ] else None\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , * * kwargs ) : if not self . api_params : self . construct_api_call_params ( ) slack = SlackHook ( token = self . token , slack_conn_id = self . slack_conn_id ) slack . call ( self . method , self . api_params )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def add_volume ( self , volume ) : self . _add_volume ( name = volume . name , configs = volume . configs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def add_mount ( self , volume_mount ) : self . _add_mount ( name = volume_mount . name , mount_path = volume_mount . mount_path , sub_path = volume_mount . sub_path , read_only = volume_mount . read_only )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_job_flow ( self , job_flow_overrides ) : if not self . emr_conn_id : raise AirflowException ( 'emr_conn_id must be present to use create_job_flow' ) emr_conn = self . get_connection ( self . emr_conn_id ) config = emr_conn . extra_dejson . copy ( ) config . update ( job_flow_overrides ) response = self . get_conn ( ) . run_job_flow ( * * config ) return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def filter_for_filesize ( result , size = None ) : if size : log = LoggingMixin ( ) . log log . debug ( 'Filtering for file size >= %s in files: %s' , size , map ( lambda x : x [ 'path' ] , result ) ) size *= settings . MEGABYTE result = [ x for x in result if x [ 'length' ] >= size ] log . debug ( 'HdfsSensor.poke: after size filter result is %s' , result ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def filter_for_ignored_ext ( result , ignored_ext , ignore_copying ) : if ignore_copying : log = LoggingMixin ( ) . log regex_builder = r\"^.*\\.(%s$)$\" % '$|' . join ( ignored_ext ) ignored_extensions_regex = re . compile ( regex_builder ) log . debug ( 'Filtering result for ignored extensions: %s in files %s' , ignored_extensions_regex . pattern , map ( lambda x : x [ 'path' ] , result ) ) result = [ x for x in result if not ignored_extensions_regex . match ( x [ 'path' ] ) ] log . debug ( 'HdfsSensor.poke: after ext filter result is %s' , result ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : s3_conn = S3Hook ( self . s3_conn_id ) # Grab collection and execute query according to whether or not it is a pipeline if self . is_pipeline : results = MongoHook ( self . mongo_conn_id ) . aggregate ( mongo_collection = self . mongo_collection , aggregate_query = self . mongo_query , mongo_db = self . mongo_db ) else : results = MongoHook ( self . mongo_conn_id ) . find ( mongo_collection = self . mongo_collection , query = self . mongo_query , mongo_db = self . mongo_db ) # Performs transform then stringifies the docs results into json format docs_str = self . _stringify ( self . transform ( results ) ) # Load Into S3 s3_conn . load_string ( string_data = docs_str , key = self . s3_key , bucket_name = self . s3_bucket , replace = self . replace ) return True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _stringify ( iterable , joinable = '\\n' ) : return joinable . join ( [ json . dumps ( doc , default = json_util . default ) for doc in iterable ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_pool ( name , session = None ) : if not ( name and name . strip ( ) ) : raise AirflowBadRequest ( \"Pool name shouldn't be empty\" ) pool = session . query ( Pool ) . filter_by ( pool = name ) . first ( ) if pool is None : raise PoolNotFound ( \"Pool '%s' doesn't exist\" % name ) return pool\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_pool ( name , slots , description , session = None ) : if not ( name and name . strip ( ) ) : raise AirflowBadRequest ( \"Pool name shouldn't be empty\" ) try : slots = int ( slots ) except ValueError : raise AirflowBadRequest ( \"Bad value for `slots`: %s\" % slots ) session . expire_on_commit = False pool = session . query ( Pool ) . filter_by ( pool = name ) . first ( ) if pool is None : pool = Pool ( pool = name , slots = slots , description = description ) session . add ( pool ) else : pool . slots = slots pool . description = description session . commit ( ) return pool\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_pool ( name , session = None ) : if not ( name and name . strip ( ) ) : raise AirflowBadRequest ( \"Pool name shouldn't be empty\" ) pool = session . query ( Pool ) . filter_by ( pool = name ) . first ( ) if pool is None : raise PoolNotFound ( \"Pool '%s' doesn't exist\" % name ) session . delete ( pool ) session . commit ( ) return pool\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _dict_to_proto ( py_dict , proto ) : dict_json_str = json . dumps ( py_dict ) return json_format . Parse ( dict_json_str , proto )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def wait_for_operation ( self , operation , project_id = None ) : self . log . info ( \"Waiting for OPERATION_NAME %s\" , operation . name ) time . sleep ( OPERATIONAL_POLL_INTERVAL ) while operation . status != Operation . Status . DONE : if operation . status == Operation . Status . RUNNING or operation . status == Operation . Status . PENDING : time . sleep ( OPERATIONAL_POLL_INTERVAL ) else : raise exceptions . GoogleCloudError ( \"Operation has failed with status: %s\" % operation . status ) # To update status of operation operation = self . get_operation ( operation . name , project_id = project_id or self . project_id ) return operation\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_operation ( self , operation_name , project_id = None ) : return self . get_client ( ) . get_operation ( project_id = project_id or self . project_id , zone = self . location , operation_id = operation_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _append_label ( cluster_proto , key , val ) : val = val . replace ( '.' , '-' ) . replace ( '+' , '-' ) cluster_proto . resource_labels . update ( { key : val } ) return cluster_proto\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_cluster ( self , name , project_id = None , retry = DEFAULT , timeout = DEFAULT ) : self . log . info ( \"Deleting (project_id=%s, zone=%s, cluster_id=%s)\" , self . project_id , self . location , name ) try : op = self . get_client ( ) . delete_cluster ( project_id = project_id or self . project_id , zone = self . location , cluster_id = name , retry = retry , timeout = timeout ) op = self . wait_for_operation ( op ) # Returns server-defined url for the resource return op . self_link except NotFound as error : self . log . info ( 'Assuming Success: %s' , error . message )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_cluster ( self , cluster , project_id = None , retry = DEFAULT , timeout = DEFAULT ) : if isinstance ( cluster , dict ) : cluster_proto = Cluster ( ) cluster = self . _dict_to_proto ( py_dict = cluster , proto = cluster_proto ) elif not isinstance ( cluster , Cluster ) : raise AirflowException ( \"cluster is not instance of Cluster proto or python dict\" ) self . _append_label ( cluster , 'airflow-version' , 'v' + version . version ) self . log . info ( \"Creating (project_id=%s, zone=%s, cluster_name=%s)\" , self . project_id , self . location , cluster . name ) try : op = self . get_client ( ) . create_cluster ( project_id = project_id or self . project_id , zone = self . location , cluster = cluster , retry = retry , timeout = timeout ) op = self . wait_for_operation ( op ) return op . target_link except AlreadyExists as error : self . log . info ( 'Assuming Success: %s' , error . message ) return self . get_cluster ( name = cluster . name ) . self_link\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_cluster ( self , name , project_id = None , retry = DEFAULT , timeout = DEFAULT ) : self . log . info ( \"Fetching cluster (project_id=%s, zone=%s, cluster_name=%s)\" , project_id or self . project_id , self . location , name ) return self . get_client ( ) . get_cluster ( project_id = project_id or self . project_id , zone = self . location , cluster_id = name , retry = retry , timeout = timeout ) . self_link\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_webhook_endpoint ( self , http_conn_id , webhook_endpoint ) : if webhook_endpoint : endpoint = webhook_endpoint elif http_conn_id : conn = self . get_connection ( http_conn_id ) extra = conn . extra_dejson endpoint = extra . get ( 'webhook_endpoint' , '' ) else : raise AirflowException ( 'Cannot get webhook endpoint: No valid Discord ' 'webhook endpoint or http_conn_id supplied.' ) # make sure endpoint matches the expected Discord webhook format if not re . match ( '^webhooks/[0-9]+/[a-zA-Z0-9_-]+$' , endpoint ) : raise AirflowException ( 'Expected Discord webhook endpoint in the form ' 'of \"webhooks/{webhook.id}/{webhook.token}\".' ) return endpoint\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_discord_payload ( self ) : payload = { } if self . username : payload [ 'username' ] = self . username if self . avatar_url : payload [ 'avatar_url' ] = self . avatar_url payload [ 'tts' ] = self . tts if len ( self . message ) <= 2000 : payload [ 'content' ] = self . message else : raise AirflowException ( 'Discord message length must be 2000 or fewer ' 'characters.' ) return json . dumps ( payload )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self ) : proxies = { } if self . proxy : # we only need https proxy for Discord proxies = { 'https' : self . proxy } discord_payload = self . _build_discord_payload ( ) self . run ( endpoint = self . webhook_endpoint , data = discord_payload , headers = { 'Content-type' : 'application/json' } , extra_options = { 'proxies' : proxies } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def encrypt ( self , key_name , plaintext , authenticated_data = None ) : keys = self . get_conn ( ) . projects ( ) . locations ( ) . keyRings ( ) . cryptoKeys ( ) body = { 'plaintext' : _b64encode ( plaintext ) } if authenticated_data : body [ 'additionalAuthenticatedData' ] = _b64encode ( authenticated_data ) request = keys . encrypt ( name = key_name , body = body ) response = request . execute ( num_retries = self . num_retries ) ciphertext = response [ 'ciphertext' ] return ciphertext\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def Popen ( self , cmd , * * kwargs ) : masked_cmd = ' ' . join ( self . cmd_mask_password ( cmd ) ) self . log . info ( \"Executing command: {}\" . format ( masked_cmd ) ) self . sp = subprocess . Popen ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , * * kwargs ) for line in iter ( self . sp . stdout ) : self . log . info ( line . strip ( ) ) self . sp . wait ( ) self . log . info ( \"Command exited with return code %s\" , self . sp . returncode ) if self . sp . returncode : raise AirflowException ( \"Sqoop command failed: {}\" . format ( masked_cmd ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def import_table ( self , table , target_dir = None , append = False , file_type = \"text\" , columns = None , split_by = None , where = None , direct = False , driver = None , extra_import_options = None ) : cmd = self . _import_cmd ( target_dir , append , file_type , split_by , direct , driver , extra_import_options ) cmd += [ \"--table\" , table ] if columns : cmd += [ \"--columns\" , columns ] if where : cmd += [ \"--where\" , where ] self . Popen ( cmd )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def import_query ( self , query , target_dir , append = False , file_type = \"text\" , split_by = None , direct = None , driver = None , extra_import_options = None ) : cmd = self . _import_cmd ( target_dir , append , file_type , split_by , direct , driver , extra_import_options ) cmd += [ \"--query\" , query ] self . Popen ( cmd )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def export_table ( self , table , export_dir , input_null_string , input_null_non_string , staging_table , clear_staging_table , enclosed_by , escaped_by , input_fields_terminated_by , input_lines_terminated_by , input_optionally_enclosed_by , batch , relaxed_isolation , extra_export_options = None ) : cmd = self . _export_cmd ( table , export_dir , input_null_string , input_null_non_string , staging_table , clear_staging_table , enclosed_by , escaped_by , input_fields_terminated_by , input_lines_terminated_by , input_optionally_enclosed_by , batch , relaxed_isolation , extra_export_options ) self . Popen ( cmd )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if not self . _client : self . _client = TextToSpeechClient ( credentials = self . _get_credentials ( ) ) return self . _client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def synthesize_speech ( self , input_data , voice , audio_config , retry = None , timeout = None ) : client = self . get_conn ( ) self . log . info ( \"Synthesizing input: %s\" % input_data ) return client . synthesize_speech ( input_ = input_data , voice = voice , audio_config = audio_config , retry = retry , timeout = timeout )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def close ( self ) : # When application exit, system shuts down all handlers by # calling close method. Here we check if logger is already # closed to prevent uploading the log to remote storage multiple # times when `logging.shutdown` is called. if self . closed : return super ( ) . close ( ) if not self . upload_on_close : return local_loc = os . path . join ( self . local_base , self . log_relative_path ) remote_loc = os . path . join ( self . remote_base , self . log_relative_path ) if os . path . exists ( local_loc ) : # read log and remove old logs to get just the latest additions with open ( local_loc , 'r' ) as logfile : log = logfile . read ( ) self . s3_write ( log , remote_loc ) # Mark closed so we don't double write if close is called twice self . closed = True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def s3_read ( self , remote_log_location , return_error = False ) : try : return self . hook . read_key ( remote_log_location ) except Exception : msg = 'Could not read logs from {}' . format ( remote_log_location ) self . log . exception ( msg ) # return error if needed if return_error : return msg\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def s3_write ( self , log , remote_log_location , append = True ) : if append and self . s3_log_exists ( remote_log_location ) : old_log = self . s3_read ( remote_log_location ) log = '\\n' . join ( [ old_log , log ] ) if old_log else log try : self . hook . load_string ( log , key = remote_log_location , replace = True , encrypt = configuration . conf . getboolean ( 'core' , 'ENCRYPT_S3_LOGS' ) , ) except Exception : self . log . exception ( 'Could not write logs to %s' , remote_log_location )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_init_containers ( self ) : # If we're using volume claims to mount the dags, no init container is needed if self . kube_config . dags_volume_claim or self . kube_config . dags_volume_host or self . kube_config . dags_in_image : return [ ] # Otherwise, define a git-sync init container init_environment = [ { 'name' : 'GIT_SYNC_REPO' , 'value' : self . kube_config . git_repo } , { 'name' : 'GIT_SYNC_BRANCH' , 'value' : self . kube_config . git_branch } , { 'name' : 'GIT_SYNC_ROOT' , 'value' : self . kube_config . git_sync_root } , { 'name' : 'GIT_SYNC_DEST' , 'value' : self . kube_config . git_sync_dest } , { 'name' : 'GIT_SYNC_DEPTH' , 'value' : '1' } , { 'name' : 'GIT_SYNC_ONE_TIME' , 'value' : 'true' } ] if self . kube_config . git_user : init_environment . append ( { 'name' : 'GIT_SYNC_USERNAME' , 'value' : self . kube_config . git_user } ) if self . kube_config . git_password : init_environment . append ( { 'name' : 'GIT_SYNC_PASSWORD' , 'value' : self . kube_config . git_password } ) volume_mounts = [ { 'mountPath' : self . kube_config . git_sync_root , 'name' : self . dags_volume_name , 'readOnly' : False } ] if self . kube_config . git_ssh_key_secret_name : volume_mounts . append ( { 'name' : self . git_sync_ssh_secret_volume_name , 'mountPath' : '/etc/git-secret/ssh' , 'subPath' : 'ssh' } ) init_environment . extend ( [ { 'name' : 'GIT_SSH_KEY_FILE' , 'value' : '/etc/git-secret/ssh' } , { 'name' : 'GIT_SYNC_SSH' , 'value' : 'true' } ] ) if self . kube_config . git_ssh_known_hosts_configmap_name : volume_mounts . append ( { 'name' : self . git_sync_ssh_known_hosts_volume_name , 'mountPath' : '/etc/git-secret/known_hosts' , 'subPath' : 'known_hosts' } ) init_environment . extend ( [ { 'name' : 'GIT_KNOWN_HOSTS' , 'value' : 'true' } , { 'name' : 'GIT_SSH_KNOWN_HOSTS_FILE' , 'value' : '/etc/git-secret/known_hosts' } ] ) else : init_environment . append ( { 'name' : 'GIT_KNOWN_HOSTS' , 'value' : 'false' } ) return [ { 'name' : self . kube_config . git_sync_init_container_name , 'image' : self . kube_config . git_sync_container , 'securityContext' : { 'runAsUser' : 65533 } , # git-sync user 'env' : init_environment , 'volumeMounts' : volume_mounts } ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_environment ( self ) : env = { } for env_var_name , env_var_val in six . iteritems ( self . kube_config . kube_env_vars ) : env [ env_var_name ] = env_var_val env [ \"AIRFLOW__CORE__EXECUTOR\" ] = \"LocalExecutor\" if self . kube_config . airflow_configmap : env [ 'AIRFLOW_HOME' ] = self . worker_airflow_home env [ 'AIRFLOW__CORE__DAGS_FOLDER' ] = self . worker_airflow_dags if ( not self . kube_config . airflow_configmap and 'AIRFLOW__CORE__SQL_ALCHEMY_CONN' not in self . kube_config . kube_secrets ) : env [ 'AIRFLOW__CORE__SQL_ALCHEMY_CONN' ] = conf . get ( \"core\" , \"SQL_ALCHEMY_CONN\" ) if self . kube_config . git_dags_folder_mount_point : # /root/airflow/dags/repo/dags dag_volume_mount_path = os . path . join ( self . kube_config . git_dags_folder_mount_point , self . kube_config . git_sync_dest , # repo self . kube_config . git_subpath # dags ) env [ 'AIRFLOW__CORE__DAGS_FOLDER' ] = dag_volume_mount_path return env\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_secrets ( self ) : worker_secrets = [ ] for env_var_name , obj_key_pair in six . iteritems ( self . kube_config . kube_secrets ) : k8s_secret_obj , k8s_secret_key = obj_key_pair . split ( '=' ) worker_secrets . append ( Secret ( 'env' , env_var_name , k8s_secret_obj , k8s_secret_key ) ) if self . kube_config . env_from_secret_ref : for secret_ref in self . kube_config . env_from_secret_ref . split ( ',' ) : worker_secrets . append ( Secret ( 'env' , None , secret_ref ) ) return worker_secrets\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_security_context ( self ) : security_context = { } if self . kube_config . worker_run_as_user : security_context [ 'runAsUser' ] = self . kube_config . worker_run_as_user if self . kube_config . worker_fs_group : security_context [ 'fsGroup' ] = self . kube_config . worker_fs_group # set fs_group to 65533 if not explicitly specified and using git ssh keypair auth if self . kube_config . git_ssh_key_secret_name and security_context . get ( 'fsGroup' ) is None : security_context [ 'fsGroup' ] = 65533 return security_context\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def kill ( self , ti ) : if self . cmd is None : if not ti and not self . task_instance : raise Exception ( \"Unable to cancel Qubole Command, context is unavailable!\" ) elif not ti : ti = self . task_instance cmd_id = ti . xcom_pull ( key = \"qbol_cmd_id\" , task_ids = ti . task_id ) self . cmd = self . cls . find ( cmd_id ) if self . cls and self . cmd : self . log . info ( 'Sending KILL signal to Qubole Command Id: %s' , self . cmd . id ) self . cmd . cancel ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_results ( self , ti = None , fp = None , inline = True , delim = None , fetch = True ) : if fp is None : iso = datetime . datetime . utcnow ( ) . isoformat ( ) logpath = os . path . expanduser ( configuration . conf . get ( 'core' , 'BASE_LOG_FOLDER' ) ) resultpath = logpath + '/' + self . dag_id + '/' + self . task_id + '/results' configuration . mkdir_p ( resultpath ) fp = open ( resultpath + '/' + iso , 'wb' ) if self . cmd is None : cmd_id = ti . xcom_pull ( key = \"qbol_cmd_id\" , task_ids = self . task_id ) self . cmd = self . cls . find ( cmd_id ) self . cmd . get_results ( fp , inline , delim , fetch ) fp . flush ( ) fp . close ( ) return fp . name\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_log ( self , ti ) : if self . cmd is None : cmd_id = ti . xcom_pull ( key = \"qbol_cmd_id\" , task_ids = self . task_id ) Command . get_log_id ( self . cls , cmd_id )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_jobs_id ( self , ti ) : if self . cmd is None : cmd_id = ti . xcom_pull ( key = \"qbol_cmd_id\" , task_ids = self . task_id ) Command . get_jobs_id ( self . cls , cmd_id )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_extra_links ( self , operator , dttm ) : conn = BaseHook . get_connection ( operator . kwargs [ 'qubole_conn_id' ] ) if conn and conn . host : host = re . sub ( r'api$' , 'v2/analyze?command_id=' , conn . host ) else : host = 'https://api.qubole.com/v2/analyze?command_id=' ti = TaskInstance ( task = operator , execution_date = dttm ) qds_command_id = ti . xcom_pull ( task_ids = operator . task_id , key = 'qbol_cmd_id' ) url = host + str ( qds_command_id ) if qds_command_id else '' return url\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def heartbeat ( self ) : try : with create_session ( ) as session : job = session . query ( BaseJob ) . filter_by ( id = self . id ) . one ( ) make_transient ( job ) session . commit ( ) if job . state == State . SHUTDOWN : self . kill ( ) is_unit_test = conf . getboolean ( 'core' , 'unit_test_mode' ) if not is_unit_test : # Figure out how long to sleep for sleep_for = 0 if job . latest_heartbeat : seconds_remaining = self . heartrate - ( timezone . utcnow ( ) - job . latest_heartbeat ) . total_seconds ( ) sleep_for = max ( 0 , seconds_remaining ) sleep ( sleep_for ) # Update last heartbeat time with create_session ( ) as session : job = session . query ( BaseJob ) . filter ( BaseJob . id == self . id ) . first ( ) job . latest_heartbeat = timezone . utcnow ( ) session . merge ( job ) session . commit ( ) self . heartbeat_callback ( session = session ) self . log . debug ( '[heartbeat]' ) except OperationalError as e : self . log . error ( \"Scheduler heartbeat got an exception: %s\" , str ( e ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def reset_state_for_orphaned_tasks ( self , filter_by_dag_run = None , session = None ) : queued_tis = self . executor . queued_tasks # also consider running as the state might not have changed in the db yet running_tis = self . executor . running resettable_states = [ State . SCHEDULED , State . QUEUED ] TI = models . TaskInstance DR = models . DagRun if filter_by_dag_run is None : resettable_tis = ( session . query ( TI ) . join ( DR , and_ ( TI . dag_id == DR . dag_id , TI . execution_date == DR . execution_date ) ) . filter ( DR . state == State . RUNNING , DR . run_id . notlike ( BackfillJob . ID_PREFIX + '%' ) , TI . state . in_ ( resettable_states ) ) ) . all ( ) else : resettable_tis = filter_by_dag_run . get_task_instances ( state = resettable_states , session = session ) tis_to_reset = [ ] # Can't use an update here since it doesn't support joins for ti in resettable_tis : if ti . key not in queued_tis and ti . key not in running_tis : tis_to_reset . append ( ti ) if len ( tis_to_reset ) == 0 : return [ ] def query ( result , items ) : filter_for_tis = ( [ and_ ( TI . dag_id == ti . dag_id , TI . task_id == ti . task_id , TI . execution_date == ti . execution_date ) for ti in items ] ) reset_tis = ( session . query ( TI ) . filter ( or_ ( * filter_for_tis ) , TI . state . in_ ( resettable_states ) ) . with_for_update ( ) . all ( ) ) for ti in reset_tis : ti . state = State . NONE session . merge ( ti ) return result + reset_tis reset_tis = helpers . reduce_in_chunks ( query , tis_to_reset , [ ] , self . max_tis_per_query ) task_instance_str = '\\n\\t' . join ( [ repr ( x ) for x in reset_tis ] ) session . commit ( ) self . log . info ( \"Reset the following %s TaskInstances:\\n\\t%s\" , len ( reset_tis ) , task_instance_str ) return reset_tis\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _launch_process ( result_queue , file_path , pickle_dags , dag_id_white_list , thread_name , zombies ) : def helper ( ) : # This helper runs in the newly created process log = logging . getLogger ( \"airflow.processor\" ) stdout = StreamLogWriter ( log , logging . INFO ) stderr = StreamLogWriter ( log , logging . WARN ) set_context ( log , file_path ) try : # redirect stdout/stderr to log sys . stdout = stdout sys . stderr = stderr # Re-configure the ORM engine as there are issues with multiple processes settings . configure_orm ( ) # Change the thread name to differentiate log lines. This is # really a separate process, but changing the name of the # process doesn't work, so changing the thread name instead. threading . current_thread ( ) . name = thread_name start_time = time . time ( ) log . info ( \"Started process (PID=%s) to work on %s\" , os . getpid ( ) , file_path ) scheduler_job = SchedulerJob ( dag_ids = dag_id_white_list , log = log ) result = scheduler_job . process_file ( file_path , zombies , pickle_dags ) result_queue . put ( result ) end_time = time . time ( ) log . info ( \"Processing %s took %.3f seconds\" , file_path , end_time - start_time ) except Exception : # Log exceptions through the logging framework. log . exception ( \"Got an exception! Propagating...\" ) raise finally : sys . stdout = sys . __stdout__ sys . stderr = sys . __stderr__ # We re-initialized the ORM within this Process above so we need to # tear it down manually here settings . dispose_orm ( ) p = multiprocessing . Process ( target = helper , args = ( ) , name = \"{}-Process\" . format ( thread_name ) ) p . start ( ) return p\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def start ( self ) : self . _process = DagFileProcessor . _launch_process ( self . _result_queue , self . file_path , self . _pickle_dags , self . _dag_id_white_list , \"DagFileProcessor{}\" . format ( self . _instance_id ) , self . _zombies ) self . _start_time = timezone . utcnow ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def terminate ( self , sigkill = False ) : if self . _process is None : raise AirflowException ( \"Tried to call stop before starting!\" ) # The queue will likely get corrupted, so remove the reference self . _result_queue = None self . _process . terminate ( ) # Arbitrarily wait 5s for the process to die self . _process . join ( 5 ) if sigkill and self . _process . is_alive ( ) : self . log . warning ( \"Killing PID %s\" , self . _process . pid ) os . kill ( self . _process . pid , signal . SIGKILL )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def done ( self ) : if self . _process is None : raise AirflowException ( \"Tried to see if it's done before starting!\" ) if self . _done : return True # In case result queue is corrupted. if self . _result_queue and not self . _result_queue . empty ( ) : self . _result = self . _result_queue . get_nowait ( ) self . _done = True self . log . debug ( \"Waiting for %s\" , self . _process ) self . _process . join ( ) return True # Potential error case when process dies if self . _result_queue and not self . _process . is_alive ( ) : self . _done = True # Get the object from the queue or else join() can hang. if not self . _result_queue . empty ( ) : self . _result = self . _result_queue . get_nowait ( ) self . log . debug ( \"Waiting for %s\" , self . _process ) self . _process . join ( ) return True return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _exit_gracefully ( self , signum , frame ) : self . log . info ( \"Exiting gracefully upon receiving signal %s\" , signum ) if self . processor_agent : self . processor_agent . end ( ) sys . exit ( os . EX_OK )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def manage_slas ( self , dag , session = None ) : if not any ( [ isinstance ( ti . sla , timedelta ) for ti in dag . tasks ] ) : self . log . info ( \"Skipping SLA check for %s because no tasks in DAG have SLAs\" , dag ) return TI = models . TaskInstance sq = ( session . query ( TI . task_id , func . max ( TI . execution_date ) . label ( 'max_ti' ) ) . with_hint ( TI , 'USE INDEX (PRIMARY)' , dialect_name = 'mysql' ) . filter ( TI . dag_id == dag . dag_id ) . filter ( or_ ( TI . state == State . SUCCESS , TI . state == State . SKIPPED ) ) . filter ( TI . task_id . in_ ( dag . task_ids ) ) . group_by ( TI . task_id ) . subquery ( 'sq' ) ) max_tis = session . query ( TI ) . filter ( TI . dag_id == dag . dag_id , TI . task_id == sq . c . task_id , TI . execution_date == sq . c . max_ti , ) . all ( ) ts = timezone . utcnow ( ) for ti in max_tis : task = dag . get_task ( ti . task_id ) dttm = ti . execution_date if isinstance ( task . sla , timedelta ) : dttm = dag . following_schedule ( dttm ) while dttm < timezone . utcnow ( ) : following_schedule = dag . following_schedule ( dttm ) if following_schedule + task . sla < timezone . utcnow ( ) : session . merge ( SlaMiss ( task_id = ti . task_id , dag_id = ti . dag_id , execution_date = dttm , timestamp = ts ) ) dttm = dag . following_schedule ( dttm ) session . commit ( ) slas = ( session . query ( SlaMiss ) . filter ( SlaMiss . notification_sent == False , SlaMiss . dag_id == dag . dag_id ) # noqa: E712 . all ( ) ) if slas : sla_dates = [ sla . execution_date for sla in slas ] qry = ( session . query ( TI ) . filter ( TI . state != State . SUCCESS , TI . execution_date . in_ ( sla_dates ) , TI . dag_id == dag . dag_id ) . all ( ) ) blocking_tis = [ ] for ti in qry : if ti . task_id in dag . task_ids : ti . task = dag . get_task ( ti . task_id ) blocking_tis . append ( ti ) else : session . delete ( ti ) session . commit ( ) task_list = \"\\n\" . join ( [ sla . task_id + ' on ' + sla . execution_date . isoformat ( ) for sla in slas ] ) blocking_task_list = \"\\n\" . join ( [ ti . task_id + ' on ' + ti . execution_date . isoformat ( ) for ti in blocking_tis ] ) # Track whether email or any alert notification sent # We consider email or the alert callback as notifications email_sent = False notification_sent = False if dag . sla_miss_callback : # Execute the alert callback self . log . info ( ' --------------> ABOUT TO CALL SLA MISS CALL BACK ' ) try : dag . sla_miss_callback ( dag , task_list , blocking_task_list , slas , blocking_tis ) notification_sent = True except Exception : self . log . exception ( \"Could not call sla_miss_callback for DAG %s\" , dag . dag_id ) email_content = \"\"\"\\ Here's a list of tasks that missed their SLAs: <pre><code>{task_list}\\n<code></pre> Blocking tasks: <pre><code>{blocking_task_list}\\n{bug}<code></pre> \"\"\" . format ( task_list = task_list , blocking_task_list = blocking_task_list , bug = asciiart . bug ) emails = set ( ) for task in dag . tasks : if task . email : if isinstance ( task . email , basestring ) : emails |= set ( get_email_address_list ( task . email ) ) elif isinstance ( task . email , ( list , tuple ) ) : emails |= set ( task . email ) if emails : try : send_email ( emails , \"[airflow] SLA miss on DAG=\" + dag . dag_id , email_content ) email_sent = True notification_sent = True except Exception : self . log . exception ( \"Could not send SLA Miss email notification for\" \" DAG %s\" , dag . dag_id ) # If we sent any notification, update the sla_miss table if notification_sent : for sla in slas : if email_sent : sla . email_sent = True sla . notification_sent = True session . merge ( sla ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_import_errors ( session , dagbag ) : # Clear the errors of the processed files for dagbag_file in dagbag . file_last_changed : session . query ( errors . ImportError ) . filter ( errors . ImportError . filename == dagbag_file ) . delete ( ) # Add the errors of the processed files for filename , stacktrace in six . iteritems ( dagbag . import_errors ) : session . add ( errors . ImportError ( filename = filename , stacktrace = stacktrace ) ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_dag_run ( self , dag , session = None ) : if dag . schedule_interval and conf . getboolean ( 'scheduler' , 'USE_JOB_SCHEDULE' ) : active_runs = DagRun . find ( dag_id = dag . dag_id , state = State . RUNNING , external_trigger = False , session = session ) # return if already reached maximum active runs and no timeout setting if len ( active_runs ) >= dag . max_active_runs and not dag . dagrun_timeout : return timedout_runs = 0 for dr in active_runs : if ( dr . start_date and dag . dagrun_timeout and dr . start_date < timezone . utcnow ( ) - dag . dagrun_timeout ) : dr . state = State . FAILED dr . end_date = timezone . utcnow ( ) dag . handle_callback ( dr , success = False , reason = 'dagrun_timeout' , session = session ) timedout_runs += 1 session . commit ( ) if len ( active_runs ) - timedout_runs >= dag . max_active_runs : return # this query should be replaced by find dagrun qry = ( session . query ( func . max ( DagRun . execution_date ) ) . filter_by ( dag_id = dag . dag_id ) . filter ( or_ ( DagRun . external_trigger == False , # noqa: E712 # add % as a wildcard for the like query DagRun . run_id . like ( DagRun . ID_PREFIX + '%' ) ) ) ) last_scheduled_run = qry . scalar ( ) # don't schedule @once again if dag . schedule_interval == '@once' and last_scheduled_run : return None # don't do scheduler catchup for dag's that don't have dag.catchup = True if not ( dag . catchup or dag . schedule_interval == '@once' ) : # The logic is that we move start_date up until # one period before, so that timezone.utcnow() is AFTER # the period end, and the job can be created... now = timezone . utcnow ( ) next_start = dag . following_schedule ( now ) last_start = dag . previous_schedule ( now ) if next_start <= now : new_start = last_start else : new_start = dag . previous_schedule ( last_start ) if dag . start_date : if new_start >= dag . start_date : dag . start_date = new_start else : dag . start_date = new_start next_run_date = None if not last_scheduled_run : # First run task_start_dates = [ t . start_date for t in dag . tasks ] if task_start_dates : next_run_date = dag . normalize_schedule ( min ( task_start_dates ) ) self . log . debug ( \"Next run date based on tasks %s\" , next_run_date ) else : next_run_date = dag . following_schedule ( last_scheduled_run ) # make sure backfills are also considered last_run = dag . get_last_dagrun ( session = session ) if last_run and next_run_date : while next_run_date <= last_run . execution_date : next_run_date = dag . following_schedule ( next_run_date ) # don't ever schedule prior to the dag's start_date if dag . start_date : next_run_date = ( dag . start_date if not next_run_date else max ( next_run_date , dag . start_date ) ) if next_run_date == dag . start_date : next_run_date = dag . normalize_schedule ( dag . start_date ) self . log . debug ( \"Dag start date: %s. Next run date: %s\" , dag . start_date , next_run_date ) # don't ever schedule in the future or if next_run_date is None if not next_run_date or next_run_date > timezone . utcnow ( ) : return # this structure is necessary to avoid a TypeError from concatenating # NoneType if dag . schedule_interval == '@once' : period_end = next_run_date elif next_run_date : period_end = dag . following_schedule ( next_run_date ) # Don't schedule a dag beyond its end_date (as specified by the dag param) if next_run_date and dag . end_date and next_run_date > dag . end_date : return # Don't schedule a dag beyond its end_date (as specified by the task params) # Get the min task end date, which may come from the dag.default_args min_task_end_date = [ ] task_end_dates = [ t . end_date for t in dag . tasks if t . end_date ] if task_end_dates : min_task_end_date = min ( task_end_dates ) if next_run_date and min_task_end_date and next_run_date > min_task_end_date : return if next_run_date and period_end and period_end <= timezone . utcnow ( ) : next_run = dag . create_dagrun ( run_id = DagRun . ID_PREFIX + next_run_date . isoformat ( ) , execution_date = next_run_date , start_date = timezone . utcnow ( ) , state = State . RUNNING , external_trigger = False ) return next_run\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _process_task_instances ( self , dag , queue , session = None ) : # update the state of the previously active dag runs dag_runs = DagRun . find ( dag_id = dag . dag_id , state = State . RUNNING , session = session ) active_dag_runs = [ ] for run in dag_runs : self . log . info ( \"Examining DAG run %s\" , run ) # don't consider runs that are executed in the future if run . execution_date > timezone . utcnow ( ) : self . log . error ( \"Execution date is in future: %s\" , run . execution_date ) continue if len ( active_dag_runs ) >= dag . max_active_runs : self . log . info ( \"Number of active dag runs reached max_active_run.\" ) break # skip backfill dagruns for now as long as they are not really scheduled if run . is_backfill : continue # todo: run.dag is transient but needs to be set run . dag = dag # todo: preferably the integrity check happens at dag collection time run . verify_integrity ( session = session ) run . update_state ( session = session ) if run . state == State . RUNNING : make_transient ( run ) active_dag_runs . append ( run ) for run in active_dag_runs : self . log . debug ( \"Examining active DAG run: %s\" , run ) # this needs a fresh session sometimes tis get detached tis = run . get_task_instances ( state = ( State . NONE , State . UP_FOR_RETRY , State . UP_FOR_RESCHEDULE ) ) # this loop is quite slow as it uses are_dependencies_met for # every task (in ti.is_runnable). This is also called in # update_state above which has already checked these tasks for ti in tis : task = dag . get_task ( ti . task_id ) # fixme: ti.task is transient but needs to be set ti . task = task if ti . are_dependencies_met ( dep_context = DepContext ( flag_upstream_failed = True ) , session = session ) : self . log . debug ( 'Queuing task: %s' , ti ) queue . append ( ti . key )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _change_state_for_tis_without_dagrun ( self , simple_dag_bag , old_states , new_state , session = None ) : tis_changed = 0 query = session . query ( models . TaskInstance ) . outerjoin ( models . DagRun , and_ ( models . TaskInstance . dag_id == models . DagRun . dag_id , models . TaskInstance . execution_date == models . DagRun . execution_date ) ) . filter ( models . TaskInstance . dag_id . in_ ( simple_dag_bag . dag_ids ) ) . filter ( models . TaskInstance . state . in_ ( old_states ) ) . filter ( or_ ( models . DagRun . state != State . RUNNING , models . DagRun . state . is_ ( None ) ) ) if self . using_sqlite : tis_to_change = query . with_for_update ( ) . all ( ) for ti in tis_to_change : ti . set_state ( new_state , session = session ) tis_changed += 1 else : subq = query . subquery ( ) tis_changed = session . query ( models . TaskInstance ) . filter ( and_ ( models . TaskInstance . dag_id == subq . c . dag_id , models . TaskInstance . task_id == subq . c . task_id , models . TaskInstance . execution_date == subq . c . execution_date ) ) . update ( { models . TaskInstance . state : new_state } , synchronize_session = False ) session . commit ( ) if tis_changed > 0 : self . log . warning ( \"Set %s task instances to state=%s as their associated DagRun was not in RUNNING state\" , tis_changed , new_state )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def __get_concurrency_maps ( self , states , session = None ) : TI = models . TaskInstance ti_concurrency_query = ( session . query ( TI . task_id , TI . dag_id , func . count ( '*' ) ) . filter ( TI . state . in_ ( states ) ) . group_by ( TI . task_id , TI . dag_id ) ) . all ( ) dag_map = defaultdict ( int ) task_map = defaultdict ( int ) for result in ti_concurrency_query : task_id , dag_id , count = result dag_map [ dag_id ] += count task_map [ ( dag_id , task_id ) ] = count return dag_map , task_map\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _find_executable_task_instances ( self , simple_dag_bag , states , session = None ) : executable_tis = [ ] # Get all task instances associated with scheduled # DagRuns which are not backfilled, in the given states, # and the dag is not paused TI = models . TaskInstance DR = models . DagRun DM = models . DagModel ti_query = ( session . query ( TI ) . filter ( TI . dag_id . in_ ( simple_dag_bag . dag_ids ) ) . outerjoin ( DR , and_ ( DR . dag_id == TI . dag_id , DR . execution_date == TI . execution_date ) ) . filter ( or_ ( DR . run_id == None , # noqa: E711 not_ ( DR . run_id . like ( BackfillJob . ID_PREFIX + '%' ) ) ) ) . outerjoin ( DM , DM . dag_id == TI . dag_id ) . filter ( or_ ( DM . dag_id == None , # noqa: E711 not_ ( DM . is_paused ) ) ) ) # Additional filters on task instance state if None in states : ti_query = ti_query . filter ( or_ ( TI . state == None , TI . state . in_ ( states ) ) # noqa: E711 ) else : ti_query = ti_query . filter ( TI . state . in_ ( states ) ) task_instances_to_examine = ti_query . all ( ) if len ( task_instances_to_examine ) == 0 : self . log . debug ( \"No tasks to consider for execution.\" ) return executable_tis # Put one task instance on each line task_instance_str = \"\\n\\t\" . join ( [ repr ( x ) for x in task_instances_to_examine ] ) self . log . info ( \"%s tasks up for execution:\\n\\t%s\" , len ( task_instances_to_examine ) , task_instance_str ) # Get the pool settings pools = { p . pool : p for p in session . query ( models . Pool ) . all ( ) } pool_to_task_instances = defaultdict ( list ) for task_instance in task_instances_to_examine : pool_to_task_instances [ task_instance . pool ] . append ( task_instance ) states_to_count_as_running = [ State . RUNNING , State . QUEUED ] # dag_id to # of running tasks and (dag_id, task_id) to # of running tasks. dag_concurrency_map , task_concurrency_map = self . __get_concurrency_maps ( states = states_to_count_as_running , session = session ) # Go through each pool, and queue up a task for execution if there are # any open slots in the pool. for pool , task_instances in pool_to_task_instances . items ( ) : pool_name = pool if not pool : # Arbitrary: # If queued outside of a pool, trigger no more than # non_pooled_task_slot_count open_slots = models . Pool . default_pool_open_slots ( ) pool_name = models . Pool . default_pool_name else : if pool not in pools : self . log . warning ( \"Tasks using non-existent pool '%s' will not be scheduled\" , pool ) open_slots = 0 else : open_slots = pools [ pool ] . open_slots ( session = session ) num_ready = len ( task_instances ) self . log . info ( \"Figuring out tasks to run in Pool(name=%s) with %s open slots \" \"and %s task instances ready to be queued\" , pool , open_slots , num_ready ) priority_sorted_task_instances = sorted ( task_instances , key = lambda ti : ( - ti . priority_weight , ti . execution_date ) ) # Number of tasks that cannot be scheduled because of no open slot in pool num_starving_tasks = 0 for current_index , task_instance in enumerate ( priority_sorted_task_instances ) : if open_slots <= 0 : self . log . info ( \"Not scheduling since there are %s open slots in pool %s\" , open_slots , pool ) # Can't schedule any more since there are no more open slots. num_starving_tasks = len ( priority_sorted_task_instances ) - current_index break # Check to make sure that the task concurrency of the DAG hasn't been # reached. dag_id = task_instance . dag_id simple_dag = simple_dag_bag . get_dag ( dag_id ) current_dag_concurrency = dag_concurrency_map [ dag_id ] dag_concurrency_limit = simple_dag_bag . get_dag ( dag_id ) . concurrency self . log . info ( \"DAG %s has %s/%s running and queued tasks\" , dag_id , current_dag_concurrency , dag_concurrency_limit ) if current_dag_concurrency >= dag_concurrency_limit : self . log . info ( \"Not executing %s since the number of tasks running or queued \" \"from DAG %s is >= to the DAG's task concurrency limit of %s\" , task_instance , dag_id , dag_concurrency_limit ) continue task_concurrency_limit = simple_dag . get_task_special_arg ( task_instance . task_id , 'task_concurrency' ) if task_concurrency_limit is not None : current_task_concurrency = task_concurrency_map [ ( task_instance . dag_id , task_instance . task_id ) ] if current_task_concurrency >= task_concurrency_limit : self . log . info ( \"Not executing %s since the task concurrency for\" \" this task has been reached.\" , task_instance ) continue if self . executor . has_task ( task_instance ) : self . log . debug ( \"Not handling task %s as the executor reports it is running\" , task_instance . key ) continue executable_tis . append ( task_instance ) open_slots -= 1 dag_concurrency_map [ dag_id ] += 1 task_concurrency_map [ ( task_instance . dag_id , task_instance . task_id ) ] += 1 Stats . gauge ( 'pool.starving_tasks.{pool_name}' . format ( pool_name = pool_name ) , num_starving_tasks ) task_instance_str = \"\\n\\t\" . join ( [ repr ( x ) for x in executable_tis ] ) self . log . info ( \"Setting the following tasks to queued state:\\n\\t%s\" , task_instance_str ) # so these dont expire on commit for ti in executable_tis : copy_dag_id = ti . dag_id copy_execution_date = ti . execution_date copy_task_id = ti . task_id make_transient ( ti ) ti . dag_id = copy_dag_id ti . execution_date = copy_execution_date ti . task_id = copy_task_id return executable_tis\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _change_state_for_executable_task_instances ( self , task_instances , acceptable_states , session = None ) : if len ( task_instances ) == 0 : session . commit ( ) return [ ] TI = models . TaskInstance filter_for_ti_state_change = ( [ and_ ( TI . dag_id == ti . dag_id , TI . task_id == ti . task_id , TI . execution_date == ti . execution_date ) for ti in task_instances ] ) ti_query = ( session . query ( TI ) . filter ( or_ ( * filter_for_ti_state_change ) ) ) if None in acceptable_states : ti_query = ti_query . filter ( or_ ( TI . state == None , TI . state . in_ ( acceptable_states ) ) # noqa: E711 ) else : ti_query = ti_query . filter ( TI . state . in_ ( acceptable_states ) ) tis_to_set_to_queued = ( ti_query . with_for_update ( ) . all ( ) ) if len ( tis_to_set_to_queued ) == 0 : self . log . info ( \"No tasks were able to have their state changed to queued.\" ) session . commit ( ) return [ ] # set TIs to queued state for task_instance in tis_to_set_to_queued : task_instance . state = State . QUEUED task_instance . queued_dttm = ( timezone . utcnow ( ) if not task_instance . queued_dttm else task_instance . queued_dttm ) session . merge ( task_instance ) # Generate a list of SimpleTaskInstance for the use of queuing # them in the executor. simple_task_instances = [ SimpleTaskInstance ( ti ) for ti in tis_to_set_to_queued ] task_instance_str = \"\\n\\t\" . join ( [ repr ( x ) for x in tis_to_set_to_queued ] ) session . commit ( ) self . log . info ( \"Setting the following %s tasks to queued state:\\n\\t%s\" , len ( tis_to_set_to_queued ) , task_instance_str ) return simple_task_instances\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _enqueue_task_instances_with_queued_state ( self , simple_dag_bag , simple_task_instances ) : TI = models . TaskInstance # actually enqueue them for simple_task_instance in simple_task_instances : simple_dag = simple_dag_bag . get_dag ( simple_task_instance . dag_id ) command = TI . generate_command ( simple_task_instance . dag_id , simple_task_instance . task_id , simple_task_instance . execution_date , local = True , mark_success = False , ignore_all_deps = False , ignore_depends_on_past = False , ignore_task_deps = False , ignore_ti_state = False , pool = simple_task_instance . pool , file_path = simple_dag . full_filepath , pickle_id = simple_dag . pickle_id ) priority = simple_task_instance . priority_weight queue = simple_task_instance . queue self . log . info ( \"Sending %s to executor with priority %s and queue %s\" , simple_task_instance . key , priority , queue ) self . executor . queue_command ( simple_task_instance , command , priority = priority , queue = queue )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _execute_task_instances ( self , simple_dag_bag , states , session = None ) : executable_tis = self . _find_executable_task_instances ( simple_dag_bag , states , session = session ) def query ( result , items ) : simple_tis_with_state_changed = self . _change_state_for_executable_task_instances ( items , states , session = session ) self . _enqueue_task_instances_with_queued_state ( simple_dag_bag , simple_tis_with_state_changed ) session . commit ( ) return result + len ( simple_tis_with_state_changed ) return helpers . reduce_in_chunks ( query , executable_tis , 0 , self . max_tis_per_query )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _change_state_for_tasks_failed_to_execute ( self , session ) : if self . executor . queued_tasks : TI = models . TaskInstance filter_for_ti_state_change = ( [ and_ ( TI . dag_id == dag_id , TI . task_id == task_id , TI . execution_date == execution_date , # The TI.try_number will return raw try_number+1 since the # ti is not running. And we need to -1 to match the DB record. TI . _try_number == try_number - 1 , TI . state == State . QUEUED ) for dag_id , task_id , execution_date , try_number in self . executor . queued_tasks . keys ( ) ] ) ti_query = ( session . query ( TI ) . filter ( or_ ( * filter_for_ti_state_change ) ) ) tis_to_set_to_scheduled = ( ti_query . with_for_update ( ) . all ( ) ) if len ( tis_to_set_to_scheduled ) == 0 : session . commit ( ) return # set TIs to queued state for task_instance in tis_to_set_to_scheduled : task_instance . state = State . SCHEDULED task_instance_str = \"\\n\\t\" . join ( [ repr ( x ) for x in tis_to_set_to_scheduled ] ) session . commit ( ) self . log . info ( \"Set the following tasks to scheduled state:\\n\\t%s\" , task_instance_str )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _process_dags ( self , dagbag , dags , tis_out ) : for dag in dags : dag = dagbag . get_dag ( dag . dag_id ) if not dag : self . log . error ( \"DAG ID %s was not found in the DagBag\" , dag . dag_id ) continue if dag . is_paused : self . log . info ( \"Not processing DAG %s since it's paused\" , dag . dag_id ) continue self . log . info ( \"Processing %s\" , dag . dag_id ) dag_run = self . create_dag_run ( dag ) if dag_run : expected_start_date = dag . following_schedule ( dag_run . execution_date ) if expected_start_date : schedule_delay = dag_run . start_date - expected_start_date Stats . timing ( 'dagrun.schedule_delay.{dag_id}' . format ( dag_id = dag . dag_id ) , schedule_delay ) self . log . info ( \"Created %s\" , dag_run ) self . _process_task_instances ( dag , tis_out ) self . manage_slas ( dag )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _process_executor_events ( self , simple_dag_bag , session = None ) : # TODO: this shares quite a lot of code with _manage_executor_state TI = models . TaskInstance for key , state in list ( self . executor . get_event_buffer ( simple_dag_bag . dag_ids ) . items ( ) ) : dag_id , task_id , execution_date , try_number = key self . log . info ( \"Executor reports execution of %s.%s execution_date=%s \" \"exited with status %s for try_number %s\" , dag_id , task_id , execution_date , state , try_number ) if state == State . FAILED or state == State . SUCCESS : qry = session . query ( TI ) . filter ( TI . dag_id == dag_id , TI . task_id == task_id , TI . execution_date == execution_date ) ti = qry . first ( ) if not ti : self . log . warning ( \"TaskInstance %s went missing from the database\" , ti ) continue # TODO: should we fail RUNNING as well, as we do in Backfills? if ti . try_number == try_number and ti . state == State . QUEUED : msg = ( \"Executor reports task instance {} finished ({}) \" \"although the task says its {}. Was the task \" \"killed externally?\" . format ( ti , state , ti . state ) ) self . log . error ( msg ) try : simple_dag = simple_dag_bag . get_dag ( dag_id ) dagbag = models . DagBag ( simple_dag . full_filepath ) dag = dagbag . get_dag ( dag_id ) ti . task = dag . get_task ( task_id ) ti . handle_failure ( msg ) except Exception : self . log . error ( \"Cannot load the dag bag to handle failure for %s\" \". Setting task to FAILED without callbacks or \" \"retries. Do you have enough resources?\" , ti ) ti . state = State . FAILED session . merge ( ti ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _execute_helper ( self ) : self . executor . start ( ) self . log . info ( \"Resetting orphaned tasks for active dag runs\" ) self . reset_state_for_orphaned_tasks ( ) # Start after resetting orphaned tasks to avoid stressing out DB. self . processor_agent . start ( ) execute_start_time = timezone . utcnow ( ) # Last time that self.heartbeat() was called. last_self_heartbeat_time = timezone . utcnow ( ) # For the execute duration, parse and schedule DAGs while True : self . log . debug ( \"Starting Loop...\" ) loop_start_time = time . time ( ) if self . using_sqlite : self . processor_agent . heartbeat ( ) # For the sqlite case w/ 1 thread, wait until the processor # is finished to avoid concurrent access to the DB. self . log . debug ( \"Waiting for processors to finish since we're using sqlite\" ) self . processor_agent . wait_until_finished ( ) self . log . debug ( \"Harvesting DAG parsing results\" ) simple_dags = self . processor_agent . harvest_simple_dags ( ) self . log . debug ( \"Harvested {} SimpleDAGs\" . format ( len ( simple_dags ) ) ) # Send tasks for execution if available simple_dag_bag = SimpleDagBag ( simple_dags ) if len ( simple_dags ) > 0 : try : simple_dag_bag = SimpleDagBag ( simple_dags ) # Handle cases where a DAG run state is set (perhaps manually) to # a non-running state. Handle task instances that belong to # DAG runs in those states # If a task instance is up for retry but the corresponding DAG run # isn't running, mark the task instance as FAILED so we don't try # to re-run it. self . _change_state_for_tis_without_dagrun ( simple_dag_bag , [ State . UP_FOR_RETRY ] , State . FAILED ) # If a task instance is scheduled or queued or up for reschedule, # but the corresponding DAG run isn't running, set the state to # NONE so we don't try to re-run it. self . _change_state_for_tis_without_dagrun ( simple_dag_bag , [ State . QUEUED , State . SCHEDULED , State . UP_FOR_RESCHEDULE ] , State . NONE ) self . _execute_task_instances ( simple_dag_bag , ( State . SCHEDULED , ) ) except Exception as e : self . log . error ( \"Error queuing tasks\" ) self . log . exception ( e ) continue # Call heartbeats self . log . debug ( \"Heartbeating the executor\" ) self . executor . heartbeat ( ) self . _change_state_for_tasks_failed_to_execute ( ) # Process events from the executor self . _process_executor_events ( simple_dag_bag ) # Heartbeat the scheduler periodically time_since_last_heartbeat = ( timezone . utcnow ( ) - last_self_heartbeat_time ) . total_seconds ( ) if time_since_last_heartbeat > self . heartrate : self . log . debug ( \"Heartbeating the scheduler\" ) self . heartbeat ( ) last_self_heartbeat_time = timezone . utcnow ( ) is_unit_test = conf . getboolean ( 'core' , 'unit_test_mode' ) loop_end_time = time . time ( ) loop_duration = loop_end_time - loop_start_time self . log . debug ( \"Ran scheduling loop in %.2f seconds\" , loop_duration ) if not is_unit_test : self . log . debug ( \"Sleeping for %.2f seconds\" , self . _processor_poll_interval ) time . sleep ( self . _processor_poll_interval ) # Exit early for a test mode, run one additional scheduler loop # to reduce the possibility that parsed DAG was put into the queue # by the DAG manager but not yet received by DAG agent. if self . processor_agent . done : self . _last_loop = True if self . _last_loop : self . log . info ( \"Exiting scheduler loop as all files\" \" have been processed {} times\" . format ( self . num_runs ) ) break if loop_duration < 1 and not is_unit_test : sleep_length = 1 - loop_duration self . log . debug ( \"Sleeping for {0:.2f} seconds to prevent excessive logging\" . format ( sleep_length ) ) sleep ( sleep_length ) # Stop any processors self . processor_agent . terminate ( ) # Verify that all files were processed, and if so, deactivate DAGs that # haven't been touched by the scheduler as they likely have been # deleted. if self . processor_agent . all_files_processed : self . log . info ( \"Deactivating DAGs that haven't been touched since %s\" , execute_start_time . isoformat ( ) ) models . DAG . deactivate_stale_dags ( execute_start_time ) self . executor . end ( ) settings . Session . remove ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def process_file ( self , file_path , zombies , pickle_dags = False , session = None ) : self . log . info ( \"Processing file %s for tasks to queue\" , file_path ) # As DAGs are parsed from this file, they will be converted into SimpleDags simple_dags = [ ] try : dagbag = models . DagBag ( file_path , include_examples = False ) except Exception : self . log . exception ( \"Failed at reloading the DAG file %s\" , file_path ) Stats . incr ( 'dag_file_refresh_error' , 1 , 1 ) return [ ] if len ( dagbag . dags ) > 0 : self . log . info ( \"DAG(s) %s retrieved from %s\" , dagbag . dags . keys ( ) , file_path ) else : self . log . warning ( \"No viable dags retrieved from %s\" , file_path ) self . update_import_errors ( session , dagbag ) return [ ] # Save individual DAGs in the ORM and update DagModel.last_scheduled_time for dag in dagbag . dags . values ( ) : dag . sync_to_db ( ) paused_dag_ids = [ dag . dag_id for dag in dagbag . dags . values ( ) if dag . is_paused ] # Pickle the DAGs (if necessary) and put them into a SimpleDag for dag_id in dagbag . dags : # Only return DAGs that are not paused if dag_id not in paused_dag_ids : dag = dagbag . get_dag ( dag_id ) pickle_id = None if pickle_dags : pickle_id = dag . pickle ( session ) . id simple_dags . append ( SimpleDag ( dag , pickle_id = pickle_id ) ) if len ( self . dag_ids ) > 0 : dags = [ dag for dag in dagbag . dags . values ( ) if dag . dag_id in self . dag_ids and dag . dag_id not in paused_dag_ids ] else : dags = [ dag for dag in dagbag . dags . values ( ) if not dag . parent_dag and dag . dag_id not in paused_dag_ids ] # Not using multiprocessing.Queue() since it's no longer a separate # process and due to some unusual behavior. (empty() incorrectly # returns true?) ti_keys_to_schedule = [ ] self . _process_dags ( dagbag , dags , ti_keys_to_schedule ) for ti_key in ti_keys_to_schedule : dag = dagbag . dags [ ti_key [ 0 ] ] task = dag . get_task ( ti_key [ 1 ] ) ti = models . TaskInstance ( task , ti_key [ 2 ] ) ti . refresh_from_db ( session = session , lock_for_update = True ) # We can defer checking the task dependency checks to the worker themselves # since they can be expensive to run in the scheduler. dep_context = DepContext ( deps = QUEUE_DEPS , ignore_task_deps = True ) # Only schedule tasks that have their dependencies met, e.g. to avoid # a task that recently got its state changed to RUNNING from somewhere # other than the scheduler from getting its state overwritten. # TODO(aoen): It's not great that we have to check all the task instance # dependencies twice; once to get the task scheduled, and again to actually # run the task. We should try to come up with a way to only check them once. if ti . are_dependencies_met ( dep_context = dep_context , session = session , verbose = True ) : # Task starts out in the scheduled state. All tasks in the # scheduled state will be sent to the executor ti . state = State . SCHEDULED # Also save this task instance to the DB. self . log . info ( \"Creating / updating %s in ORM\" , ti ) session . merge ( ti ) # commit batch session . commit ( ) # Record import errors into the ORM try : self . update_import_errors ( session , dagbag ) except Exception : self . log . exception ( \"Error logging import errors!\" ) try : dagbag . kill_zombies ( zombies ) except Exception : self . log . exception ( \"Error killing zombies!\" ) return simple_dags\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _update_counters ( self , ti_status ) : for key , ti in list ( ti_status . running . items ( ) ) : ti . refresh_from_db ( ) if ti . state == State . SUCCESS : ti_status . succeeded . add ( key ) self . log . debug ( \"Task instance %s succeeded. Don't rerun.\" , ti ) ti_status . running . pop ( key ) continue elif ti . state == State . SKIPPED : ti_status . skipped . add ( key ) self . log . debug ( \"Task instance %s skipped. Don't rerun.\" , ti ) ti_status . running . pop ( key ) continue elif ti . state == State . FAILED : self . log . error ( \"Task instance %s failed\" , ti ) ti_status . failed . add ( key ) ti_status . running . pop ( key ) continue # special case: if the task needs to run again put it back elif ti . state == State . UP_FOR_RETRY : self . log . warning ( \"Task instance %s is up for retry\" , ti ) ti_status . running . pop ( key ) ti_status . to_run [ key ] = ti # special case: if the task needs to be rescheduled put it back elif ti . state == State . UP_FOR_RESCHEDULE : self . log . warning ( \"Task instance %s is up for reschedule\" , ti ) ti_status . running . pop ( key ) ti_status . to_run [ key ] = ti # special case: The state of the task can be set to NONE by the task itself # when it reaches concurrency limits. It could also happen when the state # is changed externally, e.g. by clearing tasks from the ui. We need to cover # for that as otherwise those tasks would fall outside of the scope of # the backfill suddenly. elif ti . state == State . NONE : self . log . warning ( \"FIXME: task instance %s state was set to none externally or \" \"reaching concurrency limits. Re-adding task to queue.\" , ti ) ti . set_state ( State . SCHEDULED ) ti_status . running . pop ( key ) ti_status . to_run [ key ] = ti\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _manage_executor_state ( self , running ) : executor = self . executor for key , state in list ( executor . get_event_buffer ( ) . items ( ) ) : if key not in running : self . log . warning ( \"%s state %s not in running=%s\" , key , state , running . values ( ) ) continue ti = running [ key ] ti . refresh_from_db ( ) self . log . debug ( \"Executor state: %s task %s\" , state , ti ) if state == State . FAILED or state == State . SUCCESS : if ti . state == State . RUNNING or ti . state == State . QUEUED : msg = ( \"Executor reports task instance {} finished ({}) \" \"although the task says its {}. Was the task \" \"killed externally?\" . format ( ti , state , ti . state ) ) self . log . error ( msg ) ti . handle_failure ( msg )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_dag_run ( self , run_date , session = None ) : run_id = BackfillJob . ID_FORMAT_PREFIX . format ( run_date . isoformat ( ) ) # consider max_active_runs but ignore when running subdags respect_dag_max_active_limit = ( True if ( self . dag . schedule_interval and not self . dag . is_subdag ) else False ) current_active_dag_count = self . dag . get_num_active_runs ( external_trigger = False ) # check if we are scheduling on top of a already existing dag_run # we could find a \"scheduled\" run instead of a \"backfill\" run = DagRun . find ( dag_id = self . dag . dag_id , execution_date = run_date , session = session ) if run is not None and len ( run ) > 0 : run = run [ 0 ] if run . state == State . RUNNING : respect_dag_max_active_limit = False else : run = None # enforce max_active_runs limit for dag, special cases already # handled by respect_dag_max_active_limit if ( respect_dag_max_active_limit and current_active_dag_count >= self . dag . max_active_runs ) : return None run = run or self . dag . create_dagrun ( run_id = run_id , execution_date = run_date , start_date = timezone . utcnow ( ) , state = State . RUNNING , external_trigger = False , session = session , conf = self . conf , ) # set required transient field run . dag = self . dag # explicitly mark as backfill and running run . state = State . RUNNING run . run_id = run_id run . verify_integrity ( session = session ) return run\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _task_instances_for_dag_run ( self , dag_run , session = None ) : tasks_to_run = { } if dag_run is None : return tasks_to_run # check if we have orphaned tasks self . reset_state_for_orphaned_tasks ( filter_by_dag_run = dag_run , session = session ) # for some reason if we don't refresh the reference to run is lost dag_run . refresh_from_db ( ) make_transient ( dag_run ) # TODO(edgarRd): AIRFLOW-1464 change to batch query to improve perf for ti in dag_run . get_task_instances ( ) : # all tasks part of the backfill are scheduled to run if ti . state == State . NONE : ti . set_state ( State . SCHEDULED , session = session ) if ti . state != State . REMOVED : tasks_to_run [ ti . key ] = ti return tasks_to_run\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _process_backfill_task_instances ( self , ti_status , executor , pickle_id , start_date = None , session = None ) : executed_run_dates = [ ] while ( ( len ( ti_status . to_run ) > 0 or len ( ti_status . running ) > 0 ) and len ( ti_status . deadlocked ) == 0 ) : self . log . debug ( \"*** Clearing out not_ready list ***\" ) ti_status . not_ready . clear ( ) # we need to execute the tasks bottom to top # or leaf to root, as otherwise tasks might be # determined deadlocked while they are actually # waiting for their upstream to finish @ provide_session def _per_task_process ( task , key , ti , session = None ) : ti . refresh_from_db ( ) task = self . dag . get_task ( ti . task_id ) ti . task = task ignore_depends_on_past = ( self . ignore_first_depends_on_past and ti . execution_date == ( start_date or ti . start_date ) ) self . log . debug ( \"Task instance to run %s state %s\" , ti , ti . state ) # The task was already marked successful or skipped by a # different Job. Don't rerun it. if ti . state == State . SUCCESS : ti_status . succeeded . add ( key ) self . log . debug ( \"Task instance %s succeeded. Don't rerun.\" , ti ) ti_status . to_run . pop ( key ) if key in ti_status . running : ti_status . running . pop ( key ) return elif ti . state == State . SKIPPED : ti_status . skipped . add ( key ) self . log . debug ( \"Task instance %s skipped. Don't rerun.\" , ti ) ti_status . to_run . pop ( key ) if key in ti_status . running : ti_status . running . pop ( key ) return # guard against externally modified tasks instances or # in case max concurrency has been reached at task runtime elif ti . state == State . NONE : self . log . warning ( \"FIXME: task instance {} state was set to None \" \"externally. This should not happen\" ) ti . set_state ( State . SCHEDULED , session = session ) if self . rerun_failed_tasks : # Rerun failed tasks or upstreamed failed tasks if ti . state in ( State . FAILED , State . UPSTREAM_FAILED ) : self . log . error ( \"Task instance {ti} \" \"with state {state}\" . format ( ti = ti , state = ti . state ) ) if key in ti_status . running : ti_status . running . pop ( key ) # Reset the failed task in backfill to scheduled state ti . set_state ( State . SCHEDULED , session = session ) else : # Default behaviour which works for subdag. if ti . state in ( State . FAILED , State . UPSTREAM_FAILED ) : self . log . error ( \"Task instance {ti} \" \"with {state} state\" . format ( ti = ti , state = ti . state ) ) ti_status . failed . add ( key ) ti_status . to_run . pop ( key ) if key in ti_status . running : ti_status . running . pop ( key ) return backfill_context = DepContext ( deps = RUN_DEPS , ignore_depends_on_past = ignore_depends_on_past , ignore_task_deps = self . ignore_task_deps , flag_upstream_failed = True ) # Is the task runnable? -- then run it # the dependency checker can change states of tis if ti . are_dependencies_met ( dep_context = backfill_context , session = session , verbose = self . verbose ) : ti . refresh_from_db ( lock_for_update = True , session = session ) if ti . state in ( State . SCHEDULED , State . UP_FOR_RETRY , State . UP_FOR_RESCHEDULE ) : if executor . has_task ( ti ) : self . log . debug ( \"Task Instance %s already in executor \" \"waiting for queue to clear\" , ti ) else : self . log . debug ( 'Sending %s to executor' , ti ) # Skip scheduled state, we are executing immediately ti . state = State . QUEUED ti . queued_dttm = timezone . utcnow ( ) if not ti . queued_dttm else ti . queued_dttm session . merge ( ti ) cfg_path = None if executor . __class__ in ( executors . LocalExecutor , executors . SequentialExecutor ) : cfg_path = tmp_configuration_copy ( ) executor . queue_task_instance ( ti , mark_success = self . mark_success , pickle_id = pickle_id , ignore_task_deps = self . ignore_task_deps , ignore_depends_on_past = ignore_depends_on_past , pool = self . pool , cfg_path = cfg_path ) ti_status . running [ key ] = ti ti_status . to_run . pop ( key ) session . commit ( ) return if ti . state == State . UPSTREAM_FAILED : self . log . error ( \"Task instance %s upstream failed\" , ti ) ti_status . failed . add ( key ) ti_status . to_run . pop ( key ) if key in ti_status . running : ti_status . running . pop ( key ) return # special case if ti . state == State . UP_FOR_RETRY : self . log . debug ( \"Task instance %s retry period not \" \"expired yet\" , ti ) if key in ti_status . running : ti_status . running . pop ( key ) ti_status . to_run [ key ] = ti return # special case if ti . state == State . UP_FOR_RESCHEDULE : self . log . debug ( \"Task instance %s reschedule period not \" \"expired yet\" , ti ) if key in ti_status . running : ti_status . running . pop ( key ) ti_status . to_run [ key ] = ti return # all remaining tasks self . log . debug ( 'Adding %s to not_ready' , ti ) ti_status . not_ready . add ( key ) non_pool_slots = conf . getint ( 'core' , 'non_pooled_backfill_task_slot_count' ) try : for task in self . dag . topological_sort ( ) : for key , ti in list ( ti_status . to_run . items ( ) ) : if task . task_id != ti . task_id : continue if task . pool : pool = session . query ( models . Pool ) . filter ( models . Pool . pool == task . pool ) . first ( ) if not pool : raise PoolNotFound ( 'Unknown pool: {}' . format ( task . pool ) ) open_slots = pool . open_slots ( session = session ) if open_slots <= 0 : raise NoAvailablePoolSlot ( \"Not scheduling since there are \" \"%s open slots in pool %s\" . format ( open_slots , task . pool ) ) else : if non_pool_slots <= 0 : raise NoAvailablePoolSlot ( \"Not scheduling since there are no \" \"non_pooled_backfill_task_slot_count.\" ) non_pool_slots -= 1 num_running_tasks = DAG . get_num_task_instances ( self . dag_id , states = ( State . QUEUED , State . RUNNING ) ) if num_running_tasks >= self . dag . concurrency : raise DagConcurrencyLimitReached ( \"Not scheduling since concurrency limit \" \"is reached.\" ) _per_task_process ( task , key , ti ) except ( NoAvailablePoolSlot , DagConcurrencyLimitReached ) as e : self . log . debug ( e ) # execute the tasks in the queue self . heartbeat ( ) executor . heartbeat ( ) # If the set of tasks that aren't ready ever equals the set of # tasks to run and there are no running tasks then the backfill # is deadlocked if ( ti_status . not_ready and ti_status . not_ready == set ( ti_status . to_run ) and len ( ti_status . running ) == 0 ) : self . log . warning ( \"Deadlock discovered for ti_status.to_run=%s\" , ti_status . to_run . values ( ) ) ti_status . deadlocked . update ( ti_status . to_run . values ( ) ) ti_status . to_run . clear ( ) # check executor state self . _manage_executor_state ( ti_status . running ) # update the task counters self . _update_counters ( ti_status = ti_status ) # update dag run state _dag_runs = ti_status . active_runs [ : ] for run in _dag_runs : run . update_state ( session = session ) if run . state in State . finished ( ) : ti_status . finished_runs += 1 ti_status . active_runs . remove ( run ) executed_run_dates . append ( run . execution_date ) self . _log_progress ( ti_status ) # return updated status return executed_run_dates\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _execute_for_run_dates ( self , run_dates , ti_status , executor , pickle_id , start_date , session = None ) : for next_run_date in run_dates : dag_run = self . _get_dag_run ( next_run_date , session = session ) tis_map = self . _task_instances_for_dag_run ( dag_run , session = session ) if dag_run is None : continue ti_status . active_runs . append ( dag_run ) ti_status . to_run . update ( tis_map or { } ) processed_dag_run_dates = self . _process_backfill_task_instances ( ti_status = ti_status , executor = executor , pickle_id = pickle_id , start_date = start_date , session = session ) ti_status . executed_dag_run_dates . update ( processed_dag_run_dates )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _set_unfinished_dag_runs_to_failed ( self , dag_runs , session = None ) : for dag_run in dag_runs : dag_run . update_state ( ) if dag_run . state not in State . finished ( ) : dag_run . set_state ( State . FAILED ) session . merge ( dag_run )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _execute ( self , session = None ) : ti_status = BackfillJob . _DagRunTaskStatus ( ) start_date = self . bf_start_date # Get intervals between the start/end dates, which will turn into dag runs run_dates = self . dag . get_run_dates ( start_date = start_date , end_date = self . bf_end_date ) if self . run_backwards : tasks_that_depend_on_past = [ t . task_id for t in self . dag . task_dict . values ( ) if t . depends_on_past ] if tasks_that_depend_on_past : raise AirflowException ( 'You cannot backfill backwards because one or more tasks depend_on_past: {}' . format ( \",\" . join ( tasks_that_depend_on_past ) ) ) run_dates = run_dates [ : : - 1 ] if len ( run_dates ) == 0 : self . log . info ( \"No run dates were found for the given dates and dag interval.\" ) return # picklin' pickle_id = None if not self . donot_pickle and self . executor . __class__ not in ( executors . LocalExecutor , executors . SequentialExecutor ) : pickle = DagPickle ( self . dag ) session . add ( pickle ) session . commit ( ) pickle_id = pickle . id executor = self . executor executor . start ( ) ti_status . total_runs = len ( run_dates ) # total dag runs in backfill try : remaining_dates = ti_status . total_runs while remaining_dates > 0 : dates_to_process = [ run_date for run_date in run_dates if run_date not in ti_status . executed_dag_run_dates ] self . _execute_for_run_dates ( run_dates = dates_to_process , ti_status = ti_status , executor = executor , pickle_id = pickle_id , start_date = start_date , session = session ) remaining_dates = ( ti_status . total_runs - len ( ti_status . executed_dag_run_dates ) ) err = self . _collect_errors ( ti_status = ti_status , session = session ) if err : raise AirflowException ( err ) if remaining_dates > 0 : self . log . info ( \"max_active_runs limit for dag %s has been reached \" \" - waiting for other dag runs to finish\" , self . dag_id ) time . sleep ( self . delay_on_limit_secs ) except ( KeyboardInterrupt , SystemExit ) : self . log . warning ( \"Backfill terminated by user.\" ) # TODO: we will need to terminate running task instances and set the # state to failed. self . _set_unfinished_dag_runs_to_failed ( ti_status . active_runs ) finally : session . commit ( ) executor . end ( ) self . log . info ( \"Backfill done. Exiting.\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def heartbeat_callback ( self , session = None ) : if self . terminating : # ensure termination if processes are created later self . task_runner . terminate ( ) return self . task_instance . refresh_from_db ( ) ti = self . task_instance fqdn = get_hostname ( ) same_hostname = fqdn == ti . hostname same_process = ti . pid == os . getpid ( ) if ti . state == State . RUNNING : if not same_hostname : self . log . warning ( \"The recorded hostname %s \" \"does not match this instance's hostname \" \"%s\" , ti . hostname , fqdn ) raise AirflowException ( \"Hostname of job runner does not match\" ) elif not same_process : current_pid = os . getpid ( ) self . log . warning ( \"Recorded pid %s does not match \" \"the current pid %s\" , ti . pid , current_pid ) raise AirflowException ( \"PID of job runner does not match\" ) elif ( self . task_runner . return_code ( ) is None and hasattr ( self . task_runner , 'process' ) ) : self . log . warning ( \"State of this instance has been externally set to %s. \" \"Taking the poison pill.\" , ti . state ) self . task_runner . terminate ( ) self . terminating = True\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_client ( self , project_id ) : if not self . _client : self . _client = Client ( project = project_id , credentials = self . _get_credentials ( ) ) return self . _client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_instance ( self , instance_id , project_id = None ) : instance = self . _get_client ( project_id = project_id ) . instance ( instance_id = instance_id ) if not instance . exists ( ) : return None return instance\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _apply_to_instance ( self , project_id , instance_id , configuration_name , node_count , display_name , func ) : # noinspection PyUnresolvedReferences instance = self . _get_client ( project_id = project_id ) . instance ( instance_id = instance_id , configuration_name = configuration_name , node_count = node_count , display_name = display_name ) try : operation = func ( instance ) # type: Operation except GoogleAPICallError as e : self . log . error ( 'An error occurred: %s. Exiting.' , e . message ) raise e if operation : result = operation . result ( ) self . log . info ( result )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_instance ( self , instance_id , configuration_name , node_count , display_name , project_id = None ) : self . _apply_to_instance ( project_id , instance_id , configuration_name , node_count , display_name , lambda x : x . create ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_instance ( self , instance_id , configuration_name , node_count , display_name , project_id = None ) : return self . _apply_to_instance ( project_id , instance_id , configuration_name , node_count , display_name , lambda x : x . update ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_instance ( self , instance_id , project_id = None ) : instance = self . _get_client ( project_id = project_id ) . instance ( instance_id ) try : instance . delete ( ) return except GoogleAPICallError as e : self . log . error ( 'An error occurred: %s. Exiting.' , e . message ) raise e\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_database ( self , instance_id , database_id , project_id = None ) : instance = self . _get_client ( project_id = project_id ) . instance ( instance_id = instance_id ) if not instance . exists ( ) : raise AirflowException ( \"The instance {} does not exist in project {} !\" . format ( instance_id , project_id ) ) database = instance . database ( database_id = database_id ) if not database . exists ( ) : return None else : return database\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_database ( self , instance_id , database_id , ddl_statements , project_id = None ) : instance = self . _get_client ( project_id = project_id ) . instance ( instance_id = instance_id ) if not instance . exists ( ) : raise AirflowException ( \"The instance {} does not exist in project {} !\" . format ( instance_id , project_id ) ) database = instance . database ( database_id = database_id , ddl_statements = ddl_statements ) try : operation = database . create ( ) # type: Operation except GoogleAPICallError as e : self . log . error ( 'An error occurred: %s. Exiting.' , e . message ) raise e if operation : result = operation . result ( ) self . log . info ( result ) return\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_database ( self , instance_id , database_id , ddl_statements , project_id = None , operation_id = None ) : instance = self . _get_client ( project_id = project_id ) . instance ( instance_id = instance_id ) if not instance . exists ( ) : raise AirflowException ( \"The instance {} does not exist in project {} !\" . format ( instance_id , project_id ) ) database = instance . database ( database_id = database_id ) try : operation = database . update_ddl ( ddl_statements = ddl_statements , operation_id = operation_id ) if operation : result = operation . result ( ) self . log . info ( result ) return except AlreadyExists as e : if e . code == 409 and operation_id in e . message : self . log . info ( \"Replayed update_ddl message - the operation id %s \" \"was already done before.\" , operation_id ) return except GoogleAPICallError as e : self . log . error ( 'An error occurred: %s. Exiting.' , e . message ) raise e\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_database ( self , instance_id , database_id , project_id = None ) : instance = self . _get_client ( project_id = project_id ) . instance ( instance_id = instance_id ) if not instance . exists ( ) : raise AirflowException ( \"The instance {} does not exist in project {} !\" . format ( instance_id , project_id ) ) database = instance . database ( database_id = database_id ) if not database . exists ( ) : self . log . info ( \"The database {} is already deleted from instance {}. \" \"Exiting.\" . format ( database_id , instance_id ) ) return try : operation = database . drop ( ) # type: Operation except GoogleAPICallError as e : self . log . error ( 'An error occurred: %s. Exiting.' , e . message ) raise e if operation : result = operation . result ( ) self . log . info ( result ) return\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute_dml ( self , instance_id , database_id , queries , project_id = None ) : self . _get_client ( project_id = project_id ) . instance ( instance_id = instance_id ) . database ( database_id = database_id ) . run_in_transaction ( lambda transaction : self . _execute_sql_in_transaction ( transaction , queries ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poke ( self , context ) : self . log . info ( 'Poking for %s' , self . attachment_name ) with ImapHook ( imap_conn_id = self . conn_id ) as imap_hook : return imap_hook . has_mail_attachment ( name = self . attachment_name , mail_folder = self . mail_folder , check_regex = self . check_regex )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def prepare_additional_parameters ( additional_properties , language_hints , web_detection_params ) : if language_hints is None and web_detection_params is None : return additional_properties if additional_properties is None : return { } merged_additional_parameters = deepcopy ( additional_properties ) if 'image_context' not in merged_additional_parameters : merged_additional_parameters [ 'image_context' ] = { } merged_additional_parameters [ 'image_context' ] [ 'language_hints' ] = merged_additional_parameters [ 'image_context' ] . get ( 'language_hints' , language_hints ) merged_additional_parameters [ 'image_context' ] [ 'web_detection_params' ] = merged_additional_parameters [ 'image_context' ] . get ( 'web_detection_params' , web_detection_params ) return merged_additional_parameters\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : if self . session and not self . session . is_shutdown : return self . session self . session = self . cluster . connect ( self . keyspace ) return self . session\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def table_exists ( self , table ) : keyspace = self . keyspace if '.' in table : keyspace , table = table . split ( '.' , 1 ) cluster_metadata = self . get_conn ( ) . cluster . metadata return ( keyspace in cluster_metadata . keyspaces and table in cluster_metadata . keyspaces [ keyspace ] . tables )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def record_exists ( self , table , keys ) : keyspace = self . keyspace if '.' in table : keyspace , table = table . split ( '.' , 1 ) ks = \" AND \" . join ( \"{}=%({})s\" . format ( key , key ) for key in keys . keys ( ) ) cql = \"SELECT * FROM {keyspace}.{table} WHERE {keys}\" . format ( keyspace = keyspace , table = table , keys = ks ) try : rs = self . get_conn ( ) . execute ( cql , keys ) return rs . one ( ) is not None except Exception : return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_spark_submit_command ( self , application ) : connection_cmd = self . _get_spark_binary_path ( ) # The url ot the spark master connection_cmd += [ \"--master\" , self . _connection [ 'master' ] ] if self . _conf : for key in self . _conf : connection_cmd += [ \"--conf\" , \"{}={}\" . format ( key , str ( self . _conf [ key ] ) ) ] if self . _env_vars and ( self . _is_kubernetes or self . _is_yarn ) : if self . _is_yarn : tmpl = \"spark.yarn.appMasterEnv.{}={}\" else : tmpl = \"spark.kubernetes.driverEnv.{}={}\" for key in self . _env_vars : connection_cmd += [ \"--conf\" , tmpl . format ( key , str ( self . _env_vars [ key ] ) ) ] elif self . _env_vars and self . _connection [ 'deploy_mode' ] != \"cluster\" : self . _env = self . _env_vars # Do it on Popen of the process elif self . _env_vars and self . _connection [ 'deploy_mode' ] == \"cluster\" : raise AirflowException ( \"SparkSubmitHook env_vars is not supported in standalone-cluster mode.\" ) if self . _is_kubernetes : connection_cmd += [ \"--conf\" , \"spark.kubernetes.namespace={}\" . format ( self . _connection [ 'namespace' ] ) ] if self . _files : connection_cmd += [ \"--files\" , self . _files ] if self . _py_files : connection_cmd += [ \"--py-files\" , self . _py_files ] if self . _archives : connection_cmd += [ \"--archives\" , self . _archives ] if self . _driver_class_path : connection_cmd += [ \"--driver-class-path\" , self . _driver_class_path ] if self . _jars : connection_cmd += [ \"--jars\" , self . _jars ] if self . _packages : connection_cmd += [ \"--packages\" , self . _packages ] if self . _exclude_packages : connection_cmd += [ \"--exclude-packages\" , self . _exclude_packages ] if self . _repositories : connection_cmd += [ \"--repositories\" , self . _repositories ] if self . _num_executors : connection_cmd += [ \"--num-executors\" , str ( self . _num_executors ) ] if self . _total_executor_cores : connection_cmd += [ \"--total-executor-cores\" , str ( self . _total_executor_cores ) ] if self . _executor_cores : connection_cmd += [ \"--executor-cores\" , str ( self . _executor_cores ) ] if self . _executor_memory : connection_cmd += [ \"--executor-memory\" , self . _executor_memory ] if self . _driver_memory : connection_cmd += [ \"--driver-memory\" , self . _driver_memory ] if self . _keytab : connection_cmd += [ \"--keytab\" , self . _keytab ] if self . _principal : connection_cmd += [ \"--principal\" , self . _principal ] if self . _name : connection_cmd += [ \"--name\" , self . _name ] if self . _java_class : connection_cmd += [ \"--class\" , self . _java_class ] if self . _verbose : connection_cmd += [ \"--verbose\" ] if self . _connection [ 'queue' ] : connection_cmd += [ \"--queue\" , self . _connection [ 'queue' ] ] if self . _connection [ 'deploy_mode' ] : connection_cmd += [ \"--deploy-mode\" , self . _connection [ 'deploy_mode' ] ] # The actual script to execute connection_cmd += [ application ] # Append any application arguments if self . _application_args : connection_cmd += self . _application_args self . log . info ( \"Spark-Submit cmd: %s\" , connection_cmd ) return connection_cmd\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_track_driver_status_command ( self ) : connection_cmd = self . _get_spark_binary_path ( ) # The url ot the spark master connection_cmd += [ \"--master\" , self . _connection [ 'master' ] ] # The driver id so we can poll for its status if self . _driver_id : connection_cmd += [ \"--status\" , self . _driver_id ] else : raise AirflowException ( \"Invalid status: attempted to poll driver \" + \"status but no driver id is known. Giving up.\" ) self . log . debug ( \"Poll driver status cmd: %s\" , connection_cmd ) return connection_cmd\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def submit ( self , application = \"\" , * * kwargs ) : spark_submit_cmd = self . _build_spark_submit_command ( application ) if hasattr ( self , '_env' ) : env = os . environ . copy ( ) env . update ( self . _env ) kwargs [ \"env\" ] = env self . _submit_sp = subprocess . Popen ( spark_submit_cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , bufsize = - 1 , universal_newlines = True , * * kwargs ) self . _process_spark_submit_log ( iter ( self . _submit_sp . stdout . readline , '' ) ) returncode = self . _submit_sp . wait ( ) # Check spark-submit return code. In Kubernetes mode, also check the value # of exit code in the log, as it may differ. if returncode or ( self . _is_kubernetes and self . _spark_exit_code != 0 ) : raise AirflowException ( \"Cannot execute: {}. Error code is: {}.\" . format ( spark_submit_cmd , returncode ) ) self . log . debug ( \"Should track driver: {}\" . format ( self . _should_track_driver_status ) ) # We want the Airflow job to wait until the Spark driver is finished if self . _should_track_driver_status : if self . _driver_id is None : raise AirflowException ( \"No driver id is known: something went wrong when executing \" + \"the spark submit command\" ) # We start with the SUBMITTED status as initial status self . _driver_status = \"SUBMITTED\" # Start tracking the driver status (blocking function) self . _start_driver_status_tracking ( ) if self . _driver_status != \"FINISHED\" : raise AirflowException ( \"ERROR : Driver {} badly exited with status {}\" . format ( self . _driver_id , self . _driver_status ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _process_spark_submit_log ( self , itr ) : # Consume the iterator for line in itr : line = line . strip ( ) # If we run yarn cluster mode, we want to extract the application id from # the logs so we can kill the application when we stop it unexpectedly if self . _is_yarn and self . _connection [ 'deploy_mode' ] == 'cluster' : match = re . search ( '(application[0-9_]+)' , line ) if match : self . _yarn_application_id = match . groups ( ) [ 0 ] self . log . info ( \"Identified spark driver id: %s\" , self . _yarn_application_id ) # If we run Kubernetes cluster mode, we want to extract the driver pod id # from the logs so we can kill the application when we stop it unexpectedly elif self . _is_kubernetes : match = re . search ( r'\\s*pod name: ((.+?)-([a-z0-9]+)-driver)' , line ) if match : self . _kubernetes_driver_pod = match . groups ( ) [ 0 ] self . log . info ( \"Identified spark driver pod: %s\" , self . _kubernetes_driver_pod ) # Store the Spark Exit code match_exit_code = re . search ( r'\\s*Exit code: (\\d+)' , line ) if match_exit_code : self . _spark_exit_code = int ( match_exit_code . groups ( ) [ 0 ] ) # if we run in standalone cluster mode and we want to track the driver status # we need to extract the driver id from the logs. This allows us to poll for # the status using the driver id. Also, we can kill the driver when needed. elif self . _should_track_driver_status and not self . _driver_id : match_driver_id = re . search ( r'(driver-[0-9\\-]+)' , line ) if match_driver_id : self . _driver_id = match_driver_id . groups ( ) [ 0 ] self . log . info ( \"identified spark driver id: {}\" . format ( self . _driver_id ) ) else : self . log . info ( line ) self . log . debug ( \"spark submit log: {}\" . format ( line ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _process_spark_status_log ( self , itr ) : # Consume the iterator for line in itr : line = line . strip ( ) # Check if the log line is about the driver status and extract the status. if \"driverState\" in line : self . _driver_status = line . split ( ' : ' ) [ 1 ] . replace ( ',' , '' ) . replace ( '\\\"' , '' ) . strip ( ) self . log . debug ( \"spark driver status log: {}\" . format ( line ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _start_driver_status_tracking ( self ) : # When your Spark Standalone cluster is not performing well # due to misconfiguration or heavy loads. # it is possible that the polling request will timeout. # Therefore we use a simple retry mechanism. missed_job_status_reports = 0 max_missed_job_status_reports = 10 # Keep polling as long as the driver is processing while self . _driver_status not in [ \"FINISHED\" , \"UNKNOWN\" , \"KILLED\" , \"FAILED\" , \"ERROR\" ] : # Sleep for 1 second as we do not want to spam the cluster time . sleep ( 1 ) self . log . debug ( \"polling status of spark driver with id {}\" . format ( self . _driver_id ) ) poll_drive_status_cmd = self . _build_track_driver_status_command ( ) status_process = subprocess . Popen ( poll_drive_status_cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , bufsize = - 1 , universal_newlines = True ) self . _process_spark_status_log ( iter ( status_process . stdout . readline , '' ) ) returncode = status_process . wait ( ) if returncode : if missed_job_status_reports < max_missed_job_status_reports : missed_job_status_reports = missed_job_status_reports + 1 else : raise AirflowException ( \"Failed to poll for the driver status {} times: returncode = {}\" . format ( max_missed_job_status_reports , returncode ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_spark_driver_kill_command ( self ) : # If the spark_home is passed then build the spark-submit executable path using # the spark_home; otherwise assume that spark-submit is present in the path to # the executing user if self . _connection [ 'spark_home' ] : connection_cmd = [ os . path . join ( self . _connection [ 'spark_home' ] , 'bin' , self . _connection [ 'spark_binary' ] ) ] else : connection_cmd = [ self . _connection [ 'spark_binary' ] ] # The url ot the spark master connection_cmd += [ \"--master\" , self . _connection [ 'master' ] ] # The actual kill command connection_cmd += [ \"--kill\" , self . _driver_id ] self . log . debug ( \"Spark-Kill cmd: %s\" , connection_cmd ) return connection_cmd\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_task_runner ( local_task_job ) : if _TASK_RUNNER == \"StandardTaskRunner\" : return StandardTaskRunner ( local_task_job ) elif _TASK_RUNNER == \"CgroupTaskRunner\" : from airflow . contrib . task_runner . cgroup_task_runner import CgroupTaskRunner return CgroupTaskRunner ( local_task_job ) else : raise AirflowException ( \"Unknown task runner type {}\" . format ( _TASK_RUNNER ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _wait_for_task_ended ( self ) : try : waiter = self . client . get_waiter ( 'job_execution_complete' ) waiter . config . max_attempts = sys . maxsize # timeout is managed by airflow waiter . wait ( jobs = [ self . jobId ] ) except ValueError : # If waiter not available use expo retry = True retries = 0 while retries < self . max_retries and retry : self . log . info ( 'AWS Batch retry in the next %s seconds' , retries ) response = self . client . describe_jobs ( jobs = [ self . jobId ] ) if response [ 'jobs' ] [ - 1 ] [ 'status' ] in [ 'SUCCEEDED' , 'FAILED' ] : retry = False sleep ( 1 + pow ( retries * 0.1 , 2 ) ) retries += 1\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _query_mysql ( self ) : mysql = MySqlHook ( mysql_conn_id = self . mysql_conn_id ) conn = mysql . get_conn ( ) cursor = conn . cursor ( ) cursor . execute ( self . sql ) return cursor\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _write_local_data_files ( self , cursor ) : schema = list ( map ( lambda schema_tuple : schema_tuple [ 0 ] , cursor . description ) ) col_type_dict = self . _get_col_type_dict ( ) file_no = 0 tmp_file_handle = NamedTemporaryFile ( delete = True ) if self . export_format == 'csv' : file_mime_type = 'text/csv' else : file_mime_type = 'application/json' files_to_upload = [ { 'file_name' : self . filename . format ( file_no ) , 'file_handle' : tmp_file_handle , 'file_mime_type' : file_mime_type } ] if self . export_format == 'csv' : csv_writer = self . _configure_csv_file ( tmp_file_handle , schema ) for row in cursor : # Convert datetime objects to utc seconds, and decimals to floats. # Convert binary type object to string encoded with base64. row = self . _convert_types ( schema , col_type_dict , row ) if self . export_format == 'csv' : csv_writer . writerow ( row ) else : row_dict = dict ( zip ( schema , row ) ) # TODO validate that row isn't > 2MB. BQ enforces a hard row size of 2MB. s = json . dumps ( row_dict , sort_keys = True ) . encode ( 'utf-8' ) tmp_file_handle . write ( s ) # Append newline to make dumps BigQuery compatible. tmp_file_handle . write ( b'\\n' ) # Stop if the file exceeds the file size limit. if tmp_file_handle . tell ( ) >= self . approx_max_file_size_bytes : file_no += 1 tmp_file_handle = NamedTemporaryFile ( delete = True ) files_to_upload . append ( { 'file_name' : self . filename . format ( file_no ) , 'file_handle' : tmp_file_handle , 'file_mime_type' : file_mime_type } ) if self . export_format == 'csv' : csv_writer = self . _configure_csv_file ( tmp_file_handle , schema ) return files_to_upload\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _configure_csv_file ( self , file_handle , schema ) : csv_writer = csv . writer ( file_handle , encoding = 'utf-8' , delimiter = self . field_delimiter ) csv_writer . writerow ( schema ) return csv_writer\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _write_local_schema_file ( self , cursor ) : schema_str = None schema_file_mime_type = 'application/json' tmp_schema_file_handle = NamedTemporaryFile ( delete = True ) if self . schema is not None and isinstance ( self . schema , string_types ) : schema_str = self . schema . encode ( 'utf-8' ) elif self . schema is not None and isinstance ( self . schema , list ) : schema_str = json . dumps ( self . schema ) . encode ( 'utf-8' ) else : schema = [ ] for field in cursor . description : # See PEP 249 for details about the description tuple. field_name = field [ 0 ] field_type = self . type_map ( field [ 1 ] ) # Always allow TIMESTAMP to be nullable. MySQLdb returns None types # for required fields because some MySQL timestamps can't be # represented by Python's datetime (e.g. 0000-00-00 00:00:00). if field [ 6 ] or field_type == 'TIMESTAMP' : field_mode = 'NULLABLE' else : field_mode = 'REQUIRED' schema . append ( { 'name' : field_name , 'type' : field_type , 'mode' : field_mode , } ) schema_str = json . dumps ( schema , sort_keys = True ) . encode ( 'utf-8' ) tmp_schema_file_handle . write ( schema_str ) self . log . info ( 'Using schema for %s: %s' , self . schema_filename , schema_str ) schema_file_to_upload = { 'file_name' : self . schema_filename , 'file_handle' : tmp_schema_file_handle , 'file_mime_type' : schema_file_mime_type } return schema_file_to_upload\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _upload_to_gcs ( self , files_to_upload ) : hook = GoogleCloudStorageHook ( google_cloud_storage_conn_id = self . google_cloud_storage_conn_id , delegate_to = self . delegate_to ) for tmp_file in files_to_upload : hook . upload ( self . bucket , tmp_file . get ( 'file_name' ) , tmp_file . get ( 'file_handle' ) . name , mime_type = tmp_file . get ( 'file_mime_type' ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _convert_types ( schema , col_type_dict , row ) : converted_row = [ ] for col_name , col_val in zip ( schema , row ) : if type ( col_val ) in ( datetime , date ) : col_val = time . mktime ( col_val . timetuple ( ) ) elif isinstance ( col_val , Decimal ) : col_val = float ( col_val ) elif col_type_dict . get ( col_name ) == \"BYTES\" : col_val = base64 . standard_b64encode ( col_val ) . decode ( 'ascii' ) else : col_val = col_val converted_row . append ( col_val ) return converted_row\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_col_type_dict ( self ) : schema = [ ] if isinstance ( self . schema , string_types ) : schema = json . loads ( self . schema ) elif isinstance ( self . schema , list ) : schema = self . schema elif self . schema is not None : self . log . warn ( 'Using default schema due to unexpected type.' 'Should be a string or list.' ) col_type_dict = { } try : col_type_dict = { col [ 'name' ] : col [ 'type' ] for col in schema } except KeyError : self . log . warn ( 'Using default schema due to missing name or type. Please ' 'refer to: https://cloud.google.com/bigquery/docs/schemas' '#specifying_a_json_schema_file' ) return col_type_dict\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def type_map ( cls , mysql_type ) : d = { FIELD_TYPE . INT24 : 'INTEGER' , FIELD_TYPE . TINY : 'INTEGER' , FIELD_TYPE . BIT : 'INTEGER' , FIELD_TYPE . DATETIME : 'TIMESTAMP' , FIELD_TYPE . DATE : 'TIMESTAMP' , FIELD_TYPE . DECIMAL : 'FLOAT' , FIELD_TYPE . NEWDECIMAL : 'FLOAT' , FIELD_TYPE . DOUBLE : 'FLOAT' , FIELD_TYPE . FLOAT : 'FLOAT' , FIELD_TYPE . LONG : 'INTEGER' , FIELD_TYPE . LONGLONG : 'INTEGER' , FIELD_TYPE . SHORT : 'INTEGER' , FIELD_TYPE . TIMESTAMP : 'TIMESTAMP' , FIELD_TYPE . YEAR : 'INTEGER' , } return d [ mysql_type ] if mysql_type in d else 'STRING'\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def authenticate ( session , username , password ) : if not username or not password : raise AuthenticationError ( ) user = session . query ( PasswordUser ) . filter ( PasswordUser . username == username ) . first ( ) if not user : raise AuthenticationError ( ) if not user . authenticate ( password ) : raise AuthenticationError ( ) log . info ( \"User %s successfully authenticated\" , username ) return user\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . hook = SqoopHook ( conn_id = self . conn_id , verbose = self . verbose , num_mappers = self . num_mappers , hcatalog_database = self . hcatalog_database , hcatalog_table = self . hcatalog_table , properties = self . properties ) if self . cmd_type == 'export' : self . hook . export_table ( table = self . table , export_dir = self . export_dir , input_null_string = self . input_null_string , input_null_non_string = self . input_null_non_string , staging_table = self . staging_table , clear_staging_table = self . clear_staging_table , enclosed_by = self . enclosed_by , escaped_by = self . escaped_by , input_fields_terminated_by = self . input_fields_terminated_by , input_lines_terminated_by = self . input_lines_terminated_by , input_optionally_enclosed_by = self . input_optionally_enclosed_by , batch = self . batch , relaxed_isolation = self . relaxed_isolation , extra_export_options = self . extra_export_options ) elif self . cmd_type == 'import' : # add create hcatalog table to extra import options if option passed # if new params are added to constructor can pass them in here # so don't modify sqoop_hook for each param if self . create_hcatalog_table : self . extra_import_options [ 'create-hcatalog-table' ] = '' if self . table and self . query : raise AirflowException ( 'Cannot specify query and table together. Need to specify either or.' ) if self . table : self . hook . import_table ( table = self . table , target_dir = self . target_dir , append = self . append , file_type = self . file_type , columns = self . columns , split_by = self . split_by , where = self . where , direct = self . direct , driver = self . driver , extra_import_options = self . extra_import_options ) elif self . query : self . hook . import_query ( query = self . query , target_dir = self . target_dir , append = self . append , file_type = self . file_type , split_by = self . split_by , direct = self . direct , driver = self . driver , extra_import_options = self . extra_import_options ) else : raise AirflowException ( \"Provide query or table parameter to import using Sqoop\" ) else : raise AirflowException ( \"cmd_type should be 'import' or 'export'\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def apply_lineage ( func ) : backend = _get_backend ( ) @ wraps ( func ) def wrapper ( self , context , * args , * * kwargs ) : self . log . debug ( \"Backend: %s, Lineage called with inlets: %s, outlets: %s\" , backend , self . inlets , self . outlets ) ret_val = func ( self , context , * args , * * kwargs ) outlets = [ x . as_dict ( ) for x in self . outlets ] inlets = [ x . as_dict ( ) for x in self . inlets ] if len ( self . outlets ) > 0 : self . xcom_push ( context , key = PIPELINE_OUTLETS , value = outlets , execution_date = context [ 'ti' ] . execution_date ) if len ( self . inlets ) > 0 : self . xcom_push ( context , key = PIPELINE_INLETS , value = inlets , execution_date = context [ 'ti' ] . execution_date ) if backend : backend . send_lineage ( operator = self , inlets = self . inlets , outlets = self . outlets , context = context ) return ret_val return wrapper\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def prepare_lineage ( func ) : @ wraps ( func ) def wrapper ( self , context , * args , * * kwargs ) : self . log . debug ( \"Preparing lineage inlets and outlets\" ) task_ids = set ( self . _inlets [ 'task_ids' ] ) . intersection ( self . get_flat_relative_ids ( upstream = True ) ) if task_ids : inlets = self . xcom_pull ( context , task_ids = task_ids , dag_id = self . dag_id , key = PIPELINE_OUTLETS ) inlets = [ item for sublist in inlets if sublist for item in sublist ] inlets = [ DataSet . map_type ( i [ 'typeName' ] ) ( data = i [ 'attributes' ] ) for i in inlets ] self . inlets . extend ( inlets ) if self . _inlets [ 'auto' ] : # dont append twice task_ids = set ( self . _inlets [ 'task_ids' ] ) . symmetric_difference ( self . upstream_task_ids ) inlets = self . xcom_pull ( context , task_ids = task_ids , dag_id = self . dag_id , key = PIPELINE_OUTLETS ) inlets = [ item for sublist in inlets if sublist for item in sublist ] inlets = [ DataSet . map_type ( i [ 'typeName' ] ) ( data = i [ 'attributes' ] ) for i in inlets ] self . inlets . extend ( inlets ) if len ( self . _inlets [ 'datasets' ] ) > 0 : self . inlets . extend ( self . _inlets [ 'datasets' ] ) # outlets if len ( self . _outlets [ 'datasets' ] ) > 0 : self . outlets . extend ( self . _outlets [ 'datasets' ] ) self . log . debug ( \"inlets: %s, outlets: %s\" , self . inlets , self . outlets ) for dataset in chain ( self . inlets , self . outlets ) : dataset . set_context ( context ) return func ( self , context , * args , * * kwargs ) return wrapper\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def extra_dejson ( self ) : obj = { } if self . extra : try : obj = json . loads ( self . extra ) except Exception as e : self . log . exception ( e ) self . log . error ( \"Failed parsing the json for conn_id %s\" , self . conn_id ) return obj\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def date_range ( start_date , end_date = None , num = None , delta = None ) : if not delta : return [ ] if end_date and start_date > end_date : raise Exception ( \"Wait. start_date needs to be before end_date\" ) if end_date and num : raise Exception ( \"Wait. Either specify end_date OR num\" ) if not end_date and not num : end_date = timezone . utcnow ( ) delta_iscron = False tz = start_date . tzinfo if isinstance ( delta , six . string_types ) : delta_iscron = True start_date = timezone . make_naive ( start_date , tz ) cron = croniter ( delta , start_date ) elif isinstance ( delta , timedelta ) : delta = abs ( delta ) dates = [ ] if end_date : if timezone . is_naive ( start_date ) : end_date = timezone . make_naive ( end_date , tz ) while start_date <= end_date : if timezone . is_naive ( start_date ) : dates . append ( timezone . make_aware ( start_date , tz ) ) else : dates . append ( start_date ) if delta_iscron : start_date = cron . get_next ( datetime ) else : start_date += delta else : for _ in range ( abs ( num ) ) : if timezone . is_naive ( start_date ) : dates . append ( timezone . make_aware ( start_date , tz ) ) else : dates . append ( start_date ) if delta_iscron : if num > 0 : start_date = cron . get_next ( datetime ) else : start_date = cron . get_prev ( datetime ) else : if num > 0 : start_date += delta else : start_date -= delta return sorted ( dates )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def round_time ( dt , delta , start_date = timezone . make_aware ( datetime . min ) ) : if isinstance ( delta , six . string_types ) : # It's cron based, so it's easy tz = start_date . tzinfo start_date = timezone . make_naive ( start_date , tz ) cron = croniter ( delta , start_date ) prev = cron . get_prev ( datetime ) if prev == start_date : return timezone . make_aware ( start_date , tz ) else : return timezone . make_aware ( prev , tz ) # Ignore the microseconds of dt dt -= timedelta ( microseconds = dt . microsecond ) # We are looking for a datetime in the form start_date + i * delta # which is as close as possible to dt. Since delta could be a relative # delta we don't know its exact length in seconds so we cannot rely on # division to find i. Instead we employ a binary search algorithm, first # finding an upper and lower limit and then disecting the interval until # we have found the closest match. # We first search an upper limit for i for which start_date + upper * delta # exceeds dt. upper = 1 while start_date + upper * delta < dt : # To speed up finding an upper limit we grow this exponentially by a # factor of 2 upper *= 2 # Since upper is the first value for which start_date + upper * delta # exceeds dt, upper // 2 is below dt and therefore forms a lower limited # for the i we are looking for lower = upper // 2 # We now continue to intersect the interval between # start_date + lower * delta and start_date + upper * delta # until we find the closest value while True : # Invariant: start + lower * delta < dt <= start + upper * delta # If start_date + (lower + 1)*delta exceeds dt, then either lower or # lower+1 has to be the solution we are searching for if start_date + ( lower + 1 ) * delta >= dt : # Check if start_date + (lower + 1)*delta or # start_date + lower*delta is closer to dt and return the solution if ( start_date + ( lower + 1 ) * delta ) - dt <= dt - ( start_date + lower * delta ) : return start_date + ( lower + 1 ) * delta else : return start_date + lower * delta # We intersect the interval and either replace the lower or upper # limit with the candidate candidate = lower + ( upper - lower ) // 2 if start_date + candidate * delta >= dt : upper = candidate else : lower = candidate\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def infer_time_unit ( time_seconds_arr ) : if len ( time_seconds_arr ) == 0 : return 'hours' max_time_seconds = max ( time_seconds_arr ) if max_time_seconds <= 60 * 2 : return 'seconds' elif max_time_seconds <= 60 * 60 * 2 : return 'minutes' elif max_time_seconds <= 24 * 60 * 60 * 2 : return 'hours' else : return 'days'\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def scale_time_units ( time_seconds_arr , unit ) : if unit == 'minutes' : return list ( map ( lambda x : x * 1.0 / 60 , time_seconds_arr ) ) elif unit == 'hours' : return list ( map ( lambda x : x * 1.0 / ( 60 * 60 ) , time_seconds_arr ) ) elif unit == 'days' : return list ( map ( lambda x : x * 1.0 / ( 24 * 60 * 60 ) , time_seconds_arr ) ) return time_seconds_arr\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def days_ago ( n , hour = 0 , minute = 0 , second = 0 , microsecond = 0 ) : today = timezone . utcnow ( ) . replace ( hour = hour , minute = minute , second = second , microsecond = microsecond ) return today - timedelta ( days = n )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_dag_runs ( dag_id , state = None ) : dagbag = DagBag ( ) # Check DAG exists. if dag_id not in dagbag . dags : error_message = \"Dag id {} not found\" . format ( dag_id ) raise AirflowException ( error_message ) dag_runs = list ( ) state = state . lower ( ) if state else None for run in DagRun . find ( dag_id = dag_id , state = state ) : dag_runs . append ( { 'id' : run . id , 'run_id' : run . run_id , 'state' : run . state , 'dag_id' : run . dag_id , 'execution_date' : run . execution_date . isoformat ( ) , 'start_date' : ( ( run . start_date or '' ) and run . start_date . isoformat ( ) ) , 'dag_run_url' : url_for ( 'Airflow.graph' , dag_id = run . dag_id , execution_date = run . execution_date ) } ) return dag_runs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def init_role ( self , role_name , role_vms , role_perms ) : pvms = self . get_session . query ( sqla_models . PermissionView ) . all ( ) pvms = [ p for p in pvms if p . permission and p . view_menu ] role = self . find_role ( role_name ) if not role : role = self . add_role ( role_name ) if len ( role . permissions ) == 0 : self . log . info ( 'Initializing permissions for role:%s in the database.' , role_name ) role_pvms = set ( ) for pvm in pvms : if pvm . view_menu . name in role_vms and pvm . permission . name in role_perms : role_pvms . add ( pvm ) role . permissions = list ( role_pvms ) self . get_session . merge ( role ) self . get_session . commit ( ) else : self . log . debug ( 'Existing permissions for the role:%s ' 'within the database will persist.' , role_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_role ( self , role_name ) : session = self . get_session role = session . query ( sqla_models . Role ) . filter ( sqla_models . Role . name == role_name ) . first ( ) if role : self . log . info ( \"Deleting role '%s'\" , role_name ) session . delete ( role ) session . commit ( ) else : raise AirflowException ( \"Role named '{}' does not exist\" . format ( role_name ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_user_roles ( self , user = None ) : if user is None : user = g . user if user . is_anonymous : public_role = appbuilder . config . get ( 'AUTH_ROLE_PUBLIC' ) return [ appbuilder . security_manager . find_role ( public_role ) ] if public_role else [ ] return user . roles\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_all_permissions_views ( self ) : perms_views = set ( ) for role in self . get_user_roles ( ) : perms_views . update ( { ( perm_view . permission . name , perm_view . view_menu . name ) for perm_view in role . permissions } ) return perms_views\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_accessible_dag_ids ( self , username = None ) : if not username : username = g . user if username . is_anonymous or 'Public' in username . roles : # return an empty set if the role is public return set ( ) roles = { role . name for role in username . roles } if { 'Admin' , 'Viewer' , 'User' , 'Op' } & roles : return self . DAG_VMS user_perms_views = self . get_all_permissions_views ( ) # return a set of all dags that the user could access return set ( [ view for perm , view in user_perms_views if perm in self . DAG_PERMS ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def has_access ( self , permission , view_name , user = None ) : if not user : user = g . user if user . is_anonymous : return self . is_item_public ( permission , view_name ) return self . _has_view_access ( user , permission , view_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _has_role ( self , role_name_or_list ) : if not isinstance ( role_name_or_list , list ) : role_name_or_list = [ role_name_or_list ] return any ( [ r . name in role_name_or_list for r in self . get_user_roles ( ) ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _has_perm ( self , permission_name , view_menu_name ) : if hasattr ( self , 'perms' ) : if ( permission_name , view_menu_name ) in self . perms : return True # rebuild the permissions set self . _get_and_cache_perms ( ) return ( permission_name , view_menu_name ) in self . perms\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def clean_perms ( self ) : self . log . debug ( 'Cleaning faulty perms' ) sesh = self . get_session pvms = ( sesh . query ( sqla_models . PermissionView ) . filter ( or_ ( sqla_models . PermissionView . permission == None , # NOQA sqla_models . PermissionView . view_menu == None , # NOQA ) ) ) deleted_count = pvms . delete ( ) sesh . commit ( ) if deleted_count : self . log . info ( 'Deleted %s faulty permissions' , deleted_count )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _merge_perm ( self , permission_name , view_menu_name ) : permission = self . find_permission ( permission_name ) view_menu = self . find_view_menu ( view_menu_name ) pv = None if permission and view_menu : pv = self . get_session . query ( self . permissionview_model ) . filter_by ( permission = permission , view_menu = view_menu ) . first ( ) if not pv and permission_name and view_menu_name : self . add_permission_view_menu ( permission_name , view_menu_name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_custom_dag_permission_view ( self , session = None ) : self . log . debug ( 'Fetching a set of all permission, view_menu from FAB meta-table' ) def merge_pv ( perm , view_menu ) : \"\"\"Create permission view menu only if it doesn't exist\"\"\" if view_menu and perm and ( view_menu , perm ) not in all_pvs : self . _merge_perm ( perm , view_menu ) all_pvs = set ( ) for pv in self . get_session . query ( self . permissionview_model ) . all ( ) : if pv . permission and pv . view_menu : all_pvs . add ( ( pv . permission . name , pv . view_menu . name ) ) # Get all the active / paused dags and insert them into a set all_dags_models = session . query ( models . DagModel ) . filter ( or_ ( models . DagModel . is_active , models . DagModel . is_paused ) ) . filter ( ~ models . DagModel . is_subdag ) . all ( ) # create can_dag_edit and can_dag_read permissions for every dag(vm) for dag in all_dags_models : for perm in self . DAG_PERMS : merge_pv ( perm , dag . dag_id ) # for all the dag-level role, add the permission of viewer # with the dag view to ab_permission_view all_roles = self . get_all_roles ( ) user_role = self . find_role ( 'User' ) dag_role = [ role for role in all_roles if role . name not in EXISTING_ROLES ] update_perm_views = [ ] # need to remove all_dag vm from all the existing view-menus dag_vm = self . find_view_menu ( 'all_dags' ) ab_perm_view_role = sqla_models . assoc_permissionview_role perm_view = self . permissionview_model view_menu = self . viewmenu_model all_perm_view_by_user = session . query ( ab_perm_view_role ) . join ( perm_view , perm_view . id == ab_perm_view_role . columns . permission_view_id ) . filter ( ab_perm_view_role . columns . role_id == user_role . id ) . join ( view_menu ) . filter ( perm_view . view_menu_id != dag_vm . id ) all_perm_views = set ( [ role . permission_view_id for role in all_perm_view_by_user ] ) for role in dag_role : # Get all the perm-view of the role existing_perm_view_by_user = self . get_session . query ( ab_perm_view_role ) . filter ( ab_perm_view_role . columns . role_id == role . id ) existing_perms_views = set ( [ pv . permission_view_id for pv in existing_perm_view_by_user ] ) missing_perm_views = all_perm_views - existing_perms_views for perm_view_id in missing_perm_views : update_perm_views . append ( { 'permission_view_id' : perm_view_id , 'role_id' : role . id } ) if update_perm_views : self . get_session . execute ( ab_perm_view_role . insert ( ) , update_perm_views ) self . get_session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update_admin_perm_view ( self ) : pvms = self . get_session . query ( sqla_models . PermissionView ) . all ( ) pvms = [ p for p in pvms if p . permission and p . view_menu ] admin = self . find_role ( 'Admin' ) admin . permissions = list ( set ( admin . permissions ) | set ( pvms ) ) self . get_session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sync_roles ( self ) : self . log . debug ( 'Start syncing user roles.' ) # Create global all-dag VM self . create_perm_vm_for_all_dag ( ) # Create default user role. for config in self . ROLE_CONFIGS : role = config [ 'role' ] vms = config [ 'vms' ] perms = config [ 'perms' ] self . init_role ( role , vms , perms ) self . create_custom_dag_permission_view ( ) # init existing roles, the rest role could be created through UI. self . update_admin_perm_view ( ) self . clean_perms ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sync_perm_for_dag ( self , dag_id , access_control = None ) : for dag_perm in self . DAG_PERMS : perm_on_dag = self . find_permission_view_menu ( dag_perm , dag_id ) if perm_on_dag is None : self . add_permission_view_menu ( dag_perm , dag_id ) if access_control : self . _sync_dag_view_permissions ( dag_id , access_control )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sync_dag_view_permissions ( self , dag_id , access_control ) : def _get_or_create_dag_permission ( perm_name ) : dag_perm = self . find_permission_view_menu ( perm_name , dag_id ) if not dag_perm : self . log . info ( \"Creating new permission '%s' on view '%s'\" , perm_name , dag_id ) dag_perm = self . add_permission_view_menu ( perm_name , dag_id ) return dag_perm def _revoke_stale_permissions ( dag_view ) : existing_dag_perms = self . find_permissions_view_menu ( dag_view ) for perm in existing_dag_perms : non_admin_roles = [ role for role in perm . role if role . name != 'Admin' ] for role in non_admin_roles : target_perms_for_role = access_control . get ( role . name , { } ) if perm . permission . name not in target_perms_for_role : self . log . info ( \"Revoking '%s' on DAG '%s' for role '%s'\" , perm . permission , dag_id , role . name ) self . del_permission_role ( role , perm ) dag_view = self . find_view_menu ( dag_id ) if dag_view : _revoke_stale_permissions ( dag_view ) for rolename , perms in access_control . items ( ) : role = self . find_role ( rolename ) if not role : raise AirflowException ( \"The access_control mapping for DAG '{}' includes a role \" \"named '{}', but that role does not exist\" . format ( dag_id , rolename ) ) perms = set ( perms ) invalid_perms = perms - self . DAG_PERMS if invalid_perms : raise AirflowException ( \"The access_control map for DAG '{}' includes the following \" \"invalid permissions: {}; The set of valid permissions \" \"is: {}\" . format ( dag_id , ( perms - self . DAG_PERMS ) , self . DAG_PERMS ) ) for perm_name in perms : dag_perm = _get_or_create_dag_permission ( perm_name ) self . add_permission_role ( role , dag_perm )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_perm_vm_for_all_dag ( self ) : # create perm for global logical dag for dag_vm in self . DAG_VMS : for perm in self . DAG_PERMS : self . _merge_perm ( permission_name = perm , view_menu_name = dag_vm )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_fernet ( ) : global _fernet log = LoggingMixin ( ) . log if _fernet : return _fernet try : from cryptography . fernet import Fernet , MultiFernet , InvalidToken global InvalidFernetToken InvalidFernetToken = InvalidToken except BuiltinImportError : log . warning ( \"cryptography not found - values will not be stored encrypted.\" ) _fernet = NullFernet ( ) return _fernet try : fernet_key = configuration . conf . get ( 'core' , 'FERNET_KEY' ) if not fernet_key : log . warning ( \"empty cryptography key - values will not be stored encrypted.\" ) _fernet = NullFernet ( ) else : _fernet = MultiFernet ( [ Fernet ( fernet_part . encode ( 'utf-8' ) ) for fernet_part in fernet_key . split ( ',' ) ] ) _fernet . is_encrypted = True except ( ValueError , TypeError ) as ve : raise AirflowException ( \"Could not create Fernet object: {}\" . format ( ve ) ) return _fernet\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poke ( self , context ) : if '.' in self . table_name : self . database_name , self . table_name = self . table_name . split ( '.' ) self . log . info ( 'Poking for table %s. %s, expression %s' , self . database_name , self . table_name , self . expression ) return self . get_hook ( ) . check_for_partition ( self . database_name , self . table_name , self . expression )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_hook ( self ) : if not hasattr ( self , 'hook' ) : from airflow . contrib . hooks . aws_glue_catalog_hook import AwsGlueCatalogHook self . hook = AwsGlueCatalogHook ( aws_conn_id = self . aws_conn_id , region_name = self . region_name ) return self . hook\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poke ( self , context ) : sqs_hook = SQSHook ( aws_conn_id = self . aws_conn_id ) sqs_conn = sqs_hook . get_conn ( ) self . log . info ( 'SQSSensor checking for message on queue: %s' , self . sqs_queue ) messages = sqs_conn . receive_message ( QueueUrl = self . sqs_queue , MaxNumberOfMessages = self . max_messages , WaitTimeSeconds = self . wait_time_seconds ) self . log . info ( \"reveived message %s\" , str ( messages ) ) if 'Messages' in messages and len ( messages [ 'Messages' ] ) > 0 : entries = [ { 'Id' : message [ 'MessageId' ] , 'ReceiptHandle' : message [ 'ReceiptHandle' ] } for message in messages [ 'Messages' ] ] result = sqs_conn . delete_message_batch ( QueueUrl = self . sqs_queue , Entries = entries ) if 'Successful' in result : context [ 'ti' ] . xcom_push ( key = 'messages' , value = messages ) return True else : raise AirflowException ( 'Delete SQS Messages failed ' + str ( result ) + ' for messages ' + str ( messages ) ) return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def tmp_configuration_copy ( chmod = 0o600 ) : cfg_dict = conf . as_dict ( display_sensitive = True , raw = True ) temp_fd , cfg_path = mkstemp ( ) with os . fdopen ( temp_fd , 'w' ) as temp_file : if chmod is not None : os . fchmod ( temp_fd , chmod ) json . dump ( cfg_dict , temp_file ) return cfg_path\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : # When using HAClient, proxy_user must be the same, so is ok to always # take the first. effective_user = self . proxy_user autoconfig = self . autoconfig use_sasl = configuration . conf . get ( 'core' , 'security' ) == 'kerberos' try : connections = self . get_connections ( self . hdfs_conn_id ) if not effective_user : effective_user = connections [ 0 ] . login if not autoconfig : autoconfig = connections [ 0 ] . extra_dejson . get ( 'autoconfig' , False ) hdfs_namenode_principal = connections [ 0 ] . extra_dejson . get ( 'hdfs_namenode_principal' ) except AirflowException : if not autoconfig : raise if autoconfig : # will read config info from $HADOOP_HOME conf files client = AutoConfigClient ( effective_user = effective_user , use_sasl = use_sasl ) elif len ( connections ) == 1 : client = Client ( connections [ 0 ] . host , connections [ 0 ] . port , effective_user = effective_user , use_sasl = use_sasl , hdfs_namenode_principal = hdfs_namenode_principal ) elif len ( connections ) > 1 : nn = [ Namenode ( conn . host , conn . port ) for conn in connections ] client = HAClient ( nn , effective_user = effective_user , use_sasl = use_sasl , hdfs_namenode_principal = hdfs_namenode_principal ) else : raise HDFSHookException ( \"conn_id doesn't exist in the repository \" \"and autoconfig is not specified\" ) return client\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : connections = self . get_connections ( self . webhdfs_conn_id ) for connection in connections : try : self . log . debug ( 'Trying namenode %s' , connection . host ) client = self . _get_client ( connection ) client . status ( '/' ) self . log . debug ( 'Using namenode %s for hook' , connection . host ) return client except HdfsError as hdfs_error : self . log . debug ( 'Read operation on namenode %s failed with error: %s' , connection . host , hdfs_error ) hosts = [ connection . host for connection in connections ] error_message = 'Read operations failed on the namenodes below:\\n{hosts}' . format ( hosts = '\\n' . join ( hosts ) ) raise AirflowWebHDFSHookException ( error_message )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_for_path ( self , hdfs_path ) : conn = self . get_conn ( ) status = conn . status ( hdfs_path , strict = False ) return bool ( status )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_file ( self , source , destination , overwrite = True , parallelism = 1 , * * kwargs ) : conn = self . get_conn ( ) conn . upload ( hdfs_path = destination , local_path = source , overwrite = overwrite , n_threads = parallelism , * * kwargs ) self . log . debug ( \"Uploaded file %s to %s\" , source , destination )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . pinot_broker_conn_id ) pinot_broker_conn = connect ( host = conn . host , port = conn . port , path = conn . extra_dejson . get ( 'endpoint' , '/pql' ) , scheme = conn . extra_dejson . get ( 'schema' , 'http' ) ) self . log . info ( 'Get the connection to pinot ' 'broker on {host}' . format ( host = conn . host ) ) return pinot_broker_conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_uri ( self ) : conn = self . get_connection ( getattr ( self , self . conn_name_attr ) ) host = conn . host if conn . port is not None : host += ':{port}' . format ( port = conn . port ) conn_type = 'http' if not conn . conn_type else conn . conn_type endpoint = conn . extra_dejson . get ( 'endpoint' , 'pql' ) return '{conn_type}://{host}/{endpoint}' . format ( conn_type = conn_type , host = host , endpoint = endpoint )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_records ( self , sql ) : with self . get_conn ( ) as cur : cur . execute ( sql ) return cur . fetchall ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_first ( self , sql ) : with self . get_conn ( ) as cur : cur . execute ( sql ) return cur . fetchone ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def smart_truncate ( string , max_length = 0 , word_boundary = False , separator = ' ' , save_order = False ) : string = string . strip ( separator ) if not max_length : return string if len ( string ) < max_length : return string if not word_boundary : return string [ : max_length ] . strip ( separator ) if separator not in string : return string [ : max_length ] truncated = '' for word in string . split ( separator ) : if word : next_len = len ( truncated ) + len ( word ) if next_len < max_length : truncated += '{0}{1}' . format ( word , separator ) elif next_len == max_length : truncated += '{0}' . format ( word ) break else : if save_order : break if not truncated : # pragma: no cover truncated = string [ : max_length ] return truncated . strip ( separator )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def slugify ( text , entities = True , decimal = True , hexadecimal = True , max_length = 0 , word_boundary = False , separator = DEFAULT_SEPARATOR , save_order = False , stopwords = ( ) , regex_pattern = None , lowercase = True , replacements = ( ) ) : # user-specific replacements if replacements : for old , new in replacements : text = text . replace ( old , new ) # ensure text is unicode if not isinstance ( text , _unicode_type ) : text = _unicode ( text , 'utf-8' , 'ignore' ) # replace quotes with dashes - pre-process text = QUOTE_PATTERN . sub ( DEFAULT_SEPARATOR , text ) # decode unicode text = unidecode . unidecode ( text ) # ensure text is still in unicode if not isinstance ( text , _unicode_type ) : text = _unicode ( text , 'utf-8' , 'ignore' ) # character entity reference if entities : text = CHAR_ENTITY_PATTERN . sub ( lambda m : unichr ( name2codepoint [ m . group ( 1 ) ] ) , text ) # decimal character reference if decimal : try : text = DECIMAL_PATTERN . sub ( lambda m : unichr ( int ( m . group ( 1 ) ) ) , text ) except Exception : pass # hexadecimal character reference if hexadecimal : try : text = HEX_PATTERN . sub ( lambda m : unichr ( int ( m . group ( 1 ) , 16 ) ) , text ) except Exception : pass # translate text = unicodedata . normalize ( 'NFKD' , text ) # make the text lowercase (optional) if lowercase : text = text . lower ( ) # remove generated quotes -- post-process text = QUOTE_PATTERN . sub ( '' , text ) # cleanup numbers text = NUMBERS_PATTERN . sub ( '' , text ) # replace all other unwanted characters if lowercase : pattern = regex_pattern or ALLOWED_CHARS_PATTERN else : pattern = regex_pattern or ALLOWED_CHARS_PATTERN_WITH_UPPERCASE text = re . sub ( pattern , DEFAULT_SEPARATOR , text ) # remove redundant text = DUPLICATE_DASH_PATTERN . sub ( DEFAULT_SEPARATOR , text ) . strip ( DEFAULT_SEPARATOR ) # remove stopwords if stopwords : if lowercase : stopwords_lower = [ s . lower ( ) for s in stopwords ] words = [ w for w in text . split ( DEFAULT_SEPARATOR ) if w not in stopwords_lower ] else : words = [ w for w in text . split ( DEFAULT_SEPARATOR ) if w not in stopwords ] text = DEFAULT_SEPARATOR . join ( words ) # finalize user-specific replacements if replacements : for old , new in replacements : text = text . replace ( old , new ) # smart truncate if requested if max_length > 0 : text = smart_truncate ( text , max_length , word_boundary , DEFAULT_SEPARATOR , save_order ) if separator != DEFAULT_SEPARATOR : text = text . replace ( DEFAULT_SEPARATOR , separator ) return text\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set ( cls , key , value , execution_date , task_id , dag_id , session = None ) : session . expunge_all ( ) enable_pickling = configuration . getboolean ( 'core' , 'enable_xcom_pickling' ) if enable_pickling : value = pickle . dumps ( value ) else : try : value = json . dumps ( value ) . encode ( 'UTF-8' ) except ValueError : log = LoggingMixin ( ) . log log . error ( \"Could not serialize the XCOM value into JSON. \" \"If you are using pickles instead of JSON \" \"for XCOM, then you need to enable pickle \" \"support for XCOM in your airflow config.\" ) raise # remove any duplicate XComs session . query ( cls ) . filter ( cls . key == key , cls . execution_date == execution_date , cls . task_id == task_id , cls . dag_id == dag_id ) . delete ( ) session . commit ( ) # insert new XCom session . add ( XCom ( key = key , value = value , execution_date = execution_date , task_id = task_id , dag_id = dag_id ) ) session . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_one ( cls , execution_date , key = None , task_id = None , dag_id = None , include_prior_dates = False , session = None ) : filters = [ ] if key : filters . append ( cls . key == key ) if task_id : filters . append ( cls . task_id == task_id ) if dag_id : filters . append ( cls . dag_id == dag_id ) if include_prior_dates : filters . append ( cls . execution_date <= execution_date ) else : filters . append ( cls . execution_date == execution_date ) query = ( session . query ( cls . value ) . filter ( and_ ( * filters ) ) . order_by ( cls . execution_date . desc ( ) , cls . timestamp . desc ( ) ) ) result = query . first ( ) if result : enable_pickling = configuration . getboolean ( 'core' , 'enable_xcom_pickling' ) if enable_pickling : return pickle . loads ( result . value ) else : try : return json . loads ( result . value . decode ( 'UTF-8' ) ) except ValueError : log = LoggingMixin ( ) . log log . error ( \"Could not deserialize the XCOM value from JSON. \" \"If you are using pickles instead of JSON \" \"for XCOM, then you need to enable pickle \" \"support for XCOM in your airflow config.\" ) raise\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_many ( cls , execution_date , key = None , task_ids = None , dag_ids = None , include_prior_dates = False , limit = 100 , session = None ) : filters = [ ] if key : filters . append ( cls . key == key ) if task_ids : filters . append ( cls . task_id . in_ ( as_tuple ( task_ids ) ) ) if dag_ids : filters . append ( cls . dag_id . in_ ( as_tuple ( dag_ids ) ) ) if include_prior_dates : filters . append ( cls . execution_date <= execution_date ) else : filters . append ( cls . execution_date == execution_date ) query = ( session . query ( cls ) . filter ( and_ ( * filters ) ) . order_by ( cls . execution_date . desc ( ) , cls . timestamp . desc ( ) ) . limit ( limit ) ) results = query . all ( ) return results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _convert_date_to_dict ( field_date ) : return { DAY : field_date . day , MONTH : field_date . month , YEAR : field_date . year }\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _convert_time_to_dict ( time ) : return { HOURS : time . hour , MINUTES : time . minute , SECONDS : time . second }\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . redis_conn_id ) self . host = conn . host self . port = conn . port self . password = None if str ( conn . password ) . lower ( ) in [ 'none' , 'false' , '' ] else conn . password self . db = conn . extra_dejson . get ( 'db' , None ) if not self . redis : self . log . debug ( 'Initializing redis object for conn_id \"%s\" on %s:%s:%s' , self . redis_conn_id , self . host , self . port , self . db ) self . redis = Redis ( host = self . host , port = self . port , password = self . password , db = self . db ) return self . redis\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . oracle_conn_id ) conn_config = { 'user' : conn . login , 'password' : conn . password } dsn = conn . extra_dejson . get ( 'dsn' , None ) sid = conn . extra_dejson . get ( 'sid' , None ) mod = conn . extra_dejson . get ( 'module' , None ) service_name = conn . extra_dejson . get ( 'service_name' , None ) port = conn . port if conn . port else 1521 if dsn and sid and not service_name : conn_config [ 'dsn' ] = cx_Oracle . makedsn ( dsn , port , sid ) elif dsn and service_name and not sid : conn_config [ 'dsn' ] = cx_Oracle . makedsn ( dsn , port , service_name = service_name ) else : conn_config [ 'dsn' ] = conn . host if 'encoding' in conn . extra_dejson : conn_config [ 'encoding' ] = conn . extra_dejson . get ( 'encoding' ) # if `encoding` is specific but `nencoding` is not # `nencoding` should use same values as `encoding` to set encoding, inspired by # https://github.com/oracle/python-cx_Oracle/issues/157#issuecomment-371877993 if 'nencoding' not in conn . extra_dejson : conn_config [ 'nencoding' ] = conn . extra_dejson . get ( 'encoding' ) if 'nencoding' in conn . extra_dejson : conn_config [ 'nencoding' ] = conn . extra_dejson . get ( 'nencoding' ) if 'threaded' in conn . extra_dejson : conn_config [ 'threaded' ] = conn . extra_dejson . get ( 'threaded' ) if 'events' in conn . extra_dejson : conn_config [ 'events' ] = conn . extra_dejson . get ( 'events' ) mode = conn . extra_dejson . get ( 'mode' , '' ) . lower ( ) if mode == 'sysdba' : conn_config [ 'mode' ] = cx_Oracle . SYSDBA elif mode == 'sysasm' : conn_config [ 'mode' ] = cx_Oracle . SYSASM elif mode == 'sysoper' : conn_config [ 'mode' ] = cx_Oracle . SYSOPER elif mode == 'sysbkp' : conn_config [ 'mode' ] = cx_Oracle . SYSBKP elif mode == 'sysdgd' : conn_config [ 'mode' ] = cx_Oracle . SYSDGD elif mode == 'syskmt' : conn_config [ 'mode' ] = cx_Oracle . SYSKMT elif mode == 'sysrac' : conn_config [ 'mode' ] = cx_Oracle . SYSRAC purity = conn . extra_dejson . get ( 'purity' , '' ) . lower ( ) if purity == 'new' : conn_config [ 'purity' ] = cx_Oracle . ATTR_PURITY_NEW elif purity == 'self' : conn_config [ 'purity' ] = cx_Oracle . ATTR_PURITY_SELF elif purity == 'default' : conn_config [ 'purity' ] = cx_Oracle . ATTR_PURITY_DEFAULT conn = cx_Oracle . connect ( * * conn_config ) if mod is not None : conn . module = mod return conn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_rows ( self , table , rows , target_fields = None , commit_every = 1000 ) : if target_fields : target_fields = ', ' . join ( target_fields ) target_fields = '({})' . format ( target_fields ) else : target_fields = '' conn = self . get_conn ( ) cur = conn . cursor ( ) if self . supports_autocommit : cur . execute ( 'SET autocommit = 0' ) conn . commit ( ) i = 0 for row in rows : i += 1 lst = [ ] for cell in row : if isinstance ( cell , basestring ) : lst . append ( \"'\" + str ( cell ) . replace ( \"'\" , \"''\" ) + \"'\" ) elif cell is None : lst . append ( 'NULL' ) elif type ( cell ) == float and numpy . isnan ( cell ) : # coerce numpy NaN to NULL lst . append ( 'NULL' ) elif isinstance ( cell , numpy . datetime64 ) : lst . append ( \"'\" + str ( cell ) + \"'\" ) elif isinstance ( cell , datetime ) : lst . append ( \"to_date('\" + cell . strftime ( '%Y-%m-%d %H:%M:%S' ) + \"','YYYY-MM-DD HH24:MI:SS')\" ) else : lst . append ( str ( cell ) ) values = tuple ( lst ) sql = 'INSERT /*+ APPEND */ ' 'INTO {0} {1} VALUES ({2})' . format ( table , target_fields , ',' . join ( values ) ) cur . execute ( sql ) if i % commit_every == 0 : conn . commit ( ) self . log . info ( 'Loaded %s into %s rows so far' , i , table ) conn . commit ( ) cur . close ( ) conn . close ( ) self . log . info ( 'Done loading. Loaded a total of %s rows' , i )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bulk_insert_rows ( self , table , rows , target_fields = None , commit_every = 5000 ) : if not rows : raise ValueError ( \"parameter rows could not be None or empty iterable\" ) conn = self . get_conn ( ) cursor = conn . cursor ( ) values_base = target_fields if target_fields else rows [ 0 ] prepared_stm = 'insert into {tablename} {columns} values ({values})' . format ( tablename = table , columns = '({})' . format ( ', ' . join ( target_fields ) ) if target_fields else '' , values = ', ' . join ( ':%s' % i for i in range ( 1 , len ( values_base ) + 1 ) ) , ) row_count = 0 # Chunk the rows row_chunk = [ ] for row in rows : row_chunk . append ( row ) row_count += 1 if row_count % commit_every == 0 : cursor . prepare ( prepared_stm ) cursor . executemany ( None , row_chunk ) conn . commit ( ) self . log . info ( '[%s] inserted %s rows' , table , row_count ) # Empty chunk row_chunk = [ ] # Commit the leftover chunk cursor . prepare ( prepared_stm ) cursor . executemany ( None , row_chunk ) conn . commit ( ) self . log . info ( '[%s] inserted %s rows' , table , row_count ) cursor . close ( ) conn . close ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : db = self . get_connection ( getattr ( self , self . conn_name_attr ) ) return self . connector . connect ( host = db . host , port = db . port , username = db . login , schema = db . schema )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_pandas_df ( self , sql , parameters = None ) : import pandas . io . sql as psql with closing ( self . get_conn ( ) ) as conn : return psql . read_sql ( sql , con = conn , params = parameters )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_records ( self , sql , parameters = None ) : with closing ( self . get_conn ( ) ) as conn : with closing ( conn . cursor ( ) ) as cur : if parameters is not None : cur . execute ( sql , parameters ) else : cur . execute ( sql ) return cur . fetchall ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_first ( self , sql , parameters = None ) : with closing ( self . get_conn ( ) ) as conn : with closing ( conn . cursor ( ) ) as cur : if parameters is not None : cur . execute ( sql , parameters ) else : cur . execute ( sql ) return cur . fetchone ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run ( self , sql , autocommit = False , parameters = None ) : if isinstance ( sql , basestring ) : sql = [ sql ] with closing ( self . get_conn ( ) ) as conn : if self . supports_autocommit : self . set_autocommit ( conn , autocommit ) with closing ( conn . cursor ( ) ) as cur : for s in sql : if parameters is not None : self . log . info ( \"{} with parameters {}\" . format ( s , parameters ) ) cur . execute ( s , parameters ) else : self . log . info ( s ) cur . execute ( s ) # If autocommit was set to False for db that supports autocommit, # or if db does not supports autocommit, we do a manual commit. if not self . get_autocommit ( conn ) : conn . commit ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def set_autocommit ( self , conn , autocommit ) : if not self . supports_autocommit and autocommit : self . log . warn ( ( \"%s connection doesn't support \" \"autocommit but autocommit activated.\" ) , getattr ( self , self . conn_name_attr ) ) conn . autocommit = autocommit\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def insert_rows ( self , table , rows , target_fields = None , commit_every = 1000 , replace = False ) : if target_fields : target_fields = \", \" . join ( target_fields ) target_fields = \"({})\" . format ( target_fields ) else : target_fields = '' i = 0 with closing ( self . get_conn ( ) ) as conn : if self . supports_autocommit : self . set_autocommit ( conn , False ) conn . commit ( ) with closing ( conn . cursor ( ) ) as cur : for i , row in enumerate ( rows , 1 ) : lst = [ ] for cell in row : lst . append ( self . _serialize_cell ( cell , conn ) ) values = tuple ( lst ) placeholders = [ \"%s\" , ] * len ( values ) if not replace : sql = \"INSERT INTO \" else : sql = \"REPLACE INTO \" sql += \"{0} {1} VALUES ({2})\" . format ( table , target_fields , \",\" . join ( placeholders ) ) cur . execute ( sql , values ) if commit_every and i % commit_every == 0 : conn . commit ( ) self . log . info ( \"Loaded %s into %s rows so far\" , i , table ) conn . commit ( ) self . log . info ( \"Done loading. Loaded a total of %s rows\" , i )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _serialize_cell ( cell , conn = None ) : if cell is None : return None if isinstance ( cell , datetime ) : return cell . isoformat ( ) return str ( cell )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def health ( self , session = None ) : BJ = jobs . BaseJob payload = { } scheduler_health_check_threshold = timedelta ( seconds = conf . getint ( 'scheduler' , 'scheduler_health_check_threshold' ) ) latest_scheduler_heartbeat = None payload [ 'metadatabase' ] = { 'status' : 'healthy' } try : latest_scheduler_heartbeat = session . query ( func . max ( BJ . latest_heartbeat ) ) . filter ( BJ . state == 'running' , BJ . job_type == 'SchedulerJob' ) . scalar ( ) except Exception : payload [ 'metadatabase' ] [ 'status' ] = 'unhealthy' if not latest_scheduler_heartbeat : scheduler_status = 'unhealthy' else : if timezone . utcnow ( ) - latest_scheduler_heartbeat <= scheduler_health_check_threshold : scheduler_status = 'healthy' else : scheduler_status = 'unhealthy' payload [ 'scheduler' ] = { 'status' : scheduler_status , 'latest_scheduler_heartbeat' : str ( latest_scheduler_heartbeat ) } return wwwutils . json_response ( payload )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def extra_links ( self ) : dag_id = request . args . get ( 'dag_id' ) task_id = request . args . get ( 'task_id' ) execution_date = request . args . get ( 'execution_date' ) link_name = request . args . get ( 'link_name' ) dttm = airflow . utils . timezone . parse ( execution_date ) dag = dagbag . get_dag ( dag_id ) if not dag or task_id not in dag . task_ids : response = jsonify ( { 'url' : None , 'error' : \"can't find dag {dag} or task_id {task_id}\" . format ( dag = dag , task_id = task_id ) } ) response . status_code = 404 return response task = dag . get_task ( task_id ) try : url = task . get_extra_links ( dttm , link_name ) except ValueError as err : response = jsonify ( { 'url' : None , 'error' : str ( err ) } ) response . status_code = 404 return response if url : response = jsonify ( { 'error' : None , 'url' : url } ) response . status_code = 200 return response else : response = jsonify ( { 'url' : None , 'error' : 'No URL found for {dest}' . format ( dest = link_name ) } ) response . status_code = 404 return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_query ( self ) : return ( super ( ) . get_query ( ) . filter ( or_ ( models . DagModel . is_active , models . DagModel . is_paused ) ) . filter ( ~ models . DagModel . is_subdag ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_count_query ( self ) : return ( super ( ) . get_count_query ( ) . filter ( models . DagModel . is_active ) . filter ( ~ models . DagModel . is_subdag ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_conn ( self ) : conn = self . get_connection ( self . cloudant_conn_id ) self . _validate_connection ( conn ) cloudant_session = cloudant ( user = conn . login , passwd = conn . password , account = conn . host ) return cloudant_session\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def execute ( self , context ) : self . hook = SlackWebhookHook ( self . http_conn_id , self . webhook_token , self . message , self . attachments , self . channel , self . username , self . icon_emoji , self . link_names , self . proxy ) self . hook . execute ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_credentials ( self ) : key_path = self . _get_field ( 'key_path' , False ) keyfile_dict = self . _get_field ( 'keyfile_dict' , False ) scope = self . _get_field ( 'scope' , None ) if scope : scopes = [ s . strip ( ) for s in scope . split ( ',' ) ] else : scopes = _DEFAULT_SCOPES if not key_path and not keyfile_dict : self . log . info ( 'Getting connection using `google.auth.default()` ' 'since no key file is defined for hook.' ) credentials , _ = google . auth . default ( scopes = scopes ) elif key_path : # Get credentials from a JSON file. if key_path . endswith ( '.json' ) : self . log . debug ( 'Getting connection using JSON key file %s' % key_path ) credentials = ( google . oauth2 . service_account . Credentials . from_service_account_file ( key_path , scopes = scopes ) ) elif key_path . endswith ( '.p12' ) : raise AirflowException ( 'Legacy P12 key file are not supported, ' 'use a JSON key file.' ) else : raise AirflowException ( 'Unrecognised extension for key file.' ) else : # Get credentials from JSON data provided in the UI. try : keyfile_dict = json . loads ( keyfile_dict ) # Depending on how the JSON was formatted, it may contain # escaped newlines. Convert those to actual newlines. keyfile_dict [ 'private_key' ] = keyfile_dict [ 'private_key' ] . replace ( '\\\\n' , '\\n' ) credentials = ( google . oauth2 . service_account . Credentials . from_service_account_info ( keyfile_dict , scopes = scopes ) ) except json . decoder . JSONDecodeError : raise AirflowException ( 'Invalid key JSON.' ) return credentials . with_subject ( self . delegate_to ) if self . delegate_to else credentials\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _authorize ( self ) : credentials = self . _get_credentials ( ) http = httplib2 . Http ( ) authed_http = google_auth_httplib2 . AuthorizedHttp ( credentials , http = http ) return authed_http\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_field ( self , f , default = None ) : long_f = 'extra__google_cloud_platform__{}' . format ( f ) if hasattr ( self , 'extras' ) and long_f in self . extras : return self . extras [ long_f ] else : return default\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def catch_http_exception ( func ) : @ functools . wraps ( func ) def wrapper_decorator ( self , * args , * * kwargs ) : try : return func ( self , * args , * * kwargs ) except GoogleAPICallError as e : if isinstance ( e , AlreadyExists ) : raise e else : self . log . error ( 'The request failed:\\n%s' , str ( e ) ) raise AirflowException ( e ) except RetryError as e : self . log . error ( 'The request failed due to a retryable error and retry attempts failed.' ) raise AirflowException ( e ) except ValueError as e : self . log . error ( 'The request failed, the parameters are invalid.' ) raise AirflowException ( e ) except HttpError as e : self . log . error ( 'The request failed:\\n%s' , str ( e ) ) raise AirflowException ( e ) return wrapper_decorator\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fallback_to_default_project_id ( func ) : @ functools . wraps ( func ) def inner_wrapper ( self , * args , * * kwargs ) : if len ( args ) > 0 : raise AirflowException ( \"You must use keyword arguments in this methods rather than\" \" positional\" ) if 'project_id' in kwargs : kwargs [ 'project_id' ] = self . _get_project_id ( kwargs [ 'project_id' ] ) else : kwargs [ 'project_id' ] = self . _get_project_id ( None ) if not kwargs [ 'project_id' ] : raise AirflowException ( \"The project id must be passed either as \" \"keyword project_id parameter or as project_id extra \" \"in GCP connection definition. Both are not set!\" ) return func ( self , * args , * * kwargs ) return inner_wrapper\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def unfinished ( cls ) : return [ cls . NONE , cls . SCHEDULED , cls . QUEUED , cls . RUNNING , cls . SHUTDOWN , cls . UP_FOR_RETRY , cls . UP_FOR_RESCHEDULE ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def delete_dag ( dag_id , keep_records_in_log = True , session = None ) : DM = models . DagModel dag = session . query ( DM ) . filter ( DM . dag_id == dag_id ) . first ( ) if dag is None : raise DagNotFound ( \"Dag id {} not found\" . format ( dag_id ) ) if dag . fileloc and os . path . exists ( dag . fileloc ) : raise DagFileExists ( \"Dag id {} is still in DagBag. \" \"Remove the DAG file first: {}\" . format ( dag_id , dag . fileloc ) ) count = 0 # noinspection PyUnresolvedReferences,PyProtectedMember for m in models . base . Base . _decl_class_registry . values ( ) : if hasattr ( m , \"dag_id\" ) : if keep_records_in_log and m . __name__ == 'Log' : continue cond = or_ ( m . dag_id == dag_id , m . dag_id . like ( dag_id + \".%\" ) ) count += session . query ( m ) . filter ( cond ) . delete ( synchronize_session = 'fetch' ) if dag . is_subdag : p , c = dag_id . rsplit ( \".\" , 1 ) for m in models . DagRun , TaskFail , models . TaskInstance : count += session . query ( m ) . filter ( m . dag_id == p , m . task_id == c ) . delete ( ) return count\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_command ( self , cmd ) : connection_cmd = [ \"spark-sql\" ] if self . _conf : for conf_el in self . _conf . split ( \",\" ) : connection_cmd += [ \"--conf\" , conf_el ] if self . _total_executor_cores : connection_cmd += [ \"--total-executor-cores\" , str ( self . _total_executor_cores ) ] if self . _executor_cores : connection_cmd += [ \"--executor-cores\" , str ( self . _executor_cores ) ] if self . _executor_memory : connection_cmd += [ \"--executor-memory\" , self . _executor_memory ] if self . _keytab : connection_cmd += [ \"--keytab\" , self . _keytab ] if self . _principal : connection_cmd += [ \"--principal\" , self . _principal ] if self . _num_executors : connection_cmd += [ \"--num-executors\" , str ( self . _num_executors ) ] if self . _sql : sql = self . _sql . strip ( ) if sql . endswith ( \".sql\" ) or sql . endswith ( \".hql\" ) : connection_cmd += [ \"-f\" , sql ] else : connection_cmd += [ \"-e\" , sql ] if self . _master : connection_cmd += [ \"--master\" , self . _master ] if self . _name : connection_cmd += [ \"--name\" , self . _name ] if self . _verbose : connection_cmd += [ \"--verbose\" ] if self . _yarn_queue : connection_cmd += [ \"--queue\" , self . _yarn_queue ] connection_cmd += cmd self . log . debug ( \"Spark-Sql cmd: %s\" , connection_cmd ) return connection_cmd\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def run_query ( self , cmd = \"\" , * * kwargs ) : spark_sql_cmd = self . _prepare_command ( cmd ) self . _sp = subprocess . Popen ( spark_sql_cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , * * kwargs ) for line in iter ( self . _sp . stdout . readline , '' ) : self . log . info ( line ) returncode = self . _sp . wait ( ) if returncode : raise AirflowException ( \"Cannot execute {} on {}. Process exit code: {}.\" . format ( cmd , self . _conn . host , returncode ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def vgg11_bn ( pretrained = False , * * kwargs ) : if pretrained : kwargs [ 'init_weights' ] = False model = VGG ( make_layers ( cfg [ 'A' ] , batch_norm = True ) , * * kwargs ) if pretrained : model . load_state_dict ( model_zoo . load_url ( model_urls [ 'vgg11_bn' ] ) ) return model\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def vgg13 ( pretrained = False , * * kwargs ) : if pretrained : kwargs [ 'init_weights' ] = False model = VGG ( make_layers ( cfg [ 'B' ] ) , * * kwargs ) if pretrained : model . load_state_dict ( model_zoo . load_url ( model_urls [ 'vgg13' ] ) ) return model\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def alexnet ( pretrained = False , * * kwargs ) : model = AlexNet ( * * kwargs ) if pretrained : model . load_state_dict ( model_zoo . load_url ( model_urls [ 'alexnet' ] ) ) return model\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def densenet121 ( pretrained = False , * * kwargs ) : model = DenseNet ( num_init_features = 64 , growth_rate = 32 , block_config = ( 6 , 12 , 24 , 16 ) , * * kwargs ) if pretrained : _load_state_dict ( model , model_urls [ 'densenet121' ] ) return model\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def to_tensor ( pic ) : if not ( _is_pil_image ( pic ) or _is_numpy_image ( pic ) ) : raise TypeError ( 'pic should be PIL Image or ndarray. Got {}' . format ( type ( pic ) ) ) if isinstance ( pic , np . ndarray ) : # handle numpy array if pic . ndim == 2 : pic = pic [ : , : , None ] img = torch . from_numpy ( pic . transpose ( ( 2 , 0 , 1 ) ) ) # backward compatibility if isinstance ( img , torch . ByteTensor ) : return img . float ( ) . div ( 255 ) else : return img if accimage is not None and isinstance ( pic , accimage . Image ) : nppic = np . zeros ( [ pic . channels , pic . height , pic . width ] , dtype = np . float32 ) pic . copyto ( nppic ) return torch . from_numpy ( nppic ) # handle PIL Image if pic . mode == 'I' : img = torch . from_numpy ( np . array ( pic , np . int32 , copy = False ) ) elif pic . mode == 'I;16' : img = torch . from_numpy ( np . array ( pic , np . int16 , copy = False ) ) elif pic . mode == 'F' : img = torch . from_numpy ( np . array ( pic , np . float32 , copy = False ) ) elif pic . mode == '1' : img = 255 * torch . from_numpy ( np . array ( pic , np . uint8 , copy = False ) ) else : img = torch . ByteTensor ( torch . ByteStorage . from_buffer ( pic . tobytes ( ) ) ) # PIL image mode: L, LA, P, I, F, RGB, YCbCr, RGBA, CMYK if pic . mode == 'YCbCr' : nchannel = 3 elif pic . mode == 'I;16' : nchannel = 1 else : nchannel = len ( pic . mode ) img = img . view ( pic . size [ 1 ] , pic . size [ 0 ] , nchannel ) # put it from HWC to CHW format # yikes, this transpose takes 80% of the loading time/CPU img = img . transpose ( 0 , 1 ) . transpose ( 0 , 2 ) . contiguous ( ) if isinstance ( img , torch . ByteTensor ) : return img . float ( ) . div ( 255 ) else : return img\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def to_pil_image ( pic , mode = None ) : if not ( isinstance ( pic , torch . Tensor ) or isinstance ( pic , np . ndarray ) ) : raise TypeError ( 'pic should be Tensor or ndarray. Got {}.' . format ( type ( pic ) ) ) elif isinstance ( pic , torch . Tensor ) : if pic . ndimension ( ) not in { 2 , 3 } : raise ValueError ( 'pic should be 2/3 dimensional. Got {} dimensions.' . format ( pic . ndimension ( ) ) ) elif pic . ndimension ( ) == 2 : # if 2D image, add channel dimension (CHW) pic = pic . unsqueeze ( 0 ) elif isinstance ( pic , np . ndarray ) : if pic . ndim not in { 2 , 3 } : raise ValueError ( 'pic should be 2/3 dimensional. Got {} dimensions.' . format ( pic . ndim ) ) elif pic . ndim == 2 : # if 2D image, add channel dimension (HWC) pic = np . expand_dims ( pic , 2 ) npimg = pic if isinstance ( pic , torch . FloatTensor ) : pic = pic . mul ( 255 ) . byte ( ) if isinstance ( pic , torch . Tensor ) : npimg = np . transpose ( pic . numpy ( ) , ( 1 , 2 , 0 ) ) if not isinstance ( npimg , np . ndarray ) : raise TypeError ( 'Input pic must be a torch.Tensor or NumPy ndarray, ' + 'not {}' . format ( type ( npimg ) ) ) if npimg . shape [ 2 ] == 1 : expected_mode = None npimg = npimg [ : , : , 0 ] if npimg . dtype == np . uint8 : expected_mode = 'L' elif npimg . dtype == np . int16 : expected_mode = 'I;16' elif npimg . dtype == np . int32 : expected_mode = 'I' elif npimg . dtype == np . float32 : expected_mode = 'F' if mode is not None and mode != expected_mode : raise ValueError ( \"Incorrect mode ({}) supplied for input type {}. Should be {}\" . format ( mode , np . dtype , expected_mode ) ) mode = expected_mode elif npimg . shape [ 2 ] == 2 : permitted_2_channel_modes = [ 'LA' ] if mode is not None and mode not in permitted_2_channel_modes : raise ValueError ( \"Only modes {} are supported for 2D inputs\" . format ( permitted_2_channel_modes ) ) if mode is None and npimg . dtype == np . uint8 : mode = 'LA' elif npimg . shape [ 2 ] == 4 : permitted_4_channel_modes = [ 'RGBA' , 'CMYK' , 'RGBX' ] if mode is not None and mode not in permitted_4_channel_modes : raise ValueError ( \"Only modes {} are supported for 4D inputs\" . format ( permitted_4_channel_modes ) ) if mode is None and npimg . dtype == np . uint8 : mode = 'RGBA' else : permitted_3_channel_modes = [ 'RGB' , 'YCbCr' , 'HSV' ] if mode is not None and mode not in permitted_3_channel_modes : raise ValueError ( \"Only modes {} are supported for 3D inputs\" . format ( permitted_3_channel_modes ) ) if mode is None and npimg . dtype == np . uint8 : mode = 'RGB' if mode is None : raise TypeError ( 'Input type {} is not supported' . format ( npimg . dtype ) ) return Image . fromarray ( npimg , mode = mode )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def normalize ( tensor , mean , std , inplace = False ) : if not _is_tensor_image ( tensor ) : raise TypeError ( 'tensor is not a torch image.' ) if not inplace : tensor = tensor . clone ( ) mean = torch . as_tensor ( mean , dtype = torch . float32 , device = tensor . device ) std = torch . as_tensor ( std , dtype = torch . float32 , device = tensor . device ) tensor . sub_ ( mean [ : , None , None ] ) . div_ ( std [ : , None , None ] ) return tensor\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def resize ( img , size , interpolation = Image . BILINEAR ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) if not ( isinstance ( size , int ) or ( isinstance ( size , Iterable ) and len ( size ) == 2 ) ) : raise TypeError ( 'Got inappropriate size arg: {}' . format ( size ) ) if isinstance ( size , int ) : w , h = img . size if ( w <= h and w == size ) or ( h <= w and h == size ) : return img if w < h : ow = size oh = int ( size * h / w ) return img . resize ( ( ow , oh ) , interpolation ) else : oh = size ow = int ( size * w / h ) return img . resize ( ( ow , oh ) , interpolation ) else : return img . resize ( size [ : : - 1 ] , interpolation )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pad ( img , padding , fill = 0 , padding_mode = 'constant' ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) if not isinstance ( padding , ( numbers . Number , tuple ) ) : raise TypeError ( 'Got inappropriate padding arg' ) if not isinstance ( fill , ( numbers . Number , str , tuple ) ) : raise TypeError ( 'Got inappropriate fill arg' ) if not isinstance ( padding_mode , str ) : raise TypeError ( 'Got inappropriate padding_mode arg' ) if isinstance ( padding , Sequence ) and len ( padding ) not in [ 2 , 4 ] : raise ValueError ( \"Padding must be an int or a 2, or 4 element tuple, not a \" + \"{} element tuple\" . format ( len ( padding ) ) ) assert padding_mode in [ 'constant' , 'edge' , 'reflect' , 'symmetric' ] , 'Padding mode should be either constant, edge, reflect or symmetric' if padding_mode == 'constant' : if img . mode == 'P' : palette = img . getpalette ( ) image = ImageOps . expand ( img , border = padding , fill = fill ) image . putpalette ( palette ) return image return ImageOps . expand ( img , border = padding , fill = fill ) else : if isinstance ( padding , int ) : pad_left = pad_right = pad_top = pad_bottom = padding if isinstance ( padding , Sequence ) and len ( padding ) == 2 : pad_left = pad_right = padding [ 0 ] pad_top = pad_bottom = padding [ 1 ] if isinstance ( padding , Sequence ) and len ( padding ) == 4 : pad_left = padding [ 0 ] pad_top = padding [ 1 ] pad_right = padding [ 2 ] pad_bottom = padding [ 3 ] if img . mode == 'P' : palette = img . getpalette ( ) img = np . asarray ( img ) img = np . pad ( img , ( ( pad_top , pad_bottom ) , ( pad_left , pad_right ) ) , padding_mode ) img = Image . fromarray ( img ) img . putpalette ( palette ) return img img = np . asarray ( img ) # RGB image if len ( img . shape ) == 3 : img = np . pad ( img , ( ( pad_top , pad_bottom ) , ( pad_left , pad_right ) , ( 0 , 0 ) ) , padding_mode ) # Grayscale image if len ( img . shape ) == 2 : img = np . pad ( img , ( ( pad_top , pad_bottom ) , ( pad_left , pad_right ) ) , padding_mode ) return Image . fromarray ( img )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def crop ( img , i , j , h , w ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . crop ( ( j , i , j + w , i + h ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def resized_crop ( img , i , j , h , w , size , interpolation = Image . BILINEAR ) : assert _is_pil_image ( img ) , 'img should be PIL Image' img = crop ( img , i , j , h , w ) img = resize ( img , size , interpolation ) return img\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_perspective_coeffs ( startpoints , endpoints ) : matrix = [ ] for p1 , p2 in zip ( endpoints , startpoints ) : matrix . append ( [ p1 [ 0 ] , p1 [ 1 ] , 1 , 0 , 0 , 0 , - p2 [ 0 ] * p1 [ 0 ] , - p2 [ 0 ] * p1 [ 1 ] ] ) matrix . append ( [ 0 , 0 , 0 , p1 [ 0 ] , p1 [ 1 ] , 1 , - p2 [ 1 ] * p1 [ 0 ] , - p2 [ 1 ] * p1 [ 1 ] ] ) A = torch . tensor ( matrix , dtype = torch . float ) B = torch . tensor ( startpoints , dtype = torch . float ) . view ( 8 ) res = torch . gels ( B , A ) [ 0 ] return res . squeeze_ ( 1 ) . tolist ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def perspective ( img , startpoints , endpoints , interpolation = Image . BICUBIC ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) coeffs = _get_perspective_coeffs ( startpoints , endpoints ) return img . transform ( img . size , Image . PERSPECTIVE , coeffs , interpolation )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def vflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_TOP_BOTTOM )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def five_crop ( img , size ) : if isinstance ( size , numbers . Number ) : size = ( int ( size ) , int ( size ) ) else : assert len ( size ) == 2 , \"Please provide only two dimensions (h, w) for size.\" w , h = img . size crop_h , crop_w = size if crop_w > w or crop_h > h : raise ValueError ( \"Requested crop size {} is bigger than input size {}\" . format ( size , ( h , w ) ) ) tl = img . crop ( ( 0 , 0 , crop_w , crop_h ) ) tr = img . crop ( ( w - crop_w , 0 , w , crop_h ) ) bl = img . crop ( ( 0 , h - crop_h , crop_w , h ) ) br = img . crop ( ( w - crop_w , h - crop_h , w , h ) ) center = center_crop ( img , ( crop_h , crop_w ) ) return ( tl , tr , bl , br , center )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ten_crop ( img , size , vertical_flip = False ) : if isinstance ( size , numbers . Number ) : size = ( int ( size ) , int ( size ) ) else : assert len ( size ) == 2 , \"Please provide only two dimensions (h, w) for size.\" first_five = five_crop ( img , size ) if vertical_flip : img = vflip ( img ) else : img = hflip ( img ) second_five = five_crop ( img , size ) return first_five + second_five\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def adjust_brightness ( img , brightness_factor ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) enhancer = ImageEnhance . Brightness ( img ) img = enhancer . enhance ( brightness_factor ) return img\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def adjust_contrast ( img , contrast_factor ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) enhancer = ImageEnhance . Contrast ( img ) img = enhancer . enhance ( contrast_factor ) return img\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def adjust_saturation ( img , saturation_factor ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) enhancer = ImageEnhance . Color ( img ) img = enhancer . enhance ( saturation_factor ) return img\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def adjust_hue ( img , hue_factor ) : if not ( - 0.5 <= hue_factor <= 0.5 ) : raise ValueError ( 'hue_factor is not in [-0.5, 0.5].' . format ( hue_factor ) ) if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) input_mode = img . mode if input_mode in { 'L' , '1' , 'I' , 'F' } : return img h , s , v = img . convert ( 'HSV' ) . split ( ) np_h = np . array ( h , dtype = np . uint8 ) # uint8 addition take cares of rotation across boundaries with np . errstate ( over = 'ignore' ) : np_h += np . uint8 ( hue_factor * 255 ) h = Image . fromarray ( np_h , 'L' ) img = Image . merge ( 'HSV' , ( h , s , v ) ) . convert ( input_mode ) return img\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def adjust_gamma ( img , gamma , gain = 1 ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) if gamma < 0 : raise ValueError ( 'Gamma should be a non-negative real number' ) input_mode = img . mode img = img . convert ( 'RGB' ) gamma_map = [ 255 * gain * pow ( ele / 255. , gamma ) for ele in range ( 256 ) ] * 3 img = img . point ( gamma_map ) # use PIL's point-function to accelerate this part img = img . convert ( input_mode ) return img\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def rotate ( img , angle , resample = False , expand = False , center = None ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . rotate ( angle , resample , expand , center )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def affine ( img , angle , translate , scale , shear , resample = 0 , fillcolor = None ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) assert isinstance ( translate , ( tuple , list ) ) and len ( translate ) == 2 , \"Argument translate should be a list or tuple of length 2\" assert scale > 0.0 , \"Argument scale should be positive\" output_size = img . size center = ( img . size [ 0 ] * 0.5 + 0.5 , img . size [ 1 ] * 0.5 + 0.5 ) matrix = _get_inverse_affine_matrix ( center , angle , translate , scale , shear ) kwargs = { \"fillcolor\" : fillcolor } if PILLOW_VERSION [ 0 ] == '5' else { } return img . transform ( output_size , Image . AFFINE , matrix , resample , * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def to_grayscale ( img , num_output_channels = 1 ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) if num_output_channels == 1 : img = img . convert ( 'L' ) elif num_output_channels == 3 : img = img . convert ( 'L' ) np_img = np . array ( img , dtype = np . uint8 ) np_img = np . dstack ( [ np_img , np_img , np_img ] ) img = Image . fromarray ( np_img , 'RGB' ) else : raise ValueError ( 'num_output_channels should be either 1 or 3' ) return img\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_grid ( tensor , nrow = 8 , padding = 2 , normalize = False , range = None , scale_each = False , pad_value = 0 ) : if not ( torch . is_tensor ( tensor ) or ( isinstance ( tensor , list ) and all ( torch . is_tensor ( t ) for t in tensor ) ) ) : raise TypeError ( 'tensor or list of tensors expected, got {}' . format ( type ( tensor ) ) ) # if list of tensors, convert to a 4D mini-batch Tensor if isinstance ( tensor , list ) : tensor = torch . stack ( tensor , dim = 0 ) if tensor . dim ( ) == 2 : # single image H x W tensor = tensor . unsqueeze ( 0 ) if tensor . dim ( ) == 3 : # single image if tensor . size ( 0 ) == 1 : # if single-channel, convert to 3-channel tensor = torch . cat ( ( tensor , tensor , tensor ) , 0 ) tensor = tensor . unsqueeze ( 0 ) if tensor . dim ( ) == 4 and tensor . size ( 1 ) == 1 : # single-channel images tensor = torch . cat ( ( tensor , tensor , tensor ) , 1 ) if normalize is True : tensor = tensor . clone ( ) # avoid modifying tensor in-place if range is not None : assert isinstance ( range , tuple ) , \"range has to be a tuple (min, max) if specified. min and max are numbers\" def norm_ip ( img , min , max ) : img . clamp_ ( min = min , max = max ) img . add_ ( - min ) . div_ ( max - min + 1e-5 ) def norm_range ( t , range ) : if range is not None : norm_ip ( t , range [ 0 ] , range [ 1 ] ) else : norm_ip ( t , float ( t . min ( ) ) , float ( t . max ( ) ) ) if scale_each is True : for t in tensor : # loop over mini-batch dimension norm_range ( t , range ) else : norm_range ( tensor , range ) if tensor . size ( 0 ) == 1 : return tensor . squeeze ( ) # make the mini-batch of images into a grid nmaps = tensor . size ( 0 ) xmaps = min ( nrow , nmaps ) ymaps = int ( math . ceil ( float ( nmaps ) / xmaps ) ) height , width = int ( tensor . size ( 2 ) + padding ) , int ( tensor . size ( 3 ) + padding ) grid = tensor . new_full ( ( 3 , height * ymaps + padding , width * xmaps + padding ) , pad_value ) k = 0 for y in irange ( ymaps ) : for x in irange ( xmaps ) : if k >= nmaps : break grid . narrow ( 1 , y * height + padding , height - padding ) . narrow ( 2 , x * width + padding , width - padding ) . copy_ ( tensor [ k ] ) k = k + 1 return grid\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def save_image ( tensor , filename , nrow = 8 , padding = 2 , normalize = False , range = None , scale_each = False , pad_value = 0 ) : from PIL import Image grid = make_grid ( tensor , nrow = nrow , padding = padding , pad_value = pad_value , normalize = normalize , range = range , scale_each = scale_each ) # Add 0.5 after unnormalizing to [0, 255] to round to nearest integer ndarr = grid . mul_ ( 255 ) . add_ ( 0.5 ) . clamp_ ( 0 , 255 ) . permute ( 1 , 2 , 0 ) . to ( 'cpu' , torch . uint8 ) . numpy ( ) im = Image . fromarray ( ndarr ) im . save ( filename )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _find_classes ( self , dir ) : if sys . version_info >= ( 3 , 5 ) : # Faster and available in Python 3.5 and above classes = [ d . name for d in os . scandir ( dir ) if d . is_dir ( ) ] else : classes = [ d for d in os . listdir ( dir ) if os . path . isdir ( os . path . join ( dir , d ) ) ] classes . sort ( ) class_to_idx = { classes [ i ] : i for i in range ( len ( classes ) ) } return classes , class_to_idx\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def read_image_file ( data_dir , image_ext , n ) : def PIL2array ( _img ) : \"\"\"Convert PIL image type to numpy 2D array \"\"\" return np . array ( _img . getdata ( ) , dtype = np . uint8 ) . reshape ( 64 , 64 ) def find_files ( _data_dir , _image_ext ) : \"\"\"Return a list with the file names of the images containing the patches \"\"\" files = [ ] # find those files with the specified extension for file_dir in os . listdir ( _data_dir ) : if file_dir . endswith ( _image_ext ) : files . append ( os . path . join ( _data_dir , file_dir ) ) return sorted ( files ) # sort files in ascend order to keep relations patches = [ ] list_files = find_files ( data_dir , image_ext ) for fpath in list_files : img = Image . open ( fpath ) for y in range ( 0 , 1024 , 64 ) : for x in range ( 0 , 1024 , 64 ) : patch = img . crop ( ( x , y , x + 64 , y + 64 ) ) patches . append ( PIL2array ( patch ) ) return torch . ByteTensor ( np . array ( patches [ : n ] ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def read_info_file ( data_dir , info_file ) : labels = [ ] with open ( os . path . join ( data_dir , info_file ) , 'r' ) as f : labels = [ int ( line . split ( ) [ 0 ] ) for line in f ] return torch . LongTensor ( labels )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def read_matches_files ( data_dir , matches_file ) : matches = [ ] with open ( os . path . join ( data_dir , matches_file ) , 'r' ) as f : for line in f : line_split = line . split ( ) matches . append ( [ int ( line_split [ 0 ] ) , int ( line_split [ 3 ] ) , int ( line_split [ 1 ] == line_split [ 4 ] ) ] ) return torch . LongTensor ( matches )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def accuracy ( output , target , topk = ( 1 , ) ) : with torch . no_grad ( ) : maxk = max ( topk ) batch_size = target . size ( 0 ) _ , pred = output . topk ( maxk , 1 , True , True ) pred = pred . t ( ) correct = pred . eq ( target [ None ] ) res = [ ] for k in topk : correct_k = correct [ : k ] . flatten ( ) . sum ( dtype = torch . float32 ) res . append ( correct_k * ( 100.0 / batch_size ) ) return res\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def setup_for_distributed ( is_master ) : import builtins as __builtin__ builtin_print = __builtin__ . print def print ( * args , * * kwargs ) : force = kwargs . pop ( 'force' , False ) if is_master or force : builtin_print ( * args , * * kwargs ) __builtin__ . print = print\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def synchronize_between_processes ( self ) : if not is_dist_avail_and_initialized ( ) : return t = torch . tensor ( [ self . count , self . total ] , dtype = torch . float64 , device = 'cuda' ) dist . barrier ( ) dist . all_reduce ( t ) t = t . tolist ( ) self . count = int ( t [ 0 ] ) self . total = t [ 1 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def squeezenet1_1 ( pretrained = False , * * kwargs ) : model = SqueezeNet ( version = 1.1 , * * kwargs ) if pretrained : model . load_state_dict ( model_zoo . load_url ( model_urls [ 'squeezenet1_1' ] ) ) return model\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def makedir_exist_ok ( dirpath ) : try : os . makedirs ( dirpath ) except OSError as e : if e . errno == errno . EEXIST : pass else : raise\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download_url ( url , root , filename = None , md5 = None ) : from six . moves import urllib root = os . path . expanduser ( root ) if not filename : filename = os . path . basename ( url ) fpath = os . path . join ( root , filename ) makedir_exist_ok ( root ) # downloads file if os . path . isfile ( fpath ) and check_integrity ( fpath , md5 ) : print ( 'Using downloaded and verified file: ' + fpath ) else : try : print ( 'Downloading ' + url + ' to ' + fpath ) urllib . request . urlretrieve ( url , fpath , reporthook = gen_bar_updater ( ) ) except OSError : if url [ : 5 ] == 'https' : url = url . replace ( 'https:' , 'http:' ) print ( 'Failed download. Trying https -> http instead.' ' Downloading ' + url + ' to ' + fpath ) urllib . request . urlretrieve ( url , fpath , reporthook = gen_bar_updater ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_dir ( root , prefix = False ) : root = os . path . expanduser ( root ) directories = list ( filter ( lambda p : os . path . isdir ( os . path . join ( root , p ) ) , os . listdir ( root ) ) ) if prefix is True : directories = [ os . path . join ( root , d ) for d in directories ] return directories\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def list_files ( root , suffix , prefix = False ) : root = os . path . expanduser ( root ) files = list ( filter ( lambda p : os . path . isfile ( os . path . join ( root , p ) ) and p . endswith ( suffix ) , os . listdir ( root ) ) ) if prefix is True : files = [ os . path . join ( root , d ) for d in files ] return files\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download_file_from_google_drive ( file_id , root , filename = None , md5 = None ) : # Based on https://stackoverflow.com/questions/38511444/python-download-files-from-google-drive-using-url import requests url = \"https://docs.google.com/uc?export=download\" root = os . path . expanduser ( root ) if not filename : filename = file_id fpath = os . path . join ( root , filename ) makedir_exist_ok ( root ) if os . path . isfile ( fpath ) and check_integrity ( fpath , md5 ) : print ( 'Using downloaded and verified file: ' + fpath ) else : session = requests . Session ( ) response = session . get ( url , params = { 'id' : file_id } , stream = True ) token = _get_confirm_token ( response ) if token : params = { 'id' : file_id , 'confirm' : token } response = session . get ( url , params = params , stream = True ) _save_response_content ( response , fpath )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_params ( img , output_size ) : w , h = img . size th , tw = output_size if w == tw and h == th : return 0 , 0 , h , w i = random . randint ( 0 , h - th ) j = random . randint ( 0 , w - tw ) return i , j , th , tw\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_params ( width , height , distortion_scale ) : half_height = int ( height / 2 ) half_width = int ( width / 2 ) topleft = ( random . randint ( 0 , int ( distortion_scale * half_width ) ) , random . randint ( 0 , int ( distortion_scale * half_height ) ) ) topright = ( random . randint ( width - int ( distortion_scale * half_width ) - 1 , width - 1 ) , random . randint ( 0 , int ( distortion_scale * half_height ) ) ) botright = ( random . randint ( width - int ( distortion_scale * half_width ) - 1 , width - 1 ) , random . randint ( height - int ( distortion_scale * half_height ) - 1 , height - 1 ) ) botleft = ( random . randint ( 0 , int ( distortion_scale * half_width ) ) , random . randint ( height - int ( distortion_scale * half_height ) - 1 , height - 1 ) ) startpoints = [ ( 0 , 0 ) , ( width - 1 , 0 ) , ( width - 1 , height - 1 ) , ( 0 , height - 1 ) ] endpoints = [ topleft , topright , botright , botleft ] return startpoints , endpoints\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_params ( img , scale , ratio ) : area = img . size [ 0 ] * img . size [ 1 ] for attempt in range ( 10 ) : target_area = random . uniform ( * scale ) * area log_ratio = ( math . log ( ratio [ 0 ] ) , math . log ( ratio [ 1 ] ) ) aspect_ratio = math . exp ( random . uniform ( * log_ratio ) ) w = int ( round ( math . sqrt ( target_area * aspect_ratio ) ) ) h = int ( round ( math . sqrt ( target_area / aspect_ratio ) ) ) if w <= img . size [ 0 ] and h <= img . size [ 1 ] : i = random . randint ( 0 , img . size [ 1 ] - h ) j = random . randint ( 0 , img . size [ 0 ] - w ) return i , j , h , w # Fallback to central crop in_ratio = img . size [ 0 ] / img . size [ 1 ] if ( in_ratio < min ( ratio ) ) : w = img . size [ 0 ] h = w / min ( ratio ) elif ( in_ratio > max ( ratio ) ) : h = img . size [ 1 ] w = h * max ( ratio ) else : # whole image w = img . size [ 0 ] h = img . size [ 1 ] i = ( img . size [ 1 ] - h ) // 2 j = ( img . size [ 0 ] - w ) // 2 return i , j , h , w\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_params ( brightness , contrast , saturation , hue ) : transforms = [ ] if brightness is not None : brightness_factor = random . uniform ( brightness [ 0 ] , brightness [ 1 ] ) transforms . append ( Lambda ( lambda img : F . adjust_brightness ( img , brightness_factor ) ) ) if contrast is not None : contrast_factor = random . uniform ( contrast [ 0 ] , contrast [ 1 ] ) transforms . append ( Lambda ( lambda img : F . adjust_contrast ( img , contrast_factor ) ) ) if saturation is not None : saturation_factor = random . uniform ( saturation [ 0 ] , saturation [ 1 ] ) transforms . append ( Lambda ( lambda img : F . adjust_saturation ( img , saturation_factor ) ) ) if hue is not None : hue_factor = random . uniform ( hue [ 0 ] , hue [ 1 ] ) transforms . append ( Lambda ( lambda img : F . adjust_hue ( img , hue_factor ) ) ) random . shuffle ( transforms ) transform = Compose ( transforms ) return transform\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_params ( degrees , translate , scale_ranges , shears , img_size ) : angle = random . uniform ( degrees [ 0 ] , degrees [ 1 ] ) if translate is not None : max_dx = translate [ 0 ] * img_size [ 0 ] max_dy = translate [ 1 ] * img_size [ 1 ] translations = ( np . round ( random . uniform ( - max_dx , max_dx ) ) , np . round ( random . uniform ( - max_dy , max_dy ) ) ) else : translations = ( 0 , 0 ) if scale_ranges is not None : scale = random . uniform ( scale_ranges [ 0 ] , scale_ranges [ 1 ] ) else : scale = 1.0 if shears is not None : shear = random . uniform ( shears [ 0 ] , shears [ 1 ] ) else : shear = 0.0 return angle , translations , scale , shear\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def inception_v3 ( pretrained = False , * * kwargs ) : if pretrained : if 'transform_input' not in kwargs : kwargs [ 'transform_input' ] = True if 'aux_logits' in kwargs : original_aux_logits = kwargs [ 'aux_logits' ] kwargs [ 'aux_logits' ] = True else : original_aux_logits = True model = Inception3 ( * * kwargs ) model . load_state_dict ( model_zoo . load_url ( model_urls [ 'inception_v3_google' ] ) ) if not original_aux_logits : model . aux_logits = False del model . AuxLogits return model return Inception3 ( * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download ( self ) : import tarfile if self . _check_integrity ( ) : print ( 'Files already downloaded and verified' ) return download_url ( self . url , self . root , self . filename , self . md5_checksum ) # Extract file with tarfile . open ( os . path . join ( self . root , self . filename ) , 'r:gz' ) as tar : tar . extractall ( path = self . root ) # Download individual photos with open ( os . path . join ( self . root , 'dataset' , 'SBU_captioned_photo_dataset_urls.txt' ) ) as fh : for line in fh : url = line . rstrip ( ) try : download_url ( url , os . path . join ( self . root , 'dataset' ) ) except OSError : # The images point to public images on Flickr. # Note: Images might be removed by users at anytime. pass\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def googlenet ( pretrained = False , * * kwargs ) : if pretrained : if 'transform_input' not in kwargs : kwargs [ 'transform_input' ] = True if 'aux_logits' not in kwargs : kwargs [ 'aux_logits' ] = False if kwargs [ 'aux_logits' ] : warnings . warn ( 'auxiliary heads in the pretrained googlenet model are NOT pretrained, ' 'so make sure to train them' ) original_aux_logits = kwargs [ 'aux_logits' ] kwargs [ 'aux_logits' ] = True kwargs [ 'init_weights' ] = False model = GoogLeNet ( * * kwargs ) model . load_state_dict ( model_zoo . load_url ( model_urls [ 'googlenet' ] ) ) if not original_aux_logits : model . aux_logits = False del model . aux1 , model . aux2 return model return GoogLeNet ( * * kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download ( self ) : if self . _check_exists ( ) : return makedir_exist_ok ( self . raw_folder ) makedir_exist_ok ( self . processed_folder ) # download files for url in self . urls : filename = url . rpartition ( '/' ) [ 2 ] file_path = os . path . join ( self . raw_folder , filename ) download_url ( url , root = self . raw_folder , filename = filename , md5 = None ) self . extract_gzip ( gzip_path = file_path , remove_finished = True ) # process and save as torch files print ( 'Processing...' ) training_set = ( read_image_file ( os . path . join ( self . raw_folder , 'train-images-idx3-ubyte' ) ) , read_label_file ( os . path . join ( self . raw_folder , 'train-labels-idx1-ubyte' ) ) ) test_set = ( read_image_file ( os . path . join ( self . raw_folder , 't10k-images-idx3-ubyte' ) ) , read_label_file ( os . path . join ( self . raw_folder , 't10k-labels-idx1-ubyte' ) ) ) with open ( os . path . join ( self . processed_folder , self . training_file ) , 'wb' ) as f : torch . save ( training_set , f ) with open ( os . path . join ( self . processed_folder , self . test_file ) , 'wb' ) as f : torch . save ( test_set , f ) print ( 'Done!' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download ( self ) : import shutil import zipfile if self . _check_exists ( ) : return makedir_exist_ok ( self . raw_folder ) makedir_exist_ok ( self . processed_folder ) # download files filename = self . url . rpartition ( '/' ) [ 2 ] file_path = os . path . join ( self . raw_folder , filename ) download_url ( self . url , root = self . raw_folder , filename = filename , md5 = None ) print ( 'Extracting zip archive' ) with zipfile . ZipFile ( file_path ) as zip_f : zip_f . extractall ( self . raw_folder ) os . unlink ( file_path ) gzip_folder = os . path . join ( self . raw_folder , 'gzip' ) for gzip_file in os . listdir ( gzip_folder ) : if gzip_file . endswith ( '.gz' ) : self . extract_gzip ( gzip_path = os . path . join ( gzip_folder , gzip_file ) ) # process and save as torch files for split in self . splits : print ( 'Processing ' + split ) training_set = ( read_image_file ( os . path . join ( gzip_folder , 'emnist-{}-train-images-idx3-ubyte' . format ( split ) ) ) , read_label_file ( os . path . join ( gzip_folder , 'emnist-{}-train-labels-idx1-ubyte' . format ( split ) ) ) ) test_set = ( read_image_file ( os . path . join ( gzip_folder , 'emnist-{}-test-images-idx3-ubyte' . format ( split ) ) ) , read_label_file ( os . path . join ( gzip_folder , 'emnist-{}-test-labels-idx1-ubyte' . format ( split ) ) ) ) with open ( os . path . join ( self . processed_folder , self . _training_file ( split ) ) , 'wb' ) as f : torch . save ( training_set , f ) with open ( os . path . join ( self . processed_folder , self . _test_file ( split ) ) , 'wb' ) as f : torch . save ( test_set , f ) shutil . rmtree ( gzip_folder ) print ( 'Done!' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def request ( method , url , * * kwargs ) : time_before_request = time ( ) # session start session = SessionSinglePool ( ) # proxies kwargs [ 'proxies' ] = settings [ 'outgoing' ] . get ( 'proxies' ) or None # timeout if 'timeout' in kwargs : timeout = kwargs [ 'timeout' ] else : timeout = getattr ( threadLocal , 'timeout' , None ) if timeout is not None : kwargs [ 'timeout' ] = timeout # do request response = session . request ( method = method , url = url , * * kwargs ) time_after_request = time ( ) # is there a timeout for this engine ? if timeout is not None : timeout_overhead = 0.2 # seconds # start_time = when the user request started start_time = getattr ( threadLocal , 'start_time' , time_before_request ) search_duration = time_after_request - start_time if search_duration > timeout + timeout_overhead : raise requests . exceptions . Timeout ( response = response ) # session end session . close ( ) if hasattr ( threadLocal , 'total_time' ) : threadLocal . total_time += time_after_request - time_before_request return response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_current_theme_name ( override = None ) : if override and ( override in themes or override == '__common__' ) : return override theme_name = request . args . get ( 'theme' , request . preferences . get_value ( 'theme' ) ) if theme_name not in themes : theme_name = default_theme return theme_name\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def index ( ) : # output_format output_format = request . form . get ( 'format' , 'html' ) if output_format not in [ 'html' , 'csv' , 'json' , 'rss' ] : output_format = 'html' # check if there is query if request . form . get ( 'q' ) is None : if output_format == 'html' : return render ( 'index.html' , ) else : return index_error ( output_format , 'No query' ) , 400 # search search_query = None result_container = None try : search_query = get_search_query_from_webapp ( request . preferences , request . form ) # search = Search(search_query) # without plugins search = SearchWithPlugins ( search_query , request . user_plugins , request ) result_container = search . search ( ) except Exception as e : # log exception logger . exception ( 'search error' ) # is it an invalid input parameter or something else ? if ( issubclass ( e . __class__ , SearxParameterException ) ) : return index_error ( output_format , e . message ) , 400 else : return index_error ( output_format , gettext ( 'search error' ) ) , 500 # results results = result_container . get_ordered_results ( ) number_of_results = result_container . results_number ( ) if number_of_results < result_container . results_length ( ) : number_of_results = 0 # UI advanced_search = request . form . get ( 'advanced_search' , None ) # output for result in results : if output_format == 'html' : if 'content' in result and result [ 'content' ] : result [ 'content' ] = highlight_content ( escape ( result [ 'content' ] [ : 1024 ] ) , search_query . query ) result [ 'title' ] = highlight_content ( escape ( result [ 'title' ] or u'' ) , search_query . query ) else : if result . get ( 'content' ) : result [ 'content' ] = html_to_text ( result [ 'content' ] ) . strip ( ) # removing html content and whitespace duplications result [ 'title' ] = ' ' . join ( html_to_text ( result [ 'title' ] ) . strip ( ) . split ( ) ) result [ 'pretty_url' ] = prettify_url ( result [ 'url' ] ) # TODO, check if timezone is calculated right if 'publishedDate' in result : try : # test if publishedDate >= 1900 (datetime module bug) result [ 'pubdate' ] = result [ 'publishedDate' ] . strftime ( '%Y-%m-%d %H:%M:%S%z' ) except ValueError : result [ 'publishedDate' ] = None else : if result [ 'publishedDate' ] . replace ( tzinfo = None ) >= datetime . now ( ) - timedelta ( days = 1 ) : timedifference = datetime . now ( ) - result [ 'publishedDate' ] . replace ( tzinfo = None ) minutes = int ( ( timedifference . seconds / 60 ) % 60 ) hours = int ( timedifference . seconds / 60 / 60 ) if hours == 0 : result [ 'publishedDate' ] = gettext ( u'{minutes} minute(s) ago' ) . format ( minutes = minutes ) else : result [ 'publishedDate' ] = gettext ( u'{hours} hour(s), {minutes} minute(s) ago' ) . format ( hours = hours , minutes = minutes ) # noqa else : result [ 'publishedDate' ] = format_date ( result [ 'publishedDate' ] ) if output_format == 'json' : return Response ( json . dumps ( { 'query' : search_query . query . decode ( 'utf-8' ) , 'number_of_results' : number_of_results , 'results' : results , 'answers' : list ( result_container . answers ) , 'corrections' : list ( result_container . corrections ) , 'infoboxes' : result_container . infoboxes , 'suggestions' : list ( result_container . suggestions ) , 'unresponsive_engines' : list ( result_container . unresponsive_engines ) } , default = lambda item : list ( item ) if isinstance ( item , set ) else item ) , mimetype = 'application/json' ) elif output_format == 'csv' : csv = UnicodeWriter ( StringIO ( ) ) keys = ( 'title' , 'url' , 'content' , 'host' , 'engine' , 'score' ) csv . writerow ( keys ) for row in results : row [ 'host' ] = row [ 'parsed_url' ] . netloc csv . writerow ( [ row . get ( key , '' ) for key in keys ] ) csv . stream . seek ( 0 ) response = Response ( csv . stream . read ( ) , mimetype = 'application/csv' ) cont_disp = 'attachment;Filename=searx_-_{0}.csv' . format ( search_query . query ) response . headers . add ( 'Content-Disposition' , cont_disp ) return response elif output_format == 'rss' : response_rss = render ( 'opensearch_response_rss.xml' , results = results , q = request . form [ 'q' ] , number_of_results = number_of_results , base_url = get_base_url ( ) , override_theme = '__common__' , ) return Response ( response_rss , mimetype = 'text/xml' ) return render ( 'results.html' , results = results , q = request . form [ 'q' ] , selected_categories = search_query . categories , pageno = search_query . pageno , time_range = search_query . time_range , number_of_results = format_decimal ( number_of_results ) , advanced_search = advanced_search , suggestions = result_container . suggestions , answers = result_container . answers , corrections = result_container . corrections , infoboxes = result_container . infoboxes , paging = result_container . paging , unresponsive_engines = result_container . unresponsive_engines , current_language = match_language ( search_query . lang , LANGUAGE_CODES , fallback = settings [ 'search' ] [ 'language' ] ) , base_url = get_base_url ( ) , theme = get_current_theme_name ( ) , favicons = global_favicons [ themes . index ( get_current_theme_name ( ) ) ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def autocompleter ( ) : # set blocked engines disabled_engines = request . preferences . engines . get_disabled ( ) # parse query if PY3 : raw_text_query = RawTextQuery ( request . form . get ( 'q' , b'' ) , disabled_engines ) else : raw_text_query = RawTextQuery ( request . form . get ( 'q' , u'' ) . encode ( 'utf-8' ) , disabled_engines ) raw_text_query . parse_query ( ) # check if search query is set if not raw_text_query . getSearchQuery ( ) : return '' , 400 # run autocompleter completer = autocomplete_backends . get ( request . preferences . get_value ( 'autocomplete' ) ) # parse searx specific autocompleter results like !bang raw_results = searx_bang ( raw_text_query ) # normal autocompletion results only appear if max 3 inner results returned if len ( raw_results ) <= 3 and completer : # get language from cookie language = request . preferences . get_value ( 'language' ) if not language or language == 'all' : language = 'en' else : language = language . split ( '-' ) [ 0 ] # run autocompletion raw_results . extend ( completer ( raw_text_query . getSearchQuery ( ) , language ) ) # parse results (write :language and !engine back to result string) results = [ ] for result in raw_results : raw_text_query . changeSearchQuery ( result ) # add parsed result results . append ( raw_text_query . getFullQuery ( ) ) # return autocompleter results if request . form . get ( 'format' ) == 'x-suggestions' : return Response ( json . dumps ( [ raw_text_query . query , results ] ) , mimetype = 'application/json' ) return Response ( json . dumps ( results ) , mimetype = 'application/json' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def preferences ( ) : # save preferences if request . method == 'POST' : resp = make_response ( redirect ( urljoin ( settings [ 'server' ] [ 'base_url' ] , url_for ( 'index' ) ) ) ) try : request . preferences . parse_form ( request . form ) except ValidationException : request . errors . append ( gettext ( 'Invalid settings, please edit your preferences' ) ) return resp return request . preferences . save ( resp ) # render preferences image_proxy = request . preferences . get_value ( 'image_proxy' ) lang = request . preferences . get_value ( 'language' ) disabled_engines = request . preferences . engines . get_disabled ( ) allowed_plugins = request . preferences . plugins . get_enabled ( ) # stats for preferences page stats = { } for c in categories : for e in categories [ c ] : stats [ e . name ] = { 'time' : None , 'warn_timeout' : False , 'warn_time' : False } if e . timeout > settings [ 'outgoing' ] [ 'request_timeout' ] : stats [ e . name ] [ 'warn_timeout' ] = True stats [ e . name ] [ 'supports_selected_language' ] = _is_selected_language_supported ( e , request . preferences ) # get first element [0], the engine time, # and then the second element [1] : the time (the first one is the label) for engine_stat in get_engines_stats ( ) [ 0 ] [ 1 ] : stats [ engine_stat . get ( 'name' ) ] [ 'time' ] = round ( engine_stat . get ( 'avg' ) , 3 ) if engine_stat . get ( 'avg' ) > settings [ 'outgoing' ] [ 'request_timeout' ] : stats [ engine_stat . get ( 'name' ) ] [ 'warn_time' ] = True # end of stats return render ( 'preferences.html' , locales = settings [ 'locales' ] , current_locale = get_locale ( ) , image_proxy = image_proxy , engines_by_category = categories , stats = stats , answerers = [ { 'info' : a . self_info ( ) , 'keywords' : a . keywords } for a in answerers ] , disabled_engines = disabled_engines , autocomplete_backends = autocomplete_backends , shortcuts = { y : x for x , y in engine_shortcuts . items ( ) } , themes = themes , plugins = plugins , doi_resolvers = settings [ 'doi_resolvers' ] , current_doi_resolver = get_doi_resolver ( request . args , request . preferences . get_value ( 'doi_resolver' ) ) , allowed_plugins = allowed_plugins , theme = get_current_theme_name ( ) , preferences_url_params = request . preferences . get_as_url_params ( ) , base_url = get_base_url ( ) , preferences = True )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def request ( query , params ) : offset = ( params [ 'pageno' ] - 1 ) params [ 'url' ] = search_url . format ( offset = offset , query = quote ( query ) ) return params\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def response ( resp ) : results = [ ] dom = html . fromstring ( resp . text ) try : number_of_results_string = re . sub ( '[^0-9]' , '' , dom . xpath ( '//a[@class=\"active\" and contains(@href,\"/suchen/dudenonline\")]/span/text()' ) [ 0 ] ) results . append ( { 'number_of_results' : int ( number_of_results_string ) } ) except : logger . debug ( \"Couldn't read number of results.\" ) pass for result in dom . xpath ( '//section[@class=\"wide\" and not(contains(@style,\"overflow:hidden\"))]' ) : try : logger . debug ( \"running for %s\" % str ( result ) ) link = result . xpath ( './/h2/a' ) [ 0 ] url = link . attrib . get ( 'href' ) title = result . xpath ( 'string(.//h2/a)' ) content = extract_text ( result . xpath ( './/p' ) ) # append result results . append ( { 'url' : url , 'title' : title , 'content' : content } ) except : logger . debug ( 'result parse error in:\\n%s' , etree . tostring ( result , pretty_print = True ) ) continue return results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_themes ( templates_path ) : themes = os . listdir ( templates_path ) if '__common__' in themes : themes . remove ( '__common__' ) return themes\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def searx_bang ( full_query ) : # check if there is a query which can be parsed if len ( full_query . getSearchQuery ( ) ) == 0 : return [ ] results = [ ] # check if current query stats with !bang first_char = full_query . getSearchQuery ( ) [ 0 ] if first_char == '!' or first_char == '?' : if len ( full_query . getSearchQuery ( ) ) == 1 : # show some example queries # TODO, check if engine is not avaliable results . append ( first_char + \"images\" ) results . append ( first_char + \"wikipedia\" ) results . append ( first_char + \"osm\" ) else : engine_query = full_query . getSearchQuery ( ) [ 1 : ] # check if query starts with categorie name for categorie in categories : if categorie . startswith ( engine_query ) : results . append ( first_char + '{categorie}' . format ( categorie = categorie ) ) # check if query starts with engine name for engine in engines : if engine . startswith ( engine_query . replace ( '_' , ' ' ) ) : results . append ( first_char + '{engine}' . format ( engine = engine . replace ( ' ' , '_' ) ) ) # check if query starts with engine shortcut for engine_shortcut in engine_shortcuts : if engine_shortcut . startswith ( engine_query ) : results . append ( first_char + '{engine_shortcut}' . format ( engine_shortcut = engine_shortcut ) ) # check if current query stats with :bang elif first_char == ':' : if len ( full_query . getSearchQuery ( ) ) == 1 : # show some example queries results . append ( \":en\" ) results . append ( \":en_us\" ) results . append ( \":english\" ) results . append ( \":united_kingdom\" ) else : engine_query = full_query . getSearchQuery ( ) [ 1 : ] for lc in language_codes : lang_id , lang_name , country , english_name = map ( unicode . lower , lc ) # check if query starts with language-id if lang_id . startswith ( engine_query ) : if len ( engine_query ) <= 2 : results . append ( u':{lang_id}' . format ( lang_id = lang_id . split ( '-' ) [ 0 ] ) ) else : results . append ( u':{lang_id}' . format ( lang_id = lang_id ) ) # check if query starts with language name if lang_name . startswith ( engine_query ) or english_name . startswith ( engine_query ) : results . append ( u':{lang_name}' . format ( lang_name = lang_name ) ) # check if query starts with country if country . startswith ( engine_query . replace ( '_' , ' ' ) ) : results . append ( u':{country}' . format ( country = country . replace ( ' ' , '_' ) ) ) # remove duplicates result_set = set ( results ) # remove results which are already contained in the query for query_part in full_query . query_parts : if query_part in result_set : result_set . remove ( query_part ) # convert result_set back to list return list ( result_set )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def response ( resp ) : json_resp = resp . text [ resp . text . find ( '\\n' ) + 1 : resp . text . rfind ( '\\n' ) - 2 ] results = [ ] try : conversion_rate = float ( json . loads ( json_resp ) [ 'conversion' ] [ 'converted-amount' ] ) except : return results answer = '{0} {1} = {2} {3}, 1 {1} ({5}) = {4} {3} ({6})' . format ( resp . search_params [ 'amount' ] , resp . search_params [ 'from' ] , resp . search_params [ 'amount' ] * conversion_rate , resp . search_params [ 'to' ] , conversion_rate , resp . search_params [ 'from_name' ] , resp . search_params [ 'to_name' ] , ) url = 'https://duckduckgo.com/js/spice/currency/1/{0}/{1}' . format ( resp . search_params [ 'from' ] . upper ( ) , resp . search_params [ 'to' ] ) results . append ( { 'answer' : answer , 'url' : url } ) return results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def custom_gradient ( fx , gx , x , fx_gx_manually_stopped = False , name = None ) : def maybe_stop ( x ) : if fx_gx_manually_stopped : return x return tf . stop_gradient ( x ) with tf . compat . v1 . name_scope ( name , 'custom_gradient' , [ fx , gx , x ] ) : fx = tf . convert_to_tensor ( value = fx , name = 'fx' ) # We don't want to bother eagerly computing `gx` since we may not even need # it. with tf . control_dependencies ( [ fx ] ) : if is_list_like ( x ) : x = [ identity ( x_ , name = 'x' ) for x_ in x ] else : x = [ identity ( x , name = 'x' ) ] if is_list_like ( gx ) : gx = [ identity ( gx_ , dtype = fx . dtype , name = 'gx' ) for gx_ in gx ] else : gx = [ identity ( gx , dtype = fx . dtype , name = 'gx' ) ] override_grad = [ ] for x_ , gx_ in zip ( x , gx ) : # Observe: tf.gradients(f(x), x)[i].shape == x[i].shape # thus we check that the user is supplying correct shapes. equal_shape = tf . compat . v1 . assert_equal ( tf . shape ( input = x_ ) , tf . shape ( input = gx_ ) , message = 'Each `x` must have the same shape as each `gx`.' ) with tf . control_dependencies ( [ equal_shape ] ) : # IEEE754 ensures `(x-x)==0.` and that `0.*x==0.` so we make sure to # write the code this way, rather than, e.g., # `sum_x * stop(gx) + stop(fx - sum_x * gx)`. # For more discussion regarding the relevant portions of the IEEE754 # standard, see the StackOverflow question, # \"Is there a floating point value of x, for which x-x == 0 is false?\" # http://stackoverflow.com/q/2686644 zeros_like_x_ = x_ - tf . stop_gradient ( x_ ) override_grad . append ( tf . reduce_sum ( input_tensor = maybe_stop ( gx_ ) * zeros_like_x_ ) ) override_grad = sum ( override_grad ) override_grad /= tf . cast ( tf . size ( input = fx ) , dtype = fx . dtype . base_dtype ) # Proof of correctness: # # f(x) = x * stop[gx] + stop[fx - x * gx] # = stop[fx] # # g(x) = grad[fx] # = stop[gx] + grad[stop[fx - x * gx]] # = stop[gx] + 0 # # Notice that when x is zero it still works: # grad[x * stop(gx) + stop(fx - x * gx)] = 1 * stop[gx] + 0 = stop[gx] # # The proof is similar for the tensor-domain case, except that we # `reduce_sum` the `stop[gx] * (x - stop[x])` then rescale by # `tf.size(fx)` since this reduced version is broadcast to `fx`. return maybe_stop ( fx ) + override_grad\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def value_and_gradient ( f , xs , use_gradient_tape = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'value_and_gradient' , [ xs ] ) : is_xs_list_like = isinstance ( xs , ( tuple , list ) ) if not is_xs_list_like : xs = [ xs ] xs = [ tf . convert_to_tensor ( value = x , name = 'x{}' . format ( i ) ) for i , x in enumerate ( xs ) ] if tf . executing_eagerly ( ) or use_gradient_tape : with tf . GradientTape ( watch_accessed_variables = False ) as tape : for x in xs : tape . watch ( x ) y = f ( * xs ) dydx = tape . gradient ( y , xs ) else : y = f ( * xs ) dydx = tf . gradients ( ys = y , xs = xs ) if not is_xs_list_like : dydx = dydx [ 0 ] return y , dydx\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def mvn ( * args , * * kwargs ) : # Faster than using `tfd.MultivariateNormalDiag`. return tfd . Independent ( tfd . Normal ( * args , * * kwargs ) , reinterpreted_batch_ndims = 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def eight_schools_joint_log_prob ( treatment_effects , treatment_stddevs , avg_effect , avg_stddev , school_effects_standard ) : rv_avg_effect = tfd . Normal ( loc = 0. , scale = 10. ) rv_avg_stddev = tfd . Normal ( loc = 5. , scale = 1. ) rv_school_effects_standard = mvn ( loc = tf . zeros_like ( school_effects_standard ) , scale = tf . ones_like ( school_effects_standard ) ) rv_treatment_effects = mvn ( loc = ( avg_effect + tf . exp ( avg_stddev ) * school_effects_standard ) , scale = treatment_stddevs ) return ( rv_avg_effect . log_prob ( avg_effect ) + rv_avg_stddev . log_prob ( avg_stddev ) + rv_school_effects_standard . log_prob ( school_effects_standard ) + rv_treatment_effects . log_prob ( treatment_effects ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def benchmark_eight_schools_hmc ( num_results = int ( 5e3 ) , num_burnin_steps = int ( 3e3 ) , num_leapfrog_steps = 3 , step_size = 0.4 ) : num_schools = 8 treatment_effects = tf . constant ( [ 28 , 8 , - 3 , 7 , - 1 , 1 , 18 , 12 ] , dtype = np . float32 , name = 'treatment_effects' ) treatment_stddevs = tf . constant ( [ 15 , 10 , 16 , 11 , 9 , 11 , 10 , 18 ] , dtype = np . float32 , name = 'treatment_stddevs' ) def unnormalized_posterior_log_prob ( avg_effect , avg_stddev , school_effects_standard ) : \"\"\"Eight-schools unnormalized log posterior.\"\"\" return eight_schools_joint_log_prob ( treatment_effects , treatment_stddevs , avg_effect , avg_stddev , school_effects_standard ) if tf . executing_eagerly ( ) : sample_chain = tf . function ( tfp . mcmc . sample_chain ) else : sample_chain = tfp . mcmc . sample_chain def computation ( ) : \"\"\"The benchmark computation.\"\"\" _ , kernel_results = sample_chain ( num_results = num_results , num_burnin_steps = num_burnin_steps , current_state = ( tf . zeros ( [ ] , name = 'init_avg_effect' ) , tf . zeros ( [ ] , name = 'init_avg_stddev' ) , tf . ones ( [ num_schools ] , name = 'init_school_effects_standard' ) , ) , kernel = tfp . mcmc . HamiltonianMonteCarlo ( target_log_prob_fn = unnormalized_posterior_log_prob , step_size = step_size , num_leapfrog_steps = num_leapfrog_steps ) ) return kernel_results . is_accepted # Let's force evaluation of graph to ensure build time is not part of our time # trial. is_accepted_tensor = computation ( ) if not tf . executing_eagerly ( ) : session = tf . compat . v1 . Session ( ) session . run ( is_accepted_tensor ) start_time = time . time ( ) if tf . executing_eagerly ( ) : is_accepted = computation ( ) else : is_accepted = session . run ( is_accepted_tensor ) wall_time = time . time ( ) - start_time num_accepted = np . sum ( is_accepted ) acceptance_rate = np . float32 ( num_accepted ) / np . float32 ( num_results ) return dict ( iters = ( num_results + num_burnin_steps ) * num_leapfrog_steps , extras = { 'acceptance_rate' : acceptance_rate } , wall_time = wall_time )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def expand_docstring ( * * kwargs ) : def _fn_wrapped ( fn ) : \"\"\"Original function with modified `__doc__` attribute.\"\"\" doc = inspect . cleandoc ( fn . __doc__ ) for k , v in six . iteritems ( kwargs ) : # Capture each ${k} reference to replace with v. # We wrap the replacement in a function so no backslash escapes # are processed. pattern = r'\\$\\{' + str ( k ) + r'\\}' doc = re . sub ( pattern , lambda match : v , doc ) # pylint: disable=cell-var-from-loop fn . __doc__ = doc return fn return _fn_wrapped\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _simple_name ( distribution ) : simple_name = distribution . name # turn 'scope/x/' into 'x' if simple_name . endswith ( '/' ) : simple_name = simple_name . split ( '/' ) [ - 2 ] # turn 'x_3' into 'x' parts = simple_name . split ( '_' ) if parts [ - 1 ] . isdigit ( ) : simple_name = '_' . join ( parts [ : - 1 ] ) return simple_name\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_custom_rv ( distribution , sample_shape , value , name ) : # Program transformations (e.g., `make_log_joint_fn`) assume that # the traced constructor has `name` and `value` kwargs, enabling # them to override the value of an RV according to its name. # User-defined RVs inherit their name from the provided # distribution; this helper method exposes the name as a dummy kwarg # so that it's visible to program transformations. del name # unused return RandomVariable ( distribution = distribution , sample_shape = sample_shape , value = value )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def as_random_variable ( distribution , sample_shape = ( ) , value = None ) : return _build_custom_rv ( distribution = distribution , sample_shape = sample_shape , value = value , name = _simple_name ( distribution ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_random_variable ( distribution_cls ) : @ interceptable @ functools . wraps ( distribution_cls , assigned = ( '__module__' , '__name__' ) ) @ docstring_util . expand_docstring ( cls = distribution_cls . __name__ , doc = inspect . cleandoc ( distribution_cls . __init__ . __doc__ or '' ) ) def func ( * args , * * kwargs ) : # pylint: disable=g-doc-args \"\"\"Create a random variable for ${cls}. See ${cls} for more details. Returns: RandomVariable. #### Original Docstring for Distribution ${doc} \"\"\" # pylint: enable=g-doc-args sample_shape = kwargs . pop ( 'sample_shape' , ( ) ) value = kwargs . pop ( 'value' , None ) return RandomVariable ( distribution = distribution_cls ( * args , * * kwargs ) , sample_shape = sample_shape , value = value ) return func\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _mode_mean_shape ( self ) : shape = tensorshape_util . concatenate ( self . batch_shape , self . event_shape ) has_static_shape = tensorshape_util . is_fully_defined ( shape ) if not has_static_shape : shape = tf . concat ( [ self . batch_shape_tensor ( ) , self . event_shape_tensor ( ) , ] , 0 ) return shape\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def one_step_predictive ( model , observed_time_series , parameter_samples ) : with tf . compat . v1 . name_scope ( 'one_step_predictive' , values = [ observed_time_series , parameter_samples ] ) : [ observed_time_series , is_missing ] = sts_util . canonicalize_observed_time_series_with_mask ( observed_time_series ) # Run filtering over the training timesteps to extract the # predictive means and variances. num_timesteps = dist_util . prefer_static_value ( tf . shape ( input = observed_time_series ) ) [ - 2 ] lgssm = model . make_state_space_model ( num_timesteps = num_timesteps , param_vals = parameter_samples ) ( _ , _ , _ , _ , _ , observation_means , observation_covs ) = lgssm . forward_filter ( observed_time_series , mask = is_missing ) # Squeeze dims to convert from LGSSM's event shape `[num_timesteps, 1]` # to a scalar time series. return sts_util . mix_over_posterior_draws ( means = observation_means [ ... , 0 ] , variances = observation_covs [ ... , 0 , 0 ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def forecast ( model , observed_time_series , parameter_samples , num_steps_forecast ) : with tf . compat . v1 . name_scope ( 'forecast' , values = [ observed_time_series , parameter_samples , num_steps_forecast ] ) : [ observed_time_series , mask ] = sts_util . canonicalize_observed_time_series_with_mask ( observed_time_series ) # Run filtering over the observed timesteps to extract the # latent state posterior at timestep T+1 (i.e., the final # filtering distribution, pushed through the transition model). # This is the prior for the forecast model (\"today's prior # is yesterday's posterior\"). num_observed_steps = dist_util . prefer_static_value ( tf . shape ( input = observed_time_series ) ) [ - 2 ] observed_data_ssm = model . make_state_space_model ( num_timesteps = num_observed_steps , param_vals = parameter_samples ) ( _ , _ , _ , predictive_means , predictive_covs , _ , _ ) = observed_data_ssm . forward_filter ( observed_time_series , mask = mask ) # Build a batch of state-space models over the forecast period. Because # we'll use MixtureSameFamily to mix over the posterior draws, we need to # do some shenanigans to move the `[num_posterior_draws]` batch dimension # from the leftmost to the rightmost side of the model's batch shape. # TODO(b/120245392): enhance `MixtureSameFamily` to reduce along an # arbitrary axis, and eliminate `move_dimension` calls here. parameter_samples = model . _canonicalize_param_vals_as_map ( parameter_samples ) # pylint: disable=protected-access parameter_samples_with_reordered_batch_dimension = { param . name : dist_util . move_dimension ( parameter_samples [ param . name ] , 0 , - ( 1 + _prefer_static_event_ndims ( param . prior ) ) ) for param in model . parameters } forecast_prior = tfd . MultivariateNormalFullCovariance ( loc = dist_util . move_dimension ( predictive_means [ ... , - 1 , : ] , 0 , - 2 ) , covariance_matrix = dist_util . move_dimension ( predictive_covs [ ... , - 1 , : , : ] , 0 , - 3 ) ) # Ugly hack: because we moved `num_posterior_draws` to the trailing (rather # than leading) dimension of parameters, the parameter batch shapes no # longer broadcast against the `constant_offset` attribute used in `sts.Sum` # models. We fix this by manually adding an extra broadcasting dim to # `constant_offset` if present. # The root cause of this hack is that we mucked with param dimensions above # and are now passing params that are 'invalid' in the sense that they don't # match the shapes of the model's param priors. The fix (as above) will be # to update MixtureSameFamily so we can avoid changing param dimensions # altogether. # TODO(b/120245392): enhance `MixtureSameFamily` to reduce along an # arbitrary axis, and eliminate this hack. kwargs = { } if hasattr ( model , 'constant_offset' ) : kwargs [ 'constant_offset' ] = tf . convert_to_tensor ( value = model . constant_offset , dtype = forecast_prior . dtype ) [ ... , tf . newaxis ] # We assume that any STS model that has a `constant_offset` attribute # will allow it to be overridden as a kwarg. This is currently just # `sts.Sum`. # TODO(b/120245392): when kwargs hack is removed, switch back to calling # the public version of `_make_state_space_model`. forecast_ssm = model . _make_state_space_model ( # pylint: disable=protected-access num_timesteps = num_steps_forecast , param_map = parameter_samples_with_reordered_batch_dimension , initial_state_prior = forecast_prior , initial_step = num_observed_steps , * * kwargs ) num_posterior_draws = dist_util . prefer_static_value ( forecast_ssm . batch_shape_tensor ( ) ) [ - 1 ] return tfd . MixtureSameFamily ( mixture_distribution = tfd . Categorical ( logits = tf . zeros ( [ num_posterior_draws ] , dtype = forecast_ssm . dtype ) ) , components_distribution = forecast_ssm )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _max_mask_non_finite ( x , axis = - 1 , keepdims = False , mask = 0 ) : m = np . max ( x , axis = _astuple ( axis ) , keepdims = keepdims ) needs_masking = ~ np . isfinite ( m ) if needs_masking . ndim > 0 : m [ needs_masking ] = mask elif needs_masking : m = mask return m\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _reduce_logsumexp ( input_tensor , axis = None , keepdims = False , name = None ) : # pylint: disable=unused-argument try : return scipy_special . logsumexp ( input_tensor , axis = _astuple ( axis ) , keepdims = keepdims ) except NotImplementedError : # We offer a non SP version just in case SP isn't installed and this # because logsumexp is often used. m = _max_mask_non_finite ( input_tensor , axis = axis , keepdims = True ) y = input_tensor - m y = np . exp ( y , out = y ) return m + np . log ( np . sum ( y , axis = _astuple ( axis ) , keepdims = keepdims ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def assert_finite ( x , data = None , summarize = None , message = None , name = None ) : with tf . compat . v2 . name_scope ( name or 'assert_finite' ) : x_ = tf . get_static_value ( x ) if x_ is not None : if ~ np . all ( np . isfinite ( x_ ) ) : raise ValueError ( message ) return x assertion = tf . compat . v1 . assert_equal ( tf . math . is_finite ( x ) , tf . ones_like ( x , tf . bool ) , data = data , summarize = summarize , message = message ) with tf . control_dependencies ( [ assertion ] ) : return tf . identity ( x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def assert_rank_at_most ( x , rank , data = None , summarize = None , message = None , name = None ) : with tf . compat . v2 . name_scope ( name or 'assert_rank_at_most' ) : return tf . compat . v1 . assert_less_equal ( tf . rank ( x ) , rank , data = data , summarize = summarize , message = message )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _event_size ( event_shape , name = None ) : with tf . compat . v1 . name_scope ( name , 'event_size' , [ event_shape ] ) : event_shape = tf . convert_to_tensor ( value = event_shape , dtype = tf . int32 , name = 'event_shape' ) event_shape_const = tf . get_static_value ( event_shape ) if event_shape_const is not None : return np . prod ( event_shape_const ) else : return tf . reduce_prod ( input_tensor = event_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _eval_all_one_hot ( fn , dist , name = None ) : with tf . compat . v1 . name_scope ( name , 'eval_all_one_hot' ) : event_size = dist . event_shape_tensor ( ) [ - 1 ] batch_ndims = tf . size ( input = dist . batch_shape_tensor ( ) ) # Reshape `eye(d)` to: `[d] + [1]*batch_ndims + [d]`. x = tf . reshape ( tf . eye ( event_size , dtype = dist . dtype ) , shape = tf . pad ( tensor = tf . ones ( batch_ndims , tf . int32 ) , paddings = [ [ 1 , 1 ] ] , constant_values = event_size ) ) # Compute `fn(x)` then cyclically left-transpose one dim. perm = tf . pad ( tensor = tf . range ( 1 , batch_ndims + 1 ) , paddings = [ [ 0 , 1 ] ] ) return tf . transpose ( a = fn ( dist , x ) , perm = perm )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_kl_divergence_fn ( distribution_b , use_exact_kl = False , test_points_reduce_axis = ( ) , # `None` == \"all\"; () == \"none\". test_points_fn = tf . convert_to_tensor , weight = None ) : if use_exact_kl is None : kl_divergence_fn = tfd . kl_divergence else : # Closure over: test_points_fn, test_points_reduce_axis. def kl_divergence_fn ( distribution_a , distribution_b ) : z = test_points_fn ( distribution_a ) return tf . reduce_mean ( input_tensor = distribution_a . log_prob ( z ) - distribution_b . log_prob ( z ) , axis = test_points_reduce_axis ) # Closure over: distribution_b, kl_divergence_fn, weight. def _fn ( distribution_a ) : \"\"\"Closure that computes KLDiv as a function of `a` as in `KL[a, b]`.\"\"\" with tf . compat . v1 . name_scope ( 'kldivergence_loss' ) : # TODO(b/119756336): Due to eager/graph Jacobian graph caching bug # we add here the capability for deferred construction of the prior. # This capability can probably be removed once b/119756336 is resolved. distribution_b_ = ( distribution_b ( ) if callable ( distribution_b ) else distribution_b ) kl = kl_divergence_fn ( distribution_a , distribution_b_ ) if weight is not None : kl = tf . cast ( weight , dtype = kl . dtype ) * kl # Losses appended with the model.add_loss and are expected to be a single # scalar, unlike model.loss, which is expected to be the loss per sample. # Therefore, we reduce over all dimensions, regardless of the shape. # We take the sum because (apparently) Keras will add this to the *post* # `reduce_sum` (total) loss. # TODO(b/126259176): Add end-to-end Keras/TFP test to ensure the API's # align, particularly wrt how losses are aggregated (across batch # members). return tf . reduce_sum ( input_tensor = kl , name = 'batch_total_kl_divergence' ) return _fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_convert_to_tensor_fn ( identifier ) : if identifier is None : return None if isinstance ( identifier , six . string_types ) : identifier = str ( identifier ) return _deserialize ( identifier ) if isinstance ( identifier , dict ) : return _deserialize ( identifier ) if isinstance ( identifier , property ) : identifier = identifier . fget if callable ( identifier ) : return identifier raise ValueError ( 'Could not interpret ' 'convert-to-tensor function identifier:' , identifier )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_config ( self ) : config = { 'make_distribution_fn' : _serialize_function ( self . _make_distribution_fn ) , 'convert_to_tensor_fn' : _serialize ( self . _convert_to_tensor_fn ) , } base_config = super ( DistributionLambda , self ) . get_config ( ) return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def new ( params , event_size , validate_args = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'MultivariateNormalTriL' , [ params , event_size ] ) : params = tf . convert_to_tensor ( value = params , name = 'params' ) scale_tril = tfb . ScaleTriL ( diag_shift = np . array ( 1e-5 , params . dtype . as_numpy_dtype ( ) ) , validate_args = validate_args ) return tfd . MultivariateNormalTriL ( loc = params [ ... , : event_size ] , scale_tril = scale_tril ( params [ ... , event_size : ] ) , validate_args = validate_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def params_size ( event_size , name = None ) : with tf . compat . v1 . name_scope ( name , 'MultivariateNormalTriL_params_size' , [ event_size ] ) : return event_size + event_size * ( event_size + 1 ) // 2\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def new ( params , event_size , dtype = None , validate_args = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'OneHotCategorical' , [ params , event_size ] ) : return tfd . OneHotCategorical ( logits = params , dtype = dtype or params . dtype . base_dtype , validate_args = validate_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def new ( params , event_size , num_components , dtype = None , validate_args = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'CategoricalMixtureOfOneHotCategorical' , [ params , event_size , num_components ] ) : dist = MixtureSameFamily . new ( params , num_components , OneHotCategorical ( event_size , validate_args = False , # So we can eval on simplex interior. name = name ) , validate_args = validate_args , name = name ) # pylint: disable=protected-access dist . _mean = functools . partial ( _eval_all_one_hot , tfd . Distribution . prob , dist ) dist . log_mean = functools . partial ( _eval_all_one_hot , tfd . Distribution . log_prob , dist ) # pylint: enable=protected-access return dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def params_size ( event_size , num_components , name = None ) : with tf . compat . v1 . name_scope ( name , 'CategoricalMixtureOfOneHotCategorical_params_size' , [ event_size , num_components ] ) : return MixtureSameFamily . params_size ( num_components , OneHotCategorical . params_size ( event_size , name = name ) , name = name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def new ( params , event_shape = ( ) , dtype = None , validate_args = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'IndependentBernoulli' , [ params , event_shape ] ) : params = tf . convert_to_tensor ( value = params , name = 'params' ) event_shape = dist_util . expand_to_vector ( tf . convert_to_tensor ( value = event_shape , name = 'event_shape' , dtype_hint = tf . int32 ) , tensor_name = 'event_shape' ) new_shape = tf . concat ( [ tf . shape ( input = params ) [ : - 1 ] , event_shape , ] , axis = 0 ) dist = tfd . Independent ( tfd . Bernoulli ( logits = tf . reshape ( params , new_shape ) , dtype = dtype or params . dtype . base_dtype , validate_args = validate_args ) , reinterpreted_batch_ndims = tf . size ( input = event_shape ) , validate_args = validate_args ) dist . _logits = dist . distribution . _logits # pylint: disable=protected-access dist . _probs = dist . distribution . _probs # pylint: disable=protected-access dist . logits = tfd . Bernoulli . logits dist . probs = tfd . Bernoulli . probs return dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_config ( self ) : config = { 'event_shape' : self . _event_shape , 'convert_to_tensor_fn' : _serialize ( self . _convert_to_tensor_fn ) , 'sample_dtype' : self . _sample_dtype , 'validate_args' : self . _validate_args } base_config = super ( IndependentBernoulli , self ) . get_config ( ) return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def new ( params , event_shape = ( ) , validate_args = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'IndependentLogistic' , [ params , event_shape ] ) : params = tf . convert_to_tensor ( value = params , name = 'params' ) event_shape = dist_util . expand_to_vector ( tf . convert_to_tensor ( value = event_shape , name = 'event_shape' , dtype_hint = tf . int32 ) , tensor_name = 'event_shape' ) output_shape = tf . concat ( [ tf . shape ( input = params ) [ : - 1 ] , event_shape , ] , axis = 0 ) loc_params , scale_params = tf . split ( params , 2 , axis = - 1 ) return tfd . Independent ( tfd . Logistic ( loc = tf . reshape ( loc_params , output_shape ) , scale = tf . math . softplus ( tf . reshape ( scale_params , output_shape ) ) , validate_args = validate_args ) , reinterpreted_batch_ndims = tf . size ( input = event_shape ) , validate_args = validate_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def params_size ( event_shape = ( ) , name = None ) : with tf . compat . v1 . name_scope ( name , 'IndependentNormal_params_size' , [ event_shape ] ) : event_shape = tf . convert_to_tensor ( value = event_shape , name = 'event_shape' , dtype_hint = tf . int32 ) return 2 * _event_size ( event_shape , name = name or 'IndependentNormal_params_size' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def new ( params , event_shape = ( ) , validate_args = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'IndependentPoisson' , [ params , event_shape ] ) : params = tf . convert_to_tensor ( value = params , name = 'params' ) event_shape = dist_util . expand_to_vector ( tf . convert_to_tensor ( value = event_shape , name = 'event_shape' , dtype_hint = tf . int32 ) , tensor_name = 'event_shape' ) output_shape = tf . concat ( [ tf . shape ( input = params ) [ : - 1 ] , event_shape , ] , axis = 0 ) return tfd . Independent ( tfd . Poisson ( log_rate = tf . reshape ( params , output_shape ) , validate_args = validate_args ) , reinterpreted_batch_ndims = tf . size ( input = event_shape ) , validate_args = validate_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def new ( params , num_components , component_layer , validate_args = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'MixtureSameFamily' , [ params , num_components , component_layer ] ) : params = tf . convert_to_tensor ( value = params , name = 'params' ) num_components = tf . convert_to_tensor ( value = num_components , name = 'num_components' , dtype_hint = tf . int32 ) components_dist = component_layer ( tf . reshape ( params [ ... , num_components : ] , tf . concat ( [ tf . shape ( input = params ) [ : - 1 ] , [ num_components , - 1 ] ] , axis = 0 ) ) ) mixture_dist = tfd . Categorical ( logits = params [ ... , : num_components ] ) return tfd . MixtureSameFamily ( mixture_dist , components_dist , # TODO(b/120154797): Change following to `validate_args=True` after # fixing: \"ValueError: `mixture_distribution` must have scalar # `event_dim`s.\" assertion in MixtureSameFamily. validate_args = False )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def params_size ( num_components , component_params_size , name = None ) : with tf . compat . v1 . name_scope ( name , 'MixtureSameFamily_params_size' , [ num_components , component_params_size ] ) : num_components = tf . convert_to_tensor ( value = num_components , name = 'num_components' , dtype_hint = tf . int32 ) component_params_size = tf . convert_to_tensor ( value = component_params_size , name = 'component_params_size' ) num_components = dist_util . prefer_static_value ( num_components ) component_params_size = dist_util . prefer_static_value ( component_params_size ) return num_components + num_components * component_params_size\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def params_size ( num_components , event_shape = ( ) , name = None ) : return MixtureSameFamily . params_size ( num_components , IndependentNormal . params_size ( event_shape , name = name ) , name = name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def new ( params , num_components , event_shape = ( ) , validate_args = False , name = None ) : return MixtureSameFamily . new ( params , num_components , IndependentLogistic ( event_shape , validate_args = validate_args , name = name ) , validate_args = validate_args , name = name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def params_size ( num_components , event_shape = ( ) , name = None ) : return MixtureSameFamily . params_size ( num_components , IndependentLogistic . params_size ( event_shape , name = name ) , name = name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_next_interceptor ( ) : try : interceptor = _interceptor_stack . stack . pop ( ) yield interceptor finally : _interceptor_stack . stack . append ( interceptor )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def interceptable ( func ) : @ functools . wraps ( func ) def func_wrapped ( * args , * * kwargs ) : with get_next_interceptor ( ) as interceptor : return interceptor ( func , * args , * * kwargs ) return func_wrapped\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def tape ( ) : tape_data = collections . OrderedDict ( { } ) def record ( f , * args , * * kwargs ) : \"\"\"Records execution to a tape.\"\"\" name = kwargs . get ( \"name\" ) output = interceptable ( f ) ( * args , * * kwargs ) if name : tape_data [ name ] = output return output with interception ( record ) : yield tape_data\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def toy_logistic_data ( num_examples , input_size = 2 , weights_prior_stddev = 5.0 ) : random_weights = weights_prior_stddev * np . random . randn ( input_size ) random_bias = np . random . randn ( ) design_matrix = np . random . rand ( num_examples , input_size ) * 2 - 1 logits = np . reshape ( np . dot ( design_matrix , random_weights ) + random_bias , ( - 1 , 1 ) ) p_labels = 1. / ( 1 + np . exp ( - logits ) ) labels = np . int32 ( p_labels > np . random . rand ( num_examples , 1 ) ) return random_weights , random_bias , np . float32 ( design_matrix ) , labels\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def visualize_decision ( features , labels , true_w_b , candidate_w_bs , fname ) : fig = figure . Figure ( figsize = ( 6 , 6 ) ) canvas = backend_agg . FigureCanvasAgg ( fig ) ax = fig . add_subplot ( 1 , 1 , 1 ) ax . scatter ( features [ : , 0 ] , features [ : , 1 ] , c = np . float32 ( labels [ : , 0 ] ) , cmap = cm . get_cmap ( \"binary\" ) , edgecolors = \"k\" ) def plot_weights ( w , b , * * kwargs ) : w1 , w2 = w x1s = np . linspace ( - 1 , 1 , 100 ) x2s = - ( w1 * x1s + b ) / w2 ax . plot ( x1s , x2s , * * kwargs ) for w , b in candidate_w_bs : plot_weights ( w , b , alpha = 1. / np . sqrt ( len ( candidate_w_bs ) ) , lw = 1 , color = \"blue\" ) if true_w_b is not None : plot_weights ( * true_w_b , lw = 4 , color = \"green\" , label = \"true separator\" ) ax . set_xlim ( [ - 1.5 , 1.5 ] ) ax . set_ylim ( [ - 1.5 , 1.5 ] ) ax . legend ( ) canvas . print_figure ( fname , format = \"png\" ) print ( \"saved {}\" . format ( fname ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_input_pipeline ( x , y , batch_size ) : training_dataset = tf . data . Dataset . from_tensor_slices ( ( x , y ) ) training_batches = training_dataset . repeat ( ) . batch ( batch_size ) training_iterator = tf . compat . v1 . data . make_one_shot_iterator ( training_batches ) batch_features , batch_labels = training_iterator . get_next ( ) return batch_features , batch_labels\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_check_valid_map_values ( map_values , validate_args ) : assertions = [ ] message = 'Rank of map_values must be 1.' if tensorshape_util . rank ( map_values . shape ) is not None : if tensorshape_util . rank ( map_values . shape ) != 1 : raise ValueError ( message ) elif validate_args : assertions . append ( assert_util . assert_rank ( map_values , 1 , message = message ) ) message = 'Size of map_values must be greater than 0.' if tensorshape_util . num_elements ( map_values . shape ) is not None : if tensorshape_util . num_elements ( map_values . shape ) == 0 : raise ValueError ( message ) elif validate_args : assertions . append ( assert_util . assert_greater ( tf . size ( input = map_values ) , 0 , message = message ) ) if validate_args : assertions . append ( assert_util . assert_equal ( tf . math . is_strictly_increasing ( map_values ) , True , message = 'map_values is not strictly increasing.' ) ) return assertions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def trace ( state : State , fn : TransitionOperator , num_steps : IntTensor , trace_fn : Callable [ [ State , TensorNest ] , TensorNest ] ) -> Tuple [ State , TensorNest ] : def fn_wrapper ( args , _ ) : return tf . nest . map_structure ( tf . convert_to_tensor , call_fn ( fn , args [ 0 ] ) ) def trace_fn_wrapper ( args ) : return tf . nest . map_structure ( tf . convert_to_tensor , call_fn ( trace_fn , args ) ) state = call_fn ( fn , state ) first_trace = trace_fn_wrapper ( state ) state , full_trace = mcmc_util . trace_scan ( fn_wrapper , state , tf . ones ( num_steps - 1 ) , trace_fn = trace_fn_wrapper ) prepend = lambda x , y : tf . concat ( # pylint: disable=g-long-lambda [ tf . convert_to_tensor ( value = x ) [ tf . newaxis ] , y ] , 0 ) return state , tf . nest . map_structure ( prepend , first_trace , full_trace )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call_fn ( fn : TransitionOperator , args : Union [ Tuple [ Any ] , Any ] ) -> Any : if isinstance ( args , ( list , tuple ) ) and not mcmc_util . is_namedtuple_like ( args ) : args = args # type: Tuple[Any] return fn ( * args ) else : return fn ( args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call_and_grads ( fn : TransitionOperator , args : Union [ Tuple [ Any ] , Any ] ) -> Tuple [ tf . Tensor , TensorNest , TensorNest ] : with tf . GradientTape ( ) as tape : tape . watch ( args ) ret , extra = call_fn ( fn , args ) grads = tape . gradient ( ret , args ) return ret , extra , grads\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def maybe_broadcast_structure ( from_structure : Any , to_structure : Any ) -> Any : flat_from = tf . nest . flatten ( from_structure ) flat_to = tf . nest . flatten ( to_structure ) if len ( flat_from ) == 1 : flat_from *= len ( flat_to ) return tf . nest . pack_sequence_as ( to_structure , flat_from )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def transform_log_prob_fn ( log_prob_fn : PotentialFn , bijector : BijectorNest , init_state : State = None ) -> Union [ PotentialFn , Tuple [ PotentialFn , State ] ] : def wrapper ( * args ) : \"\"\"Transformed wrapper.\"\"\" bijector_ = bijector args = tf . nest . map_structure ( lambda x : 0. + x , args ) if len ( args ) == 1 : args = args [ 0 ] elif isinstance ( bijector_ , list ) : bijector_ = tuple ( bijector_ ) original_space_args = tf . nest . map_structure ( lambda b , x : b . forward ( x ) , bijector_ , args ) original_space_args = original_space_args # type: Tuple[Any] original_space_log_prob , extra = call_fn ( log_prob_fn , original_space_args ) event_ndims = tf . nest . map_structure ( lambda x : tf . rank ( x ) - tf . rank ( original_space_log_prob ) , args ) return original_space_log_prob + sum ( tf . nest . flatten ( tf . nest . map_structure ( lambda b , x , e : b . forward_log_det_jacobian ( x , event_ndims = e ) , bijector_ , args , event_ndims ) ) ) , [ original_space_args , extra ] if init_state is None : return wrapper else : return wrapper , tf . nest . map_structure ( lambda b , s : b . inverse ( s ) , bijector , init_state )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def leapfrog_step ( leapfrog_step_state : LeapFrogStepState , step_size : FloatTensor , target_log_prob_fn : PotentialFn , kinetic_energy_fn : PotentialFn ) -> Tuple [ LeapFrogStepState , LeapFrogStepExtras ] : state = leapfrog_step_state . state state_grads = leapfrog_step_state . state_grads momentum = leapfrog_step_state . momentum step_size = maybe_broadcast_structure ( step_size , state ) state = tf . nest . map_structure ( tf . convert_to_tensor , state ) momentum = tf . nest . map_structure ( tf . convert_to_tensor , momentum ) state = tf . nest . map_structure ( tf . convert_to_tensor , state ) if state_grads is None : _ , _ , state_grads = call_and_grads ( target_log_prob_fn , state ) else : state_grads = tf . nest . map_structure ( tf . convert_to_tensor , state_grads ) momentum = tf . nest . map_structure ( lambda m , sg , s : m + 0.5 * sg * s , momentum , state_grads , step_size ) kinetic_energy , kinetic_energy_extra , momentum_grads = call_and_grads ( kinetic_energy_fn , momentum ) state = tf . nest . map_structure ( lambda x , mg , s : x + mg * s , state , momentum_grads , step_size ) target_log_prob , state_extra , state_grads = call_and_grads ( target_log_prob_fn , state ) momentum = tf . nest . map_structure ( lambda m , sg , s : m + 0.5 * sg * s , momentum , state_grads , step_size ) return LeapFrogStepState ( state , state_grads , momentum ) , LeapFrogStepExtras ( target_log_prob , state_extra , kinetic_energy , kinetic_energy_extra )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def metropolis_hastings_step ( current_state : State , proposed_state : State , energy_change : FloatTensor , seed = None ) -> Tuple [ State , tf . Tensor , tf . Tensor ] : flat_current = tf . nest . flatten ( current_state ) flat_proposed = nest . flatten_up_to ( current_state , proposed_state ) # Impute the None's in the current state. flat_current = [ p if c is None else c for p , c in zip ( flat_proposed , flat_current ) ] current_state = tf . nest . pack_sequence_as ( current_state , flat_current ) current_state = tf . nest . map_structure ( tf . convert_to_tensor , current_state ) proposed_state = tf . nest . map_structure ( tf . convert_to_tensor , proposed_state ) energy_change = tf . convert_to_tensor ( value = energy_change ) log_accept_ratio = - energy_change log_uniform = tf . math . log ( tf . random . uniform ( shape = tf . shape ( input = log_accept_ratio ) , dtype = log_accept_ratio . dtype . base_dtype , seed = seed ) ) is_accepted = log_uniform < log_accept_ratio next_state = mcmc_util . choose ( is_accepted , proposed_state , current_state , name = 'choose_next_state' ) return next_state , is_accepted , log_uniform\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def hamiltonian_monte_carlo ( hmc_state : HamiltonianMonteCarloState , target_log_prob_fn : PotentialFn , step_size : Any , num_leapfrog_steps : IntTensor , momentum : State = None , kinetic_energy_fn : PotentialFn = None , momentum_sample_fn : MomentumSampleFn = None , leapfrog_trace_fn : Callable [ [ LeapFrogStepState , LeapFrogStepExtras ] , TensorNest ] = lambda * args : ( ) , seed = None , ) -> Tuple [ HamiltonianMonteCarloState , HamiltonianMonteCarloExtra ] : state = hmc_state . state state_grads = hmc_state . state_grads target_log_prob = hmc_state . target_log_prob state_extra = hmc_state . state_extra if kinetic_energy_fn is None : # pylint: disable=function-redefined def kinetic_energy_fn ( * momentum ) : return tf . add_n ( [ tf . reduce_sum ( input_tensor = tf . square ( x ) , axis = - 1 ) / 2. for x in tf . nest . flatten ( momentum ) ] ) , ( ) if momentum_sample_fn is None : # pylint: disable=function-redefined def momentum_sample_fn ( * momentum ) : ret = tf . nest . map_structure ( lambda x : tf . random . normal ( tf . shape ( input = x ) , dtype = x . dtype ) , momentum ) if len ( ret ) == 1 : return ret [ 0 ] else : return ret if momentum is None : momentum = call_fn ( momentum_sample_fn , tf . nest . map_structure ( tf . zeros_like , state ) ) if target_log_prob is None : target_log_prob , state_extra , state_grads = call_and_grads ( target_log_prob_fn , state ) kinetic_energy , _ = call_fn ( kinetic_energy_fn , momentum ) current_energy = - target_log_prob + kinetic_energy current_state = HamiltonianMonteCarloState ( state = state , state_grads = state_grads , state_extra = state_extra , target_log_prob = target_log_prob ) def leapfrog_wrapper ( leapfrog_state , target_log_prob , state_extra ) : \"\"\"Leapfrog wrapper that tracks extra state.\"\"\" del target_log_prob del state_extra leapfrog_state , leapfrog_extra = leapfrog_step ( leapfrog_state , step_size = step_size , target_log_prob_fn = target_log_prob_fn , kinetic_energy_fn = kinetic_energy_fn ) return [ leapfrog_state , leapfrog_extra . target_log_prob , leapfrog_extra . state_extra ] , leapfrog_extra def leapfrog_trace_wrapper_fn ( args , leapfrog_extra ) : return leapfrog_trace_fn ( args [ 0 ] , leapfrog_extra ) leapfrog_wrapper_state = ( LeapFrogStepState ( state , state_grads , momentum ) , target_log_prob , state_extra ) [ [ leapfrog_state , target_log_prob , state_extra ] , _ ] , leapfrog_trace = trace ( leapfrog_wrapper_state , leapfrog_wrapper , num_leapfrog_steps , trace_fn = leapfrog_trace_wrapper_fn ) kinetic_energy , _ = call_fn ( kinetic_energy_fn , leapfrog_state . momentum ) proposed_energy = - target_log_prob + kinetic_energy proposed_state = HamiltonianMonteCarloState ( state = leapfrog_state . state , state_grads = leapfrog_state . state_grads , target_log_prob = target_log_prob , state_extra = state_extra ) energy_change = proposed_energy - current_energy hmc_state , is_accepted , _ = metropolis_hastings_step ( current_state , proposed_state , energy_change , seed = seed ) hmc_state = hmc_state # type: HamiltonianMonteCarloState return hmc_state , HamiltonianMonteCarloExtra ( is_accepted = is_accepted , proposed_hmc_state = proposed_state , log_accept_ratio = - energy_change , leapfrog_trace = leapfrog_trace )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sign_adaptation ( control : FloatNest , output : FloatTensor , set_point : FloatTensor , adaptation_rate : FloatTensor = 0.01 ) -> FloatNest : def _get_new_control ( control , output , set_point ) : new_control = mcmc_util . choose ( output > set_point , control * ( 1. + adaptation_rate ) , control / ( 1. + adaptation_rate ) ) return new_control output = maybe_broadcast_structure ( output , control ) set_point = maybe_broadcast_structure ( set_point , control ) return tf . nest . map_structure ( _get_new_control , control , output , set_point )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def compute_output_shape ( self , input_shape ) : input_shape = tf . TensorShape ( input_shape ) . as_list ( ) if self . data_format == 'channels_last' : space = input_shape [ 1 : - 1 ] new_space = [ ] for i in range ( len ( space ) ) : new_dim = tf_layers_util . conv_output_length ( space [ i ] , self . kernel_size [ i ] , padding = self . padding , stride = self . strides [ i ] , dilation = self . dilation_rate [ i ] ) new_space . append ( new_dim ) return tf . TensorShape ( [ input_shape [ 0 ] ] + new_space + [ self . filters ] ) else : space = input_shape [ 2 : ] new_space = [ ] for i in range ( len ( space ) ) : new_dim = tf_layers_util . conv_output_length ( space [ i ] , self . kernel_size [ i ] , padding = self . padding , stride = self . strides [ i ] , dilation = self . dilation_rate [ i ] ) new_space . append ( new_dim ) return tf . TensorShape ( [ input_shape [ 0 ] , self . filters ] + new_space )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_config ( self ) : config = { 'filters' : self . filters , 'kernel_size' : self . kernel_size , 'strides' : self . strides , 'padding' : self . padding , 'data_format' : self . data_format , 'dilation_rate' : self . dilation_rate , 'activation' : ( tf . keras . activations . serialize ( self . activation ) if self . activation else None ) , 'activity_regularizer' : tf . keras . initializers . serialize ( self . activity_regularizer ) , } function_keys = [ 'kernel_posterior_fn' , 'kernel_posterior_tensor_fn' , 'kernel_prior_fn' , 'kernel_divergence_fn' , 'bias_posterior_fn' , 'bias_posterior_tensor_fn' , 'bias_prior_fn' , 'bias_divergence_fn' , ] for function_key in function_keys : function = getattr ( self , function_key ) if function is None : function_name = None function_type = None else : function_name , function_type = tfp_layers_util . serialize_function ( function ) config [ function_key ] = function_name config [ function_key + '_type' ] = function_type base_config = super ( _ConvVariational , self ) . get_config ( ) return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def from_config ( cls , config ) : config = config . copy ( ) function_keys = [ 'kernel_posterior_fn' , 'kernel_posterior_tensor_fn' , 'kernel_prior_fn' , 'kernel_divergence_fn' , 'bias_posterior_fn' , 'bias_posterior_tensor_fn' , 'bias_prior_fn' , 'bias_divergence_fn' , ] for function_key in function_keys : serial = config [ function_key ] function_type = config . pop ( function_key + '_type' ) if serial is not None : config [ function_key ] = tfp_layers_util . deserialize_function ( serial , function_type = function_type ) return cls ( * * config )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_config ( self ) : config = { 'seed' : self . seed , } base_config = super ( _ConvFlipout , self ) . get_config ( ) return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _as_tensor ( x , name , dtype ) : return None if x is None else tf . convert_to_tensor ( value = x , name = name , dtype = dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _create_scale_operator ( self , identity_multiplier , diag , tril , perturb_diag , perturb_factor , shift , validate_args , dtype ) : identity_multiplier = _as_tensor ( identity_multiplier , \"identity_multiplier\" , dtype ) diag = _as_tensor ( diag , \"diag\" , dtype ) tril = _as_tensor ( tril , \"tril\" , dtype ) perturb_diag = _as_tensor ( perturb_diag , \"perturb_diag\" , dtype ) perturb_factor = _as_tensor ( perturb_factor , \"perturb_factor\" , dtype ) # If possible, use the low rank update to infer the shape of # the identity matrix, when scale represents a scaled identity matrix # with a low rank update. shape_hint = None if perturb_factor is not None : shape_hint = distribution_util . dimension_size ( perturb_factor , axis = - 2 ) if self . _is_only_identity_multiplier : if validate_args : return distribution_util . with_dependencies ( [ assert_util . assert_none_equal ( identity_multiplier , tf . zeros ( [ ] , identity_multiplier . dtype ) , [ \"identity_multiplier should be non-zero.\" ] ) ] , identity_multiplier ) return identity_multiplier scale = distribution_util . make_tril_scale ( loc = shift , scale_tril = tril , scale_diag = diag , scale_identity_multiplier = identity_multiplier , validate_args = validate_args , assert_positive = False , shape_hint = shape_hint ) if perturb_factor is not None : return tf . linalg . LinearOperatorLowRankUpdate ( scale , u = perturb_factor , diag_update = perturb_diag , is_diag_update_positive = perturb_diag is None , is_non_singular = True , # Implied by is_positive_definite=True. is_self_adjoint = True , is_positive_definite = True , is_square = True ) return scale\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def random_walk_normal_fn ( scale = 1. , name = None ) : def _fn ( state_parts , seed ) : \"\"\"Adds a normal perturbation to the input state. Args: state_parts: A list of `Tensor`s of any shape and real dtype representing the state parts of the `current_state` of the Markov chain. seed: `int` or None. The random seed for this `Op`. If `None`, no seed is applied. Default value: `None`. Returns: perturbed_state_parts: A Python `list` of The `Tensor`s. Has the same shape and type as the `state_parts`. Raises: ValueError: if `scale` does not broadcast with `state_parts`. \"\"\" with tf . compat . v1 . name_scope ( name , 'random_walk_normal_fn' , values = [ state_parts , scale , seed ] ) : scales = scale if mcmc_util . is_list_like ( scale ) else [ scale ] if len ( scales ) == 1 : scales *= len ( state_parts ) if len ( state_parts ) != len ( scales ) : raise ValueError ( '`scale` must broadcast with `state_parts`.' ) seed_stream = distributions . SeedStream ( seed , salt = 'RandomWalkNormalFn' ) next_state_parts = [ tf . random . normal ( mean = state_part , stddev = scale_part , shape = tf . shape ( input = state_part ) , dtype = state_part . dtype . base_dtype , seed = seed_stream ( ) ) for scale_part , state_part in zip ( scales , state_parts ) ] return next_state_parts return _fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def random_walk_uniform_fn ( scale = 1. , name = None ) : def _fn ( state_parts , seed ) : \"\"\"Adds a uniform perturbation to the input state. Args: state_parts: A list of `Tensor`s of any shape and real dtype representing the state parts of the `current_state` of the Markov chain. seed: `int` or None. The random seed for this `Op`. If `None`, no seed is applied. Default value: `None`. Returns: perturbed_state_parts: A Python `list` of The `Tensor`s. Has the same shape and type as the `state_parts`. Raises: ValueError: if `scale` does not broadcast with `state_parts`. \"\"\" with tf . compat . v1 . name_scope ( name , 'random_walk_uniform_fn' , values = [ state_parts , scale , seed ] ) : scales = scale if mcmc_util . is_list_like ( scale ) else [ scale ] if len ( scales ) == 1 : scales *= len ( state_parts ) if len ( state_parts ) != len ( scales ) : raise ValueError ( '`scale` must broadcast with `state_parts`.' ) seed_stream = distributions . SeedStream ( seed , salt = 'RandomWalkUniformFn' ) next_state_parts = [ tf . random . uniform ( minval = state_part - scale_part , maxval = state_part + scale_part , shape = tf . shape ( input = state_part ) , dtype = state_part . dtype . base_dtype , seed = seed_stream ( ) ) for scale_part , state_part in zip ( scales , state_parts ) ] return next_state_parts return _fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_independent ( a , b , name = \"kl_independent\" ) : p = a . distribution q = b . distribution # The KL between any two (non)-batched distributions is a scalar. # Given that the KL between two factored distributions is the sum, i.e. # KL(p1(x)p2(y) || q1(x)q2(y)) = KL(p1 || q1) + KL(q1 || q2), we compute # KL(p || q) and do a `reduce_sum` on the reinterpreted batch dimensions. if ( tensorshape_util . is_fully_defined ( a . event_shape ) and tensorshape_util . is_fully_defined ( b . event_shape ) ) : if a . event_shape == b . event_shape : if p . event_shape == q . event_shape : num_reduce_dims = ( tensorshape_util . rank ( a . event_shape ) - tensorshape_util . rank ( p . event_shape ) ) reduce_dims = [ - i - 1 for i in range ( 0 , num_reduce_dims ) ] return tf . reduce_sum ( input_tensor = kullback_leibler . kl_divergence ( p , q , name = name ) , axis = reduce_dims ) else : raise NotImplementedError ( \"KL between Independents with different \" \"event shapes not supported.\" ) else : raise ValueError ( \"Event shapes do not match.\" ) else : with tf . control_dependencies ( [ assert_util . assert_equal ( a . event_shape_tensor ( ) , b . event_shape_tensor ( ) ) , assert_util . assert_equal ( p . event_shape_tensor ( ) , q . event_shape_tensor ( ) ) ] ) : num_reduce_dims = ( prefer_static . rank_from_shape ( a . event_shape_tensor , a . event_shape ) - prefer_static . rank_from_shape ( p . event_shape_tensor , a . event_shape ) ) reduce_dims = prefer_static . range ( - num_reduce_dims - 1 , - 1 , 1 ) return tf . reduce_sum ( input_tensor = kullback_leibler . kl_divergence ( p , q , name = name ) , axis = reduce_dims )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_default_reinterpreted_batch_ndims ( self , distribution ) : ndims = prefer_static . rank_from_shape ( distribution . batch_shape_tensor , distribution . batch_shape ) return prefer_static . maximum ( 0 , ndims - 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _expand_to_event_rank ( self , x ) : expanded_x = x for _ in range ( tensorshape_util . rank ( self . event_shape ) ) : expanded_x = tf . expand_dims ( expanded_x , - 1 ) return expanded_x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def entropy_lower_bound ( self , name = \"entropy_lower_bound\" ) : with self . _name_scope ( name ) : with tf . control_dependencies ( self . _assertions ) : distribution_entropies = [ d . entropy ( ) for d in self . components ] cat_probs = self . _cat_probs ( log_probs = False ) partial_entropies = [ c_p * m for ( c_p , m ) in zip ( cat_probs , distribution_entropies ) ] # These are all the same shape by virtue of matching batch_shape return tf . add_n ( partial_entropies )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _cat_probs ( self , log_probs ) : which_softmax = tf . nn . log_softmax if log_probs else tf . nn . softmax cat_probs = which_softmax ( self . cat . logits ) cat_probs = tf . unstack ( cat_probs , num = self . num_components , axis = - 1 ) return cat_probs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_validate_args ( outcomes , logits , probs , validate_args ) : assertions = [ ] def validate_equal_last_dim ( tensor_a , tensor_b , message ) : if tensor_a . shape . is_fully_defined ( ) and tensor_b . shape . is_fully_defined ( ) : if tensor_a . shape [ - 1 ] != tensor_b . shape [ - 1 ] : raise ValueError ( message ) elif validate_args : assertions . append ( tf . compat . v1 . assert_equal ( tf . shape ( input = tensor_a ) [ - 1 ] , tf . shape ( input = tensor_b ) [ - 1 ] , message = message ) ) if logits is not None : validate_equal_last_dim ( outcomes , logits , message = 'Last dimension of outcomes and logits must be equal size.' ) if probs is not None : validate_equal_last_dim ( outcomes , probs , message = 'Last dimension of outcomes and probs must be equal size.' ) message = 'Rank of outcomes must be 1.' if outcomes . shape . ndims is not None : if outcomes . shape . ndims != 1 : raise ValueError ( message ) elif validate_args : assertions . append ( tf . compat . v1 . assert_rank ( outcomes , 1 , message = message ) ) message = 'Size of outcomes must be greater than 0.' if outcomes . shape . num_elements ( ) is not None : if outcomes . shape . num_elements ( ) == 0 : raise ValueError ( message ) elif validate_args : assertions . append ( tf . compat . v1 . assert_greater ( tf . size ( input = outcomes ) , 0 , message = message ) ) if validate_args : assertions . append ( tf . compat . v1 . assert_equal ( tf . math . is_strictly_increasing ( outcomes ) , True , message = 'outcomes is not strictly increasing.' ) ) return assertions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _ensure_tf_install ( ) : # pylint: disable=g-statement-before-imports try : import tensorflow as tf except ImportError : # Print more informative error message, then reraise. print ( \"\\n\\nFailed to import TensorFlow. Please note that TensorFlow is not \" \"installed by default when you install TensorFlow Probability. This \" \"is so that users can decide whether to install the GPU-enabled \" \"TensorFlow package. To use TensorFlow Probability, please install \" \"the most recent version of TensorFlow, by following instructions at \" \"https://tensorflow.org/install.\\n\\n\" ) raise import distutils . version # # Update this whenever we need to depend on a newer TensorFlow release. # required_tensorflow_version = \"1.13\" if ( distutils . version . LooseVersion ( tf . __version__ ) < distutils . version . LooseVersion ( required_tensorflow_version ) ) : raise ImportError ( \"This version of TensorFlow Probability requires TensorFlow \" \"version >= {required}; Detected an installation of version {present}. \" \"Please upgrade TensorFlow to proceed.\" . format ( required = required_tensorflow_version , present = tf . __version__ ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def logistic_regression ( features ) : coeffs = ed . MultivariateNormalDiag ( loc = tf . zeros ( features . shape [ 1 ] ) , name = \"coeffs\" ) labels = ed . Bernoulli ( logits = tf . tensordot ( features , coeffs , [ [ 1 ] , [ 0 ] ] ) , name = \"labels\" ) return labels\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def covertype ( ) : import sklearn . datasets # pylint: disable=g-import-not-at-top data = sklearn . datasets . covtype . fetch_covtype ( ) features = data . data labels = data . target # Normalize features and append a column of ones for the intercept. features -= features . mean ( 0 ) features /= features . std ( 0 ) features = np . hstack ( [ features , np . ones ( [ features . shape [ 0 ] , 1 ] ) ] ) features = tf . cast ( features , dtype = tf . float32 ) # Binarize outcomes on whether it is a specific category. _ , counts = np . unique ( labels , return_counts = True ) specific_category = np . argmax ( counts ) labels = ( labels == specific_category ) labels = tf . cast ( labels , dtype = tf . int32 ) return features , labels\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_dirichlet_dirichlet ( d1 , d2 , name = None ) : with tf . name_scope ( name or \"kl_dirichlet_dirichlet\" ) : # The KL between Dirichlet distributions can be derived as follows. We have # # Dir(x; a) = 1 / B(a) * prod_i[x[i]^(a[i] - 1)] # # where B(a) is the multivariate Beta function: # # B(a) = Gamma(a[1]) * ... * Gamma(a[n]) / Gamma(a[1] + ... + a[n]) # # The KL is # # KL(Dir(x; a), Dir(x; b)) = E_Dir(x; a){log(Dir(x; a) / Dir(x; b))} # # so we'll need to know the log density of the Dirichlet. This is # # log(Dir(x; a)) = sum_i[(a[i] - 1) log(x[i])] - log B(a) # # The only term that matters for the expectations is the log(x[i]). To # compute the expectation of this term over the Dirichlet density, we can # use the following facts about the Dirichlet in exponential family form: # 1. log(x[i]) is a sufficient statistic # 2. expected sufficient statistics (of any exp family distribution) are # equal to derivatives of the log normalizer with respect to # corresponding natural parameters: E{T[i](x)} = dA/d(eta[i]) # # To proceed, we can rewrite the Dirichlet density in exponential family # form as follows: # # Dir(x; a) = exp{eta(a) . T(x) - A(a)} # # where '.' is the dot product of vectors eta and T, and A is a scalar: # # eta[i](a) = a[i] - 1 # T[i](x) = log(x[i]) # A(a) = log B(a) # # Now, we can use fact (2) above to write # # E_Dir(x; a)[log(x[i])] # = dA(a) / da[i] # = d/da[i] log B(a) # = d/da[i] (sum_j lgamma(a[j])) - lgamma(sum_j a[j]) # = digamma(a[i])) - digamma(sum_j a[j]) # # Putting it all together, we have # # KL[Dir(x; a) || Dir(x; b)] # = E_Dir(x; a){log(Dir(x; a) / Dir(x; b)} # = E_Dir(x; a){sum_i[(a[i] - b[i]) log(x[i])} - (lbeta(a) - lbeta(b)) # = sum_i[(a[i] - b[i]) * E_Dir(x; a){log(x[i])}] - lbeta(a) + lbeta(b) # = sum_i[(a[i] - b[i]) * (digamma(a[i]) - digamma(sum_j a[j]))] # - lbeta(a) + lbeta(b)) digamma_sum_d1 = tf . math . digamma ( tf . reduce_sum ( input_tensor = d1 . concentration , axis = - 1 , keepdims = True ) ) digamma_diff = tf . math . digamma ( d1 . concentration ) - digamma_sum_d1 concentration_diff = d1 . concentration - d2 . concentration return ( tf . reduce_sum ( input_tensor = concentration_diff * digamma_diff , axis = - 1 ) - tf . math . lbeta ( d1 . concentration ) + tf . math . lbeta ( d2 . concentration ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_assert_valid_concentration ( self , concentration , validate_args ) : if not validate_args : return concentration return distribution_util . with_dependencies ( [ assert_util . assert_positive ( concentration , message = \"Concentration parameter must be positive.\" ) , assert_util . assert_rank_at_least ( concentration , 1 , message = \"Concentration parameter must have >=1 dimensions.\" ) , assert_util . assert_less ( 1 , tf . shape ( input = concentration ) [ - 1 ] , message = \"Concentration parameter must have event_size >= 2.\" ) , ] , concentration )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_assert_valid_sample ( self , x ) : if not self . validate_args : return x return distribution_util . with_dependencies ( [ assert_util . assert_positive ( x , message = \"samples must be positive\" ) , assert_util . assert_near ( tf . ones ( [ ] , dtype = self . dtype ) , tf . reduce_sum ( input_tensor = x , axis = - 1 ) , message = \"sample last-dimension must sum to `1`\" ) , ] , x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def auto_correlation ( x , axis = - 1 , max_lags = None , center = True , normalize = True , name = 'auto_correlation' ) : # Implementation details: # Extend length N / 2 1-D array x to length N by zero padding onto the end. # Then, set # F[x]_k := sum_n x_n exp{-i 2 pi k n / N }. # It is not hard to see that # F[x]_k Conj(F[x]_k) = F[R]_k, where # R_m := sum_n x_n Conj(x_{(n - m) mod N}). # One can also check that R_m / (N / 2 - m) is an unbiased estimate of RXX[m]. # Since F[x] is the DFT of x, this leads us to a zero-padding and FFT/IFFT # based version of estimating RXX. # Note that this is a special case of the Wiener-Khinchin Theorem. with tf . compat . v1 . name_scope ( name , values = [ x ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) # Rotate dimensions of x in order to put axis at the rightmost dim. # FFT op requires this. rank = util . prefer_static_rank ( x ) if axis < 0 : axis = rank + axis shift = rank - 1 - axis # Suppose x.shape[axis] = T, so there are T 'time' steps. # ==> x_rotated.shape = B + [T], # where B is x_rotated's batch shape. x_rotated = util . rotate_transpose ( x , shift ) if center : x_rotated -= tf . reduce_mean ( input_tensor = x_rotated , axis = - 1 , keepdims = True ) # x_len = N / 2 from above explanation. The length of x along axis. # Get a value for x_len that works in all cases. x_len = util . prefer_static_shape ( x_rotated ) [ - 1 ] # TODO(langmore) Investigate whether this zero padding helps or hurts. At # the moment is necessary so that all FFT implementations work. # Zero pad to the next power of 2 greater than 2 * x_len, which equals # 2**(ceil(Log_2(2 * x_len))). Note: Log_2(X) = Log_e(X) / Log_e(2). x_len_float64 = tf . cast ( x_len , np . float64 ) target_length = tf . pow ( np . float64 ( 2. ) , tf . math . ceil ( tf . math . log ( x_len_float64 * 2 ) / np . log ( 2. ) ) ) pad_length = tf . cast ( target_length - x_len_float64 , np . int32 ) # We should have: # x_rotated_pad.shape = x_rotated.shape[:-1] + [T + pad_length] # = B + [T + pad_length] x_rotated_pad = util . pad ( x_rotated , axis = - 1 , back = True , count = pad_length ) dtype = x . dtype if not dtype . is_complex : if not dtype . is_floating : raise TypeError ( 'Argument x must have either float or complex dtype' ' found: {}' . format ( dtype ) ) x_rotated_pad = tf . complex ( x_rotated_pad , dtype . real_dtype . as_numpy_dtype ( 0. ) ) # Autocorrelation is IFFT of power-spectral density (up to some scaling). fft_x_rotated_pad = tf . signal . fft ( x_rotated_pad ) spectral_density = fft_x_rotated_pad * tf . math . conj ( fft_x_rotated_pad ) # shifted_product is R[m] from above detailed explanation. # It is the inner product sum_n X[n] * Conj(X[n - m]). shifted_product = tf . signal . ifft ( spectral_density ) # Cast back to real-valued if x was real to begin with. shifted_product = tf . cast ( shifted_product , dtype ) # Figure out if we can deduce the final static shape, and set max_lags. # Use x_rotated as a reference, because it has the time dimension in the far # right, and was created before we performed all sorts of crazy shape # manipulations. know_static_shape = True if not x_rotated . shape . is_fully_defined ( ) : know_static_shape = False if max_lags is None : max_lags = x_len - 1 else : max_lags = tf . convert_to_tensor ( value = max_lags , name = 'max_lags' ) max_lags_ = tf . get_static_value ( max_lags ) if max_lags_ is None or not know_static_shape : know_static_shape = False max_lags = tf . minimum ( x_len - 1 , max_lags ) else : max_lags = min ( x_len - 1 , max_lags_ ) # Chop off the padding. # We allow users to provide a huge max_lags, but cut it off here. # shifted_product_chopped.shape = x_rotated.shape[:-1] + [max_lags] shifted_product_chopped = shifted_product [ ... , : max_lags + 1 ] # If possible, set shape. if know_static_shape : chopped_shape = x_rotated . shape . as_list ( ) chopped_shape [ - 1 ] = min ( x_len , max_lags + 1 ) shifted_product_chopped . set_shape ( chopped_shape ) # Recall R[m] is a sum of N / 2 - m nonzero terms x[n] Conj(x[n - m]). The # other terms were zeros arising only due to zero padding. # `denominator = (N / 2 - m)` (defined below) is the proper term to # divide by to make this an unbiased estimate of the expectation # E[X[n] Conj(X[n - m])]. x_len = tf . cast ( x_len , dtype . real_dtype ) max_lags = tf . cast ( max_lags , dtype . real_dtype ) denominator = x_len - tf . range ( 0. , max_lags + 1. ) denominator = tf . cast ( denominator , dtype ) shifted_product_rotated = shifted_product_chopped / denominator if normalize : shifted_product_rotated /= shifted_product_rotated [ ... , : 1 ] # Transpose dimensions back to those of x. return util . rotate_transpose ( shifted_product_rotated , - shift )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def cholesky_covariance ( x , sample_axis = 0 , keepdims = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'cholesky_covariance' , values = [ x , sample_axis ] ) : sample_axis = tf . convert_to_tensor ( value = sample_axis , dtype = tf . int32 ) cov = covariance ( x , sample_axis = sample_axis , event_axis = - 1 , keepdims = keepdims ) return tf . linalg . cholesky ( cov )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def covariance ( x , y = None , sample_axis = 0 , event_axis = - 1 , keepdims = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'covariance' , values = [ x , y , event_axis , sample_axis ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) # Covariance *only* uses the centered versions of x (and y). x -= tf . reduce_mean ( input_tensor = x , axis = sample_axis , keepdims = True ) if y is None : y = x else : y = tf . convert_to_tensor ( value = y , name = 'y' , dtype = x . dtype ) # If x and y have different shape, sample_axis and event_axis will likely # be wrong for one of them! x . shape . assert_is_compatible_with ( y . shape ) y -= tf . reduce_mean ( input_tensor = y , axis = sample_axis , keepdims = True ) if event_axis is None : return tf . reduce_mean ( input_tensor = x * tf . math . conj ( y ) , axis = sample_axis , keepdims = keepdims ) if sample_axis is None : raise ValueError ( 'sample_axis was None, which means all axis hold events, and this ' 'overlaps with event_axis ({})' . format ( event_axis ) ) event_axis = _make_positive_axis ( event_axis , tf . rank ( x ) ) sample_axis = _make_positive_axis ( sample_axis , tf . rank ( x ) ) # If we get lucky and axis is statically defined, we can do some checks. if _is_list_like ( event_axis ) and _is_list_like ( sample_axis ) : if set ( event_axis ) . intersection ( sample_axis ) : raise ValueError ( 'sample_axis ({}) and event_axis ({}) overlapped' . format ( sample_axis , event_axis ) ) if ( np . diff ( sorted ( event_axis ) ) > 1 ) . any ( ) : raise ValueError ( 'event_axis must be contiguous. Found: {}' . format ( event_axis ) ) batch_axis = list ( sorted ( set ( range ( x . shape . ndims ) ) . difference ( sample_axis + event_axis ) ) ) else : batch_axis , _ = tf . compat . v1 . setdiff1d ( tf . range ( 0 , tf . rank ( x ) ) , tf . concat ( ( sample_axis , event_axis ) , 0 ) ) event_axis = tf . convert_to_tensor ( value = event_axis , name = 'event_axis' , dtype = tf . int32 ) sample_axis = tf . convert_to_tensor ( value = sample_axis , name = 'sample_axis' , dtype = tf . int32 ) batch_axis = tf . convert_to_tensor ( value = batch_axis , name = 'batch_axis' , dtype = tf . int32 ) # Permute x/y until shape = B + E + S perm_for_xy = tf . concat ( ( batch_axis , event_axis , sample_axis ) , 0 ) x_permed = tf . transpose ( a = x , perm = perm_for_xy ) y_permed = tf . transpose ( a = y , perm = perm_for_xy ) batch_ndims = tf . size ( input = batch_axis ) batch_shape = tf . shape ( input = x_permed ) [ : batch_ndims ] event_ndims = tf . size ( input = event_axis ) event_shape = tf . shape ( input = x_permed ) [ batch_ndims : batch_ndims + event_ndims ] sample_shape = tf . shape ( input = x_permed ) [ batch_ndims + event_ndims : ] sample_ndims = tf . size ( input = sample_shape ) n_samples = tf . reduce_prod ( input_tensor = sample_shape ) n_events = tf . reduce_prod ( input_tensor = event_shape ) # Flatten sample_axis into one long dim. x_permed_flat = tf . reshape ( x_permed , tf . concat ( ( batch_shape , event_shape , [ n_samples ] ) , 0 ) ) y_permed_flat = tf . reshape ( y_permed , tf . concat ( ( batch_shape , event_shape , [ n_samples ] ) , 0 ) ) # Do the same for event_axis. x_permed_flat = tf . reshape ( x_permed , tf . concat ( ( batch_shape , [ n_events ] , [ n_samples ] ) , 0 ) ) y_permed_flat = tf . reshape ( y_permed , tf . concat ( ( batch_shape , [ n_events ] , [ n_samples ] ) , 0 ) ) # After matmul, cov.shape = batch_shape + [n_events, n_events] cov = tf . matmul ( x_permed_flat , y_permed_flat , adjoint_b = True ) / tf . cast ( n_samples , x . dtype ) # Insert some singletons to make # cov.shape = batch_shape + event_shape**2 + [1,...,1] # This is just like x_permed.shape, except the sample_axis is all 1's, and # the [n_events] became event_shape**2. cov = tf . reshape ( cov , tf . concat ( ( batch_shape , # event_shape**2 used here because it is the same length as # event_shape, and has the same number of elements as one # batch of covariance. event_shape ** 2 , tf . ones ( [ sample_ndims ] , tf . int32 ) ) , 0 ) ) # Permuting by the argsort inverts the permutation, making # cov.shape have ones in the position where there were samples, and # [n_events * n_events] in the event position. cov = tf . transpose ( a = cov , perm = tf . math . invert_permutation ( perm_for_xy ) ) # Now expand event_shape**2 into event_shape + event_shape. # We here use (for the first time) the fact that we require event_axis to be # contiguous. e_start = event_axis [ 0 ] e_len = 1 + event_axis [ - 1 ] - event_axis [ 0 ] cov = tf . reshape ( cov , tf . concat ( ( tf . shape ( input = cov ) [ : e_start ] , event_shape , event_shape , tf . shape ( input = cov ) [ e_start + e_len : ] ) , 0 ) ) # tf.squeeze requires python ints for axis, not Tensor. This is enough to # require our axis args to be constants. if not keepdims : squeeze_axis = tf . where ( sample_axis < e_start , sample_axis , sample_axis + e_len ) cov = _squeeze ( cov , axis = squeeze_axis ) return cov\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def correlation ( x , y = None , sample_axis = 0 , event_axis = - 1 , keepdims = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'correlation' , values = [ x , y , event_axis , sample_axis ] ) : # Corr[X, Y] = Cov[X, Y] / (Stddev[X] * Stddev[Y]) # = Cov[X / Stddev[X], Y / Stddev[Y]] # So we could compute covariance first then divide by stddev, or # divide by stddev and compute covariance. # Dividing by stddev then computing covariance is potentially more stable. # But... computing covariance first then dividing involves 2 fewer large # broadcasts. We choose to divide first, largely because it avoids # difficulties with the various options for sample/event axis kwargs. x /= stddev ( x , sample_axis = sample_axis , keepdims = True ) if y is not None : y /= stddev ( y , sample_axis = sample_axis , keepdims = True ) return covariance ( x = x , y = y , event_axis = event_axis , sample_axis = sample_axis , keepdims = keepdims )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def stddev ( x , sample_axis = 0 , keepdims = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'stddev' , values = [ x , sample_axis ] ) : return tf . sqrt ( variance ( x , sample_axis = sample_axis , keepdims = keepdims ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def variance ( x , sample_axis = 0 , keepdims = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'variance' , values = [ x , sample_axis ] ) : return covariance ( x , y = None , sample_axis = sample_axis , event_axis = None , keepdims = keepdims )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_list_or_1d_tensor ( values ) : values = tf . convert_to_tensor ( value = values , name = 'values' ) values_ = tf . get_static_value ( values ) # Static didn't work. if values_ is None : # Cheap way to bring to at least 1d. return values + tf . zeros ( [ 1 ] , dtype = values . dtype ) # Static worked! if values_ . ndim > 1 : raise ValueError ( 'values had > 1 dim: {}' . format ( values_ . shape ) ) # Cheap way to bring to at least 1d. values_ = values_ + np . zeros ( [ 1 ] , dtype = values_ . dtype ) return list ( values_ )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_positive_axis ( axis , ndims ) : axis = _make_list_or_1d_tensor ( axis ) ndims = tf . convert_to_tensor ( value = ndims , name = 'ndims' , dtype = tf . int32 ) ndims_ = tf . get_static_value ( ndims ) if _is_list_like ( axis ) and ndims_ is not None : # Static case positive_axis = [ ] for a in axis : if a < 0 : a = ndims_ + a positive_axis . append ( a ) else : # Dynamic case axis = tf . convert_to_tensor ( value = axis , name = 'axis' , dtype = tf . int32 ) positive_axis = tf . where ( axis >= 0 , axis , axis + ndims ) return positive_axis\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _squeeze ( x , axis ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) if axis is None : return tf . squeeze ( x , axis = None ) axis = tf . convert_to_tensor ( value = axis , name = 'axis' , dtype = tf . int32 ) axis += tf . zeros ( [ 1 ] , dtype = axis . dtype ) # Make axis at least 1d. keep_axis , _ = tf . compat . v1 . setdiff1d ( tf . range ( 0 , tf . rank ( x ) ) , axis ) return tf . reshape ( x , tf . gather ( tf . shape ( input = x ) , keep_axis ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_normal_normal ( n_a , n_b , name = None ) : with tf . name_scope ( name or \"kl_normal_normal\" ) : one = tf . constant ( 1 , dtype = n_a . dtype ) two = tf . constant ( 2 , dtype = n_a . dtype ) half = tf . constant ( 0.5 , dtype = n_a . dtype ) s_a_squared = tf . square ( n_a . scale ) s_b_squared = tf . square ( n_b . scale ) ratio = s_a_squared / s_b_squared return ( tf . square ( n_a . loc - n_b . loc ) / ( two * s_b_squared ) + half * ( ratio - one - tf . math . log ( ratio ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _z ( self , x ) : with tf . name_scope ( \"standardize\" ) : return ( x - self . loc ) / self . scale\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _inv_z ( self , z ) : with tf . name_scope ( \"reconstruct\" ) : return z * self . scale + self . loc\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def semilocal_linear_trend_transition_matrix ( autoregressive_coef ) : # We want to write the following 2 x 2 matrix: # [[1., 1., ], # level(t+1) = level(t) + slope(t) # [0., ar_coef], # slope(t+1) = ar_coef * slope(t) # but it's slightly tricky to properly incorporate the batch shape of # autoregressive_coef. E.g., if autoregressive_coef has shape [4,6], we want # to return shape [4, 6, 2, 2]. We do this by breaking the matrix into its # fixed entries, written explicitly, and then the autoregressive_coef part # which we add in after using a mask to broadcast to the correct matrix shape. fixed_entries = tf . constant ( [ [ 1. , 1. ] , [ 0. , 0. ] ] , dtype = autoregressive_coef . dtype ) autoregressive_coef_mask = tf . constant ( [ [ 0. , 0. ] , [ 0. , 1. ] ] , dtype = autoregressive_coef . dtype ) bottom_right_entry = ( autoregressive_coef [ ... , tf . newaxis , tf . newaxis ] * autoregressive_coef_mask ) return tf . linalg . LinearOperatorFullMatrix ( fixed_entries + bottom_right_entry )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def semilocal_linear_trend_transition_noise ( level_scale , slope_mean , slope_scale , autoregressive_coef ) : # At each timestep, the stochasticity of `level` and `slope` are given # by `level_scale` and `slope_scale` respectively. broadcast_batch_shape = dist_util . get_broadcast_shape ( level_scale , slope_mean , slope_scale , autoregressive_coef ) broadcast_ones = tf . ones ( broadcast_batch_shape , dtype = level_scale . dtype ) scale_diag = tf . stack ( [ level_scale * broadcast_ones , slope_scale * broadcast_ones ] , axis = - 1 ) # We additionally fold in a bias term implementing the nonzero `slope_mean`. # The overall `slope` update is (from `SemiLocalLinearTrend` docstring) # slope[t] = (slope_mean + # autoregressive_coef * (slope[t-1] - slope_mean) + # Normal(0., slope_scale)) # which we rewrite as # slope[t] = ( # autoregressive_coef * slope[t-1] + # linear transition # Normal(loc=slope_mean - autoregressive_coef * slope_mean, # noise bias # scale=slope_scale)) # noise scale bias = tf . stack ( [ tf . zeros_like ( broadcast_ones ) , slope_mean * ( 1 - autoregressive_coef ) * broadcast_ones ] , axis = - 1 ) return tfd . MultivariateNormalDiag ( loc = bias , scale_diag = scale_diag )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_halton_sequence ( dim , num_results = None , sequence_indices = None , dtype = tf . float32 , randomized = True , seed = None , name = None ) : if dim < 1 or dim > _MAX_DIMENSION : raise ValueError ( 'Dimension must be between 1 and {}. Supplied {}' . format ( _MAX_DIMENSION , dim ) ) if ( num_results is None ) == ( sequence_indices is None ) : raise ValueError ( 'Either `num_results` or `sequence_indices` must be' ' specified but not both.' ) if not dtype . is_floating : raise ValueError ( 'dtype must be of `float`-type' ) with tf . compat . v1 . name_scope ( name , 'sample' , values = [ num_results , sequence_indices ] ) : # Here and in the following, the shape layout is as follows: # [sample dimension, event dimension, coefficient dimension]. # The coefficient dimension is an intermediate axes which will hold the # weights of the starting integer when expressed in the (prime) base for # an event dimension. if num_results is not None : num_results = tf . convert_to_tensor ( value = num_results ) if sequence_indices is not None : sequence_indices = tf . convert_to_tensor ( value = sequence_indices ) indices = _get_indices ( num_results , sequence_indices , dtype ) radixes = tf . constant ( _PRIMES [ 0 : dim ] , dtype = dtype , shape = [ dim , 1 ] ) max_sizes_by_axes = _base_expansion_size ( tf . reduce_max ( input_tensor = indices ) , radixes ) max_size = tf . reduce_max ( input_tensor = max_sizes_by_axes ) # The powers of the radixes that we will need. Note that there is a bit # of an excess here. Suppose we need the place value coefficients of 7 # in base 2 and 3. For 2, we will have 3 digits but we only need 2 digits # for base 3. However, we can only create rectangular tensors so we # store both expansions in a [2, 3] tensor. This leads to the problem that # we might end up attempting to raise large numbers to large powers. For # example, base 2 expansion of 1024 has 10 digits. If we were in 10 # dimensions, then the 10th prime (29) we will end up computing 29^10 even # though we don't need it. We avoid this by setting the exponents for each # axes to 0 beyond the maximum value needed for that dimension. exponents_by_axes = tf . tile ( [ tf . range ( max_size ) ] , [ dim , 1 ] ) # The mask is true for those coefficients that are irrelevant. weight_mask = exponents_by_axes >= max_sizes_by_axes capped_exponents = tf . where ( weight_mask , tf . zeros_like ( exponents_by_axes ) , exponents_by_axes ) weights = radixes ** capped_exponents # The following computes the base b expansion of the indices. Suppose, # x = a0 + a1*b + a2*b^2 + ... Then, performing a floor div of x with # the vector (1, b, b^2, b^3, ...) will produce # (a0 + s1 * b, a1 + s2 * b, ...) where s_i are coefficients we don't care # about. Noting that all a_i < b by definition of place value expansion, # we see that taking the elements mod b of the above vector produces the # place value expansion coefficients. coeffs = tf . math . floordiv ( indices , weights ) coeffs *= 1. - tf . cast ( weight_mask , dtype ) coeffs %= radixes if not randomized : coeffs /= radixes return tf . reduce_sum ( input_tensor = coeffs / weights , axis = - 1 ) stream = distributions . SeedStream ( seed , salt = 'MCMCSampleHaltonSequence' ) coeffs = _randomize ( coeffs , radixes , seed = stream ( ) ) # Remove the contribution from randomizing the trailing zero for the # axes where max_size_by_axes < max_size. This will be accounted # for separately below (using zero_correction). coeffs *= 1. - tf . cast ( weight_mask , dtype ) coeffs /= radixes base_values = tf . reduce_sum ( input_tensor = coeffs / weights , axis = - 1 ) # The randomization used in Owen (2017) does not leave 0 invariant. While # we have accounted for the randomization of the first `max_size_by_axes` # coefficients, we still need to correct for the trailing zeros. Luckily, # this is equivalent to adding a uniform random value scaled so the first # `max_size_by_axes` coefficients are zero. The following statements perform # this correction. zero_correction = tf . random . uniform ( [ dim , 1 ] , seed = stream ( ) , dtype = dtype ) zero_correction /= radixes ** max_sizes_by_axes return base_values + tf . reshape ( zero_correction , [ - 1 ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _randomize ( coeffs , radixes , seed = None ) : given_dtype = coeffs . dtype coeffs = tf . cast ( coeffs , dtype = tf . int32 ) num_coeffs = tf . shape ( input = coeffs ) [ - 1 ] radixes = tf . reshape ( tf . cast ( radixes , dtype = tf . int32 ) , shape = [ - 1 ] ) stream = distributions . SeedStream ( seed , salt = 'MCMCSampleHaltonSequence2' ) perms = _get_permutations ( num_coeffs , radixes , seed = stream ( ) ) perms = tf . reshape ( perms , shape = [ - 1 ] ) radix_sum = tf . reduce_sum ( input_tensor = radixes ) radix_offsets = tf . reshape ( tf . cumsum ( radixes , exclusive = True ) , shape = [ - 1 , 1 ] ) offsets = radix_offsets + tf . range ( num_coeffs ) * radix_sum permuted_coeffs = tf . gather ( perms , coeffs + offsets ) return tf . cast ( permuted_coeffs , dtype = given_dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_permutations ( num_results , dims , seed = None ) : sample_range = tf . range ( num_results ) stream = distributions . SeedStream ( seed , salt = 'MCMCSampleHaltonSequence3' ) def generate_one ( d ) : seed = stream ( ) fn = lambda _ : tf . random . shuffle ( tf . range ( d ) , seed = seed ) return tf . map_fn ( fn , sample_range , parallel_iterations = 1 if seed is not None else 10 ) return tf . concat ( [ generate_one ( d ) for d in tf . unstack ( dims ) ] , axis = - 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_indices ( num_results , sequence_indices , dtype , name = None ) : with tf . compat . v1 . name_scope ( name , '_get_indices' , [ num_results , sequence_indices ] ) : if sequence_indices is None : num_results = tf . cast ( num_results , dtype = dtype ) sequence_indices = tf . range ( num_results , dtype = dtype ) else : sequence_indices = tf . cast ( sequence_indices , dtype ) # Shift the indices so they are 1 based. indices = sequence_indices + 1 # Reshape to make space for the event dimension and the place value # coefficients. return tf . reshape ( indices , [ - 1 , 1 , 1 ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _base_expansion_size ( num , bases ) : return tf . floor ( tf . math . log ( num ) / tf . math . log ( bases ) ) + 1\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _primes_less_than ( n ) : # Based on # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188 small_primes = np . array ( ( 2 , 3 , 5 ) ) if n <= 6 : return small_primes [ small_primes < n ] sieve = np . ones ( n // 3 + ( n % 6 == 2 ) , dtype = np . bool ) sieve [ 0 ] = False m = int ( n ** 0.5 ) // 3 + 1 for i in range ( m ) : if not sieve [ i ] : continue k = 3 * i + 1 | 1 sieve [ k ** 2 // 3 : : 2 * k ] = False sieve [ ( k ** 2 + 4 * k - 2 * k * ( i & 1 ) ) // 3 : : 2 * k ] = False return np . r_ [ 2 , 3 , 3 * np . nonzero ( sieve ) [ 0 ] + 1 | 1 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _machine_eps ( dtype ) : if isinstance ( dtype , tf . DType ) : dtype = dtype . as_numpy_dtype ( ) return np . finfo ( dtype ) . eps\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def hager_zhang ( value_and_gradients_function , initial_step_size = None , value_at_initial_step = None , value_at_zero = None , converged = None , threshold_use_approximate_wolfe_condition = 1e-6 , shrinkage_param = 0.66 , expansion_param = 5.0 , sufficient_decrease_param = 0.1 , curvature_param = 0.9 , step_size_shrink_param = 0.1 , max_iterations = 50 , name = None ) : with tf . compat . v1 . name_scope ( name , 'hager_zhang' , [ initial_step_size , value_at_initial_step , value_at_zero , converged , threshold_use_approximate_wolfe_condition , shrinkage_param , expansion_param , sufficient_decrease_param , curvature_param ] ) : val_0 , val_initial , f_lim , prepare_evals = _prepare_args ( value_and_gradients_function , initial_step_size , value_at_initial_step , value_at_zero , threshold_use_approximate_wolfe_condition ) valid_inputs = ( hzl . is_finite ( val_0 ) & ( val_0 . df < 0 ) & tf . math . is_finite ( val_initial . x ) & ( val_initial . x > 0 ) ) if converged is None : init_converged = tf . zeros_like ( valid_inputs ) # i.e. all false. else : init_converged = tf . convert_to_tensor ( value = converged ) failed = ~ init_converged & ~ valid_inputs active = ~ init_converged & valid_inputs # Note: _fix_step_size returns immediately if either all inputs are invalid # or none of the active ones need fixing. fix_step_evals , val_c , fix_failed = _fix_step_size ( value_and_gradients_function , val_initial , active , step_size_shrink_param ) init_interval = HagerZhangLineSearchResult ( converged = init_converged , failed = failed | fix_failed , func_evals = prepare_evals + fix_step_evals , iterations = tf . convert_to_tensor ( value = 0 ) , left = val_0 , right = hzl . val_where ( init_converged , val_0 , val_c ) ) def _apply_bracket_and_search ( ) : \"\"\"Bracketing and searching to do for valid inputs.\"\"\" return _bracket_and_search ( value_and_gradients_function , init_interval , f_lim , max_iterations , shrinkage_param , expansion_param , sufficient_decrease_param , curvature_param ) init_active = ~ init_interval . failed & ~ init_interval . converged return prefer_static . cond ( tf . reduce_any ( input_tensor = init_active ) , _apply_bracket_and_search , lambda : init_interval )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _fix_step_size ( value_and_gradients_function , val_c_input , active , step_size_shrink_param ) : # The maximum iterations permitted are determined as the number of halvings # it takes to reduce 1 to 0 in the given dtype. iter_max = np . ceil ( - np . log2 ( _machine_eps ( val_c_input . x . dtype ) ) ) def _cond ( i , val_c , to_fix ) : del val_c # Unused. return ( i < iter_max ) & tf . reduce_any ( input_tensor = to_fix ) def _body ( i , val_c , to_fix ) : next_c = tf . where ( to_fix , val_c . x * step_size_shrink_param , val_c . x ) next_val_c = value_and_gradients_function ( next_c ) still_to_fix = to_fix & ~ hzl . is_finite ( next_val_c ) return ( i + 1 , next_val_c , still_to_fix ) to_fix = active & ~ hzl . is_finite ( val_c_input ) return tf . while_loop ( cond = _cond , body = _body , loop_vars = ( 0 , val_c_input , to_fix ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _bracket_and_search ( value_and_gradients_function , init_interval , f_lim , max_iterations , shrinkage_param , expansion_param , sufficient_decrease_param , curvature_param ) : bracket_result = hzl . bracket ( value_and_gradients_function , init_interval , f_lim , max_iterations , expansion_param ) converged = init_interval . converged | _very_close ( bracket_result . left . x , bracket_result . right . x ) # We fail if we have not yet converged but already exhausted all iterations. exhausted_iterations = ~ converged & tf . greater_equal ( bracket_result . iteration , max_iterations ) line_search_args = HagerZhangLineSearchResult ( converged = converged , failed = bracket_result . failed | exhausted_iterations , iterations = bracket_result . iteration , func_evals = bracket_result . num_evals , left = bracket_result . left , right = bracket_result . right ) return _line_search_after_bracketing ( value_and_gradients_function , line_search_args , init_interval . left , f_lim , max_iterations , sufficient_decrease_param , curvature_param , shrinkage_param )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _line_search_after_bracketing ( value_and_gradients_function , search_interval , val_0 , f_lim , max_iterations , sufficient_decrease_param , curvature_param , shrinkage_param ) : def _loop_cond ( curr_interval ) : \"\"\"Loop condition.\"\"\" active = ~ ( curr_interval . converged | curr_interval . failed ) return ( curr_interval . iterations < max_iterations ) & tf . reduce_any ( input_tensor = active ) def _loop_body ( curr_interval ) : \"\"\"The loop body.\"\"\" secant2_raw_result = hzl . secant2 ( value_and_gradients_function , val_0 , curr_interval , f_lim , sufficient_decrease_param , curvature_param ) secant2_result = HagerZhangLineSearchResult ( converged = secant2_raw_result . converged , failed = secant2_raw_result . failed , iterations = curr_interval . iterations + 1 , func_evals = secant2_raw_result . num_evals , left = secant2_raw_result . left , right = secant2_raw_result . right ) should_check_shrinkage = ~ ( secant2_result . converged | secant2_result . failed ) def _do_check_shrinkage ( ) : \"\"\"Check if interval has shrinked enough.\"\"\" old_width = curr_interval . right . x - curr_interval . left . x new_width = secant2_result . right . x - secant2_result . left . x sufficient_shrinkage = new_width < old_width * shrinkage_param func_is_flat = ( _very_close ( curr_interval . left . f , curr_interval . right . f ) & _very_close ( secant2_result . left . f , secant2_result . right . f ) ) new_converged = ( should_check_shrinkage & sufficient_shrinkage & func_is_flat ) needs_inner_bisect = should_check_shrinkage & ~ sufficient_shrinkage inner_bisect_args = secant2_result . _replace ( converged = secant2_result . converged | new_converged ) def _apply_inner_bisect ( ) : return _line_search_inner_bisection ( value_and_gradients_function , inner_bisect_args , needs_inner_bisect , f_lim ) return prefer_static . cond ( tf . reduce_any ( input_tensor = needs_inner_bisect ) , _apply_inner_bisect , lambda : inner_bisect_args ) next_args = prefer_static . cond ( tf . reduce_any ( input_tensor = should_check_shrinkage ) , _do_check_shrinkage , lambda : secant2_result ) interval_shrunk = ( ~ next_args . failed & _very_close ( next_args . left . x , next_args . right . x ) ) return [ next_args . _replace ( converged = next_args . converged | interval_shrunk ) ] return tf . while_loop ( cond = _loop_cond , body = _loop_body , loop_vars = [ search_interval ] , parallel_iterations = 1 ) [ 0 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _line_search_inner_bisection ( value_and_gradients_function , search_interval , active , f_lim ) : midpoint = ( search_interval . left . x + search_interval . right . x ) / 2 val_mid = value_and_gradients_function ( midpoint ) is_valid_mid = hzl . is_finite ( val_mid ) still_active = active & is_valid_mid new_failed = active & ~ is_valid_mid next_inteval = search_interval . _replace ( failed = search_interval . failed | new_failed , func_evals = search_interval . func_evals + 1 ) def _apply_update ( ) : update_result = hzl . update ( value_and_gradients_function , next_inteval . left , next_inteval . right , val_mid , f_lim , active = still_active ) return HagerZhangLineSearchResult ( converged = next_inteval . converged , failed = next_inteval . failed | update_result . failed , iterations = next_inteval . iterations + update_result . iteration , func_evals = next_inteval . func_evals + update_result . num_evals , left = update_result . left , right = update_result . right ) return prefer_static . cond ( tf . reduce_any ( input_tensor = still_active ) , _apply_update , lambda : next_inteval )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_args ( value_and_gradients_function , initial_step_size , val_initial , val_0 , approximate_wolfe_threshold ) : eval_count = 0 if val_initial is None : if initial_step_size is not None : initial_step_size = tf . convert_to_tensor ( value = initial_step_size ) else : initial_step_size = tf . convert_to_tensor ( value = 1.0 , dtype = tf . float32 ) val_initial = value_and_gradients_function ( initial_step_size ) eval_count += 1 if val_0 is None : x_0 = tf . zeros_like ( val_initial . x ) val_0 = value_and_gradients_function ( x_0 ) eval_count += 1 f_lim = val_0 . f + ( approximate_wolfe_threshold * tf . abs ( val_0 . f ) ) return val_0 , val_initial , f_lim , tf . convert_to_tensor ( value = eval_count )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _to_str ( x ) : x = tf . convert_to_tensor ( value = x ) if x . dtype == tf . bool : return tf . where ( x , tf . fill ( x . shape , 'True' ) , tf . fill ( x . shape , 'False' ) ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _print ( pass_through_tensor , values ) : flat_values = [ ] for value in values : # Checks if it is a namedtuple. if hasattr ( value , '_fields' ) : for field in value . _fields : flat_values . extend ( [ field , _to_str ( getattr ( value , field ) ) ] ) continue if isinstance ( value , ( list , tuple ) ) : for v in value : flat_values . append ( _to_str ( v ) ) continue flat_values . append ( _to_str ( value ) ) return tf . compat . v1 . Print ( pass_through_tensor , flat_values )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_brute_force ( a , b , name = None ) : def squared_frobenius_norm ( x ) : \"\"\"Helper to make KL calculation slightly more readable.\"\"\" # http://mathworld.wolfram.com/FrobeniusNorm.html # The gradient of KL[p,q] is not defined when p==q. The culprit is # tf.norm, i.e., we cannot use the commented out code. # return tf.square(tf.norm(x, ord=\"fro\", axis=[-2, -1])) return tf . reduce_sum ( input_tensor = tf . square ( x ) , axis = [ - 2 , - 1 ] ) # TODO(b/35041439): See also b/35040945. Remove this function once LinOp # supports something like: # A.inverse().solve(B).norm(order='fro', axis=[-1, -2]) def is_diagonal ( x ) : \"\"\"Helper to identify if `LinearOperator` has only a diagonal component.\"\"\" return ( isinstance ( x , tf . linalg . LinearOperatorIdentity ) or isinstance ( x , tf . linalg . LinearOperatorScaledIdentity ) or isinstance ( x , tf . linalg . LinearOperatorDiag ) ) with tf . name_scope ( name or \"kl_mvn\" ) : # Calculation is based on: # http://stats.stackexchange.com/questions/60680/kl-divergence-between-two-multivariate-gaussians # and, # https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm # i.e., # If Ca = AA', Cb = BB', then # tr[inv(Cb) Ca] = tr[inv(B)' inv(B) A A'] # = tr[inv(B) A A' inv(B)'] # = tr[(inv(B) A) (inv(B) A)'] # = sum_{ij} (inv(B) A)_{ij}**2 # = ||inv(B) A||_F**2 # where ||.||_F is the Frobenius norm and the second equality follows from # the cyclic permutation property. if is_diagonal ( a . scale ) and is_diagonal ( b . scale ) : # Using `stddev` because it handles expansion of Identity cases. b_inv_a = ( a . stddev ( ) / b . stddev ( ) ) [ ... , tf . newaxis ] else : b_inv_a = b . scale . solve ( a . scale . to_dense ( ) ) kl_div = ( b . scale . log_abs_determinant ( ) - a . scale . log_abs_determinant ( ) + 0.5 * ( - tf . cast ( a . scale . domain_dimension_tensor ( ) , a . dtype ) + squared_frobenius_norm ( b_inv_a ) + squared_frobenius_norm ( b . scale . solve ( ( b . mean ( ) - a . mean ( ) ) [ ... , tf . newaxis ] ) ) ) ) tensorshape_util . set_shape ( kl_div , tf . broadcast_static_shape ( a . batch_shape , b . batch_shape ) ) return kl_div\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def quadrature_scheme_softmaxnormal_gauss_hermite ( normal_loc , normal_scale , quadrature_size , validate_args = False , name = None ) : with tf . name_scope ( name or \"quadrature_scheme_softmaxnormal_gauss_hermite\" ) : normal_loc = tf . convert_to_tensor ( value = normal_loc , name = \"normal_loc\" ) npdt = dtype_util . as_numpy_dtype ( normal_loc . dtype ) normal_scale = tf . convert_to_tensor ( value = normal_scale , dtype = npdt , name = \"normal_scale\" ) normal_scale = maybe_check_quadrature_param ( normal_scale , \"normal_scale\" , validate_args ) grid , probs = np . polynomial . hermite . hermgauss ( deg = quadrature_size ) grid = grid . astype ( npdt ) probs = probs . astype ( npdt ) probs /= np . linalg . norm ( probs , ord = 1 , keepdims = True ) probs = tf . convert_to_tensor ( value = probs , name = \"probs\" , dtype = npdt ) grid = softmax ( - distribution_util . pad ( ( normal_loc [ ... , tf . newaxis ] + np . sqrt ( 2. ) * normal_scale [ ... , tf . newaxis ] * grid ) , axis = - 2 , front = True ) , axis = - 2 ) # shape: [B, components, deg] return grid , probs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def quadrature_scheme_softmaxnormal_quantiles ( normal_loc , normal_scale , quadrature_size , validate_args = False , name = None ) : with tf . name_scope ( name or \"softmax_normal_grid_and_probs\" ) : normal_loc = tf . convert_to_tensor ( value = normal_loc , name = \"normal_loc\" ) dt = dtype_util . base_dtype ( normal_loc . dtype ) normal_scale = tf . convert_to_tensor ( value = normal_scale , dtype = dt , name = \"normal_scale\" ) normal_scale = maybe_check_quadrature_param ( normal_scale , \"normal_scale\" , validate_args ) dist = normal . Normal ( loc = normal_loc , scale = normal_scale ) def _get_batch_ndims ( ) : \"\"\"Helper to get rank(dist.batch_shape), statically if possible.\"\"\" ndims = tensorshape_util . rank ( dist . batch_shape ) if ndims is None : ndims = tf . shape ( input = dist . batch_shape_tensor ( ) ) [ 0 ] return ndims batch_ndims = _get_batch_ndims ( ) def _get_final_shape ( qs ) : \"\"\"Helper to build `TensorShape`.\"\"\" bs = tensorshape_util . with_rank_at_least ( dist . batch_shape , 1 ) num_components = tf . compat . dimension_value ( bs [ - 1 ] ) if num_components is not None : num_components += 1 tail = tf . TensorShape ( [ num_components , qs ] ) return bs [ : - 1 ] . concatenate ( tail ) def _compute_quantiles ( ) : \"\"\"Helper to build quantiles.\"\"\" # Omit {0, 1} since they might lead to Inf/NaN. zero = tf . zeros ( [ ] , dtype = dist . dtype ) edges = tf . linspace ( zero , 1. , quadrature_size + 3 ) [ 1 : - 1 ] # Expand edges so its broadcast across batch dims. edges = tf . reshape ( edges , shape = tf . concat ( [ [ - 1 ] , tf . ones ( [ batch_ndims ] , dtype = tf . int32 ) ] , axis = 0 ) ) quantiles = dist . quantile ( edges ) quantiles = softmax_centered_bijector . SoftmaxCentered ( ) . forward ( quantiles ) # Cyclically permute left by one. perm = tf . concat ( [ tf . range ( 1 , 1 + batch_ndims ) , [ 0 ] ] , axis = 0 ) quantiles = tf . transpose ( a = quantiles , perm = perm ) tensorshape_util . set_shape ( quantiles , _get_final_shape ( quadrature_size + 1 ) ) return quantiles quantiles = _compute_quantiles ( ) # Compute grid as quantile midpoints. grid = ( quantiles [ ... , : - 1 ] + quantiles [ ... , 1 : ] ) / 2. # Set shape hints. tensorshape_util . set_shape ( grid , _get_final_shape ( quadrature_size ) ) # By construction probs is constant, i.e., `1 / quadrature_size`. This is # important, because non-constant probs leads to non-reparameterizable # samples. probs = tf . fill ( dims = [ quadrature_size ] , value = 1. / tf . cast ( quadrature_size , dist . dtype ) ) return grid , probs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def maybe_check_quadrature_param ( param , name , validate_args ) : with tf . name_scope ( \"check_\" + name ) : assertions = [ ] if tensorshape_util . rank ( param . shape ) is not None : if tensorshape_util . rank ( param . shape ) == 0 : raise ValueError ( \"Mixing params must be a (batch of) vector; \" \"{}.rank={} is not at least one.\" . format ( name , tensorshape_util . rank ( param . shape ) ) ) elif validate_args : assertions . append ( assert_util . assert_rank_at_least ( param , 1 , message = ( \"Mixing params must be a (batch of) vector; \" \"{}.rank is not at least one.\" . format ( name ) ) ) ) # TODO(jvdillon): Remove once we support k-mixtures. if tensorshape_util . with_rank_at_least ( param . shape , 1 ) [ - 1 ] is not None : if tf . compat . dimension_value ( param . shape [ - 1 ] ) != 1 : raise NotImplementedError ( \"Currently only bimixtures are supported; \" \"{}.shape[-1]={} is not 1.\" . format ( name , tf . compat . dimension_value ( param . shape [ - 1 ] ) ) ) elif validate_args : assertions . append ( assert_util . assert_equal ( tf . shape ( input = param ) [ - 1 ] , 1 , message = ( \"Currently only bimixtures are supported; \" \"{}.shape[-1] is not 1.\" . format ( name ) ) ) ) if assertions : return distribution_util . with_dependencies ( assertions , param ) return param\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def determine_batch_event_shapes ( grid , endpoint_affine ) : with tf . name_scope ( \"determine_batch_event_shapes\" ) : # grid # shape: [B, k, q] # endpoint_affine # len=k, shape: [B, d, d] batch_shape = grid . shape [ : - 2 ] batch_shape_tensor = tf . shape ( input = grid ) [ : - 2 ] event_shape = None event_shape_tensor = None def _set_event_shape ( shape , shape_tensor ) : if event_shape is None : return shape , shape_tensor return ( tf . broadcast_static_shape ( event_shape , shape ) , tf . broadcast_dynamic_shape ( event_shape_tensor , shape_tensor ) ) for aff in endpoint_affine : if aff . shift is not None : batch_shape = tf . broadcast_static_shape ( batch_shape , aff . shift . shape [ : - 1 ] ) batch_shape_tensor = tf . broadcast_dynamic_shape ( batch_shape_tensor , tf . shape ( input = aff . shift ) [ : - 1 ] ) event_shape , event_shape_tensor = _set_event_shape ( aff . shift . shape [ - 1 : ] , tf . shape ( input = aff . shift ) [ - 1 : ] ) if aff . scale is not None : batch_shape = tf . broadcast_static_shape ( batch_shape , aff . scale . batch_shape ) batch_shape_tensor = tf . broadcast_dynamic_shape ( batch_shape_tensor , aff . scale . batch_shape_tensor ( ) ) event_shape , event_shape_tensor = _set_event_shape ( tf . TensorShape ( [ aff . scale . range_dimension ] ) , aff . scale . range_dimension_tensor ( ) [ tf . newaxis ] ) return batch_shape , batch_shape_tensor , event_shape , event_shape_tensor\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def interpolate_loc ( grid , loc ) : if len ( loc ) != 2 : raise NotImplementedError ( \"Currently only bimixtures are supported; \" \"len(scale)={} is not 2.\" . format ( len ( loc ) ) ) deg = tf . compat . dimension_value ( tensorshape_util . with_rank_at_least ( grid . shape , 1 ) [ - 1 ] ) if deg is None : raise ValueError ( \"Num quadrature grid points must be known prior \" \"to graph execution.\" ) with tf . name_scope ( \"interpolate_loc\" ) : if loc is None or loc [ 0 ] is None and loc [ 1 ] is None : return [ None ] * deg # shape: [B, 1, k, deg] w = grid [ ... , tf . newaxis , : , : ] loc = [ x [ ... , tf . newaxis ] # shape: [B, e, 1] if x is not None else None for x in loc ] if loc [ 0 ] is None : x = w [ ... , 1 , : ] * loc [ 1 ] # shape: [B, e, deg] elif loc [ 1 ] is None : x = w [ ... , 0 , : ] * loc [ 0 ] # shape: [B, e, deg] else : delta = loc [ 0 ] - loc [ 1 ] x = w [ ... , 0 , : ] * delta + loc [ 1 ] # shape: [B, e, deg] return [ x [ ... , k ] for k in range ( deg ) ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def interpolate_scale ( grid , scale ) : if len ( scale ) != 2 : raise NotImplementedError ( \"Currently only bimixtures are supported; \" \"len(scale)={} is not 2.\" . format ( len ( scale ) ) ) deg = tf . compat . dimension_value ( tensorshape_util . with_rank_at_least ( grid . shape , 1 ) [ - 1 ] ) if deg is None : raise ValueError ( \"Num quadrature grid points must be known prior \" \"to graph execution.\" ) with tf . name_scope ( \"interpolate_scale\" ) : return [ linop_add_lib . add_operators ( [ linop_scale ( grid [ ... , k , q ] , s ) for k , s in enumerate ( scale ) ] ) [ 0 ] for q in range ( deg ) ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def linop_scale ( w , op ) : # We assume w > 0. (This assumption only relates to the is_* attributes.) with tf . name_scope ( \"linop_scale\" ) : # TODO(b/35301104): LinearOperatorComposition doesn't combine operators, so # special case combinations here. Once it does, this function can be # replaced by: # return linop_composition_lib.LinearOperatorComposition([ # scaled_identity(w), op]) def scaled_identity ( w ) : return tf . linalg . LinearOperatorScaledIdentity ( num_rows = op . range_dimension_tensor ( ) , multiplier = w , is_non_singular = op . is_non_singular , is_self_adjoint = op . is_self_adjoint , is_positive_definite = op . is_positive_definite ) if isinstance ( op , tf . linalg . LinearOperatorIdentity ) : return scaled_identity ( w ) if isinstance ( op , tf . linalg . LinearOperatorScaledIdentity ) : return scaled_identity ( w * op . multiplier ) if isinstance ( op , tf . linalg . LinearOperatorDiag ) : return tf . linalg . LinearOperatorDiag ( diag = w [ ... , tf . newaxis ] * op . diag_part ( ) , is_non_singular = op . is_non_singular , is_self_adjoint = op . is_self_adjoint , is_positive_definite = op . is_positive_definite ) if isinstance ( op , tf . linalg . LinearOperatorLowerTriangular ) : return tf . linalg . LinearOperatorLowerTriangular ( tril = w [ ... , tf . newaxis , tf . newaxis ] * op . to_dense ( ) , is_non_singular = op . is_non_singular , is_self_adjoint = op . is_self_adjoint , is_positive_definite = op . is_positive_definite ) raise NotImplementedError ( \"Unsupported Linop type ({})\" . format ( type ( op ) . __name__ ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def concat_vectors ( * args ) : args_ = [ tf . get_static_value ( x ) for x in args ] if any ( vec is None for vec in args_ ) : return tf . concat ( args , axis = 0 ) return [ val for vec in args_ for val in vec ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def softmax ( x , axis , name = None ) : with tf . name_scope ( name or \"softmax\" ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) ndims = ( tensorshape_util . rank ( x . shape ) if tensorshape_util . rank ( x . shape ) is not None else tf . rank ( x , name = \"ndims\" ) ) axis = tf . convert_to_tensor ( value = axis , dtype = tf . int32 , name = \"axis\" ) axis_ = tf . get_static_value ( axis ) if axis_ is not None : axis = np . int ( ndims + axis_ if axis_ < 0 else axis_ ) else : axis = tf . where ( axis < 0 , ndims + axis , axis ) return tf . nn . softmax ( x , axis = axis )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _expand_base_distribution_mean ( self ) : single_draw_shape = concat_vectors ( self . batch_shape_tensor ( ) , self . event_shape_tensor ( ) ) m = tf . reshape ( self . distribution . mean ( ) , # A scalar. shape = tf . ones_like ( single_draw_shape , dtype = tf . int32 ) ) m = tf . tile ( m , multiples = single_draw_shape ) tensorshape_util . set_shape ( m , tensorshape_util . concatenate ( self . batch_shape , self . event_shape ) ) return m\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_vector_matrix ( vs , ms ) : return tf . reduce_logsumexp ( input_tensor = vs [ ... , tf . newaxis ] + ms , axis = - 2 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_matrix_vector ( ms , vs ) : return tf . reduce_logsumexp ( input_tensor = ms + vs [ ... , tf . newaxis , : ] , axis = - 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _vector_matrix ( vs , ms ) : return tf . reduce_sum ( input_tensor = vs [ ... , tf . newaxis ] * ms , axis = - 2 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _extract_log_probs ( num_states , dist ) : states = tf . reshape ( tf . range ( num_states ) , tf . concat ( [ [ num_states ] , tf . ones_like ( dist . batch_shape_tensor ( ) ) ] , axis = 0 ) ) return distribution_util . move_dimension ( dist . log_prob ( states ) , 0 , - 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _marginal_hidden_probs ( self ) : initial_log_probs = tf . broadcast_to ( self . _log_init , tf . concat ( [ self . batch_shape_tensor ( ) , [ self . _num_states ] ] , axis = 0 ) ) # initial_log_probs :: batch_shape num_states if self . _num_steps > 1 : transition_log_probs = self . _log_trans def forward_step ( log_probs , _ ) : return _log_vector_matrix ( log_probs , transition_log_probs ) dummy_index = tf . zeros ( self . _num_steps - 1 , dtype = tf . float32 ) forward_log_probs = tf . scan ( forward_step , dummy_index , initializer = initial_log_probs , name = \"forward_log_probs\" ) forward_log_probs = tf . concat ( [ [ initial_log_probs ] , forward_log_probs ] , axis = 0 ) else : forward_log_probs = initial_log_probs [ tf . newaxis , ... ] # returns :: num_steps batch_shape num_states return tf . exp ( forward_log_probs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def posterior_marginals ( self , observations , name = None ) : with tf . name_scope ( name or \"posterior_marginals\" ) : with tf . control_dependencies ( self . _runtime_assertions ) : observation_tensor_shape = tf . shape ( input = observations ) with self . _observation_shape_preconditions ( observation_tensor_shape ) : observation_batch_shape = observation_tensor_shape [ : - 1 - self . _underlying_event_rank ] observation_event_shape = observation_tensor_shape [ - 1 - self . _underlying_event_rank : ] batch_shape = tf . broadcast_dynamic_shape ( observation_batch_shape , self . batch_shape_tensor ( ) ) log_init = tf . broadcast_to ( self . _log_init , tf . concat ( [ batch_shape , [ self . _num_states ] ] , axis = 0 ) ) log_transition = self . _log_trans observations = tf . broadcast_to ( observations , tf . concat ( [ batch_shape , observation_event_shape ] , axis = 0 ) ) observation_rank = tf . rank ( observations ) underlying_event_rank = self . _underlying_event_rank observations = distribution_util . move_dimension ( observations , observation_rank - underlying_event_rank - 1 , 0 ) observations = tf . expand_dims ( observations , observation_rank - underlying_event_rank ) observation_log_probs = self . _observation_distribution . log_prob ( observations ) log_adjoint_prob = tf . zeros_like ( log_init ) def forward_step ( log_previous_step , log_prob_observation ) : return _log_vector_matrix ( log_previous_step , log_transition ) + log_prob_observation log_prob = log_init + observation_log_probs [ 0 ] forward_log_probs = tf . scan ( forward_step , observation_log_probs [ 1 : ] , initializer = log_prob , name = \"forward_log_probs\" ) forward_log_probs = tf . concat ( [ [ log_prob ] , forward_log_probs ] , axis = 0 ) def backward_step ( log_previous_step , log_prob_observation ) : return _log_matrix_vector ( log_transition , log_prob_observation + log_previous_step ) backward_log_adjoint_probs = tf . scan ( backward_step , observation_log_probs [ 1 : ] , initializer = log_adjoint_prob , reverse = True , name = \"backward_log_adjoint_probs\" ) total_log_prob = tf . reduce_logsumexp ( input_tensor = forward_log_probs [ - 1 ] , axis = - 1 ) backward_log_adjoint_probs = tf . concat ( [ backward_log_adjoint_probs , [ log_adjoint_prob ] ] , axis = 0 ) log_likelihoods = forward_log_probs + backward_log_adjoint_probs marginal_log_probs = distribution_util . move_dimension ( log_likelihoods - total_log_prob [ ... , tf . newaxis ] , 0 , - 2 ) return categorical . Categorical ( logits = marginal_log_probs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def posterior_mode ( self , observations , name = None ) : with tf . name_scope ( name or \"posterior_mode\" ) : with tf . control_dependencies ( self . _runtime_assertions ) : observation_tensor_shape = tf . shape ( input = observations ) with self . _observation_shape_preconditions ( observation_tensor_shape ) : observation_batch_shape = observation_tensor_shape [ : - 1 - self . _underlying_event_rank ] observation_event_shape = observation_tensor_shape [ - 1 - self . _underlying_event_rank : ] batch_shape = tf . broadcast_dynamic_shape ( observation_batch_shape , self . batch_shape_tensor ( ) ) log_init = tf . broadcast_to ( self . _log_init , tf . concat ( [ batch_shape , [ self . _num_states ] ] , axis = 0 ) ) observations = tf . broadcast_to ( observations , tf . concat ( [ batch_shape , observation_event_shape ] , axis = 0 ) ) observation_rank = tf . rank ( observations ) underlying_event_rank = self . _underlying_event_rank observations = distribution_util . move_dimension ( observations , observation_rank - underlying_event_rank - 1 , 0 ) # We need to compute the probability of each observation for # each possible state. # This requires inserting an extra index just before the # observation event indices that will be broadcast with the # last batch index in `observation_distribution`. observations = tf . expand_dims ( observations , observation_rank - underlying_event_rank ) observation_log_probs = self . _observation_distribution . log_prob ( observations ) log_prob = log_init + observation_log_probs [ 0 ] if self . _num_steps == 1 : most_likely_end = tf . argmax ( input = log_prob , axis = - 1 ) return most_likely_end [ ... , tf . newaxis ] def forward_step ( previous_step_pair , log_prob_observation ) : log_prob_previous = previous_step_pair [ 0 ] log_prob = ( log_prob_previous [ ... , tf . newaxis ] + self . _log_trans + log_prob_observation [ ... , tf . newaxis , : ] ) most_likely_given_successor = tf . argmax ( input = log_prob , axis = - 2 ) max_log_p_given_successor = tf . reduce_max ( input_tensor = log_prob , axis = - 2 ) return ( max_log_p_given_successor , most_likely_given_successor ) forward_log_probs , all_most_likely_given_successor = tf . scan ( forward_step , observation_log_probs [ 1 : ] , initializer = ( log_prob , tf . zeros ( tf . shape ( input = log_init ) , dtype = tf . int64 ) ) , name = \"forward_log_probs\" ) most_likely_end = tf . argmax ( input = forward_log_probs [ - 1 ] , axis = - 1 ) # We require the operation that gives C from A and B where # C[i...j] = A[i...j, B[i...j]] # and A = most_likely_given_successor # B = most_likely_successor. # tf.gather requires indices of known shape so instead we use # reduction with tf.one_hot(B) to pick out elements from B def backward_step ( most_likely_successor , most_likely_given_successor ) : return tf . reduce_sum ( input_tensor = ( most_likely_given_successor * tf . one_hot ( most_likely_successor , self . _num_states , dtype = tf . int64 ) ) , axis = - 1 ) backward_scan = tf . scan ( backward_step , all_most_likely_given_successor , most_likely_end , reverse = True ) most_likely_sequences = tf . concat ( [ backward_scan , [ most_likely_end ] ] , axis = 0 ) return distribution_util . move_dimension ( most_likely_sequences , 0 , - 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _choose_random_direction ( current_state_parts , batch_rank , seed = None ) : seed_gen = distributions . SeedStream ( seed , salt = '_choose_random_direction' ) # Chooses the random directions across each of the input components. rnd_direction_parts = [ tf . random . normal ( tf . shape ( input = current_state_part ) , dtype = tf . float32 , seed = seed_gen ( ) ) for current_state_part in current_state_parts ] # Sum squares over all of the input components. Note this takes all # components into account. sum_squares = sum ( tf . reduce_sum ( input_tensor = rnd_direction ** 2. , axis = tf . range ( batch_rank , tf . rank ( rnd_direction ) ) , keepdims = True ) for rnd_direction in rnd_direction_parts ) # Normalizes the random direction fragments. rnd_direction_parts = [ rnd_direction / tf . sqrt ( sum_squares ) for rnd_direction in rnd_direction_parts ] return rnd_direction_parts\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sample_next ( target_log_prob_fn , current_state_parts , step_sizes , max_doublings , current_target_log_prob , batch_rank , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'sample_next' , [ current_state_parts , step_sizes , max_doublings , current_target_log_prob , batch_rank ] ) : # First step: Choose a random direction. # Direction is a list of tensors. The i'th tensor should have the same shape # as the i'th state part. direction = _choose_random_direction ( current_state_parts , batch_rank = batch_rank , seed = seed ) # Interpolates the step sizes for the chosen direction. # Applies an ellipsoidal interpolation to compute the step direction for # the chosen direction. Suppose we are given step sizes for each direction. # Label these s_1, s_2, ... s_k. These are the step sizes to use if moving # in a direction parallel to one of the axes. Consider an ellipsoid which # intercepts the i'th axis at s_i. The step size for a direction specified # by the unit vector (n_1, n_2 ...n_k) is then defined as the intersection # of the line through this vector with this ellipsoid. # # One can show that the length of the vector from the origin to the # intersection point is given by: # 1 / sqrt(n_1^2 / s_1^2 + n_2^2 / s_2^2 + ...). # # Proof: # The equation of the ellipsoid is: # Sum_i [x_i^2 / s_i^2 ] = 1. Let n be a unit direction vector. Points # along the line given by n may be parameterized as alpha*n where alpha is # the distance along the vector. Plugging this into the equation for the # ellipsoid, we get: # alpha^2 ( n_1^2 / s_1^2 + n_2^2 / s_2^2 + ...) = 1 # so alpha = \\sqrt { \\frac{1} { ( n_1^2 / s_1^2 + n_2^2 / s_2^2 + ...) } } reduce_axes = [ tf . range ( batch_rank , tf . rank ( dirn_part ) ) for dirn_part in direction ] components = [ tf . reduce_sum ( input_tensor = ( dirn_part / step_size ) ** 2 , axis = reduce_axes [ i ] ) for i , ( step_size , dirn_part ) in enumerate ( zip ( step_sizes , direction ) ) ] step_size = tf . math . rsqrt ( tf . add_n ( components ) ) # Computes the rank of a tensor. Uses the static rank if possible. def _get_rank ( x ) : return ( len ( x . shape . as_list ( ) ) if x . shape . dims is not None else tf . rank ( x ) ) state_part_ranks = [ _get_rank ( part ) for part in current_state_parts ] def _step_along_direction ( alpha ) : \"\"\"Converts the scalar alpha into an n-dim vector with full state info. Computes x_0 + alpha * direction where x_0 is the current state and direction is the direction chosen above. Args: alpha: A tensor of shape equal to the batch dimensions of `current_state_parts`. Returns: state_parts: Tensor or Python list of `Tensor`s representing the state(s) of the Markov chain(s) for a given alpha and a given chosen direction. Has the same shape as `current_state_parts`. \"\"\" padded_alphas = [ _right_pad ( alpha , final_rank = part_rank ) for part_rank in state_part_ranks ] state_parts = [ state_part + padded_alpha * direction_part for state_part , direction_part , padded_alpha in zip ( current_state_parts , direction , padded_alphas ) ] return state_parts def projected_target_log_prob_fn ( alpha ) : \"\"\"The target log density projected along the chosen direction. Args: alpha: A tensor of shape equal to the batch dimensions of `current_state_parts`. Returns: Target log density evaluated at x_0 + alpha * direction where x_0 is the current state and direction is the direction chosen above. Has the same shape as `alpha`. \"\"\" return target_log_prob_fn ( * _step_along_direction ( alpha ) ) alpha_init = tf . zeros_like ( current_target_log_prob , dtype = current_state_parts [ 0 ] . dtype . base_dtype ) [ next_alpha , next_target_log_prob , bounds_satisfied , upper_bounds , lower_bounds ] = ssu . slice_sampler_one_dim ( projected_target_log_prob_fn , x_initial = alpha_init , max_doublings = max_doublings , step_size = step_size , seed = seed ) return [ _step_along_direction ( next_alpha ) , next_target_log_prob , bounds_satisfied , direction , upper_bounds , lower_bounds ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_call_fn ( fn , fn_arg_list , fn_result = None , description = 'target_log_prob' ) : fn_arg_list = ( list ( fn_arg_list ) if mcmc_util . is_list_like ( fn_arg_list ) else [ fn_arg_list ] ) if fn_result is None : fn_result = fn ( * fn_arg_list ) if not fn_result . dtype . is_floating : raise TypeError ( '`{}` must be a `Tensor` with `float` `dtype`.' . format ( description ) ) return fn_result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _right_pad ( x , final_rank ) : padded_shape = tf . concat ( [ tf . shape ( input = x ) , tf . ones ( final_rank - tf . rank ( x ) , dtype = tf . int32 ) ] , axis = 0 ) static_padded_shape = None if x . shape . is_fully_defined ( ) and isinstance ( final_rank , int ) : static_padded_shape = x . shape . as_list ( ) extra_dims = final_rank - len ( static_padded_shape ) static_padded_shape . extend ( [ 1 ] * extra_dims ) padded_x = tf . reshape ( x , static_padded_shape or padded_shape ) return padded_x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_args ( target_log_prob_fn , state , step_size , target_log_prob = None , maybe_expand = False , description = 'target_log_prob' ) : state_parts = list ( state ) if mcmc_util . is_list_like ( state ) else [ state ] state_parts = [ tf . convert_to_tensor ( value = s , name = 'current_state' ) for s in state_parts ] target_log_prob = _maybe_call_fn ( target_log_prob_fn , state_parts , target_log_prob , description ) step_sizes = ( list ( step_size ) if mcmc_util . is_list_like ( step_size ) else [ step_size ] ) step_sizes = [ tf . convert_to_tensor ( value = s , name = 'step_size' , dtype = target_log_prob . dtype ) for s in step_sizes ] if len ( step_sizes ) == 1 : step_sizes *= len ( state_parts ) if len ( state_parts ) != len ( step_sizes ) : raise ValueError ( 'There should be exactly one `step_size` or it should ' 'have same length as `current_state`.' ) def maybe_flatten ( x ) : return x if maybe_expand or mcmc_util . is_list_like ( state ) else x [ 0 ] return [ maybe_flatten ( state_parts ) , maybe_flatten ( step_sizes ) , target_log_prob ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def one_step ( self , current_state , previous_kernel_results ) : with tf . compat . v1 . name_scope ( name = mcmc_util . make_name ( self . name , 'slice' , 'one_step' ) , values = [ self . step_size , self . max_doublings , self . _seed_stream , current_state , previous_kernel_results . target_log_prob ] ) : with tf . compat . v1 . name_scope ( 'initialize' ) : [ current_state_parts , step_sizes , current_target_log_prob ] = _prepare_args ( self . target_log_prob_fn , current_state , self . step_size , previous_kernel_results . target_log_prob , maybe_expand = True ) max_doublings = tf . convert_to_tensor ( value = self . max_doublings , dtype = tf . int32 , name = 'max_doublings' ) independent_chain_ndims = distribution_util . prefer_static_rank ( current_target_log_prob ) [ next_state_parts , next_target_log_prob , bounds_satisfied , direction , upper_bounds , lower_bounds ] = _sample_next ( self . target_log_prob_fn , current_state_parts , step_sizes , max_doublings , current_target_log_prob , independent_chain_ndims , seed = self . _seed_stream ( ) ) def maybe_flatten ( x ) : return x if mcmc_util . is_list_like ( current_state ) else x [ 0 ] return [ maybe_flatten ( next_state_parts ) , SliceSamplerKernelResults ( target_log_prob = next_target_log_prob , bounds_satisfied = bounds_satisfied , direction = direction , upper_bounds = upper_bounds , lower_bounds = lower_bounds ) , ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_uniform_initial_state ( parameter , return_constrained = True , init_sample_shape = ( ) , seed = None ) : unconstrained_prior_sample = parameter . bijector . inverse ( parameter . prior . sample ( init_sample_shape , seed = seed ) ) uniform_initializer = 4 * tf . random . uniform ( tf . shape ( input = unconstrained_prior_sample ) , dtype = unconstrained_prior_sample . dtype , seed = seed ) - 2 if return_constrained : return parameter . bijector . forward ( uniform_initializer ) else : return uniform_initializer\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_trainable_posterior ( param , initial_loc_fn ) : loc = tf . compat . v1 . get_variable ( param . name + '_loc' , initializer = lambda : initial_loc_fn ( param ) , dtype = param . prior . dtype , use_resource = True ) scale = tf . nn . softplus ( tf . compat . v1 . get_variable ( param . name + '_scale' , initializer = lambda : - 4 * tf . ones_like ( initial_loc_fn ( param ) ) , dtype = param . prior . dtype , use_resource = True ) ) q = tfd . Normal ( loc = loc , scale = scale ) # Ensure the `event_shape` of the variational distribution matches the # parameter. if ( param . prior . event_shape . ndims is None or param . prior . event_shape . ndims > 0 ) : q = tfd . Independent ( q , reinterpreted_batch_ndims = param . prior . event_shape . ndims ) # Transform to constrained parameter space. return tfd . TransformedDistribution ( q , param . bijector )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_factored_variational_loss ( model , observed_time_series , init_batch_shape = ( ) , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'build_factored_variational_loss' , values = [ observed_time_series ] ) as name : seed = tfd . SeedStream ( seed , salt = 'StructuralTimeSeries_build_factored_variational_loss' ) variational_distributions = collections . OrderedDict ( ) variational_samples = [ ] for param in model . parameters : def initial_loc_fn ( param ) : return sample_uniform_initial_state ( param , return_constrained = True , init_sample_shape = init_batch_shape , seed = seed ( ) ) q = _build_trainable_posterior ( param , initial_loc_fn = initial_loc_fn ) variational_distributions [ param . name ] = q variational_samples . append ( q . sample ( seed = seed ( ) ) ) # Multiple initializations (similar to HMC chains) manifest as an extra # param batch dimension, so we need to add corresponding batch dimension(s) # to `observed_time_series`. observed_time_series = sts_util . pad_batch_dimension_for_multiple_chains ( observed_time_series , model , chain_batch_shape = init_batch_shape ) # Construct the variational bound. log_prob_fn = model . joint_log_prob ( observed_time_series ) expected_log_joint = log_prob_fn ( * variational_samples ) entropy = tf . reduce_sum ( input_tensor = [ - q . log_prob ( sample ) for ( q , sample ) in zip ( variational_distributions . values ( ) , variational_samples ) ] , axis = 0 ) variational_loss = - ( expected_log_joint + entropy ) # -ELBO return variational_loss , variational_distributions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _minimize_in_graph ( build_loss_fn , num_steps = 200 , optimizer = None ) : optimizer = tf . compat . v1 . train . AdamOptimizer ( 0.1 ) if optimizer is None else optimizer def train_loop_body ( step ) : train_op = optimizer . minimize ( build_loss_fn if tf . executing_eagerly ( ) else build_loss_fn ( ) ) return tf . tuple ( tensors = [ tf . add ( step , 1 ) ] , control_inputs = [ train_op ] ) minimize_op = tf . compat . v1 . while_loop ( cond = lambda step : step < num_steps , body = train_loop_body , loop_vars = [ tf . constant ( 0 ) ] , return_same_structure = True ) [ 0 ] # Always return a single op. return minimize_op\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fit_with_hmc ( model , observed_time_series , num_results = 100 , num_warmup_steps = 50 , num_leapfrog_steps = 15 , initial_state = None , initial_step_size = None , chain_batch_shape = ( ) , num_variational_steps = 150 , variational_optimizer = None , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'fit_with_hmc' , values = [ observed_time_series ] ) as name : seed = tfd . SeedStream ( seed , salt = 'StructuralTimeSeries_fit_with_hmc' ) # Initialize state and step sizes from a variational posterior if not # specified. if initial_step_size is None or initial_state is None : # To avoid threading variational distributions through the training # while loop, we build our own copy here. `make_template` ensures # that our variational distributions share the optimized parameters. def make_variational ( ) : return build_factored_variational_loss ( model , observed_time_series , init_batch_shape = chain_batch_shape , seed = seed ( ) ) make_variational = tf . compat . v1 . make_template ( 'make_variational' , make_variational ) _ , variational_distributions = make_variational ( ) minimize_op = _minimize_in_graph ( build_loss_fn = lambda : make_variational ( ) [ 0 ] , # return just the loss. num_steps = num_variational_steps , optimizer = variational_optimizer ) with tf . control_dependencies ( [ minimize_op ] ) : if initial_state is None : initial_state = [ tf . stop_gradient ( d . sample ( ) ) for d in variational_distributions . values ( ) ] # Set step sizes using the unconstrained variational distribution. if initial_step_size is None : initial_step_size = [ transformed_q . distribution . stddev ( ) for transformed_q in variational_distributions . values ( ) ] # Multiple chains manifest as an extra param batch dimension, so we need to # add a corresponding batch dimension to `observed_time_series`. observed_time_series = sts_util . pad_batch_dimension_for_multiple_chains ( observed_time_series , model , chain_batch_shape = chain_batch_shape ) # Run HMC to sample from the posterior on parameters. samples , kernel_results = mcmc . sample_chain ( num_results = num_results , current_state = initial_state , num_burnin_steps = num_warmup_steps , kernel = mcmc . SimpleStepSizeAdaptation ( inner_kernel = mcmc . TransformedTransitionKernel ( inner_kernel = mcmc . HamiltonianMonteCarlo ( target_log_prob_fn = model . joint_log_prob ( observed_time_series ) , step_size = initial_step_size , num_leapfrog_steps = num_leapfrog_steps , state_gradients_are_stopped = True , seed = seed ( ) ) , bijector = [ param . bijector for param in model . parameters ] ) , num_adaptation_steps = int ( num_warmup_steps * 0.8 ) , adaptation_rate = tf . convert_to_tensor ( value = 0.1 , dtype = initial_state [ 0 ] . dtype ) ) , parallel_iterations = 1 if seed is not None else 10 ) return samples , kernel_results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def moments_of_masked_time_series ( time_series_tensor , broadcast_mask ) : num_unmasked_entries = tf . cast ( tf . reduce_sum ( input_tensor = tf . cast ( ~ broadcast_mask , tf . int32 ) , axis = - 1 ) , time_series_tensor . dtype ) # Manually compute mean and variance, excluding masked entries. mean = ( tf . reduce_sum ( input_tensor = tf . where ( broadcast_mask , tf . zeros_like ( time_series_tensor ) , time_series_tensor ) , axis = - 1 ) / num_unmasked_entries ) variance = ( tf . reduce_sum ( input_tensor = tf . where ( broadcast_mask , tf . zeros_like ( time_series_tensor ) , ( time_series_tensor - mean [ ... , tf . newaxis ] ) ** 2 ) , axis = - 1 ) / num_unmasked_entries ) return mean , variance\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def initial_value_of_masked_time_series ( time_series_tensor , broadcast_mask ) : num_timesteps = tf . shape ( input = time_series_tensor ) [ - 1 ] # Compute the index of the first unmasked entry for each series in the batch. unmasked_negindices = ( tf . cast ( ~ broadcast_mask , tf . int32 ) * tf . range ( num_timesteps , 0 , - 1 ) ) first_unmasked_indices = num_timesteps - tf . reduce_max ( input_tensor = unmasked_negindices , axis = - 1 ) if first_unmasked_indices . shape . ndims is None : raise NotImplementedError ( 'Cannot compute initial values of a masked time series with' 'dynamic rank.' ) # `batch_gather` requires static rank # Extract the initial value for each series in the batch. return tf . squeeze ( tf . compat . v1 . batch_gather ( params = time_series_tensor , indices = first_unmasked_indices [ ... , tf . newaxis ] ) , axis = - 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def broadcast_batch_shape ( distributions ) : # Static case batch_shape = distributions [ 0 ] . batch_shape for distribution in distributions : batch_shape = tf . broadcast_static_shape ( batch_shape , distribution . batch_shape ) if batch_shape . is_fully_defined ( ) : return batch_shape . as_list ( ) # Fallback on dynamic. batch_shape = distributions [ 0 ] . batch_shape_tensor ( ) for distribution in distributions : batch_shape = tf . broadcast_dynamic_shape ( batch_shape , distribution . batch_shape_tensor ( ) ) return tf . convert_to_tensor ( value = batch_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pad_batch_dimension_for_multiple_chains ( observed_time_series , model , chain_batch_shape ) : # Running with multiple chains introduces an extra batch dimension. In # general we also need to pad the observed time series with a matching batch # dimension. # # For example, suppose our model has batch shape [3, 4] and # the observed time series has shape `concat([[5], [3, 4], [100])`, # corresponding to `sample_shape`, `batch_shape`, and `num_timesteps` # respectively. The model will produce distributions with batch shape # `concat([chain_batch_shape, [3, 4]])`, so we pad `observed_time_series` to # have matching shape `[5, 1, 3, 4, 100]`, where the added `1` dimension # between the sample and batch shapes will broadcast to `chain_batch_shape`. [ # Extract mask and guarantee `event_ndims=2`. observed_time_series , is_missing ] = canonicalize_observed_time_series_with_mask ( observed_time_series ) event_ndims = 2 # event_shape = [num_timesteps, observation_size=1] model_batch_ndims = ( model . batch_shape . ndims if model . batch_shape . ndims is not None else tf . shape ( input = model . batch_shape_tensor ( ) ) [ 0 ] ) # Compute ndims from chain_batch_shape. chain_batch_shape = tf . convert_to_tensor ( value = chain_batch_shape , name = 'chain_batch_shape' , dtype = tf . int32 ) if not chain_batch_shape . shape . is_fully_defined ( ) : raise ValueError ( 'Batch shape must have static rank. (given: {})' . format ( chain_batch_shape ) ) if chain_batch_shape . shape . ndims == 0 : # expand int `k` to `[k]`. chain_batch_shape = chain_batch_shape [ tf . newaxis ] chain_batch_ndims = tf . compat . dimension_value ( chain_batch_shape . shape [ 0 ] ) def do_padding ( observed_time_series_tensor ) : current_sample_shape = tf . shape ( input = observed_time_series_tensor ) [ : - ( model_batch_ndims + event_ndims ) ] current_batch_and_event_shape = tf . shape ( input = observed_time_series_tensor ) [ - ( model_batch_ndims + event_ndims ) : ] return tf . reshape ( tensor = observed_time_series_tensor , shape = tf . concat ( [ current_sample_shape , tf . ones ( [ chain_batch_ndims ] , dtype = tf . int32 ) , current_batch_and_event_shape ] , axis = 0 ) ) # Padding is only needed if the observed time series has sample shape. observed_time_series = prefer_static . cond ( ( dist_util . prefer_static_rank ( observed_time_series ) > model_batch_ndims + event_ndims ) , lambda : do_padding ( observed_time_series ) , lambda : observed_time_series ) if is_missing is not None : is_missing = prefer_static . cond ( ( dist_util . prefer_static_rank ( is_missing ) > model_batch_ndims + event_ndims ) , lambda : do_padding ( is_missing ) , lambda : is_missing ) return missing_values_util . MaskedTimeSeries ( observed_time_series , is_missing = is_missing ) return observed_time_series\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def factored_joint_mvn ( distributions ) : graph_parents = [ tensor for distribution in distributions for tensor in distribution . _graph_parents ] # pylint: disable=protected-access with tf . compat . v1 . name_scope ( 'factored_joint_mvn' , values = graph_parents ) : # We explicitly broadcast the `locs` so that we can concatenate them. # We don't have direct numerical access to the `scales`, which are arbitrary # linear operators, but `LinearOperatorBlockDiag` appears to do the right # thing without further intervention. dtype = tf . debugging . assert_same_float_dtype ( distributions ) broadcast_ones = tf . ones ( broadcast_batch_shape ( distributions ) , dtype = dtype ) [ ... , tf . newaxis ] return MultivariateNormalLinearOperator ( loc = tf . concat ( [ mvn . mean ( ) * broadcast_ones for mvn in distributions ] , axis = - 1 ) , scale = tfl . LinearOperatorBlockDiag ( [ mvn . scale for mvn in distributions ] , is_square = True ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sum_mvns ( distributions ) : graph_parents = [ tensor for distribution in distributions for tensor in distribution . _graph_parents ] # pylint: disable=protected-access with tf . compat . v1 . name_scope ( 'sum_mvns' , values = graph_parents ) : if all ( [ isinstance ( mvn , tfd . MultivariateNormalDiag ) for mvn in distributions ] ) : return tfd . MultivariateNormalDiag ( loc = sum ( [ mvn . mean ( ) for mvn in distributions ] ) , scale_diag = tf . sqrt ( sum ( [ mvn . scale . diag ** 2 for mvn in distributions ] ) ) ) else : raise NotImplementedError ( 'Sums of distributions other than MultivariateNormalDiag are not ' 'currently implemented. (given: {})' . format ( distributions ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def empirical_statistics ( observed_time_series ) : with tf . compat . v1 . name_scope ( 'empirical_statistics' , values = [ observed_time_series ] ) : [ observed_time_series , mask ] = canonicalize_observed_time_series_with_mask ( observed_time_series ) squeezed_series = observed_time_series [ ... , 0 ] if mask is None : observed_mean , observed_variance = tf . nn . moments ( x = squeezed_series , axes = - 1 ) observed_initial = squeezed_series [ ... , 0 ] else : broadcast_mask = tf . broadcast_to ( tf . cast ( mask , tf . bool ) , tf . shape ( input = squeezed_series ) ) observed_mean , observed_variance = ( missing_values_util . moments_of_masked_time_series ( squeezed_series , broadcast_mask = broadcast_mask ) ) try : observed_initial = ( missing_values_util . initial_value_of_masked_time_series ( squeezed_series , broadcast_mask = broadcast_mask ) ) except NotImplementedError : tf . compat . v1 . logging . warn ( 'Cannot compute initial values for a masked time series' 'with dynamic shape; using the mean instead. This will' 'affect heuristic priors and may change the results of' 'inference.' ) observed_initial = observed_mean observed_stddev = tf . sqrt ( observed_variance ) observed_initial_centered = observed_initial - observed_mean return observed_mean , observed_stddev , observed_initial_centered\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_expand_trailing_dim ( observed_time_series_tensor ) : with tf . compat . v1 . name_scope ( 'maybe_expand_trailing_dim' , values = [ observed_time_series_tensor ] ) : if ( observed_time_series_tensor . shape . ndims is not None and tf . compat . dimension_value ( observed_time_series_tensor . shape [ - 1 ] ) is not None ) : expanded_time_series = ( observed_time_series_tensor if observed_time_series_tensor . shape [ - 1 ] == 1 else observed_time_series_tensor [ ... , tf . newaxis ] ) else : expanded_time_series = tf . cond ( pred = tf . equal ( tf . shape ( input = observed_time_series_tensor ) [ - 1 ] , 1 ) , true_fn = lambda : observed_time_series_tensor , false_fn = lambda : observed_time_series_tensor [ ... , tf . newaxis ] ) return expanded_time_series\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def canonicalize_observed_time_series_with_mask ( maybe_masked_observed_time_series ) : with tf . compat . v1 . name_scope ( 'canonicalize_observed_time_series_with_mask' ) : if hasattr ( maybe_masked_observed_time_series , 'is_missing' ) : observed_time_series = ( maybe_masked_observed_time_series . time_series ) is_missing = maybe_masked_observed_time_series . is_missing else : observed_time_series = maybe_masked_observed_time_series is_missing = None observed_time_series = tf . convert_to_tensor ( value = observed_time_series , name = 'observed_time_series' ) observed_time_series = _maybe_expand_trailing_dim ( observed_time_series ) if is_missing is not None : is_missing = tf . convert_to_tensor ( value = is_missing , name = 'is_missing' , dtype_hint = tf . bool ) return missing_values_util . MaskedTimeSeries ( observed_time_series , is_missing = is_missing )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def mix_over_posterior_draws ( means , variances ) : # The inputs `means`, `variances` have shape # `concat([ # [num_posterior_draws], # sample_shape, # batch_shape, # [num_timesteps]])` # Because MixtureSameFamily mixes over the rightmost batch dimension, # we need to move the `num_posterior_draws` dimension to be rightmost # in the batch shape. This requires use of `Independent` (to preserve # `num_timesteps` as part of the event shape) and `move_dimension`. # TODO(b/120245392): enhance `MixtureSameFamily` to reduce along an # arbitrary axis, and eliminate `move_dimension` calls here. with tf . compat . v1 . name_scope ( 'mix_over_posterior_draws' , values = [ means , variances ] ) : num_posterior_draws = dist_util . prefer_static_value ( tf . shape ( input = means ) ) [ 0 ] component_observations = tfd . Independent ( distribution = tfd . Normal ( loc = dist_util . move_dimension ( means , 0 , - 2 ) , scale = tf . sqrt ( dist_util . move_dimension ( variances , 0 , - 2 ) ) ) , reinterpreted_batch_ndims = 1 ) return tfd . MixtureSameFamily ( mixture_distribution = tfd . Categorical ( logits = tf . zeros ( [ num_posterior_draws ] , dtype = component_observations . dtype ) ) , components_distribution = component_observations )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_uniform_uniform ( a , b , name = None ) : with tf . name_scope ( name or \"kl_uniform_uniform\" ) : # Consistent with # http://www.mast.queensu.ca/~communications/Papers/gil-msc11.pdf, page 60 # Watch out for the change in conventions--they use 'a' and 'b' to refer to # lower and upper bounds respectively there. final_batch_shape = distribution_util . get_broadcast_shape ( a . low , b . low , a . high , b . high ) dtype = dtype_util . common_dtype ( [ a . low , a . high , b . low , b . high ] , tf . float32 ) return tf . where ( ( b . low <= a . low ) & ( a . high <= b . high ) , tf . math . log ( b . high - b . low ) - tf . math . log ( a . high - a . low ) , tf . broadcast_to ( dtype_util . as_numpy_dtype ( dtype ) ( np . inf ) , final_batch_shape ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def range ( self , name = \"range\" ) : with self . _name_scope ( name ) : return self . high - self . low\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_summary_statistic ( attr ) : def _fn ( self ) : if any ( self . _dist_fn_args ) : # pylint: disable=protected-access raise ValueError ( 'Can only compute ' + attr + ' when all distributions are ' 'independent; {}' . format ( self . model ) ) return self . _unflatten ( getattr ( d ( ) , attr ) ( ) for d in self . _dist_fn_wrapped ) # pylint: disable=protected-access return _fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _unify_call_signature ( i , dist_fn ) : if distribution_util . is_distribution_instance ( dist_fn ) : return ( lambda * _ : dist_fn ) , None if not callable ( dist_fn ) : raise TypeError ( '{} must be either `tfd.Distribution`-like or ' '`callable`.' . format ( dist_fn ) ) args = _get_required_args ( dist_fn ) if not args : return ( lambda * _ : dist_fn ( ) ) , ( ) @ functools . wraps ( dist_fn ) def dist_fn_wrapped ( * xs ) : \"\"\"Calls `dist_fn` with reversed and truncated args.\"\"\" if i != len ( xs ) : raise ValueError ( 'Internal Error: Unexpected number of inputs provided to {}-th ' 'distribution maker (dist_fn: {}, expected: {}, saw: {}).' . format ( i , dist_fn , i , len ( xs ) ) ) if len ( xs ) < len ( args ) : raise ValueError ( 'Internal Error: Too few inputs provided to {}-th distribution maker ' '(dist_fn: {}, expected: {}, saw: {}).' . format ( i , dist_fn , len ( args ) , len ( xs ) ) ) return dist_fn ( * reversed ( xs [ - len ( args ) : ] ) ) return dist_fn_wrapped , args\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _resolve_distribution_names ( dist_fn_args , dist_names , leaf_name ) : if dist_names is None : dist_names = [ ] else : dist_names = dist_names . copy ( ) n = len ( dist_fn_args ) dist_names . extend ( [ None ] * ( n - len ( dist_names ) ) ) for i_ , args in enumerate ( reversed ( dist_fn_args ) ) : if not args : continue # There's no args to analyze. i = n - i_ - 1 for j , arg_name in enumerate ( args ) : dist_names [ i - j - 1 ] = arg_name j = 0 for i_ in range ( len ( dist_names ) ) : i = n - i_ - 1 if dist_names [ i ] is None : dist_names [ i ] = leaf_name if j == 0 else leaf_name + str ( j ) j += 1 return tuple ( dist_names )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_required_args ( fn ) : argspec = tf_inspect . getfullargspec ( fn ) args = argspec . args if tf_inspect . isclass ( fn ) : args = args [ 1 : ] # Remove the `self` arg. if argspec . defaults : # Remove the args which have defaults. By convention we only feed # *required args*. This means some distributions must always be wrapped # with a `lambda`, e.g., `lambda logits: tfd.Bernoulli(logits=logits)` # or `lambda probs: tfd.Bernoulli(probs=probs)`. args = args [ : - len ( argspec . defaults ) ] return tuple ( args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_joint_joint ( d0 , d1 , name = None ) : if len ( d0 . _dist_fn_wrapped ) != len ( d1 . _dist_fn_wrapped ) : # pylint: disable=protected-access raise ValueError ( 'Can only compute KL divergence between when each has the' 'same number of component distributions.' ) if ( not all ( a is None for a in d0 . _dist_fn_args ) or # pylint: disable=protected-access not all ( a is None for a in d1 . _dist_fn_args ) ) : # pylint: disable=protected-access raise ValueError ( 'Can only compute KL divergence when all distributions are ' 'independent.' ) with tf . name_scope ( name or 'kl_jointseq_jointseq' ) : return sum ( kullback_leibler . kl_divergence ( d0_ ( ) , d1_ ( ) ) for d0_ , d1_ in zip ( d0 . _dist_fn_wrapped , d1 . _dist_fn_wrapped ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build ( self , model ) : if not isinstance ( model , collections . Sequence ) : raise TypeError ( '`model` must be `list`-like (saw: {}).' . format ( type ( model ) . __name__ ) ) self . _dist_fn = model self . _dist_fn_wrapped , self . _dist_fn_args = zip ( * [ _unify_call_signature ( i , dist_fn ) for i , dist_fn in enumerate ( model ) ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _resolve_graph ( self , distribution_names = None , leaf_name = 'x' ) : # This function additionally depends on: # self._dist_fn_args # self._dist_fn_wrapped # TODO(b/129008220): Robustify this procedure. Eg, handle collisions better, # ignore args prefixed with `_`. if distribution_names is None or any ( self . _dist_fn_args ) : distribution_names = _resolve_distribution_names ( self . _dist_fn_args , distribution_names , leaf_name ) if len ( set ( distribution_names ) ) != len ( distribution_names ) : raise ValueError ( 'Distribution names must be unique: {}' . format ( distribution_names ) ) if len ( distribution_names ) != len ( self . _dist_fn_wrapped ) : raise ValueError ( 'Distribution names must be 1:1 with `rvs`.' ) return tuple ( zip ( distribution_names , tuple ( ( ) if a is None else a for a in self . _dist_fn_args ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _entropy ( self ) : if any ( self . _dist_fn_args ) : raise ValueError ( 'Can only compute entropy when all distributions are independent.' ) return sum ( joint_distribution_lib . maybe_check_wont_broadcast ( ( d ( ) . entropy ( ) for d in self . _dist_fn_wrapped ) , self . validate_args ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def check_arg_in_support ( f ) : @ functools . wraps ( f ) def _check_arg_and_apply_f ( * args , * * kwargs ) : dist = args [ 0 ] x = args [ 1 ] with tf . control_dependencies ( [ assert_util . assert_greater_equal ( x , dist . loc , message = \"x is not in the support of the distribution\" ) ] if dist . validate_args else [ ] ) : return f ( * args , * * kwargs ) return _check_arg_and_apply_f\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _extend_support_with_default_value ( self , x , f , default_value ) : with tf . name_scope ( \"extend_support_with_default_value\" ) : x = tf . convert_to_tensor ( value = x , dtype = self . dtype , name = \"x\" ) loc = self . loc + tf . zeros_like ( self . scale ) + tf . zeros_like ( x ) x = x + tf . zeros_like ( loc ) # Substitute out-of-support values in x with values that are in the # support of the distribution before applying f. y = f ( tf . where ( x < loc , self . _inv_z ( 0.5 ) + tf . zeros_like ( x ) , x ) ) if default_value == 0. : default_value = tf . zeros_like ( y ) elif default_value == 1. : default_value = tf . ones_like ( y ) else : default_value = tf . fill ( dims = tf . shape ( input = y ) , value = dtype_util . as_numpy_dtype ( self . dtype ) ( default_value ) ) return tf . where ( x < loc , default_value , y )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_args ( log_likelihood_fn , state , log_likelihood = None , description = 'log_likelihood' ) : state_parts = list ( state ) if mcmc_util . is_list_like ( state ) else [ state ] state_parts = [ tf . convert_to_tensor ( s , name = 'current_state' ) for s in state_parts ] log_likelihood = _maybe_call_fn ( log_likelihood_fn , state_parts , log_likelihood , description ) return [ state_parts , log_likelihood ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def one_step ( self , current_state , previous_kernel_results ) : with tf . compat . v1 . name_scope ( name = mcmc_util . make_name ( self . name , 'elliptical_slice' , 'one_step' ) , values = [ self . _seed_stream , current_state , previous_kernel_results . log_likelihood ] ) : with tf . compat . v1 . name_scope ( 'initialize' ) : [ init_state_parts , init_log_likelihood ] = _prepare_args ( self . log_likelihood_fn , current_state , previous_kernel_results . log_likelihood ) normal_samples = self . normal_sampler_fn ( self . _seed_stream ( ) ) # pylint: disable=not-callable normal_samples = list ( normal_samples ) if mcmc_util . is_list_like ( normal_samples ) else [ normal_samples ] u = tf . random . uniform ( shape = tf . shape ( init_log_likelihood ) , seed = self . _seed_stream ( ) , dtype = init_log_likelihood . dtype . base_dtype , ) threshold = init_log_likelihood + tf . math . log ( u ) starting_angle = tf . random . uniform ( shape = tf . shape ( init_log_likelihood ) , minval = 0. , maxval = 2 * np . pi , name = 'angle' , seed = self . _seed_stream ( ) , dtype = init_log_likelihood . dtype . base_dtype , ) starting_angle_min = starting_angle - 2 * np . pi starting_angle_max = starting_angle starting_state_parts = _rotate_on_ellipse ( init_state_parts , normal_samples , starting_angle ) starting_log_likelihood = self . log_likelihood_fn ( * starting_state_parts ) # pylint: disable=not-callable def chain_not_done ( angle , angle_min , angle_max , current_state_parts , current_log_likelihood ) : del angle , angle_min , angle_max , current_state_parts return tf . reduce_any ( current_log_likelihood < threshold ) def sample_next_angle ( angle , angle_min , angle_max , current_state_parts , current_log_likelihood ) : \"\"\"Slice sample a new angle, and rotate init_state by that amount.\"\"\" chain_not_done = current_log_likelihood < threshold # Box in on angle. Only update angles for which we haven't generated a # point that beats the threshold. angle_min = tf . where ( tf . math . logical_and ( angle < 0 , chain_not_done ) , angle , angle_min ) angle_max = tf . where ( tf . math . logical_and ( angle >= 0 , chain_not_done ) , angle , angle_max ) new_angle = tf . random . uniform ( shape = tf . shape ( current_log_likelihood ) , minval = angle_min , maxval = angle_max , seed = self . _seed_stream ( ) , dtype = angle . dtype . base_dtype ) angle = tf . where ( chain_not_done , new_angle , angle ) next_state_parts = _rotate_on_ellipse ( init_state_parts , normal_samples , angle ) new_state_parts = [ ] broadcasted_chain_not_done = _right_pad_with_ones ( chain_not_done , tf . rank ( next_state_parts [ 0 ] ) ) for n_state , c_state in zip ( next_state_parts , current_state_parts ) : new_state_part = tf . where ( tf . broadcast_to ( broadcasted_chain_not_done , tf . shape ( n_state ) ) , n_state , c_state ) new_state_parts . append ( new_state_part ) return ( angle , angle_min , angle_max , new_state_parts , self . log_likelihood_fn ( * new_state_parts ) # pylint: disable=not-callable ) [ next_angle , _ , _ , next_state_parts , next_log_likelihood , ] = tf . while_loop ( cond = chain_not_done , body = sample_next_angle , loop_vars = [ starting_angle , starting_angle_min , starting_angle_max , starting_state_parts , starting_log_likelihood ] ) return [ next_state_parts if mcmc_util . is_list_like ( current_state ) else next_state_parts [ 0 ] , EllipticalSliceSamplerKernelResults ( log_likelihood = next_log_likelihood , angle = next_angle , normal_samples = normal_samples , ) , ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def image_summary ( seqs , name , num = None ) : seqs = tf . clip_by_value ( seqs , 0. , 1. ) seqs = tf . unstack ( seqs [ : num ] ) joined_seqs = [ tf . concat ( tf . unstack ( seq ) , 1 ) for seq in seqs ] joined_seqs = tf . expand_dims ( tf . concat ( joined_seqs , 0 ) , 0 ) tf . compat . v2 . summary . image ( name , joined_seqs , max_outputs = 1 , step = tf . compat . v1 . train . get_or_create_global_step ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def visualize_reconstruction ( inputs , reconstruct , num = 3 , name = \"reconstruction\" ) : reconstruct = tf . clip_by_value ( reconstruct , 0. , 1. ) inputs_and_reconstruct = tf . concat ( ( inputs [ : num ] , reconstruct [ : num ] ) , axis = 0 ) image_summary ( inputs_and_reconstruct , name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def visualize_qualitative_analysis ( inputs , model , samples = 1 , batch_size = 3 , length = 8 ) : average = lambda dist : tf . reduce_mean ( input_tensor = dist . mean ( ) , axis = 0 ) # avg over samples with tf . compat . v1 . name_scope ( \"val_reconstruction\" ) : reconstruct = functools . partial ( model . reconstruct , inputs = inputs , samples = samples ) visualize_reconstruction ( inputs , average ( reconstruct ( ) ) ) visualize_reconstruction ( inputs , average ( reconstruct ( sample_static = True ) ) , name = \"static_prior\" ) visualize_reconstruction ( inputs , average ( reconstruct ( sample_dynamic = True ) ) , name = \"dynamic_prior\" ) visualize_reconstruction ( inputs , average ( reconstruct ( swap_static = True ) ) , name = \"swap_static\" ) visualize_reconstruction ( inputs , average ( reconstruct ( swap_dynamic = True ) ) , name = \"swap_dynamic\" ) with tf . compat . v1 . name_scope ( \"generation\" ) : generate = functools . partial ( model . generate , batch_size = batch_size , length = length , samples = samples ) image_summary ( average ( generate ( fix_static = True ) ) , \"fix_static\" ) image_summary ( average ( generate ( fix_dynamic = True ) ) , \"fix_dynamic\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def summarize_dist_params ( dist , name , name_scope = \"dist_params\" ) : with tf . compat . v1 . name_scope ( name_scope ) : tf . compat . v2 . summary . histogram ( name = \"{}/{}\" . format ( name , \"mean\" ) , data = dist . mean ( ) , step = tf . compat . v1 . train . get_or_create_global_step ( ) ) tf . compat . v2 . summary . histogram ( name = \"{}/{}\" . format ( name , \"stddev\" ) , data = dist . stddev ( ) , step = tf . compat . v1 . train . get_or_create_global_step ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def summarize_mean_in_nats_and_bits ( inputs , units , name , nats_name_scope = \"nats\" , bits_name_scope = \"bits_per_dim\" ) : mean = tf . reduce_mean ( input_tensor = inputs ) with tf . compat . v1 . name_scope ( nats_name_scope ) : tf . compat . v2 . summary . scalar ( name , mean , step = tf . compat . v1 . train . get_or_create_global_step ( ) ) with tf . compat . v1 . name_scope ( bits_name_scope ) : tf . compat . v2 . summary . scalar ( name , mean / units / tf . math . log ( 2. ) , step = tf . compat . v1 . train . get_or_create_global_step ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call ( self , inputs ) : del inputs # unused with tf . compat . v1 . name_scope ( self . _name ) : return tfd . MultivariateNormalDiag ( self . loc , self . scale_diag )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def zero_state ( self , sample_batch_shape = ( ) ) : h0 = tf . zeros ( [ 1 , self . hidden_size ] ) c0 = tf . zeros ( [ 1 , self . hidden_size ] ) combined_shape = tf . concat ( ( tf . convert_to_tensor ( value = sample_batch_shape , dtype = tf . int32 ) , [ self . dimensions ] ) , axis = - 1 ) previous_output = tf . zeros ( combined_shape ) return previous_output , ( h0 , c0 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call ( self , inputs , state ) : # In order to allow the user to pass in a single example without a batch # dimension, we always expand the input to at least two dimensions, then # fix the output shape to remove the batch dimension if necessary. original_shape = inputs . shape if len ( original_shape ) < 2 : inputs = tf . reshape ( inputs , [ 1 , - 1 ] ) out , state = self . lstm_cell ( inputs , state ) out = self . output_layer ( out ) correct_shape = tf . concat ( ( original_shape [ : - 1 ] , tf . shape ( input = out ) [ - 1 : ] ) , 0 ) out = tf . reshape ( out , correct_shape ) loc = out [ ... , : self . dimensions ] scale_diag = tf . nn . softplus ( out [ ... , self . dimensions : ] ) + 1e-5 # keep > 0 return tfd . MultivariateNormalDiag ( loc = loc , scale_diag = scale_diag ) , state\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call ( self , inputs ) : # We explicitly broadcast f to the same shape as z other than the final # dimension, because `tf.concat` can't automatically do this. dynamic , static = inputs timesteps = tf . shape ( input = dynamic ) [ - 2 ] static = static [ ... , tf . newaxis , : ] + tf . zeros ( [ timesteps , 1 ] ) latents = tf . concat ( [ dynamic , static ] , axis = - 1 ) # (sample, N, T, latents) out = self . dense ( latents ) out = tf . reshape ( out , ( - 1 , 1 , 1 , self . hidden_size ) ) out = self . conv_transpose1 ( out ) out = self . conv_transpose2 ( out ) out = self . conv_transpose3 ( out ) out = self . conv_transpose4 ( out ) # (sample*N*T, h, w, c) expanded_shape = tf . concat ( ( tf . shape ( input = latents ) [ : - 1 ] , tf . shape ( input = out ) [ 1 : ] ) , axis = 0 ) out = tf . reshape ( out , expanded_shape ) # (sample, N, T, h, w, c) return tfd . Independent ( distribution = tfd . Normal ( loc = out , scale = 1. ) , reinterpreted_batch_ndims = 3 , # wrap (h, w, c) name = \"decoded_image\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call ( self , inputs ) : image_shape = tf . shape ( input = inputs ) [ - 3 : ] collapsed_shape = tf . concat ( ( [ - 1 ] , image_shape ) , axis = 0 ) out = tf . reshape ( inputs , collapsed_shape ) # (sample*batch*T, h, w, c) out = self . conv1 ( out ) out = self . conv2 ( out ) out = self . conv3 ( out ) out = self . conv4 ( out ) expanded_shape = tf . concat ( ( tf . shape ( input = inputs ) [ : - 3 ] , [ - 1 ] ) , axis = 0 ) return tf . reshape ( out , expanded_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call ( self , inputs ) : # TODO(dusenberrymw): Remove these reshaping commands after b/113126249 is # fixed. collapsed_shape = tf . concat ( ( [ - 1 ] , tf . shape ( input = inputs ) [ - 2 : ] ) , axis = 0 ) out = tf . reshape ( inputs , collapsed_shape ) # (sample*batch_size, T, hidden) out = self . bilstm ( out ) # (sample*batch_size, hidden) expanded_shape = tf . concat ( ( tf . shape ( input = inputs ) [ : - 2 ] , [ - 1 ] ) , axis = 0 ) out = tf . reshape ( out , expanded_shape ) # (sample, batch_size, hidden) out = self . output_layer ( out ) # (sample, batch_size, 2*latent_size) loc = out [ ... , : self . latent_size ] scale_diag = tf . nn . softplus ( out [ ... , self . latent_size : ] ) + 1e-5 # keep > 0 return tfd . MultivariateNormalDiag ( loc = loc , scale_diag = scale_diag )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call ( self , inputs ) : out = self . dense ( inputs ) # (..., batch, time, hidden) out = self . output_layer ( out ) # (..., batch, time, 2*latent) loc = out [ ... , : self . latent_size ] scale_diag = tf . nn . softplus ( out [ ... , self . latent_size : ] ) + 1e-5 # keep > 0 return tfd . MultivariateNormalDiag ( loc = loc , scale_diag = scale_diag )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call ( self , inputs ) : # We explicitly broadcast `x` and `f` to the same shape other than the final # dimension, because `tf.concat` can't automatically do this. This will # entail adding a `timesteps` dimension to `f` to give the shape `(..., # batch, timesteps, latent)`, and then broadcasting the sample shapes of # both tensors to the same shape. features , static_sample = inputs length = tf . shape ( input = features ) [ - 2 ] static_sample = static_sample [ ... , tf . newaxis , : ] + tf . zeros ( [ length , 1 ] ) sample_shape_static = tf . shape ( input = static_sample ) [ : - 3 ] sample_shape_inputs = tf . shape ( input = features ) [ : - 3 ] broadcast_shape_inputs = tf . concat ( ( sample_shape_static , [ 1 , 1 , 1 ] ) , 0 ) broadcast_shape_static = tf . concat ( ( sample_shape_inputs , [ 1 , 1 , 1 ] ) , 0 ) features = features + tf . zeros ( broadcast_shape_inputs ) static_sample = static_sample + tf . zeros ( broadcast_shape_static ) # `combined` will have shape (..., batch, T, hidden+latent). combined = tf . concat ( ( features , static_sample ) , axis = - 1 ) # TODO(dusenberrymw): Remove these reshaping commands after b/113126249 is # fixed. collapsed_shape = tf . concat ( ( [ - 1 ] , tf . shape ( input = combined ) [ - 2 : ] ) , axis = 0 ) out = tf . reshape ( combined , collapsed_shape ) out = self . bilstm ( out ) # (sample*batch, T, hidden_size) out = self . rnn ( out ) # (sample*batch, T, hidden_size) expanded_shape = tf . concat ( ( tf . shape ( input = combined ) [ : - 2 ] , tf . shape ( input = out ) [ 1 : ] ) , axis = 0 ) out = tf . reshape ( out , expanded_shape ) # (sample, batch, T, hidden_size) out = self . output_layer ( out ) # (sample, batch, T, 2*latent_size) loc = out [ ... , : self . latent_size ] scale_diag = tf . nn . softplus ( out [ ... , self . latent_size : ] ) + 1e-5 # keep > 0 return tfd . MultivariateNormalDiag ( loc = loc , scale_diag = scale_diag )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def generate ( self , batch_size , length , samples = 1 , fix_static = False , fix_dynamic = False ) : static_sample , _ = self . sample_static_prior ( samples , batch_size , fix_static ) dynamic_sample , _ = self . sample_dynamic_prior ( samples , batch_size , length , fix_dynamic ) likelihood = self . decoder ( ( dynamic_sample , static_sample ) ) return likelihood\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def reconstruct ( self , inputs , samples = 1 , sample_static = False , sample_dynamic = False , swap_static = False , swap_dynamic = False , fix_static = False , fix_dynamic = False ) : batch_size = tf . shape ( input = inputs ) [ - 5 ] length = len ( tf . unstack ( inputs , axis = - 4 ) ) # hack for graph mode features = self . compressor ( inputs ) # (..., batch, timesteps, hidden) if sample_static : static_sample , _ = self . sample_static_prior ( samples , batch_size , fix_static ) else : static_sample , _ = self . sample_static_posterior ( features , samples ) if swap_static : static_sample = tf . reverse ( static_sample , axis = [ 1 ] ) if sample_dynamic : dynamic_sample , _ = self . sample_dynamic_prior ( samples , batch_size , length , fix_dynamic ) else : dynamic_sample , _ = self . sample_dynamic_posterior ( features , samples , static_sample ) if swap_dynamic : dynamic_sample = tf . reverse ( dynamic_sample , axis = [ 1 ] ) likelihood = self . decoder ( ( dynamic_sample , static_sample ) ) return likelihood\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_static_prior ( self , samples , batch_size , fixed = False ) : dist = self . static_prior ( ) if fixed : # in either case, shape is (samples, batch, latent) sample = dist . sample ( ( samples , 1 ) ) + tf . zeros ( [ batch_size , 1 ] ) else : sample = dist . sample ( ( samples , batch_size ) ) return sample , dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_static_posterior ( self , inputs , samples ) : dist = self . static_encoder ( inputs ) sample = dist . sample ( samples ) return sample , dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_dynamic_prior ( self , samples , batch_size , length , fixed = False ) : if fixed : sample_batch_size = 1 else : sample_batch_size = batch_size sample , state = self . dynamic_prior . zero_state ( [ samples , sample_batch_size ] ) locs = [ ] scale_diags = [ ] sample_list = [ ] for _ in range ( length ) : dist , state = self . dynamic_prior ( sample , state ) sample = dist . sample ( ) locs . append ( dist . parameters [ \"loc\" ] ) scale_diags . append ( dist . parameters [ \"scale_diag\" ] ) sample_list . append ( sample ) sample = tf . stack ( sample_list , axis = 2 ) loc = tf . stack ( locs , axis = 2 ) scale_diag = tf . stack ( scale_diags , axis = 2 ) if fixed : # tile along the batch axis sample = sample + tf . zeros ( [ batch_size , 1 , 1 ] ) return sample , tfd . MultivariateNormalDiag ( loc = loc , scale_diag = scale_diag )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_dynamic_posterior ( self , inputs , samples , static_sample = None ) : if self . latent_posterior == \"factorized\" : dist = self . dynamic_encoder ( inputs ) samples = dist . sample ( samples ) # (s, N, T, lat) else : # full if static_sample is None : raise ValueError ( \"The full dynamic posterior requires a static latent sample\" ) dist = self . dynamic_encoder ( ( inputs , static_sample ) ) samples = dist . sample ( ) # (samples, N, latent) return samples , dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def batch_shape ( self ) : batch_shape = tf . TensorShape ( [ ] ) for param in self . parameters : batch_shape = tf . broadcast_static_shape ( batch_shape , param . prior . batch_shape ) return batch_shape\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def batch_shape_tensor ( self ) : batch_shape = tf . constant ( [ ] , dtype = tf . int32 ) for param in self . parameters : batch_shape = tf . broadcast_dynamic_shape ( batch_shape , param . prior . batch_shape_tensor ( ) ) return batch_shape\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _canonicalize_param_vals_as_map ( self , param_vals ) : if hasattr ( param_vals , 'keys' ) : param_map = param_vals else : param_map = { p . name : v for ( p , v ) in zip ( self . parameters , param_vals ) } return param_map\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_state_space_model ( self , num_timesteps , param_vals = None , initial_state_prior = None , initial_step = 0 ) : return self . _make_state_space_model ( num_timesteps = num_timesteps , param_map = self . _canonicalize_param_vals_as_map ( param_vals ) , initial_state_prior = initial_state_prior , initial_step = initial_step )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def prior_sample ( self , num_timesteps , initial_step = 0 , params_sample_shape = ( ) , trajectories_sample_shape = ( ) , seed = None ) : seed = distributions . SeedStream ( seed , salt = 'StructuralTimeSeries_prior_sample' ) with tf . compat . v1 . name_scope ( 'prior_sample' , values = [ num_timesteps , params_sample_shape , trajectories_sample_shape ] ) : param_samples = [ p . prior . sample ( params_sample_shape , seed = seed ( ) , name = p . name ) for p in self . parameters ] model = self . make_state_space_model ( num_timesteps = num_timesteps , initial_step = initial_step , param_vals = param_samples ) return model . sample ( trajectories_sample_shape , seed = seed ( ) ) , param_samples\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def joint_log_prob ( self , observed_time_series ) : with tf . compat . v1 . name_scope ( 'joint_log_prob' , values = [ observed_time_series ] ) : [ observed_time_series , mask ] = sts_util . canonicalize_observed_time_series_with_mask ( observed_time_series ) num_timesteps = distribution_util . prefer_static_value ( tf . shape ( input = observed_time_series ) ) [ - 2 ] def log_joint_fn ( * param_vals ) : \"\"\"Generated log-density function.\"\"\" # Sum the log_prob values from parameter priors. param_lp = sum ( [ param . prior . log_prob ( param_val ) for ( param , param_val ) in zip ( self . parameters , param_vals ) ] ) # Build a linear Gaussian state space model and evaluate the marginal # log_prob on observations. lgssm = self . make_state_space_model ( param_vals = param_vals , num_timesteps = num_timesteps ) observation_lp = lgssm . log_prob ( observed_time_series , mask = mask ) # Sum over likelihoods from iid observations. Without this sum, # adding `param_lp + observation_lp` would broadcast the param priors # over the sample shape, which incorrectly multi-counts the param # priors. sample_ndims = tf . maximum ( 0 , tf . rank ( observation_lp ) - tf . rank ( param_lp ) ) observation_lp = tf . reduce_sum ( input_tensor = observation_lp , axis = tf . range ( sample_ndims ) ) return param_lp + observation_lp return log_joint_fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _compute_min_event_ndims ( bijector_list , compute_forward = True ) : min_event_ndims = 0 # This is a mouthful, but what this encapsulates is that if not for rank # changing bijectors, we'd only need to compute the largest of the min # required ndims. Hence \"max_min\". Due to rank changing bijectors, we need to # account for synthetic rank growth / synthetic rank decrease from a rank # changing bijector. rank_changed_adjusted_max_min_event_ndims = 0 if compute_forward : bijector_list = reversed ( bijector_list ) for b in bijector_list : if compute_forward : current_min_event_ndims = b . forward_min_event_ndims current_inverse_min_event_ndims = b . inverse_min_event_ndims else : current_min_event_ndims = b . inverse_min_event_ndims current_inverse_min_event_ndims = b . forward_min_event_ndims # New dimensions were touched. if rank_changed_adjusted_max_min_event_ndims < current_min_event_ndims : min_event_ndims += ( current_min_event_ndims - rank_changed_adjusted_max_min_event_ndims ) rank_changed_adjusted_max_min_event_ndims = max ( current_min_event_ndims , rank_changed_adjusted_max_min_event_ndims ) # If the number of dimensions has increased via forward, then # inverse_min_event_ndims > forward_min_event_ndims, and hence the # dimensions we computed on, have moved left (so we have operated # on additional dimensions). # Conversely, if the number of dimensions has decreased via forward, # then we have inverse_min_event_ndims < forward_min_event_ndims, # and so we will have operated on fewer right most dimensions. number_of_changed_dimensions = ( current_min_event_ndims - current_inverse_min_event_ndims ) rank_changed_adjusted_max_min_event_ndims -= number_of_changed_dimensions return min_event_ndims\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def vector_size_to_square_matrix_size ( d , validate_args , name = None ) : if isinstance ( d , ( float , int , np . generic , np . ndarray ) ) : n = ( - 1 + np . sqrt ( 1 + 8 * d ) ) / 2. if float ( int ( n ) ) != n : raise ValueError ( \"Vector length is not a triangular number.\" ) return int ( n ) else : with tf . name_scope ( name or \"vector_size_to_square_matrix_size\" ) as name : n = ( - 1. + tf . sqrt ( 1 + 8. * tf . cast ( d , dtype = tf . float32 ) ) ) / 2. if validate_args : with tf . control_dependencies ( [ assert_util . assert_equal ( tf . cast ( tf . cast ( n , dtype = tf . int32 ) , dtype = tf . float32 ) , n , message = \"Vector length is not a triangular number\" ) ] ) : n = tf . identity ( n ) return tf . cast ( n , d . dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _argsort ( values , axis = - 1 , direction = 'ASCENDING' , stable = False , name = None ) : # pylint: disable=unused-argument if direction == 'ASCENDING' : pass elif direction == 'DESCENDING' : values = np . negative ( values ) else : raise ValueError ( 'Unrecognized direction: {}.' . format ( direction ) ) return np . argsort ( values , axis , kind = 'stable' if stable else 'quicksort' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sort ( values , axis = - 1 , direction = 'ASCENDING' , stable = False , name = None ) : # pylint: disable=unused-argument if direction == 'ASCENDING' : pass elif direction == 'DESCENDING' : values = np . negative ( values ) else : raise ValueError ( 'Unrecognized direction: {}.' . format ( direction ) ) result = np . sort ( values , axis , kind = 'stable' if stable else 'quicksort' ) if direction == 'DESCENDING' : return np . negative ( result ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_gumbel_gumbel ( a , b , name = None ) : with tf . name_scope ( name or \"kl_gumbel_gumbel\" ) : # Consistent with # http://www.mast.queensu.ca/~communications/Papers/gil-msc11.pdf, page 64 # The paper uses beta to refer to scale and mu to refer to loc. # There is actually an error in the solution as printed; this is based on # the second-to-last step of the derivation. The value as printed would be # off by (a.loc - b.loc) / b.scale. return ( tf . math . log ( b . scale ) - tf . math . log ( a . scale ) + np . euler_gamma * ( a . scale / b . scale - 1. ) + tf . math . expm1 ( ( b . loc - a . loc ) / b . scale + tf . math . lgamma ( a . scale / b . scale + 1. ) ) + ( a . loc - b . loc ) / b . scale )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ndtr ( x , name = \"ndtr\" ) : with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) if dtype_util . as_numpy_dtype ( x . dtype ) not in [ np . float32 , np . float64 ] : raise TypeError ( \"x.dtype=%s is not handled, see docstring for supported types.\" % x . dtype ) return _ndtr ( x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _ndtr ( x ) : half_sqrt_2 = tf . constant ( 0.5 * np . sqrt ( 2. ) , dtype = x . dtype , name = \"half_sqrt_2\" ) w = x * half_sqrt_2 z = tf . abs ( w ) y = tf . where ( tf . less ( z , half_sqrt_2 ) , 1. + tf . math . erf ( w ) , tf . where ( tf . greater ( w , 0. ) , 2. - tf . math . erfc ( z ) , tf . math . erfc ( z ) ) ) return 0.5 * y\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def ndtri ( p , name = \"ndtri\" ) : with tf . name_scope ( name ) : p = tf . convert_to_tensor ( value = p , name = \"p\" ) if dtype_util . as_numpy_dtype ( p . dtype ) not in [ np . float32 , np . float64 ] : raise TypeError ( \"p.dtype=%s is not handled, see docstring for supported types.\" % p . dtype ) return _ndtri ( p )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _ndtri ( p ) : # Constants used in piece-wise rational approximations. Taken from the cephes # library: # https://root.cern.ch/doc/v608/SpecFuncCephesInv_8cxx_source.html p0 = list ( reversed ( [ - 5.99633501014107895267E1 , 9.80010754185999661536E1 , - 5.66762857469070293439E1 , 1.39312609387279679503E1 , - 1.23916583867381258016E0 ] ) ) q0 = list ( reversed ( [ 1.0 , 1.95448858338141759834E0 , 4.67627912898881538453E0 , 8.63602421390890590575E1 , - 2.25462687854119370527E2 , 2.00260212380060660359E2 , - 8.20372256168333339912E1 , 1.59056225126211695515E1 , - 1.18331621121330003142E0 ] ) ) p1 = list ( reversed ( [ 4.05544892305962419923E0 , 3.15251094599893866154E1 , 5.71628192246421288162E1 , 4.40805073893200834700E1 , 1.46849561928858024014E1 , 2.18663306850790267539E0 , - 1.40256079171354495875E-1 , - 3.50424626827848203418E-2 , - 8.57456785154685413611E-4 ] ) ) q1 = list ( reversed ( [ 1.0 , 1.57799883256466749731E1 , 4.53907635128879210584E1 , 4.13172038254672030440E1 , 1.50425385692907503408E1 , 2.50464946208309415979E0 , - 1.42182922854787788574E-1 , - 3.80806407691578277194E-2 , - 9.33259480895457427372E-4 ] ) ) p2 = list ( reversed ( [ 3.23774891776946035970E0 , 6.91522889068984211695E0 , 3.93881025292474443415E0 , 1.33303460815807542389E0 , 2.01485389549179081538E-1 , 1.23716634817820021358E-2 , 3.01581553508235416007E-4 , 2.65806974686737550832E-6 , 6.23974539184983293730E-9 ] ) ) q2 = list ( reversed ( [ 1.0 , 6.02427039364742014255E0 , 3.67983563856160859403E0 , 1.37702099489081330271E0 , 2.16236993594496635890E-1 , 1.34204006088543189037E-2 , 3.28014464682127739104E-4 , 2.89247864745380683936E-6 , 6.79019408009981274425E-9 ] ) ) def _create_polynomial ( var , coeffs ) : \"\"\"Compute n_th order polynomial via Horner's method.\"\"\" coeffs = np . array ( coeffs , dtype_util . as_numpy_dtype ( var . dtype ) ) if not coeffs . size : return tf . zeros_like ( var ) return coeffs [ 0 ] + _create_polynomial ( var , coeffs [ 1 : ] ) * var maybe_complement_p = tf . where ( p > - np . expm1 ( - 2. ) , 1. - p , p ) # Write in an arbitrary value in place of 0 for p since 0 will cause NaNs # later on. The result from the computation when p == 0 is not used so any # number that doesn't result in NaNs is fine. sanitized_mcp = tf . where ( maybe_complement_p <= 0. , tf . fill ( tf . shape ( input = p ) , dtype_util . as_numpy_dtype ( p . dtype ) ( 0.5 ) ) , maybe_complement_p ) # Compute x for p > exp(-2): x/sqrt(2pi) = w + w**3 P0(w**2)/Q0(w**2). w = sanitized_mcp - 0.5 ww = w ** 2 x_for_big_p = w + w * ww * ( _create_polynomial ( ww , p0 ) / _create_polynomial ( ww , q0 ) ) x_for_big_p *= - np . sqrt ( 2. * np . pi ) # Compute x for p <= exp(-2): x = z - log(z)/z - (1/z) P(1/z) / Q(1/z), # where z = sqrt(-2. * log(p)), and P/Q are chosen between two different # arrays based on whether p < exp(-32). z = tf . sqrt ( - 2. * tf . math . log ( sanitized_mcp ) ) first_term = z - tf . math . log ( z ) / z second_term_small_p = ( _create_polynomial ( 1. / z , p2 ) / _create_polynomial ( 1. / z , q2 ) / z ) second_term_otherwise = ( _create_polynomial ( 1. / z , p1 ) / _create_polynomial ( 1. / z , q1 ) / z ) x_for_small_p = first_term - second_term_small_p x_otherwise = first_term - second_term_otherwise x = tf . where ( sanitized_mcp > np . exp ( - 2. ) , x_for_big_p , tf . where ( z >= 8.0 , x_for_small_p , x_otherwise ) ) x = tf . where ( p > 1. - np . exp ( - 2. ) , x , - x ) infinity_scalar = tf . constant ( np . inf , dtype = p . dtype ) infinity = tf . fill ( tf . shape ( input = p ) , infinity_scalar ) x_nan_replaced = tf . where ( p <= 0.0 , - infinity , tf . where ( p >= 1.0 , infinity , x ) ) return x_nan_replaced\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def log_ndtr ( x , series_order = 3 , name = \"log_ndtr\" ) : if not isinstance ( series_order , int ) : raise TypeError ( \"series_order must be a Python integer.\" ) if series_order < 0 : raise ValueError ( \"series_order must be non-negative.\" ) if series_order > 30 : raise ValueError ( \"series_order must be <= 30.\" ) with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) if dtype_util . base_equal ( x . dtype , tf . float64 ) : lower_segment = LOGNDTR_FLOAT64_LOWER upper_segment = LOGNDTR_FLOAT64_UPPER elif dtype_util . base_equal ( x . dtype , tf . float32 ) : lower_segment = LOGNDTR_FLOAT32_LOWER upper_segment = LOGNDTR_FLOAT32_UPPER else : raise TypeError ( \"x.dtype=%s is not supported.\" % x . dtype ) # The basic idea here was ported from: # https://root.cern.ch/doc/v608/SpecFuncCephesInv_8cxx_source.html # We copy the main idea, with a few changes # * For x >> 1, and X ~ Normal(0, 1), # Log[P[X < x]] = Log[1 - P[X < -x]] approx -P[X < -x], # which extends the range of validity of this function. # * We use one fixed series_order for all of 'x', rather than adaptive. # * Our docstring properly reflects that this is an asymptotic series, not a # Taylor series. We also provided a correct bound on the remainder. # * We need to use the max/min in the _log_ndtr_lower arg to avoid nan when # x=0. This happens even though the branch is unchosen because when x=0 # the gradient of a select involves the calculation 1*dy+0*(-inf)=nan # regardless of whether dy is finite. Note that the minimum is a NOP if # the branch is chosen. return tf . where ( tf . greater ( x , upper_segment ) , - _ndtr ( - x ) , # log(1-x) ~= -x, x << 1 tf . where ( tf . greater ( x , lower_segment ) , tf . math . log ( _ndtr ( tf . maximum ( x , lower_segment ) ) ) , _log_ndtr_lower ( tf . minimum ( x , lower_segment ) , series_order ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_ndtr_lower ( x , series_order ) : x_2 = tf . square ( x ) # Log of the term multiplying (1 + sum) log_scale = - 0.5 * x_2 - tf . math . log ( - x ) - 0.5 * np . log ( 2. * np . pi ) return log_scale + tf . math . log ( _log_ndtr_asymptotic_series ( x , series_order ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_ndtr_asymptotic_series ( x , series_order ) : npdt = dtype_util . as_numpy_dtype ( x . dtype ) if series_order <= 0 : return npdt ( 1 ) x_2 = tf . square ( x ) even_sum = tf . zeros_like ( x ) odd_sum = tf . zeros_like ( x ) x_2n = x_2 # Start with x^{2*1} = x^{2*n} with n = 1. for n in range ( 1 , series_order + 1 ) : y = npdt ( _double_factorial ( 2 * n - 1 ) ) / x_2n if n % 2 : odd_sum += y else : even_sum += y x_2n *= x_2 return 1. + even_sum - odd_sum\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def erfinv ( x , name = \"erfinv\" ) : with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) if dtype_util . as_numpy_dtype ( x . dtype ) not in [ np . float32 , np . float64 ] : raise TypeError ( \"x.dtype={} is not handled, see docstring for supported \" \"types.\" . format ( dtype_util . name ( x . dtype ) ) ) return ndtri ( ( x + 1. ) / 2. ) / np . sqrt ( 2. )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def log_cdf_laplace ( x , name = \"log_cdf_laplace\" ) : with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) # For x < 0, L(x) = 0.5 * exp{x} exactly, so Log[L(x)] = log(0.5) + x. lower_solution = - np . log ( 2. ) + x # safe_exp_neg_x = exp{-x} for x > 0, but is # bounded above by 1, which avoids # log[1 - 1] = -inf for x = log(1/2), AND # exp{-x} --> inf, for x << -1 safe_exp_neg_x = tf . exp ( - tf . abs ( x ) ) # log1p(z) = log(1 + z) approx z for |z| << 1. This approxmation is used # internally by log1p, rather than being done explicitly here. upper_solution = tf . math . log1p ( - 0.5 * safe_exp_neg_x ) return tf . where ( x < 0. , lower_solution , upper_solution )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def text_messages_joint_log_prob ( count_data , lambda_1 , lambda_2 , tau ) : alpha = ( 1. / tf . reduce_mean ( input_tensor = count_data ) ) rv_lambda = tfd . Exponential ( rate = alpha ) rv_tau = tfd . Uniform ( ) lambda_ = tf . gather ( [ lambda_1 , lambda_2 ] , indices = tf . cast ( tau * tf . cast ( tf . size ( input = count_data ) , dtype = tf . float32 ) <= tf . cast ( tf . range ( tf . size ( input = count_data ) ) , dtype = tf . float32 ) , dtype = tf . int32 ) ) rv_observation = tfd . Poisson ( rate = lambda_ ) return ( rv_lambda . log_prob ( lambda_1 ) + rv_lambda . log_prob ( lambda_2 ) + rv_tau . log_prob ( tau ) + tf . reduce_sum ( input_tensor = rv_observation . log_prob ( count_data ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def benchmark_text_messages_hmc ( num_results = int ( 3e3 ) , num_burnin_steps = int ( 3e3 ) , num_leapfrog_steps = 3 ) : if not tf . executing_eagerly ( ) : tf . compat . v1 . reset_default_graph ( ) # Build a static, pretend dataset. count_data = tf . cast ( tf . concat ( [ tfd . Poisson ( rate = 15. ) . sample ( 43 ) , tfd . Poisson ( rate = 25. ) . sample ( 31 ) ] , axis = 0 ) , dtype = tf . float32 ) if tf . executing_eagerly ( ) : count_data = count_data . numpy ( ) else : with tf . compat . v1 . Session ( ) : count_data = count_data . eval ( ) # Define a closure over our joint_log_prob. def unnormalized_log_posterior ( lambda1 , lambda2 , tau ) : return text_messages_joint_log_prob ( count_data , lambda1 , lambda2 , tau ) if tf . executing_eagerly ( ) : sample_chain = tf . function ( tfp . mcmc . sample_chain ) else : sample_chain = tfp . mcmc . sample_chain # Initialize the step_size. (It will be automatically adapted.) step_size = tf . compat . v2 . Variable ( name = 'step_size' , initial_value = tf . constant ( 0.05 , dtype = tf . float32 ) , trainable = False ) def computation ( ) : \"\"\"The benchmark computation.\"\"\" initial_chain_state = [ tf . constant ( count_data . mean ( ) , name = 'init_lambda1' ) , tf . constant ( count_data . mean ( ) , name = 'init_lambda2' ) , tf . constant ( 0.5 , name = 'init_tau' ) , ] unconstraining_bijectors = [ tfp . bijectors . Exp ( ) , # Maps a positive real to R. tfp . bijectors . Exp ( ) , # Maps a positive real to R. tfp . bijectors . Sigmoid ( ) , # Maps [0,1] to R. ] _ , kernel_results = sample_chain ( num_results = num_results , num_burnin_steps = num_burnin_steps , current_state = initial_chain_state , kernel = tfp . mcmc . TransformedTransitionKernel ( inner_kernel = tfp . mcmc . HamiltonianMonteCarlo ( target_log_prob_fn = unnormalized_log_posterior , num_leapfrog_steps = num_leapfrog_steps , step_size = step_size , step_size_update_fn = tfp . mcmc . make_simple_step_size_update_policy ( num_burnin_steps ) , state_gradients_are_stopped = True ) , bijector = unconstraining_bijectors ) ) return kernel_results . inner_results . is_accepted # Let's force evaluation of graph to ensure build time is not part of our time # trial. is_accepted_tensor = computation ( ) if not tf . executing_eagerly ( ) : session = tf . compat . v1 . Session ( ) session . run ( tf . compat . v1 . global_variables_initializer ( ) ) session . run ( is_accepted_tensor ) start_time = time . time ( ) if tf . executing_eagerly ( ) : is_accepted = computation ( ) else : is_accepted = session . run ( is_accepted_tensor ) wall_time = time . time ( ) - start_time num_accepted = np . sum ( is_accepted ) acceptance_rate = np . float32 ( num_accepted ) / np . float32 ( num_results ) return dict ( iters = ( num_results + num_burnin_steps ) * num_leapfrog_steps , extras = { 'acceptance_rate' : acceptance_rate } , wall_time = wall_time )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _is_univariate_marginal ( self , index_points ) : num_index_points = tf . compat . dimension_value ( index_points . shape [ - ( self . kernel . feature_ndims + 1 ) ] ) if num_index_points is None : warnings . warn ( 'Unable to detect statically whether the number of index_points is ' '1. As a result, defaulting to treating the marginal GP at ' '`index_points` as a multivariate Gaussian. This makes some methods, ' 'like `cdf` unavailable.' ) return num_index_points == 1\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_marginal_distribution ( self , index_points = None ) : with self . _name_scope ( 'get_marginal_distribution' ) : # TODO(cgs): consider caching the result here, keyed on `index_points`. index_points = self . _get_index_points ( index_points ) covariance = self . _compute_covariance ( index_points ) loc = self . _mean_fn ( index_points ) # If we're sure the number of index points is 1, we can just construct a # scalar Normal. This has computational benefits and supports things like # CDF that aren't otherwise straightforward to provide. if self . _is_univariate_marginal ( index_points ) : scale = tf . sqrt ( covariance ) # `loc` has a trailing 1 in the shape; squeeze it. loc = tf . squeeze ( loc , axis = - 1 ) return normal . Normal ( loc = loc , scale = scale , validate_args = self . _validate_args , allow_nan_stats = self . _allow_nan_stats , name = 'marginal_distribution' ) else : scale = tf . linalg . LinearOperatorLowerTriangular ( tf . linalg . cholesky ( _add_diagonal_shift ( covariance , self . jitter ) ) , is_non_singular = True , name = 'GaussianProcessScaleLinearOperator' ) return mvn_linear_operator . MultivariateNormalLinearOperator ( loc = loc , scale = scale , validate_args = self . _validate_args , allow_nan_stats = self . _allow_nan_stats , name = 'marginal_distribution' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_index_points ( self , index_points = None ) : if self . _index_points is None and index_points is None : raise ValueError ( 'This GaussianProcess instance was not instantiated with a value for ' 'index_points. One must therefore be provided when calling sample, ' 'log_prob, and other such methods. In particular, one can\\'t compute ' 'KL divergences to/from an instance of `GaussianProccess` with ' 'unspecified `index_points` directly. Instead, use the ' '`get_marginal_distribution` function, which takes `index_points` as ' 'an argument and returns a `Normal` or ' '`MultivariateNormalLinearOperator` instance, whose KL can be ' 'computed.' ) return index_points if index_points is not None else self . _index_points\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _logsum_expbig_minus_expsmall ( big , small ) : with tf . name_scope ( \"logsum_expbig_minus_expsmall\" ) : return tf . math . log1p ( - tf . exp ( small - big ) ) + big\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_prob_with_logsf_and_logcdf ( self , y ) : # There are two options that would be equal if we had infinite precision: # Log[ sf(y - 1) - sf(y) ] # = Log[ exp{logsf(y - 1)} - exp{logsf(y)} ] # Log[ cdf(y) - cdf(y - 1) ] # = Log[ exp{logcdf(y)} - exp{logcdf(y - 1)} ] logsf_y = self . log_survival_function ( y ) logsf_y_minus_1 = self . log_survival_function ( y - 1 ) logcdf_y = self . log_cdf ( y ) logcdf_y_minus_1 = self . log_cdf ( y - 1 ) # Important: Here we use select in a way such that no input is inf, this # prevents the troublesome case where the output of select can be finite, # but the output of grad(select) will be NaN. # In either case, we are doing Log[ exp{big} - exp{small} ] # We want to use the sf items precisely when we are on the right side of the # median, which occurs when logsf_y < logcdf_y. big = tf . where ( logsf_y < logcdf_y , logsf_y_minus_1 , logcdf_y ) small = tf . where ( logsf_y < logcdf_y , logsf_y , logcdf_y_minus_1 ) return _logsum_expbig_minus_expsmall ( big , small )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_iaf_stack ( total_event_size , num_hidden_layers = 2 , seed = None , dtype = tf . float32 ) : seed = tfd . SeedStream ( seed , 'make_iaf_stack' ) def make_iaf ( ) : \"\"\"Create an IAF.\"\"\" initializer = tf . compat . v2 . keras . initializers . VarianceScaling ( 2 * 0.01 , seed = seed ( ) % ( 2 ** 31 - 1 ) ) made = tfb . AutoregressiveLayer ( params = 2 , event_shape = [ total_event_size ] , hidden_units = [ total_event_size ] * num_hidden_layers , activation = tf . nn . elu , kernel_initializer = initializer , dtype = dtype ) def shift_and_scale ( x ) : # TODO(siege): Something is losing the static shape. x . set_shape ( x . shape . merge_with ( [ None ] * ( x . shape . ndims - 1 ) + [ total_event_size ] ) ) return tf . unstack ( made ( x ) , num = 2 , axis = - 1 ) return tfb . Invert ( tfb . MaskedAutoregressiveFlow ( shift_and_scale ) ) def make_swap ( ) : \"\"\"Create an swap.\"\"\" permutation = list ( reversed ( range ( total_event_size ) ) ) return tfb . Permute ( permutation ) bijector = make_iaf ( ) bijector = make_swap ( ) ( bijector ) bijector = make_iaf ( ) ( bijector ) bijector = make_swap ( ) ( bijector ) bijector = make_iaf ( ) ( bijector ) bijector = make_swap ( ) ( bijector ) return bijector\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def one_step ( self , current_state , previous_kernel_results ) : @ tfp . mcmc . internal . util . make_innermost_setter def set_num_leapfrog_steps ( kernel_results , num_leapfrog_steps ) : return kernel_results . _replace ( accepted_results = kernel_results . accepted_results . _replace ( num_leapfrog_steps = num_leapfrog_steps ) ) step_size = previous_kernel_results . new_step_size previous_kernel_results = set_num_leapfrog_steps ( previous_kernel_results , self . _num_leapfrog_steps ( step_size ) ) new_state , kernel_results = self . _kernel . one_step ( self . _flatten_state ( current_state ) , previous_kernel_results ) return self . _unflatten_state ( new_state ) , kernel_results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bootstrap_results ( self , state ) : def loss ( ) : q = self . _flattened_variational_distribution ( ) # TODO(siege): How to seed this? samples = q . sample ( self . train_batch_size ) return tf . reduce_mean ( input_tensor = q . log_prob ( samples ) - self . _flattened_target_log_prob ( samples ) , axis = - 1 ) lr = tf . convert_to_tensor ( value = self . learning_rate , dtype = self . _dtype ) dtype = lr . dtype learning_rate = tf . compat . v2 . optimizers . schedules . PiecewiseConstantDecay ( list ( self . num_train_steps * np . array ( [ 0.2 , 0.8 ] ) . astype ( dtype . as_numpy_dtype ( ) ) ) , [ lr , lr * 0.1 , lr * 0.01 ] ) opt = tf . compat . v2 . optimizers . Adam ( learning_rate ) @ tf . function ( autograph = False ) def train_step ( ) : with tf . GradientTape ( ) as tape : loss_val = loss ( ) vals = tape . watched_variables ( ) grads = tape . gradient ( loss_val , vals ) grads_and_vals = list ( zip ( grads , vals ) ) opt . apply_gradients ( grads_and_vals ) return loss_val for step in range ( self . num_train_steps ) : loss_val = train_step ( ) tf . debugging . assert_all_finite ( loss_val , 'NeuTra loss is NaN at step {}' . format ( step ) ) if self . train_debug_fn : # pylint: disable=not-callable self . train_debug_fn ( self , step , loss_val ) state_parts = tf . nest . flatten ( state ) flat_state_shapes = tf . nest . flatten ( self . state_shape ) batch_shape = tf . shape ( input = state_parts [ 0 ] ) [ : - flat_state_shapes [ 0 ] . ndims ] return self . _kernel . bootstrap_results ( self . _flattened_variational_distribution ( ) . sample ( batch_shape , seed = self . seed ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def mean_log_det ( self , name = \"mean_log_det\" ) : with self . _name_scope ( name ) : return ( self . _multi_digamma ( 0.5 * self . df , self . dimension ) + self . dimension * math . log ( 2. ) + 2 * self . scale_operator . log_abs_determinant ( ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def log_normalization ( self , name = \"log_normalization\" ) : with self . _name_scope ( name ) : return ( self . df * self . scale_operator . log_abs_determinant ( ) + 0.5 * self . df * self . dimension * math . log ( 2. ) + self . _multi_lgamma ( 0.5 * self . df , self . dimension ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _multi_gamma_sequence ( self , a , p , name = \"multi_gamma_sequence\" ) : with self . _name_scope ( name ) : # Linspace only takes scalars, so we'll add in the offset afterwards. seq = tf . linspace ( tf . constant ( 0. , dtype = self . dtype ) , 0.5 - 0.5 * p , tf . cast ( p , tf . int32 ) ) return seq + tf . expand_dims ( a , [ - 1 ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _multi_lgamma ( self , a , p , name = \"multi_lgamma\" ) : with self . _name_scope ( name ) : seq = self . _multi_gamma_sequence ( a , p ) return ( 0.25 * p * ( p - 1. ) * math . log ( math . pi ) + tf . reduce_sum ( input_tensor = tf . math . lgamma ( seq ) , axis = [ - 1 ] ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _multi_digamma ( self , a , p , name = \"multi_digamma\" ) : with self . _name_scope ( name ) : seq = self . _multi_gamma_sequence ( a , p ) return tf . reduce_sum ( input_tensor = tf . math . digamma ( seq ) , axis = [ - 1 ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _outer_squared_difference ( x , y ) : z = x - y return z [ ... , tf . newaxis , : ] * z [ ... , tf . newaxis ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _value_and_batch_jacobian ( f , x ) : if tf . executing_eagerly ( ) : with tf . GradientTape ( ) as tape : tape . watch ( x ) value = f ( x ) batch_jacobian = tape . batch_jacobian ( value , x ) else : value = f ( x ) batch_jacobian = gradients . batch_jacobian ( value , x ) return value , batch_jacobian\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prevent_2nd_derivative ( x ) : def grad ( dy ) : return array_ops . prevent_gradient ( dy , message = \"Second derivative is not implemented.\" ) return tf . identity ( x ) , grad\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _reparameterize_sample ( self , x ) : # Remove the existing gradients of x wrt parameters of the components. x = tf . stop_gradient ( x ) x_2d_shape = [ - 1 , self . _event_size ] # [S*prod(B), prod(E)] # Perform distributional transform of x in [S, B, E] shape, # but have Jacobian of size [S*prod(B), prod(E), prod(E)]. def reshaped_distributional_transform ( x_2d ) : return tf . reshape ( self . _distributional_transform ( tf . reshape ( x_2d , tf . shape ( input = x ) ) ) , x_2d_shape ) # transform_2d: [S*prod(B), prod(E)] # jacobian: [S*prod(B), prod(E), prod(E)] transform_2d , jacobian = _value_and_batch_jacobian ( reshaped_distributional_transform , tf . reshape ( x , x_2d_shape ) ) # We only provide the first derivative; the second derivative computed by # autodiff would be incorrect, so we raise an error if it is requested. transform_2d = _prevent_2nd_derivative ( transform_2d ) # Compute [- stop_gradient(jacobian)^-1 * transform] by solving a linear # system. The Jacobian is lower triangular because the distributional # transform for i-th event dimension does not depend on the next # dimensions. surrogate_x_2d = - tf . linalg . triangular_solve ( tf . stop_gradient ( jacobian ) , tf . expand_dims ( transform_2d , axis = - 1 ) , lower = True ) # [S*prod(B), prod(E), 1] surrogate_x = tf . reshape ( surrogate_x_2d , tf . shape ( input = x ) ) # Replace gradients of x with gradients of surrogate_x, but keep the value. return x + ( surrogate_x - tf . stop_gradient ( surrogate_x ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _distributional_transform ( self , x ) : if tensorshape_util . rank ( x . shape ) is None : # tf.nn.softmax raises an error when applied to inputs of undefined rank. raise ValueError ( \"Distributional transform does not support inputs of \" \"undefined rank.\" ) # Obtain factorized components distribution and assert that it's # a scalar distribution. if isinstance ( self . _components_distribution , independent . Independent ) : univariate_components = self . _components_distribution . distribution else : univariate_components = self . _components_distribution with tf . control_dependencies ( [ assert_util . assert_equal ( univariate_components . is_scalar_event ( ) , True , message = \"`univariate_components` must have scalar event\" ) ] ) : x_padded = self . _pad_sample_dims ( x ) # [S, B, 1, E] log_prob_x = univariate_components . log_prob ( x_padded ) # [S, B, k, E] cdf_x = univariate_components . cdf ( x_padded ) # [S, B, k, E] # log prob_k (x_1, ..., x_i-1) cumsum_log_prob_x = tf . reshape ( tf . math . cumsum ( # [S*prod(B)*k, prod(E)] tf . reshape ( log_prob_x , [ - 1 , self . _event_size ] ) , exclusive = True , axis = - 1 ) , tf . shape ( input = log_prob_x ) ) # [S, B, k, E] logits_mix_prob = distribution_utils . pad_mixture_dimensions ( self . mixture_distribution . logits , self , self . mixture_distribution , self . _event_ndims ) # [B, k, 1] # Logits of the posterior weights: log w_k + log prob_k (x_1, ..., x_i-1) log_posterior_weights_x = logits_mix_prob + cumsum_log_prob_x component_axis = tensorshape_util . rank ( x . shape ) - self . _event_ndims posterior_weights_x = tf . nn . softmax ( log_posterior_weights_x , axis = component_axis ) return tf . reduce_sum ( input_tensor = posterior_weights_x * cdf_x , axis = component_axis )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _split_covariance_into_marginals ( covariance , block_sizes ) : start_dim = 0 marginals = [ ] for size in block_sizes : end_dim = start_dim + size marginals . append ( covariance [ ... , start_dim : end_dim , start_dim : end_dim ] ) start_dim = end_dim return marginals\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _decompose_from_posterior_marginals ( model , posterior_means , posterior_covs , parameter_samples ) : try : model . components except AttributeError : raise ValueError ( 'Model decomposed into components must be an instance of' '`tfp.sts.Sum` (passed model {})' . format ( model ) ) with tf . compat . v1 . name_scope ( 'decompose_from_posterior_marginals' ) : # Extract the component means/covs from the joint latent posterior. latent_sizes = [ component . latent_size for component in model . components ] component_means = tf . split ( posterior_means , latent_sizes , axis = - 1 ) component_covs = _split_covariance_into_marginals ( posterior_covs , latent_sizes ) # Instantiate per-component state space models, and use them to push the # posterior means/covs through the observation model for each component. num_timesteps = dist_util . prefer_static_value ( tf . shape ( input = posterior_means ) ) [ - 2 ] component_ssms = model . make_component_state_space_models ( num_timesteps = num_timesteps , param_vals = parameter_samples ) component_predictive_dists = collections . OrderedDict ( ) for ( component , component_ssm , component_mean , component_cov ) in zip ( model . components , component_ssms , component_means , component_covs ) : component_obs_mean , component_obs_cov = ( component_ssm . latents_to_observations ( latent_means = component_mean , latent_covs = component_cov ) ) # Using the observation means and covs, build a mixture distribution # that integrates over the posterior draws. component_predictive_dists [ component ] = sts_util . mix_over_posterior_draws ( means = component_obs_mean [ ... , 0 ] , variances = component_obs_cov [ ... , 0 , 0 ] ) return component_predictive_dists\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def decompose_by_component ( model , observed_time_series , parameter_samples ) : with tf . compat . v1 . name_scope ( 'decompose_by_component' , values = [ observed_time_series ] ) : [ observed_time_series , is_missing ] = sts_util . canonicalize_observed_time_series_with_mask ( observed_time_series ) # Run smoothing over the training timesteps to extract the # posterior on latents. num_timesteps = dist_util . prefer_static_value ( tf . shape ( input = observed_time_series ) ) [ - 2 ] ssm = model . make_state_space_model ( num_timesteps = num_timesteps , param_vals = parameter_samples ) posterior_means , posterior_covs = ssm . posterior_marginals ( observed_time_series , mask = is_missing ) return _decompose_from_posterior_marginals ( model , posterior_means , posterior_covs , parameter_samples )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def decompose_forecast_by_component ( model , forecast_dist , parameter_samples ) : with tf . compat . v1 . name_scope ( 'decompose_forecast_by_component' ) : try : forecast_lgssm = forecast_dist . components_distribution forecast_latent_mean , _ = forecast_lgssm . _joint_mean ( ) # pylint: disable=protected-access forecast_latent_covs , _ = forecast_lgssm . _joint_covariances ( ) # pylint: disable=protected-access except AttributeError as e : raise ValueError ( 'Forecast distribution must be a MixtureSameFamily of' 'LinearGaussianStateSpaceModel distributions, such as returned by' '`tfp.sts.forecast()`. (saw exception: {})' . format ( e ) ) # Since `parameter_samples` will have sample shape `[num_posterior_draws]`, # we need to move the `num_posterior_draws` dimension of the forecast # moments from the trailing batch dimension, where it's currently put by # `sts.forecast`, back to the leading (sample shape) dimension. forecast_latent_mean = dist_util . move_dimension ( forecast_latent_mean , source_idx = - 3 , dest_idx = 0 ) forecast_latent_covs = dist_util . move_dimension ( forecast_latent_covs , source_idx = - 4 , dest_idx = 0 ) return _decompose_from_posterior_marginals ( model , forecast_latent_mean , forecast_latent_covs , parameter_samples )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dense_to_sparse ( x , ignore_value = None , name = None ) : # Copied (with modifications) from: # tensorflow/contrib/layers/python/ops/sparse_ops.py. with tf . compat . v1 . name_scope ( name , 'dense_to_sparse' , [ x , ignore_value ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) if ignore_value is None : if x . dtype . base_dtype == tf . string : # Exception due to TF strings are converted to numpy objects by default. ignore_value = '' else : ignore_value = x . dtype . as_numpy_dtype ( 0 ) ignore_value = tf . cast ( ignore_value , x . dtype , name = 'ignore_value' ) indices = tf . where ( tf . not_equal ( x , ignore_value ) , name = 'indices' ) return tf . SparseTensor ( indices = indices , values = tf . gather_nd ( x , indices , name = 'values' ) , dense_shape = tf . shape ( input = x , out_type = tf . int64 , name = 'dense_shape' ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _operator ( attr ) : @ functools . wraps ( attr ) def func ( a , * args ) : return attr ( a . value , * args ) return func\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _numpy_text ( tensor , is_repr = False ) : if tensor . dtype . is_numpy_compatible : text = repr ( tensor . numpy ( ) ) if is_repr else str ( tensor . numpy ( ) ) else : text = \"<unprintable>\" if \"\\n\" in text : text = \"\\n\" + text return text\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_shape ( self ) : if isinstance ( self . _sample_shape , tf . Tensor ) : return tf . TensorShape ( tf . get_static_value ( self . _sample_shape ) ) return tf . TensorShape ( self . _sample_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_shape_tensor ( self , name = \"sample_shape_tensor\" ) : with tf . compat . v1 . name_scope ( name ) : if isinstance ( self . _sample_shape , tf . Tensor ) : return self . _sample_shape return tf . convert_to_tensor ( value = self . sample_shape . as_list ( ) , dtype = tf . int32 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def value ( self ) : if self . _value is None : try : self . _value = self . distribution . sample ( self . sample_shape_tensor ( ) ) except NotImplementedError : raise NotImplementedError ( \"sample is not implemented for {0}. You must either pass in the \" \"value argument or implement sample for {0}.\" . format ( self . distribution . __class__ . __name__ ) ) return self . _value\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def eval ( self , session = None , feed_dict = None ) : return self . value . eval ( session = session , feed_dict = feed_dict )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def numpy ( self ) : if not isinstance ( self . value , ops . EagerTensor ) : raise NotImplementedError ( \"value argument must be a EagerTensor.\" ) return self . value . numpy ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def normal_conjugates_known_scale_posterior ( prior , scale , s , n ) : if not isinstance ( prior , normal . Normal ) : raise TypeError ( \"Expected prior to be an instance of type Normal\" ) if s . dtype != prior . dtype : raise TypeError ( \"Observation sum s.dtype does not match prior dtype: %s vs. %s\" % ( s . dtype , prior . dtype ) ) n = tf . cast ( n , prior . dtype ) scale0_2 = tf . square ( prior . scale ) scale_2 = tf . square ( scale ) scalep_2 = 1.0 / ( 1 / scale0_2 + n / scale_2 ) return normal . Normal ( loc = ( prior . loc / scale0_2 + s / scale_2 ) * scalep_2 , scale = tf . sqrt ( scalep_2 ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def real_nvp_default_template ( hidden_layers , shift_only = False , activation = tf . nn . relu , name = None , * args , # pylint: disable=keyword-arg-before-vararg * * kwargs ) : with tf . compat . v2 . name_scope ( name or \"real_nvp_default_template\" ) : def _fn ( x , output_units , * * condition_kwargs ) : \"\"\"Fully connected MLP parameterized via `real_nvp_template`.\"\"\" if condition_kwargs : raise NotImplementedError ( \"Conditioning not implemented in the default template.\" ) if tensorshape_util . rank ( x . shape ) == 1 : x = x [ tf . newaxis , ... ] reshape_output = lambda x : x [ 0 ] else : reshape_output = lambda x : x for units in hidden_layers : x = tf . compat . v1 . layers . dense ( inputs = x , units = units , activation = activation , * args , # pylint: disable=keyword-arg-before-vararg * * kwargs ) x = tf . compat . v1 . layers . dense ( inputs = x , units = ( 1 if shift_only else 2 ) * output_units , activation = None , * args , # pylint: disable=keyword-arg-before-vararg * * kwargs ) if shift_only : return reshape_output ( x ) , None shift , log_scale = tf . split ( x , 2 , axis = - 1 ) return reshape_output ( shift ) , reshape_output ( log_scale ) return tf . compat . v1 . make_template ( \"real_nvp_default_template\" , _fn )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _uniform_unit_norm ( dimension , shape , dtype , seed ) : # This works because the Gaussian distribution is spherically symmetric. # raw shape: shape + [dimension] raw = normal . Normal ( loc = dtype_util . as_numpy_dtype ( dtype ) ( 0 ) , scale = dtype_util . as_numpy_dtype ( dtype ) ( 1 ) ) . sample ( tf . concat ( [ shape , [ dimension ] ] , axis = 0 ) , seed = seed ( ) ) unit_norm = raw / tf . norm ( tensor = raw , ord = 2 , axis = - 1 ) [ ... , tf . newaxis ] return unit_norm\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _replicate ( n , tensor ) : # TODO(axch) Does this already exist somewhere? Should it get contributed? multiples = tf . concat ( [ [ n ] , tf . ones_like ( tensor . shape ) ] , axis = 0 ) return tf . tile ( tf . expand_dims ( tensor , axis = 0 ) , multiples )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sample_n ( self , num_samples , seed = None , name = None ) : if self . dimension < 0 : raise ValueError ( 'Cannot sample negative-dimension correlation matrices.' ) # Notation below: B is the batch shape, i.e., tf.shape(concentration) seed = seed_stream . SeedStream ( seed , 'sample_lkj' ) with tf . name_scope ( 'sample_lkj' or name ) : if not dtype_util . is_floating ( self . concentration . dtype ) : raise TypeError ( 'The concentration argument should have floating type, not ' '{}' . format ( dtype_util . name ( self . concentration . dtype ) ) ) concentration = _replicate ( num_samples , self . concentration ) concentration_shape = tf . shape ( input = concentration ) if self . dimension <= 1 : # For any dimension <= 1, there is only one possible correlation matrix. shape = tf . concat ( [ concentration_shape , [ self . dimension , self . dimension ] ] , axis = 0 ) return tf . ones ( shape = shape , dtype = self . concentration . dtype ) beta_conc = concentration + ( self . dimension - 2. ) / 2. beta_dist = beta . Beta ( concentration1 = beta_conc , concentration0 = beta_conc ) # Note that the sampler below deviates from [1], by doing the sampling in # cholesky space. This does not change the fundamental logic of the # sampler, but does speed up the sampling. # This is the correlation coefficient between the first two dimensions. # This is also `r` in reference [1]. corr12 = 2. * beta_dist . sample ( seed = seed ( ) ) - 1. # Below we construct the Cholesky of the initial 2x2 correlation matrix, # which is of the form: # [[1, 0], [r, sqrt(1 - r**2)]], where r is the correlation between the # first two dimensions. # This is the top-left corner of the cholesky of the final sample. first_row = tf . concat ( [ tf . ones_like ( corr12 ) [ ... , tf . newaxis ] , tf . zeros_like ( corr12 ) [ ... , tf . newaxis ] ] , axis = - 1 ) second_row = tf . concat ( [ corr12 [ ... , tf . newaxis ] , tf . sqrt ( 1 - corr12 ** 2 ) [ ... , tf . newaxis ] ] , axis = - 1 ) chol_result = tf . concat ( [ first_row [ ... , tf . newaxis , : ] , second_row [ ... , tf . newaxis , : ] ] , axis = - 2 ) for n in range ( 2 , self . dimension ) : # Loop invariant: on entry, result has shape B + [n, n] beta_conc -= 0.5 # norm is y in reference [1]. norm = beta . Beta ( concentration1 = n / 2. , concentration0 = beta_conc ) . sample ( seed = seed ( ) ) # distance shape: B + [1] for broadcast distance = tf . sqrt ( norm ) [ ... , tf . newaxis ] # direction is u in reference [1]. # direction shape: B + [n] direction = _uniform_unit_norm ( n , concentration_shape , self . concentration . dtype , seed ) # raw_correlation is w in reference [1]. raw_correlation = distance * direction # shape: B + [n] # This is the next row in the cholesky of the result, # which differs from the construction in reference [1]. # In the reference, the new row `z` = chol_result @ raw_correlation^T # = C @ raw_correlation^T (where as short hand we use C = chol_result). # We prove that the below equation is the right row to add to the # cholesky, by showing equality with reference [1]. # Let S be the sample constructed so far, and let `z` be as in # reference [1]. Then at this iteration, the new sample S' will be # [[S z^T] # [z 1]] # In our case we have the cholesky decomposition factor C, so # we want our new row x (same size as z) to satisfy: # [[S z^T] [[C 0] [[C^T x^T] [[CC^T Cx^T] # [z 1]] = [x k]] [0 k]] = [xC^t xx^T + k**2]] # Since C @ raw_correlation^T = z = C @ x^T, and C is invertible, # we have that x = raw_correlation. Also 1 = xx^T + k**2, so k # = sqrt(1 - xx^T) = sqrt(1 - |raw_correlation|**2) = sqrt(1 - # distance**2). new_row = tf . concat ( [ raw_correlation , tf . sqrt ( 1. - norm [ ... , tf . newaxis ] ) ] , axis = - 1 ) # Finally add this new row, by growing the cholesky of the result. chol_result = tf . concat ( [ chol_result , tf . zeros_like ( chol_result [ ... , 0 ] [ ... , tf . newaxis ] ) ] , axis = - 1 ) chol_result = tf . concat ( [ chol_result , new_row [ ... , tf . newaxis , : ] ] , axis = - 2 ) if self . input_output_cholesky : return chol_result result = tf . matmul ( chol_result , chol_result , transpose_b = True ) # The diagonal for a correlation matrix should always be ones. Due to # numerical instability the matmul might not achieve that, so manually set # these to ones. result = tf . linalg . set_diag ( result , tf . ones ( shape = tf . shape ( input = result ) [ : - 1 ] , dtype = result . dtype ) ) # This sampling algorithm can produce near-PSD matrices on which standard # algorithms such as `tf.cholesky` or `tf.linalg.self_adjoint_eigvals` # fail. Specifically, as documented in b/116828694, around 2% of trials # of 900,000 5x5 matrices (distributed according to 9 different # concentration parameter values) contained at least one matrix on which # the Cholesky decomposition failed. return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_unnorm_prob ( self , x , name = None ) : with tf . name_scope ( name or 'log_unnorm_prob_lkj' ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) # The density is det(matrix) ** (concentration - 1). # Computing the determinant with `logdet` is usually fine, since # correlation matrices are Hermitian and PSD. But in some cases, for a # PSD matrix whose eigenvalues are close to zero, `logdet` raises an error # complaining that it is not PSD. The root cause is the computation of the # cholesky decomposition in `logdet`. Hence, we use the less efficient but # more robust `slogdet` which does not use `cholesky`. # # An alternative would have been to check allow_nan_stats and use # eigenvalues = tf.linalg.self_adjoint_eigvals(x) # psd_mask = tf.cast( # tf.reduce_min(eigenvalues, axis=-1) >= 0, dtype=x.dtype) # tf.where(psd_mask, answer, float('-inf')) # to emit probability 0 for inputs that are not PSD, without ever raising # an error. More care must be taken, as due to numerical stability issues, # self_adjoint_eigvals can return slightly negative eigenvalues even for # a PSD matrix. if self . input_output_cholesky : logdet = 2.0 * tf . reduce_sum ( input_tensor = tf . math . log ( tf . linalg . diag_part ( x ) ) , axis = [ - 1 ] ) else : _ , logdet = tf . linalg . slogdet ( x ) answer = ( self . concentration - 1. ) * logdet return answer\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_normalization ( self , name = 'log_normalization' ) : # The formula is from D. Lewandowski et al [1], p. 1999, from the # proof that eqs 16 and 17 are equivalent. with tf . name_scope ( name or 'log_normalization_lkj' ) : logpi = np . log ( np . pi ) ans = tf . zeros_like ( self . concentration ) for k in range ( 1 , self . dimension ) : ans += logpi * ( k / 2. ) ans += tf . math . lgamma ( self . concentration + ( self . dimension - 1 - k ) / 2. ) ans -= tf . math . lgamma ( self . concentration + ( self . dimension - 1 ) / 2. ) return ans\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def common_dtype ( args_list , preferred_dtype = None ) : dtype = None preferred_dtype = ( None if preferred_dtype is None else tf . as_dtype ( preferred_dtype ) ) for a in tf . nest . flatten ( args_list ) : if hasattr ( a , 'dtype' ) : dt = tf . as_dtype ( a . dtype ) else : continue if dtype is None : dtype = dt elif dtype != dt : raise TypeError ( 'Found incompatible dtypes, {} and {}.' . format ( dtype , dt ) ) if dtype is None and preferred_dtype is None : return None return ( preferred_dtype if dtype is None else dtype ) . as_numpy_dtype\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_summary_statistic ( attr ) : def _fn ( self , * * kwargs ) : \"\"\"Implements summary statistic, eg, mean, stddev, mode.\"\"\" x = getattr ( self . distribution , attr ) ( * * kwargs ) shape = prefer_static . concat ( [ self . distribution . batch_shape_tensor ( ) , prefer_static . ones ( prefer_static . rank_from_shape ( self . sample_shape ) , dtype = self . sample_shape . dtype ) , self . distribution . event_shape_tensor ( ) , ] , axis = 0 ) x = tf . reshape ( x , shape = shape ) shape = prefer_static . concat ( [ self . distribution . batch_shape_tensor ( ) , self . sample_shape , self . distribution . event_shape_tensor ( ) , ] , axis = 0 ) return tf . broadcast_to ( x , shape ) return _fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_sample ( a , b , name = 'kl_sample' ) : assertions = [ ] a_ss = tf . get_static_value ( a . sample_shape ) b_ss = tf . get_static_value ( b . sample_shape ) msg = '`a.sample_shape` must be identical to `b.sample_shape`.' if a_ss is not None and b_ss is not None : if not np . array_equal ( a_ss , b_ss ) : raise ValueError ( msg ) elif a . validate_args or b . validate_args : assertions . append ( assert_util . assert_equal ( a . sample_shape , b . sample_shape , message = msg ) ) with tf . control_dependencies ( assertions ) : kl = kullback_leibler . kl_divergence ( a . distribution , b . distribution , name = name ) n = prefer_static . reduce_prod ( a . sample_shape ) return tf . cast ( x = n , dtype = kl . dtype ) * kl\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _broadcast_to ( tensor_to_broadcast , target_tensors ) : output = tensor_to_broadcast for tensor in target_tensors : output += tf . zeros_like ( tensor ) return output\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _pdf_at_peak ( self ) : return ( self . peak - self . low ) / ( self . high - self . low )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def effective_sample_size ( states , filter_threshold = 0. , filter_beyond_lag = None , name = None ) : states_was_list = _is_list_like ( states ) # Convert all args to lists. if not states_was_list : states = [ states ] filter_beyond_lag = _broadcast_maybelist_arg ( states , filter_beyond_lag , 'filter_beyond_lag' ) filter_threshold = _broadcast_maybelist_arg ( states , filter_threshold , 'filter_threshold' ) # Process items, one at a time. with tf . compat . v1 . name_scope ( name , 'effective_sample_size' ) : ess_list = [ _effective_sample_size_single_state ( s , ml , mlt ) for ( s , ml , mlt ) in zip ( states , filter_beyond_lag , filter_threshold ) ] if states_was_list : return ess_list return ess_list [ 0 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _effective_sample_size_single_state ( states , filter_beyond_lag , filter_threshold ) : with tf . compat . v1 . name_scope ( 'effective_sample_size_single_state' , values = [ states , filter_beyond_lag , filter_threshold ] ) : states = tf . convert_to_tensor ( value = states , name = 'states' ) dt = states . dtype # filter_beyond_lag == None ==> auto_corr is the full sequence. auto_corr = stats . auto_correlation ( states , axis = 0 , max_lags = filter_beyond_lag ) if filter_threshold is not None : filter_threshold = tf . convert_to_tensor ( value = filter_threshold , dtype = dt , name = 'filter_threshold' ) # Get a binary mask to zero out values of auto_corr below the threshold. # mask[i, ...] = 1 if auto_corr[j, ...] > threshold for all j <= i, # mask[i, ...] = 0, otherwise. # So, along dimension zero, the mask will look like [1, 1, ..., 0, 0,...] # Building step by step, # Assume auto_corr = [1, 0.5, 0.0, 0.3], and filter_threshold = 0.2. # Step 1: mask = [False, False, True, False] mask = auto_corr < filter_threshold # Step 2: mask = [0, 0, 1, 1] mask = tf . cast ( mask , dtype = dt ) # Step 3: mask = [0, 0, 1, 2] mask = tf . cumsum ( mask , axis = 0 ) # Step 4: mask = [1, 1, 0, 0] mask = tf . maximum ( 1. - mask , 0. ) auto_corr *= mask # With R[k] := auto_corr[k, ...], # ESS = N / {1 + 2 * Sum_{k=1}^N (N - k) / N * R[k]} # = N / {-1 + 2 * Sum_{k=0}^N (N - k) / N * R[k]} (since R[0] = 1) # approx N / {-1 + 2 * Sum_{k=0}^M (N - k) / N * R[k]} # where M is the filter_beyond_lag truncation point chosen above. # Get the factor (N - k) / N, and give it shape [M, 1,...,1], having total # ndims the same as auto_corr n = _axis_size ( states , axis = 0 ) k = tf . range ( 0. , _axis_size ( auto_corr , axis = 0 ) ) nk_factor = ( n - k ) / n if auto_corr . shape . ndims is not None : new_shape = [ - 1 ] + [ 1 ] * ( auto_corr . shape . ndims - 1 ) else : new_shape = tf . concat ( ( [ - 1 ] , tf . ones ( [ tf . rank ( auto_corr ) - 1 ] , dtype = tf . int32 ) ) , axis = 0 ) nk_factor = tf . reshape ( nk_factor , new_shape ) return n / ( - 1 + 2 * tf . reduce_sum ( input_tensor = nk_factor * auto_corr , axis = 0 ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def potential_scale_reduction ( chains_states , independent_chain_ndims = 1 , name = None ) : chains_states_was_list = _is_list_like ( chains_states ) if not chains_states_was_list : chains_states = [ chains_states ] # tf.get_static_value returns None iff a constant value (as a numpy # array) is not efficiently computable. Therefore, we try constant_value then # check for None. icn_const_ = tf . get_static_value ( tf . convert_to_tensor ( value = independent_chain_ndims ) ) if icn_const_ is not None : independent_chain_ndims = icn_const_ if icn_const_ < 1 : raise ValueError ( 'Argument `independent_chain_ndims` must be `>= 1`, found: {}' . format ( independent_chain_ndims ) ) with tf . compat . v1 . name_scope ( name , 'potential_scale_reduction' ) : rhat_list = [ _potential_scale_reduction_single_state ( s , independent_chain_ndims ) for s in chains_states ] if chains_states_was_list : return rhat_list return rhat_list [ 0 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _potential_scale_reduction_single_state ( state , independent_chain_ndims ) : with tf . compat . v1 . name_scope ( 'potential_scale_reduction_single_state' , values = [ state , independent_chain_ndims ] ) : # We assume exactly one leading dimension indexes e.g. correlated samples # from each Markov chain. state = tf . convert_to_tensor ( value = state , name = 'state' ) sample_ndims = 1 sample_axis = tf . range ( 0 , sample_ndims ) chain_axis = tf . range ( sample_ndims , sample_ndims + independent_chain_ndims ) sample_and_chain_axis = tf . range ( 0 , sample_ndims + independent_chain_ndims ) n = _axis_size ( state , sample_axis ) m = _axis_size ( state , chain_axis ) # In the language of Brooks and Gelman (1998), # B / n is the between chain variance, the variance of the chain means. # W is the within sequence variance, the mean of the chain variances. b_div_n = _reduce_variance ( tf . reduce_mean ( input_tensor = state , axis = sample_axis , keepdims = True ) , sample_and_chain_axis , biased = False ) w = tf . reduce_mean ( input_tensor = _reduce_variance ( state , sample_axis , keepdims = True , biased = True ) , axis = sample_and_chain_axis ) # sigma^2_+ is an estimate of the true variance, which would be unbiased if # each chain was drawn from the target. c.f. \"law of total variance.\" sigma_2_plus = w + b_div_n return ( ( m + 1. ) / m ) * sigma_2_plus / w - ( n - 1. ) / ( m * n )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _axis_size ( x , axis = None ) : if axis is None : return tf . cast ( tf . size ( input = x ) , x . dtype ) return tf . cast ( tf . reduce_prod ( input_tensor = tf . gather ( tf . shape ( input = x ) , axis ) ) , x . dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _broadcast_maybelist_arg ( states , secondary_arg , name ) : if _is_list_like ( secondary_arg ) : if len ( secondary_arg ) != len ( states ) : raise ValueError ( 'Argument `%s` was a list of different length ({}) than ' '`states` ({})' . format ( name , len ( states ) ) ) else : secondary_arg = [ secondary_arg ] * len ( states ) return secondary_arg\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def quadrature_scheme_lognormal_gauss_hermite ( loc , scale , quadrature_size , validate_args = False , name = None ) : # pylint: disable=unused-argument with tf . name_scope ( name or \"vector_diffeomixture_quadrature_gauss_hermite\" ) : grid , probs = np . polynomial . hermite . hermgauss ( deg = quadrature_size ) npdt = dtype_util . as_numpy_dtype ( loc . dtype ) grid = grid . astype ( npdt ) probs = probs . astype ( npdt ) probs /= np . linalg . norm ( probs , ord = 1 , keepdims = True ) probs = tf . convert_to_tensor ( value = probs , name = \"probs\" , dtype = loc . dtype ) # The following maps the broadcast of `loc` and `scale` to each grid # point, i.e., we are creating several log-rates that correspond to the # different Gauss-Hermite quadrature points and (possible) batches of # `loc` and `scale`. grid = ( loc [ ... , tf . newaxis ] + np . sqrt ( 2. ) * scale [ ... , tf . newaxis ] * grid ) return grid , probs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def quadrature_scheme_lognormal_quantiles ( loc , scale , quadrature_size , validate_args = False , name = None ) : with tf . name_scope ( name or \"quadrature_scheme_lognormal_quantiles\" ) : # Create a LogNormal distribution. dist = transformed_distribution . TransformedDistribution ( distribution = normal . Normal ( loc = loc , scale = scale ) , bijector = exp_bijector . Exp ( ) , validate_args = validate_args ) batch_ndims = tensorshape_util . rank ( dist . batch_shape ) if batch_ndims is None : batch_ndims = tf . shape ( input = dist . batch_shape_tensor ( ) ) [ 0 ] def _compute_quantiles ( ) : \"\"\"Helper to build quantiles.\"\"\" # Omit {0, 1} since they might lead to Inf/NaN. zero = tf . zeros ( [ ] , dtype = dist . dtype ) edges = tf . linspace ( zero , 1. , quadrature_size + 3 ) [ 1 : - 1 ] # Expand edges so its broadcast across batch dims. edges = tf . reshape ( edges , shape = tf . concat ( [ [ - 1 ] , tf . ones ( [ batch_ndims ] , dtype = tf . int32 ) ] , axis = 0 ) ) quantiles = dist . quantile ( edges ) # Cyclically permute left by one. perm = tf . concat ( [ tf . range ( 1 , 1 + batch_ndims ) , [ 0 ] ] , axis = 0 ) quantiles = tf . transpose ( a = quantiles , perm = perm ) return quantiles quantiles = _compute_quantiles ( ) # Compute grid as quantile midpoints. grid = ( quantiles [ ... , : - 1 ] + quantiles [ ... , 1 : ] ) / 2. # Set shape hints. new_shape = tensorshape_util . concatenate ( dist . batch_shape , [ quadrature_size ] ) tensorshape_util . set_shape ( grid , new_shape ) # By construction probs is constant, i.e., `1 / quadrature_size`. This is # important, because non-constant probs leads to non-reparameterizable # samples. probs = tf . fill ( dims = [ quadrature_size ] , value = 1. / tf . cast ( quadrature_size , dist . dtype ) ) return grid , probs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def merge ( self , x = None , y = None , ildj = None , kwargs = None , mapping = None ) : if mapping is None : mapping = _Mapping ( x = x , y = y , ildj = ildj , kwargs = kwargs ) elif any ( arg is not None for arg in [ x , y , ildj , kwargs ] ) : raise ValueError ( \"Cannot simultaneously specify mapping and individual \" \"arguments.\" ) return _Mapping ( x = self . _merge ( self . x , mapping . x ) , y = self . _merge ( self . y , mapping . y ) , ildj = self . _merge ( self . ildj , mapping . ildj ) , kwargs = self . _merge ( self . kwargs , mapping . kwargs , use_equals = True ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def remove ( self , field ) : return _Mapping ( x = None if field == \"x\" else self . x , y = None if field == \"y\" else self . y , ildj = self . ildj , kwargs = self . kwargs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _merge ( self , old , new , use_equals = False ) : if old is None : return new if new is None : return old if ( old == new ) if use_equals else ( old is new ) : return old raise ValueError ( \"Incompatible values: %s != %s\" % ( old , new ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _deep_tuple ( self , x ) : if isinstance ( x , dict ) : return self . _deep_tuple ( tuple ( sorted ( x . items ( ) ) ) ) elif isinstance ( x , ( list , tuple ) ) : return tuple ( map ( self . _deep_tuple , x ) ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _left_doubling_increments ( batch_shape , max_doublings , step_size , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'left_doubling_increments' , [ batch_shape , max_doublings , step_size ] ) : step_size = tf . convert_to_tensor ( value = step_size ) dtype = step_size . dtype . base_dtype # Output shape of the left increments tensor. output_shape = tf . concat ( ( [ max_doublings + 1 ] , batch_shape ) , axis = 0 ) # A sample realization of X_k. expand_left = distributions . Bernoulli ( 0.5 , dtype = dtype ) . sample ( sample_shape = output_shape , seed = seed ) # The widths of the successive intervals. Starts with 1.0 and ends with # 2^max_doublings. width_multipliers = tf . cast ( 2 ** tf . range ( 0 , max_doublings + 1 ) , dtype = dtype ) # Output shape of the `widths` tensor. widths_shape = tf . concat ( ( [ max_doublings + 1 ] , tf . ones_like ( batch_shape ) ) , axis = 0 ) width_multipliers = tf . reshape ( width_multipliers , shape = widths_shape ) # Widths shape is [max_doublings + 1, 1, 1, 1...]. widths = width_multipliers * step_size # Take the cumulative sum of the left side increments in slice width to give # the resulting distance from the inital lower bound. left_increments = tf . cumsum ( widths * expand_left , exclusive = True , axis = 0 ) return left_increments , widths\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _find_best_interval_idx ( x , name = None ) : with tf . compat . v1 . name_scope ( name , 'find_best_interval_idx' , [ x ] ) : # Returns max_doublings + 1. Positive int32. k = tf . shape ( input = x ) [ 0 ] dtype = x . dtype . base_dtype # Factors by which to multiply the flag. Corresponds to (2 * k - i) above. mults = tf . range ( 2 * k , k , - 1 , dtype = dtype ) [ : , tf . newaxis ] # Factors by which to shift the flag. Corresponds to i above. Ensures the # widest bounds are selected if there are no bounds outside the slice. shifts = tf . range ( k , dtype = dtype ) [ : , tf . newaxis ] indices = tf . argmax ( input = mults * x + shifts , axis = 0 , output_type = dtype ) return indices\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def slice_bounds_by_doubling ( x_initial , target_log_prob , log_slice_heights , max_doublings , step_size , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'slice_bounds_by_doubling' , [ x_initial , log_slice_heights , max_doublings , step_size ] ) : seed_gen = distributions . SeedStream ( seed , salt = 'slice_bounds_by_doubling' ) x_initial = tf . convert_to_tensor ( value = x_initial ) batch_shape = tf . shape ( input = x_initial ) dtype = step_size . dtype . base_dtype left_endpoints = x_initial + step_size * tf . random . uniform ( batch_shape , minval = - 1.0 , maxval = 0.0 , dtype = dtype , seed = seed_gen ( ) ) # Compute the increments by which we need to step the upper and lower bounds # part of the doubling procedure. left_increments , widths = _left_doubling_increments ( batch_shape , max_doublings , step_size , seed = seed_gen ( ) ) # The left and right end points. Shape (max_doublings+1,) + batch_shape. left_endpoints -= left_increments right_endpoints = left_endpoints + widths # Test if these end points lie outside of the slice. # Checks if the end points of the slice are outside the graph of the pdf. left_ep_values = tf . map_fn ( target_log_prob , left_endpoints ) right_ep_values = tf . map_fn ( target_log_prob , right_endpoints ) left_ok = left_ep_values < log_slice_heights right_ok = right_ep_values < log_slice_heights both_ok = left_ok & right_ok both_ok_f = tf . reshape ( both_ok , [ max_doublings + 1 , - 1 ] ) best_interval_idx = _find_best_interval_idx ( tf . cast ( both_ok_f , dtype = tf . int32 ) ) # Formats the above index as required to use with gather_nd. point_index_gather = tf . stack ( [ best_interval_idx , tf . range ( tf . size ( input = best_interval_idx ) ) ] , axis = 1 , name = 'point_index_gather' ) left_ep_f = tf . reshape ( left_endpoints , [ max_doublings + 1 , - 1 ] ) right_ep_f = tf . reshape ( right_endpoints , [ max_doublings + 1 , - 1 ] ) # The x values of the uppper and lower bounds of the slices for each chain. lower_bounds = tf . reshape ( tf . gather_nd ( left_ep_f , point_index_gather ) , batch_shape ) upper_bounds = tf . reshape ( tf . gather_nd ( right_ep_f , point_index_gather ) , batch_shape ) both_ok = tf . reduce_any ( input_tensor = both_ok , axis = 0 ) return upper_bounds , lower_bounds , both_ok\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sample_with_shrinkage ( x_initial , target_log_prob , log_slice_heights , step_size , lower_bounds , upper_bounds , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'sample_with_shrinkage' , [ x_initial , log_slice_heights , step_size , lower_bounds , upper_bounds ] ) : seed_gen = distributions . SeedStream ( seed , salt = '_sample_with_shrinkage' ) # Keeps track of whether an acceptable sample has been found for the chain. found = tf . zeros_like ( x_initial , dtype = tf . bool ) cond = lambda found , * ignored_args : ~ tf . reduce_all ( input_tensor = found ) x_next = tf . identity ( x_initial ) x_initial_shape = tf . shape ( input = x_initial ) x_initial_dtype = x_initial . dtype . base_dtype def _body ( found , left , right , x_next ) : \"\"\"Iterates until every chain has found a suitable next state.\"\"\" proportions = tf . random . uniform ( x_initial_shape , dtype = x_initial_dtype , seed = seed_gen ( ) ) x_proposed = tf . where ( ~ found , left + proportions * ( right - left ) , x_next ) accept_res = _test_acceptance ( x_initial , target_log_prob = target_log_prob , decided = found , log_slice_heights = log_slice_heights , x_proposed = x_proposed , step_size = step_size , lower_bounds = left , upper_bounds = right ) boundary_test = log_slice_heights < target_log_prob ( x_proposed ) can_accept = boundary_test & accept_res next_found = found | can_accept # Note that it might seem that we are moving the left and right end points # even if the point has been accepted (which is contrary to the stated # algorithm in Neal). However, this does not matter because the endpoints # for points that have been already accepted are not used again so it # doesn't matter what we do with them. next_left = tf . where ( x_proposed < x_initial , x_proposed , left ) next_right = tf . where ( x_proposed >= x_initial , x_proposed , right ) return next_found , next_left , next_right , x_proposed return tf . while_loop ( cond = cond , body = _body , loop_vars = ( found , lower_bounds , upper_bounds , x_next ) ) [ - 1 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def slice_sampler_one_dim ( target_log_prob , x_initial , step_size = 0.01 , max_doublings = 30 , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'slice_sampler_one_dim' , [ x_initial , step_size , max_doublings ] ) : x_initial = tf . convert_to_tensor ( value = x_initial ) # Obtain the input dtype of the array. dtype = x_initial . dtype . base_dtype # Select the height of the slice. Tensor of shape x_initial.shape. log_slice_heights = target_log_prob ( x_initial ) - tf . random . gamma ( tf . shape ( input = x_initial ) , alpha = 1 , dtype = dtype , seed = seed ) # Given the above x and slice heights, compute the bounds of the slice for # each chain. upper_bounds , lower_bounds , bounds_satisfied = slice_bounds_by_doubling ( x_initial , target_log_prob , log_slice_heights , max_doublings , step_size , seed = seed ) retval = _sample_with_shrinkage ( x_initial , target_log_prob = target_log_prob , log_slice_heights = log_slice_heights , step_size = step_size , lower_bounds = lower_bounds , upper_bounds = upper_bounds , seed = seed ) return ( retval , target_log_prob ( retval ) , bounds_satisfied , upper_bounds , lower_bounds )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_annealed_importance_chain ( num_steps , proposal_log_prob_fn , target_log_prob_fn , current_state , make_kernel_fn , parallel_iterations = 10 , name = None ) : with tf . compat . v1 . name_scope ( name , \"sample_annealed_importance_chain\" , [ num_steps , current_state ] ) : num_steps = tf . convert_to_tensor ( value = num_steps , dtype = tf . int32 , name = \"num_steps\" ) if mcmc_util . is_list_like ( current_state ) : current_state = [ tf . convert_to_tensor ( value = s , name = \"current_state\" ) for s in current_state ] else : current_state = tf . convert_to_tensor ( value = current_state , name = \"current_state\" ) def _make_convex_combined_log_prob_fn ( iter_ ) : def _fn ( * args ) : p = tf . identity ( proposal_log_prob_fn ( * args ) , name = \"proposal_log_prob\" ) t = tf . identity ( target_log_prob_fn ( * args ) , name = \"target_log_prob\" ) dtype = p . dtype . base_dtype beta = tf . cast ( iter_ + 1 , dtype ) / tf . cast ( num_steps , dtype ) return tf . identity ( beta * t + ( 1. - beta ) * p , name = \"convex_combined_log_prob\" ) return _fn def _loop_body ( iter_ , ais_weights , current_state , kernel_results ) : \"\"\"Closure which implements `tf.while_loop` body.\"\"\" x = ( current_state if mcmc_util . is_list_like ( current_state ) else [ current_state ] ) proposal_log_prob = proposal_log_prob_fn ( * x ) target_log_prob = target_log_prob_fn ( * x ) ais_weights += ( ( target_log_prob - proposal_log_prob ) / tf . cast ( num_steps , ais_weights . dtype ) ) kernel = make_kernel_fn ( _make_convex_combined_log_prob_fn ( iter_ ) ) next_state , inner_results = kernel . one_step ( current_state , kernel_results . inner_results ) kernel_results = AISResults ( proposal_log_prob = proposal_log_prob , target_log_prob = target_log_prob , inner_results = inner_results , ) return [ iter_ + 1 , ais_weights , next_state , kernel_results ] def _bootstrap_results ( init_state ) : \"\"\"Creates first version of `previous_kernel_results`.\"\"\" kernel = make_kernel_fn ( _make_convex_combined_log_prob_fn ( iter_ = 0 ) ) inner_results = kernel . bootstrap_results ( init_state ) convex_combined_log_prob = inner_results . accepted_results . target_log_prob dtype = convex_combined_log_prob . dtype . as_numpy_dtype shape = tf . shape ( input = convex_combined_log_prob ) proposal_log_prob = tf . fill ( shape , dtype ( np . nan ) , name = \"bootstrap_proposal_log_prob\" ) target_log_prob = tf . fill ( shape , dtype ( np . nan ) , name = \"target_target_log_prob\" ) return AISResults ( proposal_log_prob = proposal_log_prob , target_log_prob = target_log_prob , inner_results = inner_results , ) previous_kernel_results = _bootstrap_results ( current_state ) inner_results = previous_kernel_results . inner_results ais_weights = tf . zeros ( shape = tf . broadcast_dynamic_shape ( tf . shape ( input = inner_results . proposed_results . target_log_prob ) , tf . shape ( input = inner_results . accepted_results . target_log_prob ) ) , dtype = inner_results . proposed_results . target_log_prob . dtype . base_dtype ) [ _ , ais_weights , current_state , kernel_results ] = tf . while_loop ( cond = lambda iter_ , * args : iter_ < num_steps , body = _loop_body , loop_vars = [ np . int32 ( 0 ) , # iter_ ais_weights , current_state , previous_kernel_results , ] , parallel_iterations = parallel_iterations ) return [ current_state , ais_weights , kernel_results ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_value_setter ( * * model_kwargs ) : def set_values ( f , * args , * * kwargs ) : \"\"\"Sets random variable values to its aligned value.\"\"\" name = kwargs . get ( \"name\" ) if name in model_kwargs : kwargs [ \"value\" ] = model_kwargs [ name ] return interceptable ( f ) ( * args , * * kwargs ) return set_values\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_log_joint_fn ( model ) : def log_joint_fn ( * args , * * kwargs ) : \"\"\"Log-probability of inputs according to a joint probability distribution. Args: *args: Positional arguments. They are the model's original inputs and can alternatively be specified as part of `kwargs`. **kwargs: Keyword arguments, where for each key-value pair `k` and `v`, `v` is passed as a `value` to the random variable(s) whose keyword argument `name` during construction is equal to `k`. Returns: Scalar tf.Tensor, which represents the model's log-probability summed over all Edward random variables and their dimensions. Raises: TypeError: If a random variable in the model has no specified value in `**kwargs`. \"\"\" log_probs = [ ] def interceptor ( rv_constructor , * rv_args , * * rv_kwargs ) : \"\"\"Overrides a random variable's `value` and accumulates its log-prob.\"\"\" # Set value to keyword argument indexed by `name` (an input tensor). rv_name = rv_kwargs . get ( \"name\" ) if rv_name is None : raise KeyError ( \"Random variable constructor {} has no name \" \"in its arguments.\" . format ( rv_constructor . __name__ ) ) # If no value is explicitly passed in for an RV, default to the value # from the RV constructor. This may have been set explicitly by the user # or forwarded from a lower-level interceptor. previously_specified_value = rv_kwargs . get ( \"value\" ) value = kwargs . get ( rv_name , previously_specified_value ) if value is None : raise LookupError ( \"Keyword argument specifying value for {} is \" \"missing.\" . format ( rv_name ) ) rv_kwargs [ \"value\" ] = value rv = rv_constructor ( * rv_args , * * rv_kwargs ) log_prob = tf . reduce_sum ( input_tensor = rv . distribution . log_prob ( rv . value ) ) log_probs . append ( log_prob ) return rv model_kwargs = _get_function_inputs ( model , kwargs ) with interception ( interceptor ) : model ( * args , * * model_kwargs ) log_prob = sum ( log_probs ) return log_prob return log_joint_fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_function_inputs ( f , src_kwargs ) : if hasattr ( f , \"_func\" ) : # functions returned by tf.make_template f = f . _func # pylint: disable=protected-access try : # getargspec was deprecated in Python 3.6 argspec = inspect . getfullargspec ( f ) except AttributeError : argspec = inspect . getargspec ( f ) fkwargs = { k : v for k , v in six . iteritems ( src_kwargs ) if k in argspec . args } return fkwargs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _vggconv_block ( x , filters , kernel , stride , kernel_posterior_fn ) : out = tfp . layers . Convolution2DFlipout ( filters , kernel , padding = 'same' , kernel_posterior_fn = kernel_posterior_fn ) ( x ) out = tf . keras . layers . BatchNormalization ( ) ( out ) out = tf . keras . layers . Activation ( 'relu' ) ( out ) out = tfp . layers . Convolution2DFlipout ( filters , kernel , padding = 'same' , kernel_posterior_fn = kernel_posterior_fn ) ( out ) out = tf . keras . layers . BatchNormalization ( ) ( out ) out = tf . keras . layers . Activation ( 'relu' ) ( out ) out = tf . keras . layers . MaxPooling2D ( pool_size = ( 2 , 2 ) , strides = stride ) ( out ) return out\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def compute_output_shape ( self , input_shape ) : input_shape = tf . TensorShape ( input_shape ) input_shape = input_shape . with_rank_at_least ( 2 ) if tf . compat . dimension_value ( input_shape [ - 1 ] ) is None : raise ValueError ( 'The innermost dimension of `input_shape` must be defined, ' 'but saw: {}' . format ( input_shape ) ) return input_shape [ : - 1 ] . concatenate ( self . units )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_config ( self ) : config = { 'units' : self . units , 'activation' : ( tf . keras . activations . serialize ( self . activation ) if self . activation else None ) , 'activity_regularizer' : tf . keras . initializers . serialize ( self . activity_regularizer ) , } function_keys = [ 'kernel_posterior_fn' , 'kernel_posterior_tensor_fn' , 'kernel_prior_fn' , 'kernel_divergence_fn' , 'bias_posterior_fn' , 'bias_posterior_tensor_fn' , 'bias_prior_fn' , 'bias_divergence_fn' , ] for function_key in function_keys : function = getattr ( self , function_key ) if function is None : function_name = None function_type = None else : function_name , function_type = tfp_layers_util . serialize_function ( function ) config [ function_key ] = function_name config [ function_key + '_type' ] = function_type base_config = super ( _DenseVariational , self ) . get_config ( ) return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def kernel ( target_log_prob_fn , current_state , step_size , seed = None , current_target_log_prob = None , current_grads_target_log_prob = None , name = None ) : if not tf . executing_eagerly ( ) : raise NotImplementedError ( \"`kernel` is only available in Eager mode.\" ) with tf . compat . v1 . name_scope ( name , default_name = \"nuts_kernel\" , values = [ current_state , step_size , seed , current_target_log_prob , current_grads_target_log_prob ] ) : with tf . compat . v1 . name_scope ( \"initialize\" ) : current_state = [ tf . convert_to_tensor ( value = s ) for s in current_state ] step_size = [ tf . convert_to_tensor ( value = s ) for s in step_size ] value_and_gradients_fn = lambda * args : tfp . math . value_and_gradient ( # pylint: disable=g-long-lambda target_log_prob_fn , args ) value_and_gradients_fn = _embed_no_none_gradient_check ( value_and_gradients_fn ) if ( current_target_log_prob is None or current_grads_target_log_prob is None ) : ( current_target_log_prob , current_grads_target_log_prob ) = value_and_gradients_fn ( * current_state ) seed_stream = tfd . SeedStream ( seed , \"nuts_kernel\" ) current_momentum = [ ] for state_tensor in current_state : momentum_tensor = tf . random . normal ( shape = tf . shape ( input = state_tensor ) , dtype = state_tensor . dtype , seed = seed_stream ( ) ) current_momentum . append ( momentum_tensor ) # Draw a slice variable u ~ Uniform(0, p(initial state, initial # momentum)) and compute log u. For numerical stability, we perform this # in log space where log u = log (u' * p(...)) = log u' + log # p(...) and u' ~ Uniform(0, 1). log_slice_sample = tf . math . log ( tf . random . uniform ( [ ] , seed = seed_stream ( ) ) ) log_slice_sample += _log_joint ( current_target_log_prob , current_momentum ) # Initialize loop variables. It comprises a collection of information # about a \"reverse\" state, a collection of information about a \"forward\" # state, a collection of information about the next state, # the trajectory's tree depth, the number of candidate states, and # whether to continue the trajectory. reverse_state = current_state reverse_target_log_prob = current_target_log_prob reverse_grads_target_log_prob = current_grads_target_log_prob reverse_momentum = current_momentum forward_state = current_state forward_target_log_prob = current_target_log_prob forward_grads_target_log_prob = current_grads_target_log_prob forward_momentum = current_momentum next_state = current_state next_target_log_prob = current_target_log_prob next_grads_target_log_prob = current_grads_target_log_prob depth = 0 num_states = 1 continue_trajectory = True while continue_trajectory : # Grow the No-U-Turn Sampler trajectory by choosing a random direction and # simulating Hamiltonian dynamics in that direction. This extends either # the forward or reverse state. direction = tfp . math . random_rademacher ( [ ] , seed = seed_stream ( ) ) if direction < 0 : [ reverse_state , reverse_target_log_prob , reverse_grads_target_log_prob , reverse_momentum , _ , _ , _ , _ , next_state_in_subtree , next_target_log_prob_in_subtree , next_grads_target_log_prob_in_subtree , num_states_in_subtree , continue_trajectory , ] = _build_tree ( value_and_gradients_fn = value_and_gradients_fn , current_state = reverse_state , current_target_log_prob = reverse_target_log_prob , current_grads_target_log_prob = reverse_grads_target_log_prob , current_momentum = reverse_momentum , direction = direction , depth = depth , step_size = step_size , log_slice_sample = log_slice_sample , seed = seed_stream ( ) ) else : [ _ , _ , _ , _ , forward_state , forward_target_log_prob , forward_grads_target_log_prob , forward_momentum , next_state_in_subtree , next_target_log_prob_in_subtree , next_grads_target_log_prob_in_subtree , num_states_in_subtree , continue_trajectory , ] = _build_tree ( value_and_gradients_fn = value_and_gradients_fn , current_state = forward_state , current_target_log_prob = forward_target_log_prob , current_grads_target_log_prob = forward_grads_target_log_prob , current_momentum = forward_momentum , direction = direction , depth = depth , step_size = step_size , log_slice_sample = log_slice_sample , seed = seed_stream ( ) ) if continue_trajectory : # If the built tree did not terminate, accept the tree's next state # with a certain probability. accept_state_in_subtree = _random_bernoulli ( [ ] , probs = tf . minimum ( 1. , num_states_in_subtree / num_states ) , dtype = tf . bool , seed = seed_stream ( ) ) if accept_state_in_subtree : next_state = next_state_in_subtree next_target_log_prob = next_target_log_prob_in_subtree next_grads_target_log_prob = next_grads_target_log_prob_in_subtree # Continue the NUTS trajectory if the tree-building did not terminate, and # if the reverse-most and forward-most states do not exhibit a U-turn. has_no_u_turn = tf . logical_and ( _has_no_u_turn ( forward_state , reverse_state , forward_momentum ) , _has_no_u_turn ( forward_state , reverse_state , reverse_momentum ) ) continue_trajectory = continue_trajectory and has_no_u_turn num_states += num_states_in_subtree depth += 1 return next_state , next_target_log_prob , next_grads_target_log_prob\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _build_tree ( value_and_gradients_fn , current_state , current_target_log_prob , current_grads_target_log_prob , current_momentum , direction , depth , step_size , log_slice_sample , max_simulation_error = 1000. , seed = None ) : if depth == 0 : # base case # Take a leapfrog step. Terminate the tree-building if the simulation # error from the leapfrog integrator is too large. States discovered by # continuing the simulation are likely to have very low probability. [ next_state , next_target_log_prob , next_grads_target_log_prob , next_momentum , ] = _leapfrog ( value_and_gradients_fn = value_and_gradients_fn , current_state = current_state , current_grads_target_log_prob = current_grads_target_log_prob , current_momentum = current_momentum , step_size = direction * step_size ) next_log_joint = _log_joint ( next_target_log_prob , next_momentum ) num_states = tf . cast ( next_log_joint > log_slice_sample , dtype = tf . int32 ) continue_trajectory = ( next_log_joint > log_slice_sample - max_simulation_error ) return [ next_state , next_target_log_prob , next_grads_target_log_prob , next_momentum , next_state , next_target_log_prob , next_grads_target_log_prob , next_momentum , next_state , next_target_log_prob , next_grads_target_log_prob , num_states , continue_trajectory , ] # Build a tree at the current state. seed_stream = tfd . SeedStream ( seed , \"build_tree\" ) [ reverse_state , reverse_target_log_prob , reverse_grads_target_log_prob , reverse_momentum , forward_state , forward_target_log_prob , forward_grads_target_log_prob , forward_momentum , next_state , next_target_log_prob , next_grads_target_log_prob , num_states , continue_trajectory , ] = _build_tree ( value_and_gradients_fn = value_and_gradients_fn , current_state = current_state , current_target_log_prob = current_target_log_prob , current_grads_target_log_prob = current_grads_target_log_prob , current_momentum = current_momentum , direction = direction , depth = depth - 1 , step_size = step_size , log_slice_sample = log_slice_sample , seed = seed_stream ( ) ) if continue_trajectory : # If the just-built subtree did not terminate, build a second subtree at # the forward or reverse state, as appropriate. if direction < 0 : [ reverse_state , reverse_target_log_prob , reverse_grads_target_log_prob , reverse_momentum , _ , _ , _ , _ , far_state , far_target_log_prob , far_grads_target_log_prob , far_num_states , far_continue_trajectory , ] = _build_tree ( value_and_gradients_fn = value_and_gradients_fn , current_state = reverse_state , current_target_log_prob = reverse_target_log_prob , current_grads_target_log_prob = reverse_grads_target_log_prob , current_momentum = reverse_momentum , direction = direction , depth = depth - 1 , step_size = step_size , log_slice_sample = log_slice_sample , seed = seed_stream ( ) ) else : [ _ , _ , _ , _ , forward_state , forward_target_log_prob , forward_grads_target_log_prob , forward_momentum , far_state , far_target_log_prob , far_grads_target_log_prob , far_num_states , far_continue_trajectory , ] = _build_tree ( value_and_gradients_fn = value_and_gradients_fn , current_state = forward_state , current_target_log_prob = forward_target_log_prob , current_grads_target_log_prob = forward_grads_target_log_prob , current_momentum = forward_momentum , direction = direction , depth = depth - 1 , step_size = step_size , log_slice_sample = log_slice_sample , seed = seed_stream ( ) ) # Propose either `next_state` (which came from the first subtree and so is # nearby) or the new forward/reverse state (which came from the second # subtree and so is far away). num_states += far_num_states accept_far_state = _random_bernoulli ( [ ] , probs = far_num_states / num_states , dtype = tf . bool , seed = seed_stream ( ) ) if accept_far_state : next_state = far_state next_target_log_prob = far_target_log_prob next_grads_target_log_prob = far_grads_target_log_prob # Continue the NUTS trajectory if the far subtree did not terminate either, # and if the reverse-most and forward-most states do not exhibit a U-turn. has_no_u_turn = tf . logical_and ( _has_no_u_turn ( forward_state , reverse_state , forward_momentum ) , _has_no_u_turn ( forward_state , reverse_state , reverse_momentum ) ) continue_trajectory = far_continue_trajectory and has_no_u_turn return [ reverse_state , reverse_target_log_prob , reverse_grads_target_log_prob , reverse_momentum , forward_state , forward_target_log_prob , forward_grads_target_log_prob , forward_momentum , next_state , next_target_log_prob , next_grads_target_log_prob , num_states , continue_trajectory , ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _embed_no_none_gradient_check ( value_and_gradients_fn ) : @ functools . wraps ( value_and_gradients_fn ) def func_wrapped ( * args , * * kwargs ) : \"\"\"Wrapped function which checks for None gradients.\"\"\" value , grads = value_and_gradients_fn ( * args , * * kwargs ) if any ( grad is None for grad in grads ) : raise ValueError ( \"Gradient is None for a state.\" ) return value , grads return func_wrapped\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _has_no_u_turn ( state_one , state_two , momentum ) : dot_product = sum ( [ tf . reduce_sum ( input_tensor = ( s1 - s2 ) * m ) for s1 , s2 , m in zip ( state_one , state_two , momentum ) ] ) return dot_product > 0\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _leapfrog ( value_and_gradients_fn , current_state , current_grads_target_log_prob , current_momentum , step_size ) : mid_momentum = [ m + 0.5 * step * g for m , step , g in zip ( current_momentum , step_size , current_grads_target_log_prob ) ] next_state = [ s + step * m for s , step , m in zip ( current_state , step_size , mid_momentum ) ] next_target_log_prob , next_grads_target_log_prob = value_and_gradients_fn ( * next_state ) next_momentum = [ m + 0.5 * step * g for m , step , g in zip ( mid_momentum , step_size , next_grads_target_log_prob ) ] return [ next_state , next_target_log_prob , next_grads_target_log_prob , next_momentum , ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_joint ( current_target_log_prob , current_momentum ) : momentum_log_prob = - sum ( [ tf . reduce_sum ( input_tensor = 0.5 * ( m ** 2. ) ) for m in current_momentum ] ) return current_target_log_prob + momentum_log_prob\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _random_bernoulli ( shape , probs , dtype = tf . int32 , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , \"random_bernoulli\" , [ shape , probs ] ) : probs = tf . convert_to_tensor ( value = probs ) random_uniform = tf . random . uniform ( shape , dtype = probs . dtype , seed = seed ) return tf . cast ( tf . less ( random_uniform , probs ) , dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def default_loc_scale_fn ( is_singular = False , loc_initializer = tf . compat . v1 . initializers . random_normal ( stddev = 0.1 ) , untransformed_scale_initializer = tf . compat . v1 . initializers . random_normal ( mean = - 3. , stddev = 0.1 ) , loc_regularizer = None , untransformed_scale_regularizer = None , loc_constraint = None , untransformed_scale_constraint = None ) : def _fn ( dtype , shape , name , trainable , add_variable_fn ) : \"\"\"Creates `loc`, `scale` parameters.\"\"\" loc = add_variable_fn ( name = name + '_loc' , shape = shape , initializer = loc_initializer , regularizer = loc_regularizer , constraint = loc_constraint , dtype = dtype , trainable = trainable ) if is_singular : return loc , None untransformed_scale = add_variable_fn ( name = name + '_untransformed_scale' , shape = shape , initializer = untransformed_scale_initializer , regularizer = untransformed_scale_regularizer , constraint = untransformed_scale_constraint , dtype = dtype , trainable = trainable ) scale = ( np . finfo ( dtype . as_numpy_dtype ) . eps + tf . nn . softplus ( untransformed_scale ) ) return loc , scale return _fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def default_mean_field_normal_fn ( is_singular = False , loc_initializer = tf . compat . v1 . initializers . random_normal ( stddev = 0.1 ) , untransformed_scale_initializer = tf . compat . v1 . initializers . random_normal ( mean = - 3. , stddev = 0.1 ) , loc_regularizer = None , untransformed_scale_regularizer = None , loc_constraint = None , untransformed_scale_constraint = None ) : loc_scale_fn = default_loc_scale_fn ( is_singular = is_singular , loc_initializer = loc_initializer , untransformed_scale_initializer = untransformed_scale_initializer , loc_regularizer = loc_regularizer , untransformed_scale_regularizer = untransformed_scale_regularizer , loc_constraint = loc_constraint , untransformed_scale_constraint = untransformed_scale_constraint ) def _fn ( dtype , shape , name , trainable , add_variable_fn ) : \"\"\"Creates multivariate `Deterministic` or `Normal` distribution. Args: dtype: Type of parameter's event. shape: Python `list`-like representing the parameter's event shape. name: Python `str` name prepended to any created (or existing) `tf.Variable`s. trainable: Python `bool` indicating all created `tf.Variable`s should be added to the graph collection `GraphKeys.TRAINABLE_VARIABLES`. add_variable_fn: `tf.get_variable`-like `callable` used to create (or access existing) `tf.Variable`s. Returns: Multivariate `Deterministic` or `Normal` distribution. \"\"\" loc , scale = loc_scale_fn ( dtype , shape , name , trainable , add_variable_fn ) if scale is None : dist = tfd . Deterministic ( loc = loc ) else : dist = tfd . Normal ( loc = loc , scale = scale ) batch_ndims = tf . size ( input = dist . batch_shape_tensor ( ) ) return tfd . Independent ( dist , reinterpreted_batch_ndims = batch_ndims ) return _fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def default_multivariate_normal_fn ( dtype , shape , name , trainable , add_variable_fn ) : del name , trainable , add_variable_fn # unused dist = tfd . Normal ( loc = tf . zeros ( shape , dtype ) , scale = dtype . as_numpy_dtype ( 1 ) ) batch_ndims = tf . size ( input = dist . batch_shape_tensor ( ) ) return tfd . Independent ( dist , reinterpreted_batch_ndims = batch_ndims )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def deserialize_function ( serial , function_type ) : if function_type == 'function' : # Simple lookup in custom objects function = tf . keras . utils . deserialize_keras_object ( serial ) elif function_type == 'lambda' : # Unsafe deserialization from bytecode function = generic_utils . func_load ( serial ) else : raise TypeError ( 'Unknown function type:' , function_type ) return function\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def serialize_function ( func ) : if isinstance ( func , types . LambdaType ) : return generic_utils . func_dump ( func ) , 'lambda' return func . __name__ , 'function'\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def broadcast_structure ( to_structure , from_structure ) : from_parts = tf . nest . flatten ( from_structure ) if len ( from_parts ) == 1 : from_structure = tf . nest . map_structure ( lambda _ : from_parts [ 0 ] , to_structure ) return from_structure\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def expand_as_args ( args ) : return ( isinstance ( args , collections . Sequence ) and not _is_namedtuple ( args ) and not _force_leaf ( args ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _nested_convert_to_tensor ( struct , dtype = None , name = None ) : if dtype is not None or not tf . nest . is_nested ( struct ) : return tf . convert_to_tensor ( struct , dtype = dtype ) if _maybe_convertible_to_tensor ( struct ) : try : # Try converting the structure wholesale. return tf . convert_to_tensor ( value = struct , name = name ) except ( ValueError , TypeError ) : # Unfortunately Eager/Graph mode don't agree on the error type. pass # Try converting all of its children. shallow_struct = _get_shallow_structure ( struct ) return nest . map_structure_up_to ( shallow_struct , lambda s : _nested_convert_to_tensor ( s , name = name ) , struct )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def convert_args_to_tensor ( args , dtype = None , name = None ) : if dtype is None : if expand_as_args ( args ) or _expand_as_kwargs ( args ) : shallow_args = _get_shallow_structure ( args ) return nest . map_structure_up_to ( shallow_args , lambda s : _nested_convert_to_tensor ( s , name = name ) , args ) else : return _nested_convert_to_tensor ( args , name = name ) else : return nest . map_structure_up_to ( dtype , lambda s , dtype : _nested_convert_to_tensor ( s , dtype , name ) , args , dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def call_fn ( fn , args ) : if expand_as_args ( args ) : return fn ( * args ) elif _expand_as_kwargs ( args ) : return fn ( * * args ) else : return fn ( args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _wrap_method ( cls , attr ) : fn = getattr ( cls , attr ) is_property = isinstance ( fn , property ) if is_property : fn = fn . fget @ functools . wraps ( fn ) def wrapped ( self , * args , * * kwargs ) : return fn ( self . _value ( ) , * args , * * kwargs ) # pylint: disable=protected-access return property ( wrapped ) if is_property else wrapped\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_tensor_like_attributes ( ) : # Enable \"Tensor semantics\" for distributions. # See tensorflow/python/framework/ops.py `class Tensor` for details. attrs = dict ( ) # Setup overloadable operators and white-listed members / properties. attrs . update ( ( attr , _wrap_method ( tf . Tensor , attr ) ) for attr in tf . Tensor . OVERLOADABLE_OPERATORS . union ( { '__iter__' } ) ) # Copy some members straight-through. attrs . update ( ( attr , getattr ( tf . Tensor , attr ) ) for attr in { '__nonzero__' , '__bool__' , '__array_priority__' } ) return attrs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _value ( self , dtype = None , name = None , as_ref = False ) : # pylint: disable=g-doc-args # pylint: disable=protected-access if as_ref : raise NotImplementedError ( 'Cannot convert a `Distribution` to a reference ' '(e.g., `tf.Variable`).' ) if self . _concrete_value is None : if self . _convert_to_tensor_fn is None : raise NotImplementedError ( 'Failed to convert object of type {} to Tensor. Contents: {}. ' 'Call `distribution.set_tensor_conversion(lambda self: ...)` to ' 'enable `tf.convert_to_tensor` capability. For example: ' '`x = tfd.Normal(0,1).set_tensor_conversion(tfd.Distribution.mean)`' ' results in `tf.convert_to_tensor(x)` being identical to ' '`x.mean()`.' . format ( type ( self ) , self ) ) with self . _name_scope ( 'value' ) : self . _concrete_value = ( self . _convert_to_tensor_fn ( self ) if callable ( self . _convert_to_tensor_fn ) else self . _convert_to_tensor_fn ) if not tf . is_tensor ( self . _concrete_value ) : self . _concrete_value = tfd . _convert_to_tensor ( value = self . _concrete_value , name = name or 'concrete_value' , dtype = dtype , dtype_hint = self . dtype ) return self . _concrete_value\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_encoder ( activation , latent_size , base_depth ) : conv = functools . partial ( tf . keras . layers . Conv2D , padding = \"SAME\" , activation = activation ) encoder_net = tf . keras . Sequential ( [ conv ( base_depth , 5 , 1 ) , conv ( base_depth , 5 , 2 ) , conv ( 2 * base_depth , 5 , 1 ) , conv ( 2 * base_depth , 5 , 2 ) , conv ( 4 * latent_size , 7 , padding = \"VALID\" ) , tf . keras . layers . Flatten ( ) , tf . keras . layers . Dense ( 2 * latent_size , activation = None ) , ] ) def encoder ( images ) : images = 2 * tf . cast ( images , dtype = tf . float32 ) - 1 net = encoder_net ( images ) return tfd . MultivariateNormalDiag ( loc = net [ ... , : latent_size ] , scale_diag = tf . nn . softplus ( net [ ... , latent_size : ] + _softplus_inverse ( 1.0 ) ) , name = \"code\" ) return encoder\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_decoder ( activation , latent_size , output_shape , base_depth ) : deconv = functools . partial ( tf . keras . layers . Conv2DTranspose , padding = \"SAME\" , activation = activation ) conv = functools . partial ( tf . keras . layers . Conv2D , padding = \"SAME\" , activation = activation ) decoder_net = tf . keras . Sequential ( [ deconv ( 2 * base_depth , 7 , padding = \"VALID\" ) , deconv ( 2 * base_depth , 5 ) , deconv ( 2 * base_depth , 5 , 2 ) , deconv ( base_depth , 5 ) , deconv ( base_depth , 5 , 2 ) , deconv ( base_depth , 5 ) , conv ( output_shape [ - 1 ] , 5 , activation = None ) , ] ) def decoder ( codes ) : original_shape = tf . shape ( input = codes ) # Collapse the sample and batch dimension and convert to rank-4 tensor for # use with a convolutional decoder network. codes = tf . reshape ( codes , ( - 1 , 1 , 1 , latent_size ) ) logits = decoder_net ( codes ) logits = tf . reshape ( logits , shape = tf . concat ( [ original_shape [ : - 1 ] , output_shape ] , axis = 0 ) ) return tfd . Independent ( tfd . Bernoulli ( logits = logits ) , reinterpreted_batch_ndims = len ( output_shape ) , name = \"image\" ) return decoder\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_mixture_prior ( latent_size , mixture_components ) : if mixture_components == 1 : # See the module docstring for why we don't learn the parameters here. return tfd . MultivariateNormalDiag ( loc = tf . zeros ( [ latent_size ] ) , scale_identity_multiplier = 1.0 ) loc = tf . compat . v1 . get_variable ( name = \"loc\" , shape = [ mixture_components , latent_size ] ) raw_scale_diag = tf . compat . v1 . get_variable ( name = \"raw_scale_diag\" , shape = [ mixture_components , latent_size ] ) mixture_logits = tf . compat . v1 . get_variable ( name = \"mixture_logits\" , shape = [ mixture_components ] ) return tfd . MixtureSameFamily ( components_distribution = tfd . MultivariateNormalDiag ( loc = loc , scale_diag = tf . nn . softplus ( raw_scale_diag ) ) , mixture_distribution = tfd . Categorical ( logits = mixture_logits ) , name = \"prior\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pack_images ( images , rows , cols ) : shape = tf . shape ( input = images ) width = shape [ - 3 ] height = shape [ - 2 ] depth = shape [ - 1 ] images = tf . reshape ( images , ( - 1 , width , height , depth ) ) batch = tf . shape ( input = images ) [ 0 ] rows = tf . minimum ( rows , batch ) cols = tf . minimum ( batch // rows , cols ) images = images [ : rows * cols ] images = tf . reshape ( images , ( rows , cols , width , height , depth ) ) images = tf . transpose ( a = images , perm = [ 0 , 2 , 1 , 3 , 4 ] ) images = tf . reshape ( images , [ 1 , rows * width , cols * height , depth ] ) return images\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def model_fn ( features , labels , mode , params , config ) : del labels , config if params [ \"analytic_kl\" ] and params [ \"mixture_components\" ] != 1 : raise NotImplementedError ( \"Using `analytic_kl` is only supported when `mixture_components = 1` \" \"since there's no closed form otherwise.\" ) encoder = make_encoder ( params [ \"activation\" ] , params [ \"latent_size\" ] , params [ \"base_depth\" ] ) decoder = make_decoder ( params [ \"activation\" ] , params [ \"latent_size\" ] , IMAGE_SHAPE , params [ \"base_depth\" ] ) latent_prior = make_mixture_prior ( params [ \"latent_size\" ] , params [ \"mixture_components\" ] ) image_tile_summary ( \"input\" , tf . cast ( features , dtype = tf . float32 ) , rows = 1 , cols = 16 ) approx_posterior = encoder ( features ) approx_posterior_sample = approx_posterior . sample ( params [ \"n_samples\" ] ) decoder_likelihood = decoder ( approx_posterior_sample ) image_tile_summary ( \"recon/sample\" , tf . cast ( decoder_likelihood . sample ( ) [ : 3 , : 16 ] , dtype = tf . float32 ) , rows = 3 , cols = 16 ) image_tile_summary ( \"recon/mean\" , decoder_likelihood . mean ( ) [ : 3 , : 16 ] , rows = 3 , cols = 16 ) # `distortion` is just the negative log likelihood. distortion = - decoder_likelihood . log_prob ( features ) avg_distortion = tf . reduce_mean ( input_tensor = distortion ) tf . compat . v1 . summary . scalar ( \"distortion\" , avg_distortion ) if params [ \"analytic_kl\" ] : rate = tfd . kl_divergence ( approx_posterior , latent_prior ) else : rate = ( approx_posterior . log_prob ( approx_posterior_sample ) - latent_prior . log_prob ( approx_posterior_sample ) ) avg_rate = tf . reduce_mean ( input_tensor = rate ) tf . compat . v1 . summary . scalar ( \"rate\" , avg_rate ) elbo_local = - ( rate + distortion ) elbo = tf . reduce_mean ( input_tensor = elbo_local ) loss = - elbo tf . compat . v1 . summary . scalar ( \"elbo\" , elbo ) importance_weighted_elbo = tf . reduce_mean ( input_tensor = tf . reduce_logsumexp ( input_tensor = elbo_local , axis = 0 ) - tf . math . log ( tf . cast ( params [ \"n_samples\" ] , dtype = tf . float32 ) ) ) tf . compat . v1 . summary . scalar ( \"elbo/importance_weighted\" , importance_weighted_elbo ) # Decode samples from the prior for visualization. random_image = decoder ( latent_prior . sample ( 16 ) ) image_tile_summary ( \"random/sample\" , tf . cast ( random_image . sample ( ) , dtype = tf . float32 ) , rows = 4 , cols = 4 ) image_tile_summary ( \"random/mean\" , random_image . mean ( ) , rows = 4 , cols = 4 ) # Perform variational inference by minimizing the -ELBO. global_step = tf . compat . v1 . train . get_or_create_global_step ( ) learning_rate = tf . compat . v1 . train . cosine_decay ( params [ \"learning_rate\" ] , global_step , params [ \"max_steps\" ] ) tf . compat . v1 . summary . scalar ( \"learning_rate\" , learning_rate ) optimizer = tf . compat . v1 . train . AdamOptimizer ( learning_rate ) train_op = optimizer . minimize ( loss , global_step = global_step ) return tf . estimator . EstimatorSpec ( mode = mode , loss = loss , train_op = train_op , eval_metric_ops = { \"elbo\" : tf . compat . v1 . metrics . mean ( elbo ) , \"elbo/importance_weighted\" : tf . compat . v1 . metrics . mean ( importance_weighted_elbo ) , \"rate\" : tf . compat . v1 . metrics . mean ( avg_rate ) , \"distortion\" : tf . compat . v1 . metrics . mean ( avg_distortion ) , } , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download ( directory , filename ) : filepath = os . path . join ( directory , filename ) if tf . io . gfile . exists ( filepath ) : return filepath if not tf . io . gfile . exists ( directory ) : tf . io . gfile . makedirs ( directory ) url = os . path . join ( ROOT_PATH , filename ) print ( \"Downloading %s to %s\" % ( url , filepath ) ) urllib . request . urlretrieve ( url , filepath ) return filepath\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_fake_input_fns ( batch_size ) : random_sample = np . random . rand ( batch_size , * IMAGE_SHAPE ) . astype ( \"float32\" ) def train_input_fn ( ) : dataset = tf . data . Dataset . from_tensor_slices ( random_sample ) . map ( lambda row : ( row , 0 ) ) . batch ( batch_size ) . repeat ( ) return tf . compat . v1 . data . make_one_shot_iterator ( dataset ) . get_next ( ) def eval_input_fn ( ) : dataset = tf . data . Dataset . from_tensor_slices ( random_sample ) . map ( lambda row : ( row , 0 ) ) . batch ( batch_size ) return tf . compat . v1 . data . make_one_shot_iterator ( dataset ) . get_next ( ) return train_input_fn , eval_input_fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_input_fns ( data_dir , batch_size ) : # Build an iterator over training batches. def train_input_fn ( ) : dataset = static_mnist_dataset ( data_dir , \"train\" ) dataset = dataset . shuffle ( 50000 ) . repeat ( ) . batch ( batch_size ) return tf . compat . v1 . data . make_one_shot_iterator ( dataset ) . get_next ( ) # Build an iterator over the heldout set. def eval_input_fn ( ) : eval_dataset = static_mnist_dataset ( data_dir , \"valid\" ) eval_dataset = eval_dataset . batch ( batch_size ) return tf . compat . v1 . data . make_one_shot_iterator ( eval_dataset ) . get_next ( ) return train_input_fn , eval_input_fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _validate_block_sizes ( block_sizes , bijectors , validate_args ) : block_sizes_shape = block_sizes . shape if tensorshape_util . is_fully_defined ( block_sizes_shape ) : if ( tensorshape_util . rank ( block_sizes_shape ) != 1 or ( tensorshape_util . num_elements ( block_sizes_shape ) != len ( bijectors ) ) ) : raise ValueError ( '`block_sizes` must be `None`, or a vector of the same length as ' '`bijectors`. Got a `Tensor` with shape {} and `bijectors` of ' 'length {}' . format ( block_sizes_shape , len ( bijectors ) ) ) return block_sizes elif validate_args : message = ( '`block_sizes` must be `None`, or a vector of the same length ' 'as `bijectors`.' ) with tf . control_dependencies ( [ assert_util . assert_equal ( tf . size ( input = block_sizes ) , len ( bijectors ) , message = message ) , assert_util . assert_equal ( tf . rank ( block_sizes ) , 1 ) ] ) : return tf . identity ( block_sizes ) else : return block_sizes\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def maybe_check_wont_broadcast ( flat_xs , validate_args ) : flat_xs = tuple ( flat_xs ) # So we can receive generators. if not validate_args : # Note: we don't try static validation because it is theoretically # possible that a user wants to take advantage of broadcasting. # Only when `validate_args` is `True` do we enforce the validation. return flat_xs msg = 'Broadcasting probably indicates an error in model specification.' s = tuple ( x . shape for x in flat_xs ) if all ( tensorshape_util . is_fully_defined ( s_ ) for s_ in s ) : if not all ( a == b for a , b in zip ( s [ 1 : ] , s [ : - 1 ] ) ) : raise ValueError ( msg ) return flat_xs assertions = [ assert_util . assert_equal ( a , b , message = msg ) for a , b in zip ( s [ 1 : ] , s [ : - 1 ] ) ] with tf . control_dependencies ( assertions ) : return tuple ( tf . identity ( x ) for x in flat_xs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def softplus_and_shift ( x , shift = 1e-5 , name = None ) : with tf . compat . v1 . name_scope ( name , 'softplus_and_shift' , [ x , shift ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) y = tf . nn . softplus ( x ) if shift is not None : y += shift return y\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def tril_with_diag_softplus_and_shift ( x , diag_shift = 1e-5 , name = None ) : with tf . compat . v1 . name_scope ( name , 'tril_with_diag_softplus_and_shift' , [ x , diag_shift ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) x = tfd . fill_triangular ( x ) diag = softplus_and_shift ( tf . linalg . diag_part ( x ) , diag_shift ) x = tf . linalg . set_diag ( x , diag ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def multivariate_normal_tril ( x , dims , layer_fn = tf . compat . v1 . layers . dense , loc_fn = lambda x : x , scale_fn = tril_with_diag_softplus_and_shift , name = None ) : with tf . compat . v1 . name_scope ( name , 'multivariate_normal_tril' , [ x , dims ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) x = layer_fn ( x , dims + dims * ( dims + 1 ) // 2 ) return tfd . MultivariateNormalTriL ( loc = loc_fn ( x [ ... , : dims ] ) , scale_tril = scale_fn ( x [ ... , dims : ] ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bernoulli ( x , layer_fn = tf . compat . v1 . layers . dense , name = None ) : with tf . compat . v1 . name_scope ( name , 'bernoulli' , [ x ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) logits = tf . squeeze ( layer_fn ( x , 1 ) , axis = - 1 ) return tfd . Bernoulli ( logits = logits )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def normal ( x , layer_fn = tf . compat . v1 . layers . dense , loc_fn = lambda x : x , scale_fn = 1. , name = None ) : with tf . compat . v1 . name_scope ( name , 'normal' , [ x ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) if callable ( scale_fn ) : y = layer_fn ( x , 2 ) loc = loc_fn ( y [ ... , 0 ] ) scale = scale_fn ( y [ ... , 1 ] ) else : y = tf . squeeze ( layer_fn ( x , 1 ) , axis = - 1 ) loc = loc_fn ( y ) scale = tf . cast ( scale_fn , loc . dtype . base_dtype ) return tfd . Normal ( loc = loc , scale = scale )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def poisson ( x , layer_fn = tf . compat . v1 . layers . dense , log_rate_fn = lambda x : x , name = None ) : with tf . compat . v1 . name_scope ( name , 'poisson' , [ x ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) log_rate = log_rate_fn ( tf . squeeze ( layer_fn ( x , 1 ) , axis = - 1 ) ) return tfd . Poisson ( log_rate = log_rate )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def secant_root ( objective_fn , initial_position , next_position = None , value_at_position = None , position_tolerance = 1e-8 , value_tolerance = 1e-8 , max_iterations = 50 , stopping_policy_fn = tf . reduce_all , validate_args = False , name = None ) : if not callable ( stopping_policy_fn ) : raise ValueError ( 'stopping_policy_fn must be callable' ) position = tf . convert_to_tensor ( value = initial_position , name = 'position' , ) value_at_position = tf . convert_to_tensor ( value = value_at_position or objective_fn ( position ) , name = 'value_at_position' , dtype = position . dtype . base_dtype ) zero = tf . zeros_like ( position ) position_tolerance = tf . convert_to_tensor ( value = position_tolerance , name = 'position_tolerance' , dtype = position . dtype ) value_tolerance = tf . convert_to_tensor ( value = value_tolerance , name = 'value_tolerance' , dtype = position . dtype ) num_iterations = tf . zeros_like ( position , dtype = tf . int32 ) max_iterations = tf . convert_to_tensor ( value = max_iterations , dtype = tf . int32 ) max_iterations = tf . broadcast_to ( max_iterations , name = 'max_iterations' , shape = position . shape ) # Compute the step from `next_position` if present. This covers the case where # a user has two starting points, which bound the root or has a specific step # size in mind. if next_position is None : epsilon = tf . constant ( 1e-4 , dtype = position . dtype , shape = position . shape ) step = position * epsilon + tf . sign ( position ) * epsilon else : step = next_position - initial_position finished = tf . constant ( False , shape = position . shape ) # Negate `stopping_condition` to determine if the search should continue. # This means, in particular, that tf.reduce_*all* will return only when the # search is finished for *all* starting points. def _should_continue ( position , value_at_position , num_iterations , step , finished ) : \"\"\"Indicates whether the overall search should continue. Args: position: `Tensor` containing the current root estimates. value_at_position: `Tensor` containing the value of `objective_fn` at `position`. num_iterations: `Tensor` containing the current iteration index for each point. step: `Tensor` containing the size of the step to take for each point. finished: `Tensor` indicating for which points the search is finished. Returns: A boolean value indicating whether the overall search should continue. \"\"\" del position , value_at_position , num_iterations , step # Unused return ~ tf . convert_to_tensor ( value = stopping_policy_fn ( finished ) , name = 'should_stop' , dtype = tf . bool ) # For each point in `position`, the search is stopped if either: # (1) A root has been found # (2) f(position) == f(position + step) # (3) The maximum number of iterations has been reached # In case (2), the search may be stopped both before the desired tolerance is # achieved (or even a root is found), and the maximum number of iterations is # reached. def _body ( position , value_at_position , num_iterations , step , finished ) : \"\"\"Performs one iteration of the secant root-finding algorithm. Args: position: `Tensor` containing the current root estimates. value_at_position: `Tensor` containing the value of `objective_fn` at `position`. num_iterations: `Tensor` containing the current iteration index for each point. step: `Tensor` containing the size of the step to take for each point. finished: `Tensor` indicating for which points the search is finished. Returns: The `Tensor`s to use for the next iteration of the algorithm. \"\"\" # True if the search was already finished, or (1) or (3) just became true. was_finished = finished | ( num_iterations >= max_iterations ) | ( tf . abs ( step ) < position_tolerance ) | ( tf . abs ( value_at_position ) < value_tolerance ) # Compute the next position and the value at that point. next_position = tf . where ( was_finished , position , position + step ) value_at_next_position = tf . where ( was_finished , value_at_position , objective_fn ( next_position ) ) # True if the search was already finished, or (2) just became true. is_finished = tf . equal ( value_at_position , value_at_next_position ) # Use the mid-point between the last two positions if (2) just became true. next_position = tf . where ( is_finished & ~ was_finished , ( position + next_position ) * 0.5 , next_position ) # Once finished, stop updating the iteration index and set the step to zero. num_iterations = tf . where ( is_finished , num_iterations , num_iterations + 1 ) next_step = tf . where ( is_finished , zero , step * value_at_next_position / ( value_at_position - value_at_next_position ) ) return ( next_position , value_at_next_position , num_iterations , next_step , is_finished ) with tf . compat . v1 . name_scope ( name , 'secant_root' , [ position , next_position , value_at_position , max_iterations ] ) : assertions = [ ] if validate_args : assertions += [ tf . Assert ( tf . reduce_all ( input_tensor = position_tolerance > zero ) , [ position_tolerance ] ) , tf . Assert ( tf . reduce_all ( input_tensor = value_tolerance > zero ) , [ value_tolerance ] ) , tf . Assert ( tf . reduce_all ( input_tensor = max_iterations >= num_iterations ) , [ max_iterations ] ) , ] with tf . control_dependencies ( assertions ) : root , value_at_root , num_iterations , _ , _ = tf . while_loop ( cond = _should_continue , body = _body , loop_vars = [ position , value_at_position , num_iterations , step , finished ] ) return RootSearchResults ( estimated_root = root , objective_at_estimated_root = value_at_root , num_iterations = num_iterations )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _euler_method ( random_draw_parts , state_parts , drift_parts , step_size_parts , volatility_parts , name = None ) : with tf . compat . v1 . name_scope ( name , 'mala_euler_method' , [ random_draw_parts , state_parts , drift_parts , step_size_parts , volatility_parts ] ) : proposed_state_parts = [ ] for random_draw , state , drift , step_size , volatility in zip ( random_draw_parts , state_parts , drift_parts , step_size_parts , volatility_parts ) : proposal = state + drift + volatility * tf . sqrt ( step_size ) * random_draw proposed_state_parts . append ( proposal ) return proposed_state_parts\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_drift ( step_size_parts , volatility_parts , grads_volatility , grads_target_log_prob , name = None ) : with tf . compat . v1 . name_scope ( name , 'mala_get_drift' , [ step_size_parts , volatility_parts , grads_volatility , grads_target_log_prob ] ) : drift_parts = [ ] for step_size , volatility , grad_volatility , grad_target_log_prob in ( zip ( step_size_parts , volatility_parts , grads_volatility , grads_target_log_prob ) ) : volatility_squared = tf . square ( volatility ) drift = 0.5 * step_size * ( volatility_squared * grad_target_log_prob + grad_volatility ) drift_parts . append ( drift ) return drift_parts\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _compute_log_acceptance_correction ( current_state_parts , proposed_state_parts , current_volatility_parts , proposed_volatility_parts , current_drift_parts , proposed_drift_parts , step_size_parts , independent_chain_ndims , name = None ) : with tf . compat . v1 . name_scope ( name , 'compute_log_acceptance_correction' , [ current_state_parts , proposed_state_parts , current_volatility_parts , proposed_volatility_parts , current_drift_parts , proposed_drift_parts , step_size_parts , independent_chain_ndims ] ) : proposed_log_density_parts = [ ] dual_log_density_parts = [ ] for [ current_state , proposed_state , current_volatility , proposed_volatility , current_drift , proposed_drift , step_size , ] in zip ( current_state_parts , proposed_state_parts , current_volatility_parts , proposed_volatility_parts , current_drift_parts , proposed_drift_parts , step_size_parts , ) : axis = tf . range ( independent_chain_ndims , tf . rank ( current_state ) ) state_diff = proposed_state - current_state current_volatility *= tf . sqrt ( step_size ) proposed_energy = ( state_diff - current_drift ) / current_volatility proposed_volatility *= tf . sqrt ( step_size ) # Compute part of `q(proposed_state | current_state)` proposed_energy = ( tf . reduce_sum ( input_tensor = mcmc_util . safe_sum ( [ tf . math . log ( current_volatility ) , 0.5 * ( proposed_energy ** 2 ) ] ) , axis = axis ) ) proposed_log_density_parts . append ( - proposed_energy ) # Compute part of `q(current_state | proposed_state)` dual_energy = ( state_diff + proposed_drift ) / proposed_volatility dual_energy = ( tf . reduce_sum ( input_tensor = mcmc_util . safe_sum ( [ tf . math . log ( proposed_volatility ) , 0.5 * ( dual_energy ** 2 ) ] ) , axis = axis ) ) dual_log_density_parts . append ( - dual_energy ) # Compute `q(proposed_state | current_state)` proposed_log_density_reduce = tf . reduce_sum ( input_tensor = tf . stack ( proposed_log_density_parts , axis = - 1 ) , axis = - 1 ) # Compute `q(current_state | proposed_state)` dual_log_density_reduce = tf . reduce_sum ( input_tensor = tf . stack ( dual_log_density_parts , axis = - 1 ) , axis = - 1 ) return mcmc_util . safe_sum ( [ dual_log_density_reduce , - proposed_log_density_reduce ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_call_volatility_fn_and_grads ( volatility_fn , state , volatility_fn_results = None , grads_volatility_fn = None , sample_shape = None , parallel_iterations = 10 ) : state_parts = list ( state ) if mcmc_util . is_list_like ( state ) else [ state ] needs_volatility_fn_gradients = grads_volatility_fn is None # Convert `volatility_fn_results` to a list if volatility_fn_results is None : volatility_fn_results = volatility_fn ( * state_parts ) volatility_fn_results = ( list ( volatility_fn_results ) if mcmc_util . is_list_like ( volatility_fn_results ) else [ volatility_fn_results ] ) if len ( volatility_fn_results ) == 1 : volatility_fn_results *= len ( state_parts ) if len ( state_parts ) != len ( volatility_fn_results ) : raise ValueError ( '`volatility_fn` should return a tensor or a list ' 'of the same length as `current_state`.' ) # The shape of 'volatility_parts' needs to have the number of chains as a # leading dimension. For determinism we broadcast 'volatility_parts' to the # shape of `state_parts` since each dimension of `state_parts` could have a # different volatility value. volatility_fn_results = _maybe_broadcast_volatility ( volatility_fn_results , state_parts ) if grads_volatility_fn is None : [ _ , grads_volatility_fn , ] = diag_jacobian ( xs = state_parts , ys = volatility_fn_results , sample_shape = sample_shape , parallel_iterations = parallel_iterations , fn = volatility_fn ) # Compute gradient of `volatility_parts**2` if needs_volatility_fn_gradients : grads_volatility_fn = [ 2. * g * volatility if g is not None else tf . zeros_like ( fn_arg , dtype = fn_arg . dtype . base_dtype ) for g , volatility , fn_arg in zip ( grads_volatility_fn , volatility_fn_results , state_parts ) ] return volatility_fn_results , grads_volatility_fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_broadcast_volatility ( volatility_parts , state_parts ) : return [ v + tf . zeros_like ( sp , dtype = sp . dtype . base_dtype ) for v , sp in zip ( volatility_parts , state_parts ) ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_args ( target_log_prob_fn , volatility_fn , state , step_size , target_log_prob = None , grads_target_log_prob = None , volatility = None , grads_volatility_fn = None , diffusion_drift = None , parallel_iterations = 10 ) : state_parts = list ( state ) if mcmc_util . is_list_like ( state ) else [ state ] [ target_log_prob , grads_target_log_prob , ] = mcmc_util . maybe_call_fn_and_grads ( target_log_prob_fn , state_parts , target_log_prob , grads_target_log_prob ) [ volatility_parts , grads_volatility , ] = _maybe_call_volatility_fn_and_grads ( volatility_fn , state_parts , volatility , grads_volatility_fn , distribution_util . prefer_static_shape ( target_log_prob ) , parallel_iterations ) step_sizes = ( list ( step_size ) if mcmc_util . is_list_like ( step_size ) else [ step_size ] ) step_sizes = [ tf . convert_to_tensor ( value = s , name = 'step_size' , dtype = target_log_prob . dtype ) for s in step_sizes ] if len ( step_sizes ) == 1 : step_sizes *= len ( state_parts ) if len ( state_parts ) != len ( step_sizes ) : raise ValueError ( 'There should be exactly one `step_size` or it should ' 'have same length as `current_state`.' ) if diffusion_drift is None : diffusion_drift_parts = _get_drift ( step_sizes , volatility_parts , grads_volatility , grads_target_log_prob ) else : diffusion_drift_parts = ( list ( diffusion_drift ) if mcmc_util . is_list_like ( diffusion_drift ) else [ diffusion_drift ] ) if len ( state_parts ) != len ( diffusion_drift ) : raise ValueError ( 'There should be exactly one `diffusion_drift` or it ' 'should have same length as list-like `current_state`.' ) return [ state_parts , step_sizes , target_log_prob , grads_target_log_prob , volatility_parts , grads_volatility , diffusion_drift_parts , ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_ar_transition_matrix ( coefficients ) : top_row = tf . expand_dims ( coefficients , - 2 ) coef_shape = dist_util . prefer_static_shape ( coefficients ) batch_shape , order = coef_shape [ : - 1 ] , coef_shape [ - 1 ] remaining_rows = tf . concat ( [ tf . eye ( order - 1 , dtype = coefficients . dtype , batch_shape = batch_shape ) , tf . zeros ( tf . concat ( [ batch_shape , ( order - 1 , 1 ) ] , axis = 0 ) , dtype = coefficients . dtype ) ] , axis = - 1 ) ar_matrix = tf . concat ( [ top_row , remaining_rows ] , axis = - 2 ) return ar_matrix\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def diag_jacobian ( xs , ys = None , sample_shape = None , fn = None , parallel_iterations = 10 , name = None ) : with tf . compat . v1 . name_scope ( name , 'jacobians_diag' , [ xs , ys ] ) : if sample_shape is None : sample_shape = [ 1 ] # Output Jacobian diagonal jacobians_diag_res = [ ] # Convert input `xs` to a list xs = list ( xs ) if _is_list_like ( xs ) else [ xs ] xs = [ tf . convert_to_tensor ( value = x ) for x in xs ] if not tf . executing_eagerly ( ) : if ys is None : if fn is None : raise ValueError ( 'Both `ys` and `fn` can not be `None`' ) else : ys = fn ( * xs ) # Convert ys to a list ys = list ( ys ) if _is_list_like ( ys ) else [ ys ] if len ( xs ) != len ( ys ) : raise ValueError ( '`xs` and `ys` should have the same length' ) for y , x in zip ( ys , xs ) : # Broadcast `y` to the shape of `x`. y_ = y + tf . zeros_like ( x ) # Change `event_shape` to one-dimension y_ = tf . reshape ( y , tf . concat ( [ sample_shape , [ - 1 ] ] , - 1 ) ) # Declare an iterator and tensor array loop variables for the gradients. n = tf . size ( input = x ) / tf . cast ( tf . reduce_prod ( input_tensor = sample_shape ) , dtype = tf . int32 ) n = tf . cast ( n , dtype = tf . int32 ) loop_vars = [ 0 , tf . TensorArray ( x . dtype , n ) ] def loop_body ( j ) : \"\"\"Loop function to compute gradients of the each direction.\"\"\" # Gradient along direction `j`. res = tf . gradients ( ys = y_ [ ... , j ] , xs = x ) [ 0 ] # pylint: disable=cell-var-from-loop if res is None : # Return zero, if the gradient is `None`. res = tf . zeros ( tf . concat ( [ sample_shape , [ 1 ] ] , - 1 ) , dtype = x . dtype ) # pylint: disable=cell-var-from-loop else : # Reshape `event_shape` to 1D res = tf . reshape ( res , tf . concat ( [ sample_shape , [ - 1 ] ] , - 1 ) ) # Add artificial dimension for the case of zero shape input tensor res = tf . expand_dims ( res , 0 ) res = res [ ... , j ] return res # pylint: disable=cell-var-from-loop # Iterate over all elements of the gradient and compute second order # derivatives. _ , jacobian_diag_res = tf . while_loop ( cond = lambda j , _ : j < n , # pylint: disable=cell-var-from-loop body = lambda j , result : ( j + 1 , result . write ( j , loop_body ( j ) ) ) , loop_vars = loop_vars , parallel_iterations = parallel_iterations ) shape_x = tf . shape ( input = x ) # Stack gradients together and move flattened `event_shape` to the # zero position reshaped_jacobian_diag = tf . transpose ( a = jacobian_diag_res . stack ( ) ) # Reshape to the original tensor reshaped_jacobian_diag = tf . reshape ( reshaped_jacobian_diag , shape_x ) jacobians_diag_res . append ( reshaped_jacobian_diag ) else : if fn is None : raise ValueError ( '`fn` can not be `None` when eager execution is ' 'enabled' ) if ys is None : ys = fn ( * xs ) def fn_slice ( i , j ) : \"\"\"Broadcast y[i], flatten event shape of y[i], return y[i][..., j].\"\"\" def fn_broadcast ( * state ) : res = fn ( * state ) res = list ( res ) if _is_list_like ( res ) else [ res ] if len ( res ) != len ( state ) : res *= len ( state ) res = [ tf . reshape ( r + tf . zeros_like ( s ) , tf . concat ( [ sample_shape , [ - 1 ] ] , - 1 ) ) for r , s in zip ( res , state ) ] return res # Expand dimensions before returning in order to support 0D input `xs` return lambda * state : tf . expand_dims ( fn_broadcast ( * state ) [ i ] , 0 ) [ ... , j ] def make_loop_body ( i , x ) : \"\"\"Loop function to compute gradients of the each direction.\"\"\" def _fn ( j , result ) : res = value_and_gradient ( fn_slice ( i , j ) , xs ) [ 1 ] [ i ] if res is None : res = tf . zeros ( tf . concat ( [ sample_shape , [ 1 ] ] , - 1 ) , dtype = x . dtype ) else : res = tf . reshape ( res , tf . concat ( [ sample_shape , [ - 1 ] ] , - 1 ) ) res = res [ ... , j ] return j + 1 , result . write ( j , res ) return _fn for i , x in enumerate ( xs ) : # Declare an iterator and tensor array loop variables for the gradients. n = tf . size ( input = x ) / tf . cast ( tf . reduce_prod ( input_tensor = sample_shape ) , dtype = tf . int32 ) n = tf . cast ( n , dtype = tf . int32 ) loop_vars = [ 0 , tf . TensorArray ( x . dtype , n ) ] # Iterate over all elements of the gradient and compute second order # derivatives. _ , jacobian_diag_res = tf . while_loop ( cond = lambda j , _ : j < n , body = make_loop_body ( i , x ) , loop_vars = loop_vars , parallel_iterations = parallel_iterations ) shape_x = tf . shape ( input = x ) # Stack gradients together and move flattened `event_shape` to the # zero position reshaped_jacobian_diag = tf . transpose ( a = jacobian_diag_res . stack ( ) ) # Reshape to the original tensor reshaped_jacobian_diag = tf . reshape ( reshaped_jacobian_diag , shape_x ) jacobians_diag_res . append ( reshaped_jacobian_diag ) return ys , jacobians_diag_res\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def calculate_reshape ( original_shape , new_shape , validate = False , name = None ) : batch_shape_static = tensorshape_util . constant_value_as_shape ( new_shape ) if tensorshape_util . is_fully_defined ( batch_shape_static ) : return np . int32 ( batch_shape_static ) , batch_shape_static , [ ] with tf . name_scope ( name or \"calculate_reshape\" ) : original_size = tf . reduce_prod ( input_tensor = original_shape ) implicit_dim = tf . equal ( new_shape , - 1 ) size_implicit_dim = ( original_size // tf . maximum ( 1 , - tf . reduce_prod ( input_tensor = new_shape ) ) ) new_ndims = tf . shape ( input = new_shape ) expanded_new_shape = tf . where ( # Assumes exactly one `-1`. implicit_dim , tf . fill ( new_ndims , size_implicit_dim ) , new_shape ) validations = [ ] if not validate else [ # pylint: disable=g-long-ternary assert_util . assert_rank ( original_shape , 1 , message = \"Original shape must be a vector.\" ) , assert_util . assert_rank ( new_shape , 1 , message = \"New shape must be a vector.\" ) , assert_util . assert_less_equal ( tf . math . count_nonzero ( implicit_dim , dtype = tf . int32 ) , 1 , message = \"At most one dimension can be unknown.\" ) , assert_util . assert_positive ( expanded_new_shape , message = \"Shape elements must be >=-1.\" ) , assert_util . assert_equal ( tf . reduce_prod ( input_tensor = expanded_new_shape ) , original_size , message = \"Shape sizes do not match.\" ) , ] return expanded_new_shape , batch_shape_static , validations\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def validate_init_args_statically ( distribution , batch_shape ) : if tensorshape_util . rank ( batch_shape . shape ) is not None : if tensorshape_util . rank ( batch_shape . shape ) != 1 : raise ValueError ( \"`batch_shape` must be a vector \" \"(saw rank: {}).\" . format ( tensorshape_util . rank ( batch_shape . shape ) ) ) batch_shape_static = tensorshape_util . constant_value_as_shape ( batch_shape ) batch_size_static = tensorshape_util . num_elements ( batch_shape_static ) dist_batch_size_static = tensorshape_util . num_elements ( distribution . batch_shape ) if batch_size_static is not None and dist_batch_size_static is not None : if batch_size_static != dist_batch_size_static : raise ValueError ( \"`batch_shape` size ({}) must match \" \"`distribution.batch_shape` size ({}).\" . format ( batch_size_static , dist_batch_size_static ) ) if tensorshape_util . dims ( batch_shape_static ) is not None : if any ( tf . compat . dimension_value ( dim ) is not None and tf . compat . dimension_value ( dim ) < 1 for dim in batch_shape_static ) : raise ValueError ( \"`batch_shape` elements must be >=-1.\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sample_shape ( self , x ) : x_ndims = ( tf . rank ( x ) if tensorshape_util . rank ( x . shape ) is None else tensorshape_util . rank ( x . shape ) ) event_ndims = ( tf . size ( input = self . event_shape_tensor ( ) ) if tensorshape_util . rank ( self . event_shape ) is None else tensorshape_util . rank ( self . event_shape ) ) batch_ndims = ( tf . size ( input = self . _batch_shape_unexpanded ) if tensorshape_util . rank ( self . batch_shape ) is None else tensorshape_util . rank ( self . batch_shape ) ) sample_ndims = x_ndims - batch_ndims - event_ndims if isinstance ( sample_ndims , int ) : static_sample_shape = x . shape [ : sample_ndims ] else : static_sample_shape = tf . TensorShape ( None ) if tensorshape_util . is_fully_defined ( static_sample_shape ) : sample_shape = np . int32 ( static_sample_shape ) else : sample_shape = tf . shape ( input = x ) [ : sample_ndims ] return sample_shape , static_sample_shape\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _call_reshape_input_output ( self , fn , x , extra_kwargs = None ) : # Note: we take `extra_kwargs` as a dict rather than `**extra_kwargs` # because it is possible the user provided extra kwargs would itself # have `fn` and/or `x` as a key. with tf . control_dependencies ( self . _runtime_assertions + self . _validate_sample_arg ( x ) ) : sample_shape , static_sample_shape = self . _sample_shape ( x ) old_shape = tf . concat ( [ sample_shape , self . distribution . batch_shape_tensor ( ) , self . event_shape_tensor ( ) , ] , axis = 0 ) x_reshape = tf . reshape ( x , old_shape ) result = fn ( x_reshape , * * extra_kwargs ) if extra_kwargs else fn ( x_reshape ) new_shape = tf . concat ( [ sample_shape , self . _batch_shape_unexpanded , ] , axis = 0 ) result = tf . reshape ( result , new_shape ) if ( tensorshape_util . rank ( static_sample_shape ) is not None and tensorshape_util . rank ( self . batch_shape ) is not None ) : new_shape = tensorshape_util . concatenate ( static_sample_shape , self . batch_shape ) tensorshape_util . set_shape ( result , new_shape ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _call_and_reshape_output ( self , fn , event_shape_list = None , static_event_shape_list = None , extra_kwargs = None ) : # Note: we take `extra_kwargs` as a dict rather than `**extra_kwargs` # because it is possible the user provided extra kwargs would itself # have `fn`, `event_shape_list`, `static_event_shape_list` and/or # `extra_kwargs` as keys. with tf . control_dependencies ( self . _runtime_assertions ) : if event_shape_list is None : event_shape_list = [ self . _event_shape_tensor ( ) ] if static_event_shape_list is None : static_event_shape_list = [ self . event_shape ] new_shape = tf . concat ( [ self . _batch_shape_unexpanded ] + event_shape_list , axis = 0 ) result = tf . reshape ( fn ( * * extra_kwargs ) if extra_kwargs else fn ( ) , new_shape ) if ( tensorshape_util . rank ( self . batch_shape ) is not None and tensorshape_util . rank ( self . event_shape ) is not None ) : event_shape = tf . TensorShape ( [ ] ) for rss in static_event_shape_list : event_shape = tensorshape_util . concatenate ( event_shape , rss ) static_shape = tensorshape_util . concatenate ( self . batch_shape , event_shape ) tensorshape_util . set_shape ( result , static_shape ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _validate_sample_arg ( self , x ) : with tf . name_scope ( \"validate_sample_arg\" ) : x_ndims = ( tf . rank ( x ) if tensorshape_util . rank ( x . shape ) is None else tensorshape_util . rank ( x . shape ) ) event_ndims = ( tf . size ( input = self . event_shape_tensor ( ) ) if tensorshape_util . rank ( self . event_shape ) is None else tensorshape_util . rank ( self . event_shape ) ) batch_ndims = ( tf . size ( input = self . _batch_shape_unexpanded ) if tensorshape_util . rank ( self . batch_shape ) is None else tensorshape_util . rank ( self . batch_shape ) ) expected_batch_event_ndims = batch_ndims + event_ndims if ( isinstance ( x_ndims , int ) and isinstance ( expected_batch_event_ndims , int ) ) : if x_ndims < expected_batch_event_ndims : raise NotImplementedError ( \"Broadcasting is not supported; too few batch and event dims \" \"(expected at least {}, saw {}).\" . format ( expected_batch_event_ndims , x_ndims ) ) ndims_assertion = [ ] elif self . validate_args : ndims_assertion = [ assert_util . assert_greater_equal ( x_ndims , expected_batch_event_ndims , message = ( \"Broadcasting is not supported; too few \" \"batch and event dims.\" ) , name = \"assert_batch_and_event_ndims_large_enough\" ) , ] if ( tensorshape_util . is_fully_defined ( self . batch_shape ) and tensorshape_util . is_fully_defined ( self . event_shape ) ) : expected_batch_event_shape = np . int32 ( tensorshape_util . concatenate ( self . batch_shape , self . event_shape ) ) else : expected_batch_event_shape = tf . concat ( [ self . batch_shape_tensor ( ) , self . event_shape_tensor ( ) , ] , axis = 0 ) sample_ndims = x_ndims - expected_batch_event_ndims if isinstance ( sample_ndims , int ) : sample_ndims = max ( sample_ndims , 0 ) if ( isinstance ( sample_ndims , int ) and tensorshape_util . is_fully_defined ( x . shape [ sample_ndims : ] ) ) : actual_batch_event_shape = np . int32 ( x . shape [ sample_ndims : ] ) else : sample_ndims = tf . maximum ( sample_ndims , 0 ) actual_batch_event_shape = tf . shape ( input = x ) [ sample_ndims : ] if ( isinstance ( expected_batch_event_shape , np . ndarray ) and isinstance ( actual_batch_event_shape , np . ndarray ) ) : if any ( expected_batch_event_shape != actual_batch_event_shape ) : raise NotImplementedError ( \"Broadcasting is not supported; \" \"unexpected batch and event shape \" \"(expected {}, saw {}).\" . format ( expected_batch_event_shape , actual_batch_event_shape ) ) # We need to set the final runtime-assertions to `ndims_assertion` since # its possible this assertion was created. We could add a condition to # only do so if `self.validate_args == True`, however this is redundant # as `ndims_assertion` already encodes this information. runtime_assertions = ndims_assertion elif self . validate_args : # We need to make the `ndims_assertion` a control dep because otherwise # TF itself might raise an exception owing to this assertion being # ill-defined, ie, one cannot even compare different rank Tensors. with tf . control_dependencies ( ndims_assertion ) : shape_assertion = assert_util . assert_equal ( expected_batch_event_shape , actual_batch_event_shape , message = ( \"Broadcasting is not supported; \" \"unexpected batch and event shape.\" ) , name = \"assert_batch_and_event_shape_same\" ) runtime_assertions = [ shape_assertion ] else : runtime_assertions = [ ] return runtime_assertions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _bdtr ( k , n , p ) : # Trick for getting safe backprop/gradients into n, k when # betainc(a = 0, ..) = nan # Write: # where(unsafe, safe_output, betainc(where(unsafe, safe_input, input))) ones = tf . ones_like ( n - k ) k_eq_n = tf . equal ( k , n ) safe_dn = tf . where ( k_eq_n , ones , n - k ) dk = tf . math . betainc ( a = safe_dn , b = k + 1 , x = 1 - p ) return tf . where ( k_eq_n , ones , dk )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_assert_valid_sample ( self , counts ) : if not self . validate_args : return counts counts = distribution_util . embed_check_nonnegative_integer_form ( counts ) return distribution_util . with_dependencies ( [ assert_util . assert_less_equal ( counts , self . total_count , message = \"counts are not less than or equal to n.\" ) , ] , counts )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _flat_sample_distributions ( self , sample_shape = ( ) , seed = None , value = None ) : ds = [ ] values_out = [ ] seed = seed_stream . SeedStream ( 'JointDistributionCoroutine' , seed ) gen = self . _model ( ) index = 0 d = next ( gen ) try : while True : actual_distribution = d . distribution if isinstance ( d , self . Root ) else d ds . append ( actual_distribution ) if ( value is not None and len ( value ) > index and value [ index ] is not None ) : seed ( ) next_value = value [ index ] else : next_value = actual_distribution . sample ( sample_shape = sample_shape if isinstance ( d , self . Root ) else ( ) , seed = seed ( ) ) values_out . append ( next_value ) index += 1 d = gen . send ( next_value ) except StopIteration : pass return ds , values_out\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_pareto_pareto ( a , b , name = None ) : with tf . name_scope ( name or \"kl_pareto_pareto\" ) : # Consistent with # http://www.mast.queensu.ca/~communications/Papers/gil-msc11.pdf, page 55 # Terminology is different from source to source for Pareto distributions. # The 'concentration' parameter corresponds to 'a' in that source, and the # 'scale' parameter corresponds to 'm'. final_batch_shape = distribution_util . get_broadcast_shape ( a . concentration , b . concentration , a . scale , b . scale ) common_type = dtype_util . common_dtype ( [ a . concentration , b . concentration , a . scale , b . scale ] , tf . float32 ) return tf . where ( a . scale >= b . scale , b . concentration * ( tf . math . log ( a . scale ) - tf . math . log ( b . scale ) ) + tf . math . log ( a . concentration ) - tf . math . log ( b . concentration ) + b . concentration / a . concentration - 1.0 , tf . broadcast_to ( tf . cast ( np . inf , common_type ) , final_batch_shape ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _extend_support ( self , x , f , alt ) : # We need to do a series of broadcasts for the tf.where. scale = self . scale + tf . zeros_like ( self . concentration ) is_invalid = x < scale scale = scale + tf . zeros_like ( x ) x = x + tf . zeros_like ( scale ) # We need to do this to ensure gradients are sound. y = f ( tf . where ( is_invalid , scale , x ) ) if alt == 0. : alt = tf . zeros_like ( y ) elif alt == 1. : alt = tf . ones_like ( y ) else : alt = tf . fill ( dims = tf . shape ( input = y ) , value = dtype_util . as_numpy_dtype ( self . dtype ) ( alt ) ) return tf . where ( is_invalid , alt , y )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def latent_dirichlet_allocation ( concentration , topics_words ) : topics = ed . Dirichlet ( concentration = concentration , name = \"topics\" ) word_probs = tf . matmul ( topics , topics_words ) # The observations are bags of words and therefore not one-hot. However, # log_prob of OneHotCategorical computes the probability correctly in # this case. bag_of_words = ed . OneHotCategorical ( probs = word_probs , name = \"bag_of_words\" ) return bag_of_words\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_lda_variational ( activation , num_topics , layer_sizes ) : encoder_net = tf . keras . Sequential ( ) for num_hidden_units in layer_sizes : encoder_net . add ( tf . keras . layers . Dense ( num_hidden_units , activation = activation , kernel_initializer = tf . compat . v1 . glorot_normal_initializer ( ) ) ) encoder_net . add ( tf . keras . layers . Dense ( num_topics , activation = tf . nn . softplus , kernel_initializer = tf . compat . v1 . glorot_normal_initializer ( ) ) ) def lda_variational ( bag_of_words ) : concentration = _clip_dirichlet_parameters ( encoder_net ( bag_of_words ) ) return ed . Dirichlet ( concentration = concentration , name = \"topics_posterior\" ) return lda_variational\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def model_fn ( features , labels , mode , params , config ) : del labels , config # Set up the model's learnable parameters. logit_concentration = tf . compat . v1 . get_variable ( \"logit_concentration\" , shape = [ 1 , params [ \"num_topics\" ] ] , initializer = tf . compat . v1 . initializers . constant ( _softplus_inverse ( params [ \"prior_initial_value\" ] ) ) ) concentration = _clip_dirichlet_parameters ( tf . nn . softplus ( logit_concentration ) ) num_words = features . shape [ 1 ] topics_words_logits = tf . compat . v1 . get_variable ( \"topics_words_logits\" , shape = [ params [ \"num_topics\" ] , num_words ] , initializer = tf . compat . v1 . glorot_normal_initializer ( ) ) topics_words = tf . nn . softmax ( topics_words_logits , axis = - 1 ) # Compute expected log-likelihood. First, sample from the variational # distribution; second, compute the log-likelihood given the sample. lda_variational = make_lda_variational ( params [ \"activation\" ] , params [ \"num_topics\" ] , params [ \"layer_sizes\" ] ) with ed . tape ( ) as variational_tape : _ = lda_variational ( features ) with ed . tape ( ) as model_tape : with ed . interception ( make_value_setter ( topics = variational_tape [ \"topics_posterior\" ] ) ) : posterior_predictive = latent_dirichlet_allocation ( concentration , topics_words ) log_likelihood = posterior_predictive . distribution . log_prob ( features ) tf . compat . v1 . summary . scalar ( \"log_likelihood\" , tf . reduce_mean ( input_tensor = log_likelihood ) ) # Compute the KL-divergence between two Dirichlets analytically. # The sampled KL does not work well for \"sparse\" distributions # (see Appendix D of [2]). kl = variational_tape [ \"topics_posterior\" ] . distribution . kl_divergence ( model_tape [ \"topics\" ] . distribution ) tf . compat . v1 . summary . scalar ( \"kl\" , tf . reduce_mean ( input_tensor = kl ) ) # Ensure that the KL is non-negative (up to a very small slack). # Negative KL can happen due to numerical instability. with tf . control_dependencies ( [ tf . compat . v1 . assert_greater ( kl , - 1e-3 , message = \"kl\" ) ] ) : kl = tf . identity ( kl ) elbo = log_likelihood - kl avg_elbo = tf . reduce_mean ( input_tensor = elbo ) tf . compat . v1 . summary . scalar ( \"elbo\" , avg_elbo ) loss = - avg_elbo # Perform variational inference by minimizing the -ELBO. global_step = tf . compat . v1 . train . get_or_create_global_step ( ) optimizer = tf . compat . v1 . train . AdamOptimizer ( params [ \"learning_rate\" ] ) # This implements the \"burn-in\" for prior parameters (see Appendix D of [2]). # For the first prior_burn_in_steps steps they are fixed, and then trained # jointly with the other parameters. grads_and_vars = optimizer . compute_gradients ( loss ) grads_and_vars_except_prior = [ x for x in grads_and_vars if x [ 1 ] != logit_concentration ] def train_op_except_prior ( ) : return optimizer . apply_gradients ( grads_and_vars_except_prior , global_step = global_step ) def train_op_all ( ) : return optimizer . apply_gradients ( grads_and_vars , global_step = global_step ) train_op = tf . cond ( pred = global_step < params [ \"prior_burn_in_steps\" ] , true_fn = train_op_except_prior , false_fn = train_op_all ) # The perplexity is an exponent of the average negative ELBO per word. words_per_document = tf . reduce_sum ( input_tensor = features , axis = 1 ) log_perplexity = - elbo / words_per_document tf . compat . v1 . summary . scalar ( \"perplexity\" , tf . exp ( tf . reduce_mean ( input_tensor = log_perplexity ) ) ) ( log_perplexity_tensor , log_perplexity_update ) = tf . compat . v1 . metrics . mean ( log_perplexity ) perplexity_tensor = tf . exp ( log_perplexity_tensor ) # Obtain the topics summary. Implemented as a py_func for simplicity. topics = tf . compat . v1 . py_func ( functools . partial ( get_topics_strings , vocabulary = params [ \"vocabulary\" ] ) , [ topics_words , concentration ] , tf . string , stateful = False ) tf . compat . v1 . summary . text ( \"topics\" , topics ) return tf . estimator . EstimatorSpec ( mode = mode , loss = loss , train_op = train_op , eval_metric_ops = { \"elbo\" : tf . compat . v1 . metrics . mean ( elbo ) , \"log_likelihood\" : tf . compat . v1 . metrics . mean ( log_likelihood ) , \"kl\" : tf . compat . v1 . metrics . mean ( kl ) , \"perplexity\" : ( perplexity_tensor , log_perplexity_update ) , \"topics\" : ( topics , tf . no_op ( ) ) , } , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_topics_strings ( topics_words , alpha , vocabulary , topics_to_print = 10 , words_per_topic = 10 ) : alpha = np . squeeze ( alpha , axis = 0 ) # Use a stable sorting algorithm so that when alpha is fixed # we always get the same topics. highest_weight_topics = np . argsort ( - alpha , kind = \"mergesort\" ) top_words = np . argsort ( - topics_words , axis = 1 ) res = [ ] for topic_idx in highest_weight_topics [ : topics_to_print ] : l = [ \"index={} alpha={:.2f}\" . format ( topic_idx , alpha [ topic_idx ] ) ] l += [ vocabulary [ word ] for word in top_words [ topic_idx , : words_per_topic ] ] res . append ( \" \" . join ( l ) ) return np . array ( res )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def newsgroups_dataset ( directory , split_name , num_words , shuffle_and_repeat ) : data = np . load ( download ( directory , FILE_TEMPLATE . format ( split = split_name ) ) ) # The last row is empty in both train and test. data = data [ : - 1 ] # Each row is a list of word ids in the document. We first convert this to # sparse COO matrix (which automatically sums the repeating words). Then, # we convert this COO matrix to CSR format which allows for fast querying of # documents. num_documents = data . shape [ 0 ] indices = np . array ( [ ( row_idx , column_idx ) for row_idx , row in enumerate ( data ) for column_idx in row ] ) sparse_matrix = scipy . sparse . coo_matrix ( ( np . ones ( indices . shape [ 0 ] ) , ( indices [ : , 0 ] , indices [ : , 1 ] ) ) , shape = ( num_documents , num_words ) , dtype = np . float32 ) sparse_matrix = sparse_matrix . tocsr ( ) dataset = tf . data . Dataset . range ( num_documents ) # For training, we shuffle each epoch and repeat the epochs. if shuffle_and_repeat : dataset = dataset . shuffle ( num_documents ) . repeat ( ) # Returns a single document as a dense TensorFlow tensor. The dataset is # stored as a sparse matrix outside of the graph. def get_row_py_func ( idx ) : def get_row_python ( idx_py ) : return np . squeeze ( np . array ( sparse_matrix [ idx_py ] . todense ( ) ) , axis = 0 ) py_func = tf . compat . v1 . py_func ( get_row_python , [ idx ] , tf . float32 , stateful = False ) py_func . set_shape ( ( num_words , ) ) return py_func dataset = dataset . map ( get_row_py_func ) return dataset\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_fake_input_fns ( batch_size ) : num_words = 1000 vocabulary = [ str ( i ) for i in range ( num_words ) ] random_sample = np . random . randint ( 10 , size = ( batch_size , num_words ) ) . astype ( np . float32 ) def train_input_fn ( ) : dataset = tf . data . Dataset . from_tensor_slices ( random_sample ) dataset = dataset . batch ( batch_size ) . repeat ( ) return tf . compat . v1 . data . make_one_shot_iterator ( dataset ) . get_next ( ) def eval_input_fn ( ) : dataset = tf . data . Dataset . from_tensor_slices ( random_sample ) dataset = dataset . batch ( batch_size ) return tf . compat . v1 . data . make_one_shot_iterator ( dataset ) . get_next ( ) return train_input_fn , eval_input_fn , vocabulary\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_input_fns ( data_dir , batch_size ) : with open ( download ( data_dir , \"vocab.pkl\" ) , \"r\" ) as f : words_to_idx = pickle . load ( f ) num_words = len ( words_to_idx ) vocabulary = [ None ] * num_words for word , idx in words_to_idx . items ( ) : vocabulary [ idx ] = word # Build an iterator over training batches. def train_input_fn ( ) : dataset = newsgroups_dataset ( data_dir , \"train\" , num_words , shuffle_and_repeat = True ) # Prefetching makes training about 1.5x faster. dataset = dataset . batch ( batch_size ) . prefetch ( 32 ) return tf . compat . v1 . data . make_one_shot_iterator ( dataset ) . get_next ( ) # Build an iterator over the heldout set. def eval_input_fn ( ) : dataset = newsgroups_dataset ( data_dir , \"test\" , num_words , shuffle_and_repeat = False ) dataset = dataset . batch ( batch_size ) return tf . compat . v1 . data . make_one_shot_iterator ( dataset ) . get_next ( ) return train_input_fn , eval_input_fn , vocabulary\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_chi_chi ( a , b , name = None ) : with tf . name_scope ( name or \"kl_chi_chi\" ) : # Consistent with # https://mast.queensu.ca/~communications/Papers/gil-msc11.pdf, page 118 # The paper introduces an additional scaling parameter; setting that # parameter to 1 and simplifying yields the expression we use here. return ( 0.5 * tf . math . digamma ( 0.5 * a . df ) * ( a . df - b . df ) + tf . math . lgamma ( 0.5 * b . df ) - tf . math . lgamma ( 0.5 * a . df ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sparse_or_dense_matmul_onehot ( sparse_or_dense_matrix , col_index ) : if isinstance ( sparse_or_dense_matrix , ( tf . SparseTensor , tf . compat . v1 . SparseTensorValue ) ) : # TODO(b/111924846): Implement better (ideally in a way that allows us to # eliminate the `num_rows` arg, if possible). num_rows = _get_shape ( sparse_or_dense_matrix ) [ - 2 ] batch_shape = _get_shape ( sparse_or_dense_matrix ) [ : - 2 ] slice_start = tf . concat ( [ tf . zeros_like ( batch_shape ) , [ 0 , col_index ] ] , axis = 0 ) slice_size = tf . concat ( [ batch_shape , [ num_rows , 1 ] ] , axis = 0 ) # We momentarily lose static shape information in tf.sparse_slice. However # we regain it in the following tf.reshape. sparse_slice = tf . sparse . slice ( sparse_or_dense_matrix , tf . cast ( slice_start , tf . int64 ) , tf . cast ( slice_size , tf . int64 ) ) output_shape = tf . concat ( [ batch_shape , [ num_rows ] ] , axis = 0 ) return tf . reshape ( tf . sparse . to_dense ( sparse_slice ) , output_shape ) else : return tf . gather ( sparse_or_dense_matrix , col_index , axis = - 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def minimize_one_step ( gradient_unregularized_loss , hessian_unregularized_loss_outer , hessian_unregularized_loss_middle , x_start , tolerance , l1_regularizer , l2_regularizer = None , maximum_full_sweeps = 1 , learning_rate = None , name = None ) : graph_deps = [ gradient_unregularized_loss , hessian_unregularized_loss_outer , hessian_unregularized_loss_middle , x_start , l1_regularizer , l2_regularizer , maximum_full_sweeps , tolerance , learning_rate , ] with tf . compat . v1 . name_scope ( name , 'minimize_one_step' , graph_deps ) : x_shape = _get_shape ( x_start ) batch_shape = x_shape [ : - 1 ] dims = x_shape [ - 1 ] def _hessian_diag_elt_with_l2 ( coord ) : # pylint: disable=missing-docstring # Returns the (coord, coord) entry of # # Hessian(UnregularizedLoss(x) + l2_regularizer * ||x||_2**2) # # evaluated at x = x_start. inner_square = tf . reduce_sum ( input_tensor = _sparse_or_dense_matmul_onehot ( hessian_unregularized_loss_outer , coord ) ** 2 , axis = - 1 ) unregularized_component = ( hessian_unregularized_loss_middle [ ... , coord ] * inner_square ) l2_component = _mul_or_none ( 2. , l2_regularizer ) return _add_ignoring_nones ( unregularized_component , l2_component ) grad_loss_with_l2 = _add_ignoring_nones ( gradient_unregularized_loss , _mul_or_none ( 2. , l2_regularizer , x_start ) ) # We define `x_update_diff_norm_sq_convergence_threshold` such that the # convergence condition # ||x_update_end - x_update_start||_2 / (1 + ||x_start||_2) # < sqrt(tolerance) # is equivalent to # ||x_update_end - x_update_start||_2**2 # < x_update_diff_norm_sq_convergence_threshold. x_update_diff_norm_sq_convergence_threshold = ( tolerance * ( 1. + tf . norm ( tensor = x_start , ord = 2 , axis = - 1 ) ) ** 2 ) # Reshape update vectors so that the coordinate sweeps happen along the # first dimension. This is so that we can use tensor_scatter_update to make # sparse updates along the first axis without copying the Tensor. # TODO(b/118789120): Switch to something like tf.tensor_scatter_nd_add if # or when it exists. update_shape = tf . concat ( [ [ dims ] , batch_shape ] , axis = - 1 ) def _loop_cond ( iter_ , x_update_diff_norm_sq , x_update , hess_matmul_x_update ) : del x_update del hess_matmul_x_update sweep_complete = ( iter_ > 0 ) & tf . equal ( iter_ % dims , 0 ) small_delta = ( x_update_diff_norm_sq < x_update_diff_norm_sq_convergence_threshold ) converged = sweep_complete & small_delta allowed_more_iterations = iter_ < maximum_full_sweeps * dims return allowed_more_iterations & tf . reduce_any ( input_tensor = ~ converged ) def _loop_body ( # pylint: disable=missing-docstring iter_ , x_update_diff_norm_sq , x_update , hess_matmul_x_update ) : # Inner loop of the minimizer. # # This loop updates a single coordinate of x_update. Ideally, an # iteration of this loop would set # # x_update[j] += argmin{ LocalLoss(x_update + z*e_j) : z in R } # # where # # LocalLoss(x_update') # = LocalLossSmoothComponent(x_update') # + l1_regularizer * (||x_start + x_update'||_1 - # ||x_start + x_update||_1) # := (UnregularizedLoss(x_start + x_update') - # UnregularizedLoss(x_start + x_update) # + l2_regularizer * (||x_start + x_update'||_2**2 - # ||x_start + x_update||_2**2) # + l1_regularizer * (||x_start + x_update'||_1 - # ||x_start + x_update||_1) # # In this algorithm approximate the above argmin using (univariate) # proximal gradient descent: # # (*) x_update[j] = prox_{t * l1_regularizer * L1}( # x_update[j] - # t * d/dz|z=0 UnivariateLocalLossSmoothComponent(z)) # # where # # UnivariateLocalLossSmoothComponent(z) # := LocalLossSmoothComponent(x_update + z*e_j) # # and we approximate # # d/dz UnivariateLocalLossSmoothComponent(z) # = grad LocalLossSmoothComponent(x_update))[j] # ~= (grad LossSmoothComponent(x_start) # + x_update matmul HessianOfLossSmoothComponent(x_start))[j]. # # To choose the parameter t, we squint and pretend that the inner term of # (*) is a Newton update as if we were using Newton's method to minimize # UnivariateLocalLossSmoothComponent. That is, we choose t such that # # -t * d/dz ULLSC = -learning_rate * (d/dz ULLSC) / (d^2/dz^2 ULLSC) # # at z=0. Hence # # t = learning_rate / (d^2/dz^2|z=0 ULLSC) # = learning_rate / HessianOfLossSmoothComponent( # x_start + x_update)[j,j] # ~= learning_rate / HessianOfLossSmoothComponent( # x_start)[j,j] # # The above approximation is equivalent to assuming that # HessianOfUnregularizedLoss is constant, i.e., ignoring third-order # effects. # # Note that because LossSmoothComponent is (assumed to be) convex, t is # positive. # In above notation, coord = j. coord = iter_ % dims # x_update_diff_norm_sq := ||x_update_end - x_update_start||_2**2, # computed incrementally, where x_update_end and x_update_start are as # defined in the convergence criteria. Accordingly, we reset # x_update_diff_norm_sq to zero at the beginning of each sweep. x_update_diff_norm_sq = tf . where ( tf . equal ( coord , 0 ) , tf . zeros_like ( x_update_diff_norm_sq ) , x_update_diff_norm_sq ) # Recall that x_update and hess_matmul_x_update has the rightmost # dimension transposed to the leftmost dimension. w_old = x_start [ ... , coord ] + x_update [ coord , ... ] # This is the coordinatewise Newton update if no L1 regularization. # In above notation, newton_step = -t * (approximation of d/dz|z=0 ULLSC). second_deriv = _hessian_diag_elt_with_l2 ( coord ) newton_step = - _mul_ignoring_nones ( # pylint: disable=invalid-unary-operand-type learning_rate , grad_loss_with_l2 [ ... , coord ] + hess_matmul_x_update [ coord , ... ] ) / second_deriv # Applying the soft-threshold operator accounts for L1 regularization. # In above notation, delta = # prox_{t*l1_regularizer*L1}(w_old + newton_step) - w_old. delta = ( soft_threshold ( w_old + newton_step , _mul_ignoring_nones ( learning_rate , l1_regularizer ) / second_deriv ) - w_old ) def _do_update ( x_update_diff_norm_sq , x_update , hess_matmul_x_update ) : # pylint: disable=missing-docstring hessian_column_with_l2 = sparse_or_dense_matvecmul ( hessian_unregularized_loss_outer , hessian_unregularized_loss_middle * _sparse_or_dense_matmul_onehot ( hessian_unregularized_loss_outer , coord ) , adjoint_a = True ) if l2_regularizer is not None : hessian_column_with_l2 += _one_hot_like ( hessian_column_with_l2 , coord , on_value = 2. * l2_regularizer ) # Move the batch dimensions of `hessian_column_with_l2` to rightmost in # order to conform to `hess_matmul_x_update`. n = tf . rank ( hessian_column_with_l2 ) perm = tf . roll ( tf . range ( n ) , shift = 1 , axis = 0 ) hessian_column_with_l2 = tf . transpose ( a = hessian_column_with_l2 , perm = perm ) # Update the entire batch at `coord` even if `delta` may be 0 at some # batch coordinates. In those cases, adding `delta` is a no-op. x_update = tf . tensor_scatter_nd_add ( x_update , [ [ coord ] ] , [ delta ] ) with tf . control_dependencies ( [ x_update ] ) : x_update_diff_norm_sq_ = x_update_diff_norm_sq + delta ** 2 hess_matmul_x_update_ = ( hess_matmul_x_update + delta * hessian_column_with_l2 ) # Hint that loop vars retain the same shape. x_update_diff_norm_sq_ . set_shape ( x_update_diff_norm_sq_ . shape . merge_with ( x_update_diff_norm_sq . shape ) ) hess_matmul_x_update_ . set_shape ( hess_matmul_x_update_ . shape . merge_with ( hess_matmul_x_update . shape ) ) return [ x_update_diff_norm_sq_ , x_update , hess_matmul_x_update_ ] inputs_to_update = [ x_update_diff_norm_sq , x_update , hess_matmul_x_update ] return [ iter_ + 1 ] + prefer_static . cond ( # Note on why checking delta (a difference of floats) for equality to # zero is ok: # # First of all, x - x == 0 in floating point -- see # https://stackoverflow.com/a/2686671 # # Delta will conceptually equal zero when one of the following holds: # (i) |w_old + newton_step| <= threshold and w_old == 0 # (ii) |w_old + newton_step| > threshold and # w_old + newton_step - sign(w_old + newton_step) * threshold # == w_old # # In case (i) comparing delta to zero is fine. # # In case (ii), newton_step conceptually equals # sign(w_old + newton_step) * threshold. # Also remember # threshold = -newton_step / (approximation of d/dz|z=0 ULLSC). # So (i) happens when # (approximation of d/dz|z=0 ULLSC) == -sign(w_old + newton_step). # If we did not require LossSmoothComponent to be strictly convex, # then this could actually happen a non-negligible amount of the time, # e.g. if the loss function is piecewise linear and one of the pieces # has slope 1. But since LossSmoothComponent is strictly convex, (i) # should not systematically happen. tf . reduce_all ( input_tensor = tf . equal ( delta , 0. ) ) , lambda : inputs_to_update , lambda : _do_update ( * inputs_to_update ) ) base_dtype = x_start . dtype . base_dtype iter_ , x_update_diff_norm_sq , x_update , _ = tf . while_loop ( cond = _loop_cond , body = _loop_body , loop_vars = [ tf . zeros ( [ ] , dtype = np . int32 , name = 'iter' ) , tf . zeros ( batch_shape , dtype = base_dtype , name = 'x_update_diff_norm_sq' ) , tf . zeros ( update_shape , dtype = base_dtype , name = 'x_update' ) , tf . zeros ( update_shape , dtype = base_dtype , name = 'hess_matmul_x_update' ) , ] ) # Convert back x_update to the shape of x_start by transposing the leftmost # dimension to the rightmost. n = tf . rank ( x_update ) perm = tf . roll ( tf . range ( n ) , shift = - 1 , axis = 0 ) x_update = tf . transpose ( a = x_update , perm = perm ) converged = tf . reduce_all ( input_tensor = x_update_diff_norm_sq < x_update_diff_norm_sq_convergence_threshold ) return x_start + x_update , converged , iter_ / dims\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def minimize ( grad_and_hessian_loss_fn , x_start , tolerance , l1_regularizer , l2_regularizer = None , maximum_iterations = 1 , maximum_full_sweeps_per_iteration = 1 , learning_rate = None , name = None ) : graph_deps = [ x_start , l1_regularizer , l2_regularizer , maximum_iterations , maximum_full_sweeps_per_iteration , tolerance , learning_rate , ] , with tf . compat . v1 . name_scope ( name , 'minimize' , graph_deps ) : def _loop_cond ( x_start , converged , iter_ ) : del x_start return tf . logical_and ( iter_ < maximum_iterations , tf . logical_not ( converged ) ) def _loop_body ( x_start , converged , iter_ ) : # pylint: disable=missing-docstring g , h_outer , h_middle = grad_and_hessian_loss_fn ( x_start ) x_start , converged , _ = minimize_one_step ( gradient_unregularized_loss = g , hessian_unregularized_loss_outer = h_outer , hessian_unregularized_loss_middle = h_middle , x_start = x_start , l1_regularizer = l1_regularizer , l2_regularizer = l2_regularizer , maximum_full_sweeps = maximum_full_sweeps_per_iteration , tolerance = tolerance , learning_rate = learning_rate ) return x_start , converged , iter_ + 1 return tf . while_loop ( cond = _loop_cond , body = _loop_body , loop_vars = [ x_start , tf . zeros ( [ ] , np . bool , name = 'converged' ) , tf . zeros ( [ ] , np . int32 , name = 'iter' ) , ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_encoder ( base_depth , activation , latent_size , code_size ) : conv = functools . partial ( tf . keras . layers . Conv2D , padding = \"SAME\" , activation = activation ) encoder_net = tf . keras . Sequential ( [ conv ( base_depth , 5 , 1 ) , conv ( base_depth , 5 , 2 ) , conv ( 2 * base_depth , 5 , 1 ) , conv ( 2 * base_depth , 5 , 2 ) , conv ( 4 * latent_size , 7 , padding = \"VALID\" ) , tf . keras . layers . Flatten ( ) , tf . keras . layers . Dense ( latent_size * code_size , activation = None ) , tf . keras . layers . Reshape ( [ latent_size , code_size ] ) ] ) def encoder ( images ) : \"\"\"Encodes a batch of images. Args: images: A `Tensor` representing the inputs to be encoded, of shape `[..., channels]`. Returns: codes: A `float`-like `Tensor` of shape `[..., latent_size, code_size]`. It represents latent vectors to be matched with the codebook. \"\"\" images = 2 * tf . cast ( images , dtype = tf . float32 ) - 1 codes = encoder_net ( images ) return codes return encoder\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_decoder ( base_depth , activation , input_size , output_shape ) : deconv = functools . partial ( tf . keras . layers . Conv2DTranspose , padding = \"SAME\" , activation = activation ) conv = functools . partial ( tf . keras . layers . Conv2D , padding = \"SAME\" , activation = activation ) decoder_net = tf . keras . Sequential ( [ tf . keras . layers . Reshape ( ( 1 , 1 , input_size ) ) , deconv ( 2 * base_depth , 7 , padding = \"VALID\" ) , deconv ( 2 * base_depth , 5 ) , deconv ( 2 * base_depth , 5 , 2 ) , deconv ( base_depth , 5 ) , deconv ( base_depth , 5 , 2 ) , deconv ( base_depth , 5 ) , conv ( output_shape [ - 1 ] , 5 , activation = None ) , tf . keras . layers . Reshape ( output_shape ) , ] ) def decoder ( codes ) : \"\"\"Builds a distribution over images given codes. Args: codes: A `Tensor` representing the inputs to be decoded, of shape `[..., code_size]`. Returns: decoder_distribution: A multivariate `Bernoulli` distribution. \"\"\" logits = decoder_net ( codes ) return tfd . Independent ( tfd . Bernoulli ( logits = logits ) , reinterpreted_batch_ndims = len ( output_shape ) , name = \"decoder_distribution\" ) return decoder\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def add_ema_control_dependencies ( vector_quantizer , one_hot_assignments , codes , commitment_loss , decay ) : # Use an exponential moving average to update the codebook. updated_ema_count = moving_averages . assign_moving_average ( vector_quantizer . ema_count , tf . reduce_sum ( input_tensor = one_hot_assignments , axis = [ 0 , 1 ] ) , decay , zero_debias = False ) updated_ema_means = moving_averages . assign_moving_average ( vector_quantizer . ema_means , tf . reduce_sum ( input_tensor = tf . expand_dims ( codes , 2 ) * tf . expand_dims ( one_hot_assignments , 3 ) , axis = [ 0 , 1 ] ) , decay , zero_debias = False ) # Add small value to avoid dividing by zero. perturbed_ema_count = updated_ema_count + 1e-5 with tf . control_dependencies ( [ commitment_loss ] ) : update_means = tf . compat . v1 . assign ( vector_quantizer . codebook , updated_ema_means / perturbed_ema_count [ ... , tf . newaxis ] ) with tf . control_dependencies ( [ update_means ] ) : return tf . identity ( commitment_loss )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def save_imgs ( x , fname ) : n = x . shape [ 0 ] fig = figure . Figure ( figsize = ( n , 1 ) , frameon = False ) canvas = backend_agg . FigureCanvasAgg ( fig ) for i in range ( n ) : ax = fig . add_subplot ( 1 , n , i + 1 ) ax . imshow ( x [ i ] . squeeze ( ) , interpolation = \"none\" , cmap = cm . get_cmap ( \"binary\" ) ) ax . axis ( \"off\" ) canvas . print_figure ( fname , format = \"png\" ) print ( \"saved %s\" % fname )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def visualize_training ( images_val , reconstructed_images_val , random_images_val , log_dir , prefix , viz_n = 10 ) : save_imgs ( images_val [ : viz_n ] , os . path . join ( log_dir , \"{}_inputs.png\" . format ( prefix ) ) ) save_imgs ( reconstructed_images_val [ : viz_n ] , os . path . join ( log_dir , \"{}_reconstructions.png\" . format ( prefix ) ) ) if random_images_val is not None : save_imgs ( random_images_val [ : viz_n ] , os . path . join ( log_dir , \"{}_prior_samples.png\" . format ( prefix ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_bernoulli_mnist_dataset ( directory , split_name ) : amat_file = download ( directory , FILE_TEMPLATE . format ( split = split_name ) ) dataset = tf . data . TextLineDataset ( amat_file ) str_to_arr = lambda string : np . array ( [ c == b\"1\" for c in string . split ( ) ] ) def _parser ( s ) : booltensor = tf . compat . v1 . py_func ( str_to_arr , [ s ] , tf . bool ) reshaped = tf . reshape ( booltensor , [ 28 , 28 , 1 ] ) return tf . cast ( reshaped , dtype = tf . float32 ) , tf . constant ( 0 , tf . int32 ) return dataset . map ( _parser )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_input_pipeline ( data_dir , batch_size , heldout_size , mnist_type ) : # Build an iterator over training batches. if mnist_type in [ MnistType . FAKE_DATA , MnistType . THRESHOLD ] : if mnist_type == MnistType . FAKE_DATA : mnist_data = build_fake_data ( ) else : mnist_data = mnist . read_data_sets ( data_dir ) training_dataset = tf . data . Dataset . from_tensor_slices ( ( mnist_data . train . images , np . int32 ( mnist_data . train . labels ) ) ) heldout_dataset = tf . data . Dataset . from_tensor_slices ( ( mnist_data . validation . images , np . int32 ( mnist_data . validation . labels ) ) ) elif mnist_type == MnistType . BERNOULLI : training_dataset = load_bernoulli_mnist_dataset ( data_dir , \"train\" ) heldout_dataset = load_bernoulli_mnist_dataset ( data_dir , \"valid\" ) else : raise ValueError ( \"Unknown MNIST type.\" ) training_batches = training_dataset . repeat ( ) . batch ( batch_size ) training_iterator = tf . compat . v1 . data . make_one_shot_iterator ( training_batches ) # Build a iterator over the heldout set with batch_size=heldout_size, # i.e., return the entire heldout set as a constant. heldout_frozen = ( heldout_dataset . take ( heldout_size ) . repeat ( ) . batch ( heldout_size ) ) heldout_iterator = tf . compat . v1 . data . make_one_shot_iterator ( heldout_frozen ) # Combine these into a feedable iterator that can switch between training # and validation inputs. handle = tf . compat . v1 . placeholder ( tf . string , shape = [ ] ) feedable_iterator = tf . compat . v1 . data . Iterator . from_string_handle ( handle , training_batches . output_types , training_batches . output_shapes ) images , labels = feedable_iterator . get_next ( ) # Reshape as a pixel image and binarize pixels. images = tf . reshape ( images , shape = [ - 1 ] + IMAGE_SHAPE ) if mnist_type in [ MnistType . FAKE_DATA , MnistType . THRESHOLD ] : images = tf . cast ( images > 0.5 , dtype = tf . int32 ) return images , labels , handle , training_iterator , heldout_iterator\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def as_numpy_dtype ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'as_numpy_dtype' ) : return dtype . as_numpy_dtype return dtype\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def base_dtype ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'base_dtype' ) : return dtype . base_dtype return dtype\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_bool ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_bool' ) : return dtype . is_bool # We use `kind` because: # np.issubdtype(np.uint8, np.bool) == True. return np . dtype ( dtype ) . kind == 'b'\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_floating ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_floating' ) : return dtype . is_floating return np . issubdtype ( np . dtype ( dtype ) , np . float )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_integer ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_integer' ) : return dtype . is_integer return np . issubdtype ( np . dtype ( dtype ) , np . integer )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def max ( dtype ) : # pylint: disable=redefined-builtin dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'max' ) : return dtype . max use_finfo = is_floating ( dtype ) or is_complex ( dtype ) return np . finfo ( dtype ) . max if use_finfo else np . iinfo ( dtype ) . max\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def name ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'name' ) : return dtype . name if hasattr ( dtype , '__name__' ) : return dtype . __name__ return str ( dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def size ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'size' ) : return dtype . size return np . dtype ( dtype ) . itemsize\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _assert_same_base_type ( items , expected_type = None ) : original_expected_type = expected_type mismatch = False for item in items : if item is not None : item_type = base_dtype ( item . dtype ) if not expected_type : expected_type = item_type elif expected_type != item_type : mismatch = True break if mismatch : # Loop back through and build up an informative error message (this is very # slow, so we don't do it unless we found an error above). expected_type = original_expected_type original_item_str = None get_name = lambda x : x . name if hasattr ( x , 'name' ) else str ( x ) for item in items : if item is not None : item_type = base_dtype ( item . dtype ) if not expected_type : expected_type = item_type original_item_str = get_name ( item ) elif expected_type != item_type : raise ValueError ( '{}, type={}, must be of the same type ({}){}.' . format ( get_name ( item ) , item_type , expected_type , ( ( ' as {}' . format ( original_item_str ) ) if original_item_str else '' ) ) ) return expected_type # Should be unreachable else : return expected_type\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def assert_same_float_dtype ( tensors = None , dtype = None ) : if tensors : dtype = _assert_same_base_type ( tensors , dtype ) if not dtype : dtype = tf . float32 elif not is_floating ( dtype ) : raise ValueError ( 'Expected floating point type, got {}.' . format ( dtype ) ) return dtype\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_categorical_categorical ( a , b , name = None ) : with tf . name_scope ( name or \"kl_categorical_categorical\" ) : # sum(p ln(p / q)) return tf . reduce_sum ( input_tensor = tf . nn . softmax ( a . logits ) * ( tf . nn . log_softmax ( a . logits ) - tf . nn . log_softmax ( b . logits ) ) , axis = - 1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def minimize ( objective_function , initial_simplex = None , initial_vertex = None , step_sizes = None , objective_at_initial_simplex = None , objective_at_initial_vertex = None , batch_evaluate_objective = False , func_tolerance = 1e-8 , position_tolerance = 1e-8 , parallel_iterations = 1 , max_iterations = None , reflection = None , expansion = None , contraction = None , shrinkage = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'minimize' , [ initial_simplex , initial_vertex , step_sizes , objective_at_initial_simplex , objective_at_initial_vertex , func_tolerance , position_tolerance ] ) : ( dim , _ , simplex , objective_at_simplex , num_evaluations ) = _prepare_args ( objective_function , initial_simplex , initial_vertex , step_sizes , objective_at_initial_simplex , objective_at_initial_vertex , batch_evaluate_objective ) domain_dtype = simplex . dtype ( reflection , expansion , contraction , shrinkage ) = _resolve_parameters ( dim , reflection , expansion , contraction , shrinkage , domain_dtype ) closure_kwargs = dict ( objective_function = objective_function , dim = dim , func_tolerance = func_tolerance , position_tolerance = position_tolerance , batch_evaluate_objective = batch_evaluate_objective , reflection = reflection , expansion = expansion , contraction = contraction , shrinkage = shrinkage ) def _loop_body ( _ , iterations , simplex , objective_at_simplex , num_evaluations ) : ( converged , next_simplex , next_objective , evaluations ) = nelder_mead_one_step ( simplex , objective_at_simplex , * * closure_kwargs ) return ( converged , iterations + 1 , next_simplex , next_objective , num_evaluations + evaluations ) initial_args = ( False , 0 , simplex , objective_at_simplex , num_evaluations ) # Loop until either we have converged or if the max iterations are supplied # then until we have converged or exhausted the available iteration budget. def _is_converged ( converged , num_iterations , * ignored_args ) : # pylint:disable=unused-argument # It is important to ensure that not_converged is a tensor. If # converged is not a tensor but a Python bool, then the overloaded # op '~' acts as bitwise complement so ~True = -2 and ~False = -1. # In that case, the loop will never terminate. not_converged = tf . logical_not ( converged ) return ( not_converged if max_iterations is None else ( not_converged & ( num_iterations < max_iterations ) ) ) ( converged , num_iterations , final_simplex , final_objective_values , final_evaluations ) = tf . while_loop ( cond = _is_converged , body = _loop_body , loop_vars = initial_args , parallel_iterations = parallel_iterations ) order = tf . argsort ( final_objective_values , direction = 'ASCENDING' , stable = True ) best_index = order [ 0 ] # The explicit cast to Tensor below is done to avoid returning a mixture # of Python types and Tensors which cause problems with session.run. # In the eager mode, converged may remain a Python bool. Trying to evaluate # the whole tuple in one evaluate call will raise an exception because # of the presence of non-tensors. This is very annoying so we explicitly # cast those arguments to Tensors. return NelderMeadOptimizerResults ( converged = tf . convert_to_tensor ( value = converged ) , num_objective_evaluations = final_evaluations , position = final_simplex [ best_index ] , objective_value = final_objective_values [ best_index ] , final_simplex = final_simplex , final_objective_values = final_objective_values , num_iterations = tf . convert_to_tensor ( value = num_iterations ) , initial_simplex = simplex , initial_objective_values = objective_at_simplex )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def nelder_mead_one_step ( current_simplex , current_objective_values , objective_function = None , dim = None , func_tolerance = None , position_tolerance = None , batch_evaluate_objective = False , reflection = None , expansion = None , contraction = None , shrinkage = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'nelder_mead_one_step' ) : domain_dtype = current_simplex . dtype . base_dtype order = tf . argsort ( current_objective_values , direction = 'ASCENDING' , stable = True ) ( best_index , worst_index , second_worst_index ) = order [ 0 ] , order [ - 1 ] , order [ - 2 ] worst_vertex = current_simplex [ worst_index ] ( best_objective_value , worst_objective_value , second_worst_objective_value ) = ( current_objective_values [ best_index ] , current_objective_values [ worst_index ] , current_objective_values [ second_worst_index ] ) # Compute the centroid of the face opposite the worst vertex. face_centroid = tf . reduce_sum ( input_tensor = current_simplex , axis = 0 ) - worst_vertex face_centroid /= tf . cast ( dim , domain_dtype ) # Reflect the worst vertex through the opposite face. reflected = face_centroid + reflection * ( face_centroid - worst_vertex ) objective_at_reflected = objective_function ( reflected ) num_evaluations = 1 has_converged = _check_convergence ( current_simplex , current_simplex [ best_index ] , best_objective_value , worst_objective_value , func_tolerance , position_tolerance ) def _converged_fn ( ) : return ( True , current_simplex , current_objective_values , 0 ) case0 = has_converged , _converged_fn accept_reflected = ( ( objective_at_reflected < second_worst_objective_value ) & ( objective_at_reflected >= best_objective_value ) ) accept_reflected_fn = _accept_reflected_fn ( current_simplex , current_objective_values , worst_index , reflected , objective_at_reflected ) case1 = accept_reflected , accept_reflected_fn do_expansion = objective_at_reflected < best_objective_value expansion_fn = _expansion_fn ( objective_function , current_simplex , current_objective_values , worst_index , reflected , objective_at_reflected , face_centroid , expansion ) case2 = do_expansion , expansion_fn do_outside_contraction = ( ( objective_at_reflected < worst_objective_value ) & ( objective_at_reflected >= second_worst_objective_value ) ) outside_contraction_fn = _outside_contraction_fn ( objective_function , current_simplex , current_objective_values , face_centroid , best_index , worst_index , reflected , objective_at_reflected , contraction , shrinkage , batch_evaluate_objective ) case3 = do_outside_contraction , outside_contraction_fn default_fn = _inside_contraction_fn ( objective_function , current_simplex , current_objective_values , face_centroid , best_index , worst_index , worst_objective_value , contraction , shrinkage , batch_evaluate_objective ) ( converged , next_simplex , next_objective_at_simplex , case_evals ) = prefer_static . case ( [ case0 , case1 , case2 , case3 ] , default = default_fn , exclusive = False ) next_simplex . set_shape ( current_simplex . shape ) next_objective_at_simplex . set_shape ( current_objective_values . shape ) return ( converged , next_simplex , next_objective_at_simplex , num_evaluations + case_evals )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _accept_reflected_fn ( simplex , objective_values , worst_index , reflected , objective_at_reflected ) : def _replace_worst_with_reflected ( ) : next_simplex = _replace_at_index ( simplex , worst_index , reflected ) next_objective_values = _replace_at_index ( objective_values , worst_index , objective_at_reflected ) return False , next_simplex , next_objective_values , 0 return _replace_worst_with_reflected\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _expansion_fn ( objective_function , simplex , objective_values , worst_index , reflected , objective_at_reflected , face_centroid , expansion ) : def _expand_and_maybe_replace ( ) : \"\"\"Performs the expansion step.\"\"\" expanded = face_centroid + expansion * ( reflected - face_centroid ) expanded_objective_value = objective_function ( expanded ) expanded_is_better = ( expanded_objective_value < objective_at_reflected ) accept_expanded_fn = lambda : ( expanded , expanded_objective_value ) accept_reflected_fn = lambda : ( reflected , objective_at_reflected ) next_pt , next_objective_value = prefer_static . cond ( expanded_is_better , accept_expanded_fn , accept_reflected_fn ) next_simplex = _replace_at_index ( simplex , worst_index , next_pt ) next_objective_at_simplex = _replace_at_index ( objective_values , worst_index , next_objective_value ) return False , next_simplex , next_objective_at_simplex , 1 return _expand_and_maybe_replace\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _outside_contraction_fn ( objective_function , simplex , objective_values , face_centroid , best_index , worst_index , reflected , objective_at_reflected , contraction , shrinkage , batch_evaluate_objective ) : def _contraction ( ) : \"\"\"Performs a contraction.\"\"\" contracted = face_centroid + contraction * ( reflected - face_centroid ) objective_at_contracted = objective_function ( contracted ) is_contracted_acceptable = objective_at_contracted <= objective_at_reflected def _accept_contraction ( ) : next_simplex = _replace_at_index ( simplex , worst_index , contracted ) objective_at_next_simplex = _replace_at_index ( objective_values , worst_index , objective_at_contracted ) return ( False , next_simplex , objective_at_next_simplex , 1 ) def _reject_contraction ( ) : return _shrink_towards_best ( objective_function , simplex , best_index , shrinkage , batch_evaluate_objective ) return prefer_static . cond ( is_contracted_acceptable , _accept_contraction , _reject_contraction ) return _contraction\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _shrink_towards_best ( objective_function , simplex , best_index , shrinkage , batch_evaluate_objective ) : # If the contraction step fails to improve the average objective enough, # the simplex is shrunk towards the best vertex. best_vertex = simplex [ best_index ] shrunk_simplex = best_vertex + shrinkage * ( simplex - best_vertex ) objective_at_shrunk_simplex , evals = _evaluate_objective_multiple ( objective_function , shrunk_simplex , batch_evaluate_objective ) return ( False , shrunk_simplex , objective_at_shrunk_simplex , evals )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _replace_at_index ( x , index , replacement ) : x_new = tf . concat ( [ x [ : index ] , tf . expand_dims ( replacement , axis = 0 ) , x [ ( index + 1 ) : ] ] , axis = 0 ) return x_new\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _check_convergence ( simplex , best_vertex , best_objective , worst_objective , func_tolerance , position_tolerance ) : objective_convergence = tf . abs ( worst_objective - best_objective ) < func_tolerance simplex_degeneracy = tf . reduce_max ( input_tensor = tf . abs ( simplex - best_vertex ) ) < position_tolerance return objective_convergence | simplex_degeneracy\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_args ( objective_function , initial_simplex , initial_vertex , step_sizes , objective_at_initial_simplex , objective_at_initial_vertex , batch_evaluate_objective ) : if objective_at_initial_simplex is not None and initial_simplex is None : raise ValueError ( '`objective_at_initial_simplex` specified but the' '`initial_simplex` was not.' ) if objective_at_initial_vertex is not None and initial_vertex is None : raise ValueError ( '`objective_at_initial_vertex` specified but the' '`initial_vertex` was not.' ) # The full simplex was specified. if initial_simplex is not None : if initial_vertex is not None : raise ValueError ( 'Both `initial_simplex` and `initial_vertex` specified.' ' Only one of the two should be specified.' ) if step_sizes is not None : raise ValueError ( '`step_sizes` must not be specified when an' ' `initial_simplex` has been specified.' ) return _prepare_args_with_initial_simplex ( objective_function , initial_simplex , objective_at_initial_simplex , batch_evaluate_objective ) if initial_vertex is None : raise ValueError ( 'One of `initial_simplex` or `initial_vertex`' ' must be supplied' ) if step_sizes is None : step_sizes = _default_step_sizes ( initial_vertex ) return _prepare_args_with_initial_vertex ( objective_function , initial_vertex , step_sizes , objective_at_initial_vertex , batch_evaluate_objective )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _default_step_sizes ( reference_vertex ) : # Step size to choose when the coordinate is zero. small_sizes = tf . ones_like ( reference_vertex ) * 0.00025 # Step size to choose when the coordinate is non-zero. large_sizes = reference_vertex * 0.05 return tf . where ( tf . abs ( reference_vertex ) < _EPSILON , small_sizes , large_sizes )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_args_with_initial_simplex ( objective_function , initial_simplex , objective_at_initial_simplex , batch_evaluate_objective ) : initial_simplex = tf . convert_to_tensor ( value = initial_simplex ) # If d is the dimension of the problem, the number of vertices in the # simplex should be d+1. From this, we can infer the number of dimensions # as n - 1 where n is the number of vertices specified. num_vertices = tf . shape ( input = initial_simplex ) [ 0 ] dim = num_vertices - 1 num_evaluations = 0 if objective_at_initial_simplex is None : objective_at_initial_simplex , n_evals = _evaluate_objective_multiple ( objective_function , initial_simplex , batch_evaluate_objective ) num_evaluations += n_evals objective_at_initial_simplex = tf . convert_to_tensor ( value = objective_at_initial_simplex ) return ( dim , num_vertices , initial_simplex , objective_at_initial_simplex , num_evaluations )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_args_with_initial_vertex ( objective_function , initial_vertex , step_sizes , objective_at_initial_vertex , batch_evaluate_objective ) : dim = tf . size ( input = initial_vertex ) num_vertices = dim + 1 unit_vectors_along_axes = tf . reshape ( tf . eye ( dim , dim , dtype = initial_vertex . dtype . base_dtype ) , tf . concat ( [ [ dim ] , tf . shape ( input = initial_vertex ) ] , axis = 0 ) ) # If step_sizes does not broadcast to initial_vertex, the multiplication # in the second term will fail. simplex_face = initial_vertex + step_sizes * unit_vectors_along_axes simplex = tf . concat ( [ tf . expand_dims ( initial_vertex , axis = 0 ) , simplex_face ] , axis = 0 ) num_evaluations = 0 # Evaluate the objective function at the simplex vertices. if objective_at_initial_vertex is None : objective_at_initial_vertex = objective_function ( initial_vertex ) num_evaluations += 1 objective_at_simplex_face , num_evals = _evaluate_objective_multiple ( objective_function , simplex_face , batch_evaluate_objective ) num_evaluations += num_evals objective_at_simplex = tf . concat ( [ tf . expand_dims ( objective_at_initial_vertex , axis = 0 ) , objective_at_simplex_face ] , axis = 0 ) return ( dim , num_vertices , simplex , objective_at_simplex , num_evaluations )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _resolve_parameters ( dim , reflection , expansion , contraction , shrinkage , dtype ) : dim = tf . cast ( dim , dtype = dtype ) reflection = 1. if reflection is None else reflection expansion = ( 1. + 2. / dim ) if expansion is None else expansion contraction = ( 0.75 - 1. / ( 2 * dim ) ) if contraction is None else contraction shrinkage = ( 1. - 1. / dim ) if shrinkage is None else shrinkage return reflection , expansion , contraction , shrinkage\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _evaluate_objective_multiple ( objective_function , arg_batch , batch_evaluate_objective ) : n_points = tf . shape ( input = arg_batch ) [ 0 ] if batch_evaluate_objective : return objective_function ( arg_batch ) , n_points return tf . map_fn ( objective_function , arg_batch ) , n_points\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def plot_weight_posteriors ( names , qm_vals , qs_vals , fname ) : fig = figure . Figure ( figsize = ( 6 , 3 ) ) canvas = backend_agg . FigureCanvasAgg ( fig ) ax = fig . add_subplot ( 1 , 2 , 1 ) for n , qm in zip ( names , qm_vals ) : sns . distplot ( qm . flatten ( ) , ax = ax , label = n ) ax . set_title ( \"weight means\" ) ax . set_xlim ( [ - 1.5 , 1.5 ] ) ax . legend ( ) ax = fig . add_subplot ( 1 , 2 , 2 ) for n , qs in zip ( names , qs_vals ) : sns . distplot ( qs . flatten ( ) , ax = ax ) ax . set_title ( \"weight stddevs\" ) ax . set_xlim ( [ 0 , 1. ] ) fig . tight_layout ( ) canvas . print_figure ( fname , format = \"png\" ) print ( \"saved {}\" . format ( fname ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def plot_heldout_prediction ( input_vals , probs , fname , n = 10 , title = \"\" ) : fig = figure . Figure ( figsize = ( 9 , 3 * n ) ) canvas = backend_agg . FigureCanvasAgg ( fig ) for i in range ( n ) : ax = fig . add_subplot ( n , 3 , 3 * i + 1 ) ax . imshow ( input_vals [ i , : ] . reshape ( IMAGE_SHAPE [ : - 1 ] ) , interpolation = \"None\" ) ax = fig . add_subplot ( n , 3 , 3 * i + 2 ) for prob_sample in probs : sns . barplot ( np . arange ( 10 ) , prob_sample [ i , : ] , alpha = 0.1 , ax = ax ) ax . set_ylim ( [ 0 , 1 ] ) ax . set_title ( \"posterior samples\" ) ax = fig . add_subplot ( n , 3 , 3 * i + 3 ) sns . barplot ( np . arange ( 10 ) , np . mean ( probs [ : , i , : ] , axis = 0 ) , ax = ax ) ax . set_ylim ( [ 0 , 1 ] ) ax . set_title ( \"predictive probs\" ) fig . suptitle ( title ) fig . tight_layout ( ) canvas . print_figure ( fname , format = \"png\" ) print ( \"saved {}\" . format ( fname ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_input_pipeline ( mnist_data , batch_size , heldout_size ) : # Build an iterator over training batches. training_dataset = tf . data . Dataset . from_tensor_slices ( ( mnist_data . train . images , np . int32 ( mnist_data . train . labels ) ) ) training_batches = training_dataset . shuffle ( 50000 , reshuffle_each_iteration = True ) . repeat ( ) . batch ( batch_size ) training_iterator = tf . compat . v1 . data . make_one_shot_iterator ( training_batches ) # Build a iterator over the heldout set with batch_size=heldout_size, # i.e., return the entire heldout set as a constant. heldout_dataset = tf . data . Dataset . from_tensor_slices ( ( mnist_data . validation . images , np . int32 ( mnist_data . validation . labels ) ) ) heldout_frozen = ( heldout_dataset . take ( heldout_size ) . repeat ( ) . batch ( heldout_size ) ) heldout_iterator = tf . compat . v1 . data . make_one_shot_iterator ( heldout_frozen ) # Combine these into a feedable iterator that can switch between training # and validation inputs. handle = tf . compat . v1 . placeholder ( tf . string , shape = [ ] ) feedable_iterator = tf . compat . v1 . data . Iterator . from_string_handle ( handle , training_batches . output_types , training_batches . output_shapes ) images , labels = feedable_iterator . get_next ( ) return images , labels , handle , training_iterator , heldout_iterator\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_fake_data ( num_examples = 10 ) : class Dummy ( object ) : pass num_examples = 10 mnist_data = Dummy ( ) mnist_data . train = Dummy ( ) mnist_data . train . images = np . float32 ( np . random . randn ( num_examples , * IMAGE_SHAPE ) ) mnist_data . train . labels = np . int32 ( np . random . permutation ( np . arange ( num_examples ) ) ) mnist_data . train . num_examples = num_examples mnist_data . validation = Dummy ( ) mnist_data . validation . images = np . float32 ( np . random . randn ( num_examples , * IMAGE_SHAPE ) ) mnist_data . validation . labels = np . int32 ( np . random . permutation ( np . arange ( num_examples ) ) ) mnist_data . validation . num_examples = num_examples return mnist_data\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_bernoulli_bernoulli ( a , b , name = None ) : with tf . name_scope ( name or \"kl_bernoulli_bernoulli\" ) : delta_probs0 = tf . nn . softplus ( - b . logits ) - tf . nn . softplus ( - a . logits ) delta_probs1 = tf . nn . softplus ( b . logits ) - tf . nn . softplus ( a . logits ) return ( tf . sigmoid ( a . logits ) * delta_probs0 + tf . sigmoid ( - a . logits ) * delta_probs1 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_config ( self ) : return { 'initializers' : [ tf . compat . v2 . initializers . serialize ( tf . keras . initializers . get ( init ) ) for init in self . initializers ] , 'sizes' : self . sizes , 'validate_args' : self . validate_args , }\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def from_config ( cls , config ) : return cls ( * * { 'initializers' : [ tf . compat . v2 . initializers . deserialize ( init ) for init in config . get ( 'initializers' , [ ] ) ] , 'sizes' : config . get ( 'sizes' , [ ] ) , 'validate_args' : config . get ( 'validate_args' , False ) , } )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _matmul ( a , b , transpose_a = False , transpose_b = False , adjoint_a = False , adjoint_b = False , a_is_sparse = False , b_is_sparse = False , name = None ) : # pylint: disable=unused-argument if a_is_sparse or b_is_sparse : raise NotImplementedError ( 'Numpy backend does not support sparse matmul.' ) if transpose_a or adjoint_a : a = _matrix_transpose ( a , conjugate = adjoint_a ) if transpose_b or adjoint_b : b = _matrix_transpose ( b , conjugate = adjoint_b ) return np . matmul ( a , b )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _std_var_helper ( self , statistic , statistic_name , statistic_ndims , df_factor_fn ) : df = tf . reshape ( self . df , tf . concat ( [ tf . shape ( input = self . df ) , tf . ones ( [ statistic_ndims ] , dtype = tf . int32 ) ] , - 1 ) ) df = _broadcast_to_shape ( df , tf . shape ( input = statistic ) ) # We need to put the tf.where inside the outer tf.where to ensure we never # hit a NaN in the gradient. denom = tf . where ( df > 2. , df - 2. , tf . ones_like ( df ) ) statistic = statistic * df_factor_fn ( df / denom ) # When 1 < df <= 2, stddev/variance are infinite. inf = dtype_util . as_numpy_dtype ( self . dtype ) ( np . inf ) result_where_defined = tf . where ( df > 2. , statistic , tf . fill ( tf . shape ( input = statistic ) , inf , name = \"inf\" ) ) if self . allow_nan_stats : nan = dtype_util . as_numpy_dtype ( self . dtype ) ( np . nan ) return tf . where ( df > 1. , result_where_defined , tf . fill ( tf . shape ( input = statistic ) , nan , name = \"nan\" ) ) else : with tf . control_dependencies ( [ assert_util . assert_less ( tf . cast ( 1. , self . dtype ) , df , message = statistic_name + \" not defined for components of df <= 1\" ) , ] ) : return tf . identity ( result_where_defined )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def assign_moving_mean_variance ( mean_var , variance_var , value , decay , name = None ) : with tf . compat . v1 . name_scope ( name , \"assign_moving_mean_variance\" , [ variance_var , mean_var , value , decay ] ) : with tf . compat . v1 . colocate_with ( variance_var ) : with tf . compat . v1 . colocate_with ( mean_var ) : base_dtype = mean_var . dtype . base_dtype if not base_dtype . is_floating : raise TypeError ( \"mean_var.base_dtype({}) does not have float type \" \"`dtype`.\" . format ( base_dtype . name ) ) if base_dtype != variance_var . dtype . base_dtype : raise TypeError ( \"mean_var.base_dtype({}) != variance_var.base_dtype({})\" . format ( base_dtype . name , variance_var . dtype . base_dtype . name ) ) value = tf . convert_to_tensor ( value = value , dtype = base_dtype , name = \"value\" ) decay = tf . convert_to_tensor ( value = decay , dtype = base_dtype , name = \"decay\" ) delta = value - mean_var with tf . control_dependencies ( [ delta ] ) : # We want mean_{t+1} = decay * mean_t + (1. - decay) * value # We compute mean += decay * mean_t - mean_t + (1. - decay) * value = # = (1. - decay) * (value - mean_t) mean_var = mean_var . assign_add ( ( 1. - decay ) * delta ) # We want variance_{t+1} = decay * (variance_t + # + (1 - decay) * (value - mean_var)**2). # We compute variance -= variance_t - decay * (variance_t + # + (1 - decay) * (value - mean_var)**2) = # = (1 - decay) * variance_t # - decay * (1 - decay) * (value - mean_var)**2 # = (1 - decay) * (variance_t - decay * (value - mean_var)**2). variance_var = variance_var . assign_sub ( ( 1. - decay ) * ( variance_var - decay * tf . square ( delta ) ) ) return mean_var , variance_var\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def assign_log_moving_mean_exp ( log_mean_exp_var , log_value , decay , name = None ) : with tf . compat . v1 . name_scope ( name , \"assign_log_moving_mean_exp\" , [ log_mean_exp_var , log_value , decay ] ) : # We want to update the variable in a numerically stable and lock-free way. # To do this, observe that variable `x` updated by `v` is: # x = log(w exp(x) + (1-w) exp(v)) # = log(exp(x + log(w)) + exp(v + log1p(-w))) # = x + log(exp(x - x + log(w)) + exp(v - x + log1p(-w))) # = x + lse([log(w), v - x + log1p(-w)]) with tf . compat . v1 . colocate_with ( log_mean_exp_var ) : base_dtype = log_mean_exp_var . dtype . base_dtype if not base_dtype . is_floating : raise TypeError ( \"log_mean_exp_var.base_dtype({}) does not have float type \" \"`dtype`.\" . format ( base_dtype . name ) ) log_value = tf . convert_to_tensor ( value = log_value , dtype = base_dtype , name = \"log_value\" ) decay = tf . convert_to_tensor ( value = decay , dtype = base_dtype , name = \"decay\" ) delta = ( log_value - log_mean_exp_var ) [ tf . newaxis , ... ] x = tf . concat ( [ tf . math . log ( decay ) * tf . ones_like ( delta ) , delta + tf . math . log1p ( - decay ) ] , axis = 0 ) x = tf . reduce_logsumexp ( input_tensor = x , axis = 0 ) return log_mean_exp_var . assign_add ( x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def moving_mean_variance ( value , decay , name = None ) : with tf . compat . v1 . variable_scope ( name , \"moving_mean_variance\" , [ value , decay ] ) : value = tf . convert_to_tensor ( value = value , name = \"value\" ) base_dtype = value . dtype . base_dtype if not base_dtype . is_floating : raise TypeError ( \"value.base_dtype({}) does not have float type `dtype`.\" . format ( base_dtype . name ) ) decay = tf . convert_to_tensor ( value = decay , dtype = base_dtype , name = \"decay\" ) variance_var = tf . compat . v2 . Variable ( name = \"moving_variance\" , initial_value = tf . zeros ( shape = value . shape , dtype = value . dtype ) , trainable = False ) mean_var = tf . compat . v2 . Variable ( name = \"moving_mean\" , initial_value = tf . zeros ( shape = value . shape , dtype = value . dtype ) , trainable = False ) return assign_moving_mean_variance ( mean_var , variance_var , value , decay )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_columnar ( self , x ) : if tensorshape_util . rank ( x . shape ) is not None : if tensorshape_util . rank ( x . shape ) == 1 : x = x [ tf . newaxis , : ] return x shape = tf . shape ( input = x ) maybe_expanded_shape = tf . concat ( [ shape [ : - 1 ] , distribution_util . pick_vector ( tf . equal ( tf . rank ( x ) , 1 ) , [ 1 ] , np . array ( [ ] , dtype = np . int32 ) ) , shape [ - 1 : ] , ] , 0 ) return tf . reshape ( x , maybe_expanded_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_laplace_laplace ( a , b , name = None ) : with tf . name_scope ( name or \"kl_laplace_laplace\" ) : # Consistent with # http://www.mast.queensu.ca/~communications/Papers/gil-msc11.pdf, page 38 distance = tf . abs ( a . loc - b . loc ) ratio = a . scale / b . scale return ( - tf . math . log ( ratio ) - 1 + distance / b . scale + ratio * tf . exp ( - distance / a . scale ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def random_rademacher ( shape , dtype = tf . float32 , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'random_rademacher' , [ shape , seed ] ) : # Choose the dtype to cause `2 * random_bernoulli - 1` to run in the same # memory (host or device) as the downstream cast will want to put it. The # convention on GPU is that int32 are in host memory and int64 are in device # memory. generation_dtype = tf . int64 if tf . as_dtype ( dtype ) != tf . int32 else tf . int32 random_bernoulli = tf . random . uniform ( shape , minval = 0 , maxval = 2 , dtype = generation_dtype , seed = seed ) return tf . cast ( 2 * random_bernoulli - 1 , dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def random_rayleigh ( shape , scale = None , dtype = tf . float32 , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'random_rayleigh' , [ shape , scale , seed ] ) : if scale is not None : # Its important to expand the shape to match scale's, otherwise we won't # have independent draws. scale = tf . convert_to_tensor ( value = scale , dtype = dtype , name = 'scale' ) shape = tf . broadcast_dynamic_shape ( shape , tf . shape ( input = scale ) ) x = tf . sqrt ( - 2. * tf . math . log ( tf . random . uniform ( shape , minval = 0 , maxval = 1 , dtype = dtype , seed = seed ) ) ) if scale is None : return x return x * scale\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _pick_scalar_condition ( pred , cond_true , cond_false ) : # Note: This function is only valid if all of pred, cond_true, and cond_false # are scalars. This means its semantics are arguably more like tf.cond than # tf.where even though we use tf.where to implement it. pred_ = tf . get_static_value ( tf . convert_to_tensor ( value = pred ) ) if pred_ is None : return tf . where ( pred , cond_true , cond_false ) return cond_true if pred_ else cond_false\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _finish_log_prob_for_one_fiber ( self , y , x , ildj , event_ndims , * * distribution_kwargs ) : x = self . _maybe_rotate_dims ( x , rotate_right = True ) log_prob = self . distribution . log_prob ( x , * * distribution_kwargs ) if self . _is_maybe_event_override : log_prob = tf . reduce_sum ( input_tensor = log_prob , axis = self . _reduce_event_indices ) log_prob += tf . cast ( ildj , log_prob . dtype ) if self . _is_maybe_event_override and isinstance ( event_ndims , int ) : tensorshape_util . set_shape ( log_prob , tf . broadcast_static_shape ( tensorshape_util . with_rank_at_least ( y . shape , 1 ) [ : - event_ndims ] , self . batch_shape ) ) return log_prob\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _finish_prob_for_one_fiber ( self , y , x , ildj , event_ndims , * * distribution_kwargs ) : x = self . _maybe_rotate_dims ( x , rotate_right = True ) prob = self . distribution . prob ( x , * * distribution_kwargs ) if self . _is_maybe_event_override : prob = tf . reduce_prod ( input_tensor = prob , axis = self . _reduce_event_indices ) prob *= tf . exp ( tf . cast ( ildj , prob . dtype ) ) if self . _is_maybe_event_override and isinstance ( event_ndims , int ) : tensorshape_util . set_shape ( prob , tf . broadcast_static_shape ( tensorshape_util . with_rank_at_least ( y . shape , 1 ) [ : - event_ndims ] , self . batch_shape ) ) return prob\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_validate_shape_override ( self , override_shape , base_is_scalar , validate_args , name ) : if override_shape is None : override_shape = [ ] override_shape = tf . convert_to_tensor ( value = override_shape , dtype = tf . int32 , name = name ) if not dtype_util . is_integer ( override_shape . dtype ) : raise TypeError ( \"shape override must be an integer\" ) override_is_scalar = _is_scalar_from_shape_tensor ( override_shape ) if tf . get_static_value ( override_is_scalar ) : return self . _empty dynamic_assertions = [ ] if tensorshape_util . rank ( override_shape . shape ) is not None : if tensorshape_util . rank ( override_shape . shape ) != 1 : raise ValueError ( \"shape override must be a vector\" ) elif validate_args : dynamic_assertions += [ assert_util . assert_rank ( override_shape , 1 , message = \"shape override must be a vector\" ) ] if tf . get_static_value ( override_shape ) is not None : if any ( s < 0 for s in tf . get_static_value ( override_shape ) ) : raise ValueError ( \"shape override must have non-negative elements\" ) elif validate_args : dynamic_assertions += [ assert_util . assert_non_negative ( override_shape , message = \"shape override must have non-negative elements\" ) ] is_both_nonscalar = prefer_static . logical_and ( prefer_static . logical_not ( base_is_scalar ) , prefer_static . logical_not ( override_is_scalar ) ) if tf . get_static_value ( is_both_nonscalar ) is not None : if tf . get_static_value ( is_both_nonscalar ) : raise ValueError ( \"base distribution not scalar\" ) elif validate_args : dynamic_assertions += [ assert_util . assert_equal ( is_both_nonscalar , False , message = \"base distribution not scalar\" ) ] if not dynamic_assertions : return override_shape return distribution_util . with_dependencies ( dynamic_assertions , override_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_rotate_dims ( self , x , rotate_right = False ) : needs_rotation_const = tf . get_static_value ( self . _needs_rotation ) if needs_rotation_const is not None and not needs_rotation_const : return x ndims = prefer_static . rank ( x ) n = ( ndims - self . _rotate_ndims ) if rotate_right else self . _rotate_ndims perm = prefer_static . concat ( [ prefer_static . range ( n , ndims ) , prefer_static . range ( 0 , n ) ] , axis = 0 ) return tf . transpose ( a = x , perm = perm )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _undo_batch_normalization ( x , mean , variance , offset , scale , variance_epsilon , name = None ) : with tf . compat . v2 . name_scope ( name or \"undo_batchnorm\" ) : # inv = tf.rsqrt(variance + variance_epsilon) # if scale is not None: # inv *= scale # return x * inv + ( # offset - mean * inv if offset is not None else -mean * inv) rescale = tf . sqrt ( variance + variance_epsilon ) if scale is not None : rescale /= scale batch_unnormalized = x * rescale + ( mean - offset * rescale if offset is not None else mean ) return batch_unnormalized\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _validate_bn_layer ( self , layer ) : if ( not isinstance ( layer , tf . keras . layers . BatchNormalization ) and not isinstance ( layer , tf . compat . v1 . layers . BatchNormalization ) ) : raise ValueError ( \"batchnorm_layer must be an instance of BatchNormalization layer.\" ) if layer . renorm : raise ValueError ( \"BatchNorm Bijector does not support renormalization.\" ) if layer . virtual_batch_size : raise ValueError ( \"BatchNorm Bijector does not support virtual batch sizes.\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _slice_single_param ( param , param_event_ndims , slices , dist_batch_shape ) : # Extend param shape with ones on the left to match dist_batch_shape. param_shape = tf . shape ( input = param ) insert_ones = tf . ones ( [ tf . size ( input = dist_batch_shape ) + param_event_ndims - tf . rank ( param ) ] , dtype = param_shape . dtype ) new_param_shape = tf . concat ( [ insert_ones , param_shape ] , axis = 0 ) full_batch_param = tf . reshape ( param , new_param_shape ) param_slices = [ ] # We separately track the batch axis from the parameter axis because we want # them to align for positive indexing, and be offset by param_event_ndims for # negative indexing. param_dim_idx = 0 batch_dim_idx = 0 for slc in slices : if slc is tf . newaxis : param_slices . append ( slc ) continue if slc is Ellipsis : if batch_dim_idx < 0 : raise ValueError ( 'Found multiple `...` in slices {}' . format ( slices ) ) param_slices . append ( slc ) # Switch over to negative indexing for the broadcast check. num_remaining_non_newaxis_slices = sum ( [ s is not tf . newaxis for s in slices [ slices . index ( Ellipsis ) + 1 : ] ] ) batch_dim_idx = - num_remaining_non_newaxis_slices param_dim_idx = batch_dim_idx - param_event_ndims continue # Find the batch dimension sizes for both parameter and distribution. param_dim_size = new_param_shape [ param_dim_idx ] batch_dim_size = dist_batch_shape [ batch_dim_idx ] is_broadcast = batch_dim_size > param_dim_size # Slices are denoted by start:stop:step. if isinstance ( slc , slice ) : start , stop , step = slc . start , slc . stop , slc . step if start is not None : start = tf . where ( is_broadcast , 0 , start ) if stop is not None : stop = tf . where ( is_broadcast , 1 , stop ) if step is not None : step = tf . where ( is_broadcast , 1 , step ) param_slices . append ( slice ( start , stop , step ) ) else : # int, or int Tensor, e.g. d[d.batch_shape_tensor()[0] // 2] param_slices . append ( tf . where ( is_broadcast , 0 , slc ) ) param_dim_idx += 1 batch_dim_idx += 1 param_slices . extend ( [ ALL_SLICE ] * param_event_ndims ) return full_batch_param . __getitem__ ( param_slices )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _slice_params_to_dict ( dist , params_event_ndims , slices ) : override_dict = { } for param_name , param_event_ndims in six . iteritems ( params_event_ndims ) : # Verify that either None or a legit value is in the parameters dict. if param_name not in dist . parameters : raise ValueError ( 'Distribution {} is missing advertised ' 'parameter {}' . format ( dist , param_name ) ) param = dist . parameters [ param_name ] if param is None : # some distributions have multiple possible parameterizations; this # param was not provided continue dtype = None if hasattr ( dist , param_name ) : attr = getattr ( dist , param_name ) dtype = getattr ( attr , 'dtype' , None ) if dtype is None : dtype = dist . dtype warnings . warn ( 'Unable to find property getter for parameter Tensor {} ' 'on {}, falling back to Distribution.dtype {}' . format ( param_name , dist , dtype ) ) param = tf . convert_to_tensor ( value = param , dtype = dtype ) override_dict [ param_name ] = _slice_single_param ( param , param_event_ndims , slices , dist . batch_shape_tensor ( ) ) return override_dict\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _apply_single_step ( dist , params_event_ndims , slices , params_overrides ) : if len ( slices ) == 1 and slices [ 0 ] == Ellipsis : # The path used by Distribution.copy: batch_slice(...args..., Ellipsis) override_dict = { } else : override_dict = _slice_params_to_dict ( dist , params_event_ndims , slices ) override_dict . update ( params_overrides ) parameters = dict ( dist . parameters , * * override_dict ) new_dist = type ( dist ) ( * * parameters ) return new_dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _apply_slice_sequence ( dist , params_event_ndims , slice_overrides_seq ) : for slices , overrides in slice_overrides_seq : dist = _apply_single_step ( dist , params_event_ndims , slices , overrides ) return dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def batch_slice ( dist , params_event_ndims , params_overrides , slices ) : if not isinstance ( slices , collections . Sequence ) : slices = ( slices , ) # We track the history of slice and copy(**param_overrides) in order to trace # back to the original distribution's source variables. orig_dist , slice_overrides_seq = getattr ( dist , PROVENANCE_ATTR , ( dist , [ ] ) ) slice_overrides_seq += [ ( slices , params_overrides ) ] # Re-doing the full sequence of slice+copy override work here enables # gradients all the way back to the original distribution's arguments. dist = _apply_slice_sequence ( orig_dist , params_event_ndims , slice_overrides_seq ) setattr ( dist , PROVENANCE_ATTR , ( orig_dist , slice_overrides_seq ) ) return dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fit ( model_matrix , response , model , model_coefficients_start = None , predicted_linear_response_start = None , l2_regularizer = None , dispersion = None , offset = None , convergence_criteria_fn = None , learning_rate = None , fast_unsafe_numerics = True , maximum_iterations = None , name = None ) : graph_deps = [ model_matrix , response , model_coefficients_start , predicted_linear_response_start , dispersion , offset , learning_rate , maximum_iterations ] with tf . compat . v1 . name_scope ( name , 'fit' , graph_deps ) : [ model_matrix , response , model_coefficients_start , predicted_linear_response_start , offset , ] = prepare_args ( model_matrix , response , model_coefficients_start , predicted_linear_response_start , offset ) if convergence_criteria_fn is None : convergence_criteria_fn = ( convergence_criteria_small_relative_norm_weights_change ( ) ) def _body ( is_converged_previous , iter_ , model_coefficients_previous , predicted_linear_response_previous ) : \"\"\"`tf.while_loop` body.\"\"\" model_coefficients_next , predicted_linear_response_next = fit_one_step ( model_matrix , response , model , model_coefficients_previous , predicted_linear_response_previous , l2_regularizer , dispersion , offset , learning_rate , fast_unsafe_numerics ) is_converged_next = convergence_criteria_fn ( is_converged_previous = is_converged_previous , iter_ = iter_ , model_coefficients_previous = model_coefficients_previous , predicted_linear_response_previous = predicted_linear_response_previous , model_coefficients_next = model_coefficients_next , predicted_linear_response_next = predicted_linear_response_next , response = response , model = model , dispersion = dispersion ) return [ is_converged_next , iter_ + 1 , model_coefficients_next , predicted_linear_response_next , ] # while not converged: # fit_one_step [ is_converged , iter_ , model_coefficients , predicted_linear_response , ] = tf . while_loop ( cond = lambda is_converged , * args : tf . logical_not ( is_converged ) , body = _body , loop_vars = [ tf . zeros ( [ ] , np . bool ) , # is_converged tf . zeros ( [ ] , np . int32 ) , # iter_ model_coefficients_start , predicted_linear_response_start , ] , maximum_iterations = maximum_iterations ) return [ model_coefficients , predicted_linear_response , is_converged , iter_ ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fit_one_step ( model_matrix , response , model , model_coefficients_start = None , predicted_linear_response_start = None , l2_regularizer = None , dispersion = None , offset = None , learning_rate = None , fast_unsafe_numerics = True , name = None ) : graph_deps = [ model_matrix , response , model_coefficients_start , predicted_linear_response_start , dispersion , learning_rate ] with tf . compat . v1 . name_scope ( name , 'fit_one_step' , graph_deps ) : [ model_matrix , response , model_coefficients_start , predicted_linear_response_start , offset , ] = prepare_args ( model_matrix , response , model_coefficients_start , predicted_linear_response_start , offset ) # Compute: mean, grad(mean, predicted_linear_response_start), and variance. mean , variance , grad_mean = model ( predicted_linear_response_start ) # If either `grad_mean` or `variance is non-finite or zero, then we'll # replace it with a value such that the row is zeroed out. Although this # procedure may seem circuitous, it is necessary to ensure this algorithm is # itself differentiable. is_valid = ( tf . math . is_finite ( grad_mean ) & tf . not_equal ( grad_mean , 0. ) & tf . math . is_finite ( variance ) & ( variance > 0. ) ) def mask_if_invalid ( x , mask ) : mask = tf . fill ( tf . shape ( input = x ) , value = np . array ( mask , x . dtype . as_numpy_dtype ) ) return tf . where ( is_valid , x , mask ) # Run one step of iteratively reweighted least-squares. # Compute \"`z`\", the adjusted predicted linear response. # z = predicted_linear_response_start # + learning_rate * (response - mean) / grad_mean z = ( response - mean ) / mask_if_invalid ( grad_mean , 1. ) # TODO(jvdillon): Rather than use learning rate, we should consider using # backtracking line search. if learning_rate is not None : z *= learning_rate [ ... , tf . newaxis ] z += predicted_linear_response_start if offset is not None : z -= offset # Compute \"`w`\", the per-sample weight. if dispersion is not None : # For convenience, we'll now scale the variance by the dispersion factor. variance *= dispersion w = ( mask_if_invalid ( grad_mean , 0. ) * tf . math . rsqrt ( mask_if_invalid ( variance , np . inf ) ) ) a = model_matrix * w [ ... , tf . newaxis ] b = z * w # Solve `min{ || A @ model_coefficients - b ||_2**2 : model_coefficients }` # where `@` denotes `matmul`. if l2_regularizer is None : l2_regularizer = np . array ( 0 , a . dtype . as_numpy_dtype ) else : l2_regularizer_ = distribution_util . maybe_get_static_value ( l2_regularizer , a . dtype . as_numpy_dtype ) if l2_regularizer_ is not None : l2_regularizer = l2_regularizer_ def _embed_l2_regularization ( ) : \"\"\"Adds synthetic observations to implement L2 regularization.\"\"\" # `tf.matrix_solve_ls` does not respect the `l2_regularization` argument # when `fast_unsafe_numerics` is `False`. This function adds synthetic # observations to the data to implement the regularization instead. # Adding observations `sqrt(l2_regularizer) * I` is mathematically # equivalent to adding the term # `-l2_regularizer ||coefficients||_2**2` to the log-likelihood. num_model_coefficients = num_cols ( model_matrix ) batch_shape = tf . shape ( input = model_matrix ) [ : - 2 ] eye = tf . eye ( num_model_coefficients , batch_shape = batch_shape , dtype = a . dtype ) a_ = tf . concat ( [ a , tf . sqrt ( l2_regularizer ) * eye ] , axis = - 2 ) b_ = distribution_util . pad ( b , count = num_model_coefficients , axis = - 1 , back = True ) # Return l2_regularizer=0 since its now embedded. l2_regularizer_ = np . array ( 0 , a . dtype . as_numpy_dtype ) return a_ , b_ , l2_regularizer_ a , b , l2_regularizer = prefer_static . cond ( prefer_static . reduce_all ( [ not ( fast_unsafe_numerics ) , l2_regularizer > 0. ] ) , _embed_l2_regularization , lambda : ( a , b , l2_regularizer ) ) model_coefficients_next = tf . linalg . lstsq ( a , b [ ... , tf . newaxis ] , fast = fast_unsafe_numerics , l2_regularizer = l2_regularizer , name = 'model_coefficients_next' ) model_coefficients_next = model_coefficients_next [ ... , 0 ] # TODO(b/79122261): The approach used in `matrix_solve_ls` could be made # faster by avoiding explicitly forming Q and instead keeping the # factorization in 'implicit' form with stacked (rescaled) Householder # vectors underneath the 'R' and then applying the (accumulated) # reflectors in the appropriate order to apply Q'. However, we don't # presently do this because we lack core TF functionality. For reference, # the vanilla QR approach is: # q, r = tf.linalg.qr(a) # c = tf.matmul(q, b, adjoint_a=True) # model_coefficients_next = tf.matrix_triangular_solve( # r, c, lower=False, name='model_coefficients_next') predicted_linear_response_next = calculate_linear_predictor ( model_matrix , model_coefficients_next , offset , name = 'predicted_linear_response_next' ) return model_coefficients_next , predicted_linear_response_next\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def convergence_criteria_small_relative_norm_weights_change ( tolerance = 1e-5 , norm_order = 2 ) : def convergence_criteria_fn ( is_converged_previous , # pylint: disable=unused-argument iter_ , model_coefficients_previous , predicted_linear_response_previous , # pylint: disable=unused-argument model_coefficients_next , predicted_linear_response_next , # pylint: disable=unused-argument response , # pylint: disable=unused-argument model , # pylint: disable=unused-argument dispersion ) : # pylint: disable=unused-argument \"\"\"Returns `bool` `Tensor` indicating if fitting procedure has converged. Args: is_converged_previous: \"old\" convergence results. iter_: Iteration number. model_coefficients_previous: \"old\" `model_coefficients`. predicted_linear_response_previous: \"old\" `predicted_linear_response`. model_coefficients_next: \"new\" `model_coefficients`. predicted_linear_response_next: \"new: `predicted_linear_response`. response: (Batch of) vector-shaped `Tensor` where each element represents a sample's observed response (to the corresponding row of features). Must have same `dtype` as `model_matrix`. model: `tfp.glm.ExponentialFamily`-like instance used to construct the negative log-likelihood loss, gradient, and expected Hessian (i.e., the Fisher information matrix). dispersion: `Tensor` representing `response` dispersion, i.e., as in: `p(y|theta) := exp((y theta - A(theta)) / dispersion)`. Must broadcast with rows of `model_matrix`. Default value: `None` (i.e., \"no dispersion\"). Returns: is_converged: `bool` `Tensor`. \"\"\" relative_euclidean_norm = ( tf . norm ( tensor = model_coefficients_previous - model_coefficients_next , ord = norm_order , axis = - 1 ) / ( 1. + tf . norm ( tensor = model_coefficients_previous , ord = norm_order , axis = - 1 ) ) ) return ( iter_ > 0 ) & tf . reduce_all ( input_tensor = relative_euclidean_norm < tolerance ) return convergence_criteria_fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def prepare_args ( model_matrix , response , model_coefficients , predicted_linear_response , offset , name = None ) : graph_deps = [ model_matrix , response , model_coefficients , predicted_linear_response , offset ] with tf . compat . v1 . name_scope ( name , 'prepare_args' , graph_deps ) : dtype = dtype_util . common_dtype ( graph_deps , np . float32 ) model_matrix = tf . convert_to_tensor ( value = model_matrix , dtype = dtype , name = 'model_matrix' ) if offset is not None : offset = tf . convert_to_tensor ( value = offset , dtype = dtype , name = 'offset' ) response = tf . convert_to_tensor ( value = response , dtype = dtype , name = 'response' ) use_default_model_coefficients = model_coefficients is None if use_default_model_coefficients : # User did not supply model coefficients; assume they're all zero. batch_shape = tf . shape ( input = model_matrix ) [ : - 2 ] num_columns = tf . shape ( input = model_matrix ) [ - 1 ] model_coefficients = tf . zeros ( shape = tf . concat ( [ batch_shape , [ num_columns ] ] , axis = 0 ) , dtype = dtype , name = 'model_coefficients' ) else : # User did supply model coefficients; convert to Tensor in case it's # numpy or literal. model_coefficients = tf . convert_to_tensor ( value = model_coefficients , dtype = dtype , name = 'model_coefficients' ) if predicted_linear_response is None : if use_default_model_coefficients : # Since we're using zeros for model_coefficients, we know the predicted # linear response will also be all zeros. if offset is None : predicted_linear_response = tf . zeros_like ( response , dtype , name = 'predicted_linear_response' ) else : predicted_linear_response = tf . broadcast_to ( offset , tf . shape ( input = response ) , name = 'predicted_linear_response' ) else : # We were given model_coefficients but not the predicted linear # response. predicted_linear_response = calculate_linear_predictor ( model_matrix , model_coefficients , offset ) else : predicted_linear_response = tf . convert_to_tensor ( value = predicted_linear_response , dtype = dtype , name = 'predicted_linear_response' ) return [ model_matrix , response , model_coefficients , predicted_linear_response , offset , ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def calculate_linear_predictor ( model_matrix , model_coefficients , offset = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'calculate_linear_predictor' , [ model_matrix , model_coefficients , offset ] ) : predicted_linear_response = tf . linalg . matvec ( model_matrix , model_coefficients ) if offset is not None : predicted_linear_response += offset return predicted_linear_response\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def num_cols ( x ) : if tf . compat . dimension_value ( x . shape [ - 1 ] ) is not None : return tf . compat . dimension_value ( x . shape [ - 1 ] ) return tf . shape ( input = x ) [ - 1 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prefer_static ( original_fn , static_fn ) : original_spec = tf_inspect . getfullargspec ( original_fn ) static_spec = tf_inspect . getfullargspec ( static_fn ) if original_spec != static_spec : raise ValueError ( 'Arg specs do not match: original={}, static={}, fn={}' . format ( original_spec , static_spec , original_fn ) ) @ decorator . decorator def wrap ( wrapped_fn , * args , * * kwargs ) : del wrapped_fn [ args_ , kwargs_ ] , all_static = _maybe_get_static_args ( [ args , kwargs ] ) if all_static : return static_fn ( * args_ , * * kwargs_ ) return original_fn ( * args , * * kwargs ) return wrap ( original_fn )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _copy_docstring ( original_fn , new_fn ) : original_spec = tf_inspect . getfullargspec ( original_fn ) new_spec = tf_inspect . getfullargspec ( new_fn ) if original_spec != new_spec : raise ValueError ( 'Arg specs do not match: original={}, new={}, fn={}' . format ( original_spec , new_spec , original_fn ) ) @ decorator . decorator def wrap ( wrapped_fn , * args , * * kwargs ) : del wrapped_fn return new_fn ( * args , * * kwargs ) return wrap ( original_fn )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_static_predicate ( pred ) : if pred in { 0 , 1 } : # Accept 1/0 as valid boolean values pred_value = bool ( pred ) elif isinstance ( pred , bool ) : pred_value = pred elif isinstance ( pred , tf . Tensor ) : pred_value = tf . get_static_value ( pred ) # TODO(jamieas): remove the dependency on `pywrap_tensorflow`. # pylint: disable=protected-access if pred_value is None : pred_value = c_api . TF_TryEvaluateConstant_wrapper ( pred . graph . _c_graph , pred . _as_tf_output ( ) ) # pylint: enable=protected-access else : raise TypeError ( '`pred` must be a Tensor, or a Python bool, or 1 or 0. ' 'Found instead: {}' . format ( pred ) ) return pred_value\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def rank_from_shape ( shape_tensor_fn , tensorshape = None ) : if tensorshape is None : shape_tensor = ( shape_tensor_fn ( ) if callable ( shape_tensor_fn ) else shape_tensor_fn ) if ( hasattr ( shape_tensor , 'shape' ) and hasattr ( shape_tensor . shape , 'num_elements' ) ) : ndims_ = tensorshape_util . num_elements ( shape_tensor . shape ) else : ndims_ = len ( shape_tensor ) ndims_fn = lambda : tf . size ( input = shape_tensor ) else : ndims_ = tensorshape_util . rank ( tensorshape ) ndims_fn = lambda : tf . size ( input = shape_tensor_fn ( ) # pylint: disable=g-long-lambda if callable ( shape_tensor_fn ) else shape_tensor_fn ) return ndims_fn ( ) if ndims_ is None else ndims_\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def cond ( pred , true_fn = None , false_fn = None , name = None ) : if not callable ( true_fn ) : raise TypeError ( '`true_fn` must be callable.' ) if not callable ( false_fn ) : raise TypeError ( '`false_fn` must be callable.' ) pred_value = _get_static_predicate ( pred ) if pred_value is not None : if pred_value : return true_fn ( ) else : return false_fn ( ) else : return tf . cond ( pred = pred , true_fn = true_fn , false_fn = false_fn , name = name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def case ( pred_fn_pairs , default = None , exclusive = False , name = 'smart_case' ) : return control_flow_ops . _case_helper ( # pylint: disable=protected-access cond , pred_fn_pairs , default , exclusive , name , allow_python_preds = True )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def log_prob ( self , response , predicted_linear_response , name = None ) : with self . _name_scope ( name , 'log_prob' , [ response , predicted_linear_response ] ) : dtype = dtype_util . common_dtype ( [ response , predicted_linear_response ] ) response = tf . convert_to_tensor ( value = response , dtype = dtype , name = 'response' ) predicted_linear_response = tf . convert_to_tensor ( value = predicted_linear_response , name = 'predicted_linear_response' ) return self . _log_prob ( response , predicted_linear_response )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _name_scope ( self , name = None , default_name = None , values = None ) : with tf . compat . v1 . name_scope ( self . name ) : with tf . compat . v1 . name_scope ( name , default_name , values = values or [ ] ) as scope : yield scope\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def mixture_stddev ( mixture_weight_vector , mean_vector , stddev_vector ) : tensorshape_util . assert_has_rank ( mixture_weight_vector . shape , 2 ) if not tensorshape_util . is_compatible_with ( mean_vector . shape , mixture_weight_vector . shape ) : raise ValueError ( \"Expecting means to have same shape as mixture weights.\" ) if not tensorshape_util . is_compatible_with ( stddev_vector . shape , mixture_weight_vector . shape ) : raise ValueError ( \"Expecting stddevs to have same shape as mixture weights.\" ) # Reshape the distribution parameters for batched vectorized dot products. pi_for_dot_prod = tf . expand_dims ( mixture_weight_vector , axis = 1 ) mu_for_dot_prod = tf . expand_dims ( mean_vector , axis = 2 ) sigma_for_dot_prod = tf . expand_dims ( stddev_vector , axis = 2 ) # weighted average of component means under mixture distribution. mean_wa = tf . matmul ( pi_for_dot_prod , mu_for_dot_prod ) mean_wa = tf . reshape ( mean_wa , ( - 1 , ) ) # weighted average of component variances under mixture distribution. var_wa = tf . matmul ( pi_for_dot_prod , tf . square ( sigma_for_dot_prod ) ) var_wa = tf . reshape ( var_wa , ( - 1 , ) ) # weighted average of component squared means under mixture distribution. sq_mean_wa = tf . matmul ( pi_for_dot_prod , tf . square ( mu_for_dot_prod ) ) sq_mean_wa = tf . reshape ( sq_mean_wa , ( - 1 , ) ) mixture_variance = var_wa + sq_mean_wa - tf . square ( mean_wa ) return tf . sqrt ( mixture_variance )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_tril_scale ( loc = None , scale_tril = None , scale_diag = None , scale_identity_multiplier = None , shape_hint = None , validate_args = False , assert_positive = False , name = None ) : def _maybe_attach_assertion ( x ) : if not validate_args : return x if assert_positive : return with_dependencies ( [ assert_util . assert_positive ( tf . linalg . diag_part ( x ) , message = \"diagonal part must be positive\" ) , ] , x ) return with_dependencies ( [ assert_util . assert_none_equal ( tf . linalg . diag_part ( x ) , tf . zeros ( [ ] , x . dtype ) , message = \"diagonal part must be non-zero\" ) , ] , x ) with tf . name_scope ( name or \"make_tril_scale\" ) : dtype = dtype_util . common_dtype ( [ loc , scale_tril , scale_diag , scale_identity_multiplier ] , preferred_dtype = tf . float32 ) loc = _convert_to_tensor ( loc , name = \"loc\" , dtype = dtype ) scale_tril = _convert_to_tensor ( scale_tril , name = \"scale_tril\" , dtype = dtype ) scale_diag = _convert_to_tensor ( scale_diag , name = \"scale_diag\" , dtype = dtype ) scale_identity_multiplier = _convert_to_tensor ( scale_identity_multiplier , name = \"scale_identity_multiplier\" , dtype = dtype ) if scale_tril is not None : scale_tril = tf . linalg . band_part ( scale_tril , - 1 , 0 ) # Zero out TriU. tril_diag = tf . linalg . diag_part ( scale_tril ) if scale_diag is not None : tril_diag += scale_diag if scale_identity_multiplier is not None : tril_diag += scale_identity_multiplier [ ... , tf . newaxis ] scale_tril = tf . linalg . set_diag ( scale_tril , tril_diag ) return tf . linalg . LinearOperatorLowerTriangular ( tril = _maybe_attach_assertion ( scale_tril ) , is_non_singular = True , is_self_adjoint = False , is_positive_definite = assert_positive ) return make_diag_scale ( loc = loc , scale_diag = scale_diag , scale_identity_multiplier = scale_identity_multiplier , shape_hint = shape_hint , validate_args = validate_args , assert_positive = assert_positive , name = name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_diag_scale ( loc = None , scale_diag = None , scale_identity_multiplier = None , shape_hint = None , validate_args = False , assert_positive = False , name = None , dtype = None ) : def _maybe_attach_assertion ( x ) : if not validate_args : return x if assert_positive : return with_dependencies ( [ assert_util . assert_positive ( x , message = \"diagonal part must be positive\" ) , ] , x ) return with_dependencies ( [ assert_util . assert_none_equal ( x , tf . zeros ( [ ] , x . dtype ) , message = \"diagonal part must be non-zero\" ) ] , x ) with tf . name_scope ( name or \"make_diag_scale\" ) : if dtype is None : dtype = dtype_util . common_dtype ( [ loc , scale_diag , scale_identity_multiplier ] , preferred_dtype = tf . float32 ) loc = _convert_to_tensor ( loc , name = \"loc\" , dtype = dtype ) scale_diag = _convert_to_tensor ( scale_diag , name = \"scale_diag\" , dtype = dtype ) scale_identity_multiplier = _convert_to_tensor ( scale_identity_multiplier , name = \"scale_identity_multiplier\" , dtype = dtype ) if scale_diag is not None : if scale_identity_multiplier is not None : scale_diag += scale_identity_multiplier [ ... , tf . newaxis ] return tf . linalg . LinearOperatorDiag ( diag = _maybe_attach_assertion ( scale_diag ) , is_non_singular = True , is_self_adjoint = True , is_positive_definite = assert_positive ) if loc is None and shape_hint is None : raise ValueError ( \"Cannot infer `event_shape` unless `loc` or \" \"`shape_hint` is specified.\" ) num_rows = shape_hint del shape_hint if num_rows is None : num_rows = tf . compat . dimension_value ( loc . shape [ - 1 ] ) if num_rows is None : num_rows = tf . shape ( input = loc ) [ - 1 ] if scale_identity_multiplier is None : return tf . linalg . LinearOperatorIdentity ( num_rows = num_rows , dtype = dtype , is_self_adjoint = True , is_positive_definite = True , assert_proper_shapes = validate_args ) return tf . linalg . LinearOperatorScaledIdentity ( num_rows = num_rows , multiplier = _maybe_attach_assertion ( scale_identity_multiplier ) , is_non_singular = True , is_self_adjoint = True , is_positive_definite = assert_positive , assert_proper_shapes = validate_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def shapes_from_loc_and_scale ( loc , scale , name = \"shapes_from_loc_and_scale\" ) : if loc is not None and tensorshape_util . rank ( loc . shape ) == 0 : loc = None # scalar loc is irrelevant to determining batch/event shape. with tf . name_scope ( name ) : # Get event shape. event_size = scale . range_dimension_tensor ( ) event_size_ = tf . get_static_value ( event_size ) loc_event_size_ = ( None if loc is None else tf . compat . dimension_value ( loc . shape [ - 1 ] ) ) if event_size_ is not None and loc_event_size_ is not None : # Static check that event shapes match. if loc_event_size_ != 1 and loc_event_size_ != event_size_ : raise ValueError ( \"Event size of 'scale' ({}) could not be broadcast up to that \" \"of 'loc' ({}).\" . format ( event_size_ , loc_event_size_ ) ) elif loc_event_size_ is not None and loc_event_size_ != 1 : event_size_ = loc_event_size_ if event_size_ is None : event_shape = event_size [ tf . newaxis ] else : event_shape = tf . convert_to_tensor ( value = np . reshape ( event_size_ , [ 1 ] ) , dtype = tf . int32 , name = \"event_shape\" ) # Get batch shape. batch_shape = scale . batch_shape_tensor ( ) if loc is not None : loc_batch_shape = tensorshape_util . with_rank_at_least ( loc . shape , 1 ) [ : - 1 ] if tensorshape_util . rank ( loc . shape ) is None or not tensorshape_util . is_fully_defined ( loc_batch_shape ) : loc_batch_shape = tf . shape ( input = loc ) [ : - 1 ] else : loc_batch_shape = tf . convert_to_tensor ( value = loc_batch_shape , dtype = tf . int32 , name = \"loc_batch_shape\" ) # This is defined in the core util module. batch_shape = prefer_static_broadcast_shape ( batch_shape , loc_batch_shape ) # pylint: disable=undefined-variable batch_shape = tf . convert_to_tensor ( value = batch_shape , dtype = tf . int32 , name = \"batch_shape\" ) return batch_shape , event_shape\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_broadcast_shape ( * tensors ) : # Try static. s_shape = tensors [ 0 ] . shape for t in tensors [ 1 : ] : s_shape = tf . broadcast_static_shape ( s_shape , t . shape ) if tensorshape_util . is_fully_defined ( s_shape ) : return tensorshape_util . as_list ( s_shape ) # Fallback on dynamic. d_shape = tf . shape ( input = tensors [ 0 ] ) for t in tensors [ 1 : ] : d_shape = tf . broadcast_dynamic_shape ( d_shape , tf . shape ( input = t ) ) return d_shape\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_diagonal_scale ( scale ) : if not isinstance ( scale , tf . linalg . LinearOperator ) : raise TypeError ( \"Expected argument 'scale' to be instance of LinearOperator\" \". Found: %s\" % scale ) return ( isinstance ( scale , tf . linalg . LinearOperatorIdentity ) or isinstance ( scale , tf . linalg . LinearOperatorScaledIdentity ) or isinstance ( scale , tf . linalg . LinearOperatorDiag ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def maybe_check_scalar_distribution ( distribution , expected_base_dtype , validate_args ) : if distribution . dtype != expected_base_dtype : raise TypeError ( \"dtype mismatch; \" \"distribution.dtype=\\\"{}\\\" is not \\\"{}\\\"\" . format ( dtype_util . name ( distribution . dtype ) , dtype_util . name ( expected_base_dtype ) ) ) # Although `reparameterization_type` is a static property, we guard it by # `validate_args`. This allows users to use a `distribution` which is not # reparameterized itself. However, we tacitly assume that although the # distribution is not reparameterized, it only depends on non-trainable # variables. if validate_args and ( distribution . reparameterization_type != reparameterization . FULLY_REPARAMETERIZED ) : raise ValueError ( \"Base distribution should be reparameterized or be \" \"a function of non-trainable variables; \" \"distribution.reparameterization_type = \\\"{}\\\" \" \"!= \\\"FULLY_REPARAMETERIZED\\\".\" . format ( distribution . reparameterization_type ) ) with tf . name_scope ( \"check_distribution\" ) : assertions = [ ] def check_is_scalar ( is_scalar , name ) : is_scalar_ = tf . get_static_value ( is_scalar ) if is_scalar_ is not None : if not is_scalar_ : raise ValueError ( \"distribution must be scalar; \" \"distribution.{}=False is not True\" . format ( name ) ) elif validate_args : assertions . append ( assert_util . assert_equal ( is_scalar , True , message = ( \"distribution must be scalar; \" \"distribution.{}=False is not True\" . format ( name ) ) ) ) check_is_scalar ( distribution . is_scalar_event ( ) , \"is_scalar_event\" ) check_is_scalar ( distribution . is_scalar_batch ( ) , \"is_scalar_batch\" ) return assertions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pad_mixture_dimensions ( x , mixture_distribution , categorical_distribution , event_ndims ) : with tf . name_scope ( \"pad_mix_dims\" ) : def _get_ndims ( d ) : if tensorshape_util . rank ( d . batch_shape ) is not None : return tensorshape_util . rank ( d . batch_shape ) return tf . shape ( input = d . batch_shape_tensor ( ) ) [ 0 ] dist_batch_ndims = _get_ndims ( mixture_distribution ) cat_batch_ndims = _get_ndims ( categorical_distribution ) pad_ndims = tf . where ( categorical_distribution . is_scalar_batch ( ) , dist_batch_ndims , dist_batch_ndims - cat_batch_ndims ) s = tf . shape ( input = x ) x = tf . reshape ( x , shape = tf . concat ( [ s [ : - 1 ] , tf . ones ( [ pad_ndims ] , dtype = tf . int32 ) , s [ - 1 : ] , tf . ones ( [ event_ndims ] , dtype = tf . int32 ) , ] , axis = 0 ) ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pick_scalar_condition ( pred , true_value , false_value , name = None ) : with tf . name_scope ( name or \"pick_scalar_condition\" ) : pred = tf . convert_to_tensor ( value = pred , dtype_hint = tf . bool , name = \"pred\" ) true_value = tf . convert_to_tensor ( value = true_value , name = \"true_value\" ) false_value = tf . convert_to_tensor ( value = false_value , name = \"false_value\" ) pred_ = tf . get_static_value ( pred ) if pred_ is None : return tf . where ( pred , true_value , false_value ) return true_value if pred_ else false_value\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_non_negative_axis ( axis , rank ) : axis = tf . convert_to_tensor ( value = axis , name = \"axis\" ) rank = tf . convert_to_tensor ( value = rank , name = \"rank\" ) axis_ = tf . get_static_value ( axis ) rank_ = tf . get_static_value ( rank ) # Static case. if axis_ is not None and rank_ is not None : is_scalar = axis_ . ndim == 0 if is_scalar : axis_ = [ axis_ ] positive_axis = [ ] for a_ in axis_ : if a_ < 0 : positive_axis . append ( rank_ + a_ ) else : positive_axis . append ( a_ ) if is_scalar : positive_axis = positive_axis [ 0 ] return tf . convert_to_tensor ( value = positive_axis , dtype = axis . dtype ) # Dynamic case. # Unfortunately static values are lost by this tf.where. return tf . where ( axis < 0 , rank + axis , axis )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def move_dimension ( x , source_idx , dest_idx ) : ndims = prefer_static_rank ( x ) dtype = dtype_util . common_dtype ( [ source_idx , dest_idx ] , preferred_dtype = tf . int32 ) source_idx = tf . convert_to_tensor ( value = source_idx , dtype = dtype ) dest_idx = tf . convert_to_tensor ( value = dest_idx , dtype = dtype ) # Handle negative indexing. source_idx = pick_scalar_condition ( source_idx < 0 , ndims + source_idx , source_idx ) dest_idx = pick_scalar_condition ( dest_idx < 0 , ndims + dest_idx , dest_idx ) # Construct the appropriate permutation of dimensions, depending # whether the source is before or after the destination. def move_left_permutation ( ) : return prefer_static_value ( tf . concat ( [ tf . range ( 0 , dest_idx , dtype = dtype ) , [ source_idx ] , tf . range ( dest_idx , source_idx , dtype = dtype ) , tf . range ( source_idx + 1 , ndims , dtype = dtype ) ] , axis = 0 ) ) def move_right_permutation ( ) : return prefer_static_value ( tf . concat ( [ tf . range ( 0 , source_idx , dtype = dtype ) , tf . range ( source_idx + 1 , dest_idx + 1 , dtype = dtype ) , [ source_idx ] , tf . range ( dest_idx + 1 , ndims , dtype = dtype ) ] , axis = 0 ) ) def x_permuted ( ) : return tf . transpose ( a = x , perm = prefer_static . cond ( source_idx < dest_idx , move_right_permutation , move_left_permutation ) ) # One final conditional to handle the special case where source # and destination indices are equal. return prefer_static . cond ( tf . equal ( source_idx , dest_idx ) , lambda : x , x_permuted )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def assert_integer_form ( x , data = None , summarize = None , message = None , int_dtype = None , name = \"assert_integer_form\" ) : with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) if dtype_util . is_integer ( x . dtype ) : return tf . no_op ( ) message = message or \"{} has non-integer components\" . format ( x ) if int_dtype is None : try : int_dtype = { tf . float16 : tf . int16 , tf . float32 : tf . int32 , tf . float64 : tf . int64 , } [ dtype_util . base_dtype ( x . dtype ) ] except KeyError : raise TypeError ( \"Unrecognized type {}\" . format ( dtype_util . name ( x . dtype ) ) ) return assert_util . assert_equal ( x , tf . cast ( tf . cast ( x , int_dtype ) , x . dtype ) , data = data , summarize = summarize , message = message , name = name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def embed_check_nonnegative_integer_form ( x , name = \"embed_check_nonnegative_integer_form\" ) : with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) assertions = [ assert_util . assert_non_negative ( x , message = \"'{}' must be non-negative.\" . format ( x ) ) , ] if not dtype_util . is_integer ( x . dtype ) : assertions += [ assert_integer_form ( x , message = \"'{}' cannot contain fractional components.\" . format ( x ) ) , ] return with_dependencies ( assertions , x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def same_dynamic_shape ( a , b ) : a = tf . convert_to_tensor ( value = a , name = \"a\" ) b = tf . convert_to_tensor ( value = b , name = \"b\" ) # Here we can't just do tf.equal(a.shape, b.shape), since # static shape inference may break the equality comparison between # shape(a) and shape(b) in tf.equal. def all_shapes_equal ( ) : return tf . reduce_all ( input_tensor = tf . equal ( tf . concat ( [ tf . shape ( input = a ) , tf . shape ( input = b ) ] , 0 ) , tf . concat ( [ tf . shape ( input = b ) , tf . shape ( input = a ) ] , 0 ) ) ) # One of the shapes isn't fully defined, so we need to use the dynamic # shape. return tf . cond ( pred = tf . equal ( tf . rank ( a ) , tf . rank ( b ) ) , true_fn = all_shapes_equal , false_fn = lambda : tf . constant ( False ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def maybe_get_static_value ( x , dtype = None ) : if x is None : return x try : # This returns an np.ndarray. x_ = tf . get_static_value ( x ) except TypeError : x_ = x if x_ is None or dtype is None : return x_ return np . array ( x_ , dtype )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_logits_and_probs ( logits = None , probs = None , multidimensional = False , validate_args = False , name = \"get_logits_and_probs\" , dtype = None ) : if dtype is None : dtype = dtype_util . common_dtype ( [ probs , logits ] , preferred_dtype = tf . float32 ) with tf . name_scope ( name ) : if ( probs is None ) == ( logits is None ) : raise ValueError ( \"Must pass probs or logits, but not both.\" ) if probs is None : logits = tf . convert_to_tensor ( value = logits , name = \"logits\" , dtype = dtype ) if not dtype_util . is_floating ( logits . dtype ) : raise TypeError ( \"logits must having floating type.\" ) # We can early return since we constructed probs and therefore know # they're valid. if multidimensional : if validate_args : logits = embed_check_categorical_event_shape ( logits ) return logits , tf . nn . softmax ( logits , name = \"probs\" ) return logits , tf . sigmoid ( logits , name = \"probs\" ) probs = tf . convert_to_tensor ( value = probs , name = \"probs\" , dtype = dtype ) if not dtype_util . is_floating ( probs . dtype ) : raise TypeError ( \"probs must having floating type.\" ) if validate_args : with tf . name_scope ( \"validate_probs\" ) : one = tf . constant ( 1. , probs . dtype ) dependencies = [ assert_util . assert_non_negative ( probs ) ] if multidimensional : probs = embed_check_categorical_event_shape ( probs ) dependencies += [ assert_util . assert_near ( tf . reduce_sum ( input_tensor = probs , axis = - 1 ) , one , message = \"probs does not sum to 1.\" ) ] else : dependencies += [ assert_util . assert_less_equal ( probs , one , message = \"probs has components greater than 1.\" ) ] probs = with_dependencies ( dependencies , probs ) with tf . name_scope ( \"logits\" ) : if multidimensional : # Here we don't compute the multidimensional case, in a manner # consistent with respect to the unidimensional case. We do so # following the TF convention. Typically, you might expect to see # logits = log(probs) - log(probs[pivot]). A side-effect of # being consistent with the TF approach is that the unidimensional case # implicitly handles the second dimension but the multidimensional case # explicitly keeps the pivot dimension. return tf . math . log ( probs ) , probs return tf . math . log ( probs ) - tf . math . log1p ( - 1. * probs ) , probs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _is_known_unsigned_by_dtype ( dt ) : return { tf . bool : True , tf . uint8 : True , tf . uint16 : True , } . get ( dt . base_dtype , False )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _is_known_signed_by_dtype ( dt ) : return { tf . float16 : True , tf . float32 : True , tf . float64 : True , tf . int8 : True , tf . int16 : True , tf . int32 : True , tf . int64 : True , } . get ( dt . base_dtype , False )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _largest_integer_by_dtype ( dt ) : if not _is_known_dtype ( dt ) : raise TypeError ( \"Unrecognized dtype: {}\" . format ( dt . name ) ) if dt . is_floating : return int ( 2 ** ( np . finfo ( dt . as_numpy_dtype ) . nmant + 1 ) ) if dt . is_integer : return np . iinfo ( dt . as_numpy_dtype ) . max if dt . base_dtype == tf . bool : return int ( 1 ) # We actually can't land here but keep the case for completeness. raise TypeError ( \"Unrecognized dtype: {}\" . format ( dt . name ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _smallest_integer_by_dtype ( dt ) : if not _is_known_dtype ( dt ) : raise TypeError ( \"Unrecognized dtype: {}\" . format ( dt . name ) ) if _is_known_unsigned_by_dtype ( dt ) : return 0 return - 1 * _largest_integer_by_dtype ( dt )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _is_integer_like_by_dtype ( dt ) : if not _is_known_dtype ( dt ) : raise TypeError ( \"Unrecognized dtype: {}\" . format ( dt . name ) ) return dt . is_integer or dt . base_dtype == tf . bool\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def embed_check_categorical_event_shape ( categorical_param , name = \"embed_check_categorical_event_shape\" ) : with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = categorical_param , name = \"categorical_param\" ) # The size must not exceed both of: # - The largest possible int32 (since categorical values are presumed to be # indexes into a Tensor). # - The largest possible integer exactly representable under the given # floating-point dtype (since we need to cast to/from). # # The chosen floating-point thresholds are 2**(1 + mantissa_bits). # For more details, see: # https://en.wikipedia.org/wiki/Floating-point_arithmetic#Internal_representation x_dtype = dtype_util . base_dtype ( x . dtype ) max_event_size = ( _largest_integer_by_dtype ( x_dtype ) if dtype_util . is_floating ( x_dtype ) else 0 ) if max_event_size is 0 : raise TypeError ( \"Unable to validate size of unrecognized dtype \" \"({}).\" . format ( dtype_util . name ( x_dtype ) ) ) try : x_shape_static = tensorshape_util . with_rank_at_least ( x . shape , 1 ) except ValueError : raise ValueError ( \"A categorical-distribution parameter must have \" \"at least 1 dimension.\" ) event_size = tf . compat . dimension_value ( x_shape_static [ - 1 ] ) if event_size is not None : if event_size < 2 : raise ValueError ( \"A categorical-distribution parameter must have at \" \"least 2 events.\" ) if event_size > max_event_size : raise ValueError ( \"Number of classes exceeds `dtype` precision, i.e., \" \"{} implies shape ({}) cannot exceed {}.\" . format ( dtype_util . name ( x_dtype ) , event_size , max_event_size ) ) return x else : event_size = tf . shape ( input = x , out_type = tf . int64 , name = \"x_shape\" ) [ - 1 ] return with_dependencies ( [ assert_util . assert_rank_at_least ( x , 1 , message = ( \"A categorical-distribution parameter must have \" \"at least 1 dimension.\" ) ) , assert_util . assert_greater_equal ( tf . shape ( input = x ) [ - 1 ] , 2 , message = ( \"A categorical-distribution parameter must have at \" \"least 2 events.\" ) ) , assert_util . assert_less_equal ( event_size , tf . convert_to_tensor ( max_event_size , dtype = tf . int64 ) , message = \"Number of classes exceeds `dtype` precision, \" \"i.e., {} dtype cannot exceed {} shape.\" . format ( dtype_util . name ( x_dtype ) , max_event_size ) ) , ] , x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def embed_check_integer_casting_closed ( x , target_dtype , assert_nonnegative = True , assert_positive = False , name = \"embed_check_casting_closed\" ) : with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) if ( not _is_integer_like_by_dtype ( x . dtype ) and not dtype_util . is_floating ( x . dtype ) ) : raise TypeError ( \"{}.dtype must be floating- or \" \"integer-type.\" . format ( dtype_util . name ( x . dtype ) ) ) if ( not _is_integer_like_by_dtype ( target_dtype ) and not dtype_util . is_floating ( target_dtype ) ) : raise TypeError ( \"target_dtype ({}) must be floating- or \" \"integer-type.\" . format ( dtype_util . name ( target_dtype ) ) ) if ( not _is_integer_like_by_dtype ( x . dtype ) and not _is_integer_like_by_dtype ( target_dtype ) ) : raise TypeError ( \"At least one of {}.dtype ({}) and target_dtype ({}) \" \"must be integer-type.\" . format ( x , dtype_util . name ( x . dtype ) , dtype_util . name ( target_dtype ) ) ) assertions = [ ] if assert_positive : assertions += [ assert_util . assert_positive ( x , message = \"Elements must be positive.\" ) , ] elif assert_nonnegative : assertions += [ assert_util . assert_non_negative ( x , message = \"Elements must be non-negative.\" ) , ] if dtype_util . is_floating ( x . dtype ) : # Being here means _is_integer_like_by_dtype(target_dtype) = True. # Since this check implies the magnitude check below, we need only it. assertions += [ assert_integer_form ( x , int_dtype = target_dtype , message = \"Elements must be {}-equivalent.\" . format ( dtype_util . name ( target_dtype ) ) ) , ] else : if ( _largest_integer_by_dtype ( x . dtype ) > _largest_integer_by_dtype ( target_dtype ) ) : # Cast may lose integer precision. assertions += [ assert_util . assert_less_equal ( x , _largest_integer_by_dtype ( target_dtype ) , message = ( \"Elements cannot exceed {}.\" . format ( _largest_integer_by_dtype ( target_dtype ) ) ) ) , ] if ( not assert_nonnegative and ( _smallest_integer_by_dtype ( x . dtype ) < _smallest_integer_by_dtype ( target_dtype ) ) ) : assertions += [ assert_util . assert_greater_equal ( x , _smallest_integer_by_dtype ( target_dtype ) , message = ( \"Elements cannot be smaller than {}.\" . format ( _smallest_integer_by_dtype ( target_dtype ) ) ) ) , ] if not assertions : return x return with_dependencies ( assertions , x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def log_combinations ( n , counts , name = \"log_combinations\" ) : # First a bit about the number of ways counts could have come in: # E.g. if counts = [1, 2], then this is 3 choose 2. # In general, this is (sum counts)! / sum(counts!) # The sum should be along the last dimension of counts. This is the # \"distribution\" dimension. Here n a priori represents the sum of counts. with tf . name_scope ( name ) : n = tf . convert_to_tensor ( value = n , name = \"n\" ) counts = tf . convert_to_tensor ( value = counts , name = \"counts\" ) total_permutations = tf . math . lgamma ( n + 1 ) counts_factorial = tf . math . lgamma ( counts + 1 ) redundant_permutations = tf . reduce_sum ( input_tensor = counts_factorial , axis = [ - 1 ] ) return total_permutations - redundant_permutations\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def matrix_diag_transform ( matrix , transform = None , name = None ) : with tf . name_scope ( name or \"matrix_diag_transform\" ) : matrix = tf . convert_to_tensor ( value = matrix , name = \"matrix\" ) if transform is None : return matrix # Replace the diag with transformed diag. diag = tf . linalg . diag_part ( matrix ) transformed_diag = transform ( diag ) transformed_mat = tf . linalg . set_diag ( matrix , transformed_diag ) return transformed_mat\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def rotate_transpose ( x , shift , name = \"rotate_transpose\" ) : with tf . name_scope ( name ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) shift = tf . convert_to_tensor ( value = shift , name = \"shift\" ) # We do not assign back to preserve constant-ness. assert_util . assert_integer ( shift ) shift_value_static = tf . get_static_value ( shift ) ndims = tensorshape_util . rank ( x . shape ) if ndims is not None and shift_value_static is not None : if ndims < 2 : return x shift_value_static = np . sign ( shift_value_static ) * ( abs ( shift_value_static ) % ndims ) if shift_value_static == 0 : return x perm = np . roll ( np . arange ( ndims ) , shift_value_static ) return tf . transpose ( a = x , perm = perm ) else : # Consider if we always had a positive shift, and some specified # direction. # When shifting left we want the new array: # last(x, n-shift) + first(x, shift) # and if shifting right then we want: # last(x, shift) + first(x, n-shift) # Observe that last(a) == slice(a, n) and first(a) == slice(0, a). # Also, we can encode direction and shift as one: direction * shift. # Combining these facts, we have: # a = cond(shift<0, -shift, n-shift) # last(x, n-a) + first(x, a) == x[a:n] + x[0:a] # Finally, we transform shift by modulo length so it can be specified # independently from the array upon which it operates (like python). ndims = tf . rank ( x ) shift = tf . where ( tf . less ( shift , 0 ) , - shift % ndims , ndims - shift % ndims ) first = tf . range ( 0 , shift ) last = tf . range ( shift , ndims ) perm = tf . concat ( [ last , first ] , 0 ) return tf . transpose ( a = x , perm = perm )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pick_vector ( cond , true_vector , false_vector , name = \"pick_vector\" ) : with tf . name_scope ( name ) : cond = tf . convert_to_tensor ( value = cond , dtype_hint = tf . bool , name = \"cond\" ) if cond . dtype != tf . bool : raise TypeError ( \"{}.dtype={} which is not {}\" . format ( cond , cond . dtype , tf . bool ) ) true_vector = tf . convert_to_tensor ( value = true_vector , name = \"true_vector\" ) false_vector = tf . convert_to_tensor ( value = false_vector , name = \"false_vector\" ) if true_vector . dtype != false_vector . dtype : raise TypeError ( \"{}.dtype={} does not match {}.dtype={}\" . format ( true_vector , true_vector . dtype , false_vector , false_vector . dtype ) ) cond_value_static = tf . get_static_value ( cond ) if cond_value_static is not None : return true_vector if cond_value_static else false_vector n = tf . shape ( input = true_vector ) [ 0 ] return tf . slice ( tf . concat ( [ true_vector , false_vector ] , 0 ) , [ tf . where ( cond , 0 , n ) ] , [ tf . where ( cond , n , - 1 ) ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def prefer_static_broadcast_shape ( shape1 , shape2 , name = \"prefer_static_broadcast_shape\" ) : with tf . name_scope ( name ) : def make_shape_tensor ( x ) : return tf . convert_to_tensor ( value = x , name = \"shape\" , dtype = tf . int32 ) def get_tensor_shape ( s ) : if isinstance ( s , tf . TensorShape ) : return s s_ = tf . get_static_value ( make_shape_tensor ( s ) ) if s_ is not None : return tf . TensorShape ( s_ ) return None def get_shape_tensor ( s ) : if not isinstance ( s , tf . TensorShape ) : return make_shape_tensor ( s ) if tensorshape_util . is_fully_defined ( s ) : return make_shape_tensor ( tensorshape_util . as_list ( s ) ) raise ValueError ( \"Cannot broadcast from partially \" \"defined `TensorShape`.\" ) shape1_ = get_tensor_shape ( shape1 ) shape2_ = get_tensor_shape ( shape2 ) if shape1_ is not None and shape2_ is not None : return tf . broadcast_static_shape ( shape1_ , shape2_ ) shape1_ = get_shape_tensor ( shape1 ) shape2_ = get_shape_tensor ( shape2 ) return tf . broadcast_dynamic_shape ( shape1_ , shape2_ )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def gen_new_seed ( seed , salt ) : if seed is None : return None string = ( str ( seed ) + salt ) . encode ( \"utf-8\" ) return int ( hashlib . md5 ( string ) . hexdigest ( ) [ : 8 ] , 16 ) & 0x7FFFFFFF\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fill_triangular ( x , upper = False , name = None ) : with tf . name_scope ( name or \"fill_triangular\" ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) m = tf . compat . dimension_value ( tensorshape_util . with_rank_at_least ( x . shape , 1 ) [ - 1 ] ) if m is not None : # Formula derived by solving for n: m = n(n+1)/2. m = np . int32 ( m ) n = np . sqrt ( 0.25 + 2. * m ) - 0.5 if n != np . floor ( n ) : raise ValueError ( \"Input right-most shape ({}) does not \" \"correspond to a triangular matrix.\" . format ( m ) ) n = np . int32 ( n ) static_final_shape = x . shape [ : - 1 ] . concatenate ( [ n , n ] ) else : m = tf . shape ( input = x ) [ - 1 ] # For derivation, see above. Casting automatically lops off the 0.5, so we # omit it. We don't validate n is an integer because this has # graph-execution cost; an error will be thrown from the reshape, below. n = tf . cast ( tf . sqrt ( 0.25 + tf . cast ( 2 * m , dtype = tf . float32 ) ) , dtype = tf . int32 ) static_final_shape = tensorshape_util . with_rank_at_least ( x . shape , 1 ) [ : - 1 ] . concatenate ( [ None , None ] ) # Try it out in numpy: # n = 3 # x = np.arange(n * (n + 1) / 2) # m = x.shape[0] # n = np.int32(np.sqrt(.25 + 2 * m) - .5) # x_tail = x[(m - (n**2 - m)):] # np.concatenate([x_tail, x[::-1]], 0).reshape(n, n) # lower # # ==> array([[3, 4, 5], # [5, 4, 3], # [2, 1, 0]]) # np.concatenate([x, x_tail[::-1]], 0).reshape(n, n) # upper # # ==> array([[0, 1, 2], # [3, 4, 5], # [5, 4, 3]]) # # Note that we can't simply do `x[..., -(n**2 - m):]` because this doesn't # correctly handle `m == n == 1`. Hence, we do nonnegative indexing. # Furthermore observe that: # m - (n**2 - m) # = n**2 / 2 + n / 2 - (n**2 - n**2 / 2 + n / 2) # = 2 (n**2 / 2 + n / 2) - n**2 # = n**2 + n - n**2 # = n ndims = prefer_static_rank ( x ) if upper : x_list = [ x , tf . reverse ( x [ ... , n : ] , axis = [ ndims - 1 ] ) ] else : x_list = [ x [ ... , n : ] , tf . reverse ( x , axis = [ ndims - 1 ] ) ] new_shape = ( tensorshape_util . as_list ( static_final_shape ) if tensorshape_util . is_fully_defined ( static_final_shape ) else tf . concat ( [ tf . shape ( input = x ) [ : - 1 ] , [ n , n ] ] , axis = 0 ) ) x = tf . reshape ( tf . concat ( x_list , axis = - 1 ) , new_shape ) x = tf . linalg . band_part ( x , num_lower = ( 0 if upper else - 1 ) , num_upper = ( - 1 if upper else 0 ) ) tensorshape_util . set_shape ( x , static_final_shape ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def fill_triangular_inverse ( x , upper = False , name = None ) : with tf . name_scope ( name or \"fill_triangular_inverse\" ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) n = tf . compat . dimension_value ( tensorshape_util . with_rank_at_least ( x . shape , 2 ) [ - 1 ] ) if n is not None : n = np . int32 ( n ) m = np . int32 ( ( n * ( n + 1 ) ) // 2 ) static_final_shape = x . shape [ : - 2 ] . concatenate ( [ m ] ) else : n = tf . shape ( input = x ) [ - 1 ] m = ( n * ( n + 1 ) ) // 2 static_final_shape = tensorshape_util . with_rank_at_least ( x . shape , 2 ) [ : - 2 ] . concatenate ( [ None ] ) ndims = prefer_static_rank ( x ) if upper : initial_elements = x [ ... , 0 , : ] triangular_portion = x [ ... , 1 : , : ] else : initial_elements = tf . reverse ( x [ ... , - 1 , : ] , axis = [ ndims - 2 ] ) triangular_portion = x [ ... , : - 1 , : ] rotated_triangular_portion = tf . reverse ( tf . reverse ( triangular_portion , axis = [ ndims - 1 ] ) , axis = [ ndims - 2 ] ) consolidated_matrix = triangular_portion + rotated_triangular_portion end_sequence = tf . reshape ( consolidated_matrix , tf . concat ( [ tf . shape ( input = x ) [ : - 2 ] , [ n * ( n - 1 ) ] ] , axis = 0 ) ) y = tf . concat ( [ initial_elements , end_sequence [ ... , : m - n ] ] , axis = - 1 ) tensorshape_util . set_shape ( y , static_final_shape ) return y\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def tridiag ( below = None , diag = None , above = None , name = None ) : def _pad ( x ) : \"\"\"Prepends and appends a zero to every vector in a batch of vectors.\"\"\" shape = tf . concat ( [ tf . shape ( input = x ) [ : - 1 ] , [ 1 ] ] , axis = 0 ) z = tf . zeros ( shape , dtype = x . dtype ) return tf . concat ( [ z , x , z ] , axis = - 1 ) def _add ( * x ) : \"\"\"Adds list of Tensors, ignoring `None`.\"\"\" s = None for y in x : if y is None : continue elif s is None : s = y else : s += y if s is None : raise ValueError ( \"Must specify at least one of `below`, `diag`, `above`.\" ) return s with tf . name_scope ( name or \"tridiag\" ) : if below is not None : below = tf . convert_to_tensor ( value = below , name = \"below\" ) below = tf . linalg . diag ( _pad ( below ) ) [ ... , : - 1 , 1 : ] if diag is not None : diag = tf . convert_to_tensor ( value = diag , name = \"diag\" ) diag = tf . linalg . diag ( diag ) if above is not None : above = tf . convert_to_tensor ( value = above , name = \"above\" ) above = tf . linalg . diag ( _pad ( above ) ) [ ... , 1 : , : - 1 ] # TODO(jvdillon): Consider using scatter_nd instead of creating three full # matrices. return _add ( below , diag , above )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def reduce_weighted_logsumexp ( logx , w = None , axis = None , keep_dims = False , return_sign = False , name = None ) : with tf . name_scope ( name or \"reduce_weighted_logsumexp\" ) : logx = tf . convert_to_tensor ( value = logx , name = \"logx\" ) if w is None : lswe = tf . reduce_logsumexp ( input_tensor = logx , axis = axis , keepdims = keep_dims ) if return_sign : sgn = tf . ones_like ( lswe ) return lswe , sgn return lswe w = tf . convert_to_tensor ( value = w , dtype = logx . dtype , name = \"w\" ) log_absw_x = logx + tf . math . log ( tf . abs ( w ) ) max_log_absw_x = tf . reduce_max ( input_tensor = log_absw_x , axis = axis , keepdims = True ) # If the largest element is `-inf` or `inf` then we don't bother subtracting # off the max. We do this because otherwise we'd get `inf - inf = NaN`. That # this is ok follows from the fact that we're actually free to subtract any # value we like, so long as we add it back after taking the `log(sum(...))`. max_log_absw_x = tf . where ( tf . math . is_inf ( max_log_absw_x ) , tf . zeros_like ( max_log_absw_x ) , max_log_absw_x ) wx_over_max_absw_x = ( tf . sign ( w ) * tf . exp ( log_absw_x - max_log_absw_x ) ) sum_wx_over_max_absw_x = tf . reduce_sum ( input_tensor = wx_over_max_absw_x , axis = axis , keepdims = keep_dims ) if not keep_dims : max_log_absw_x = tf . squeeze ( max_log_absw_x , axis ) sgn = tf . sign ( sum_wx_over_max_absw_x ) lswe = max_log_absw_x + tf . math . log ( sgn * sum_wx_over_max_absw_x ) if return_sign : return lswe , sgn return lswe\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def softplus_inverse ( x , name = None ) : with tf . name_scope ( name or \"softplus_inverse\" ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) # We begin by deriving a more numerically stable softplus_inverse: # x = softplus(y) = Log[1 + exp{y}], (which means x > 0). # ==> exp{x} = 1 + exp{y} (1) # ==> y = Log[exp{x} - 1] (2) # = Log[(exp{x} - 1) / exp{x}] + Log[exp{x}] # = Log[(1 - exp{-x}) / 1] + Log[exp{x}] # = Log[1 - exp{-x}] + x (3) # (2) is the \"obvious\" inverse, but (3) is more stable than (2) for large x. # For small x (e.g. x = 1e-10), (3) will become -inf since 1 - exp{-x} will # be zero. To fix this, we use 1 - exp{-x} approx x for small x > 0. # # In addition to the numerically stable derivation above, we clamp # small/large values to be congruent with the logic in: # tensorflow/core/kernels/softplus_op.h # # Finally, we set the input to one whenever the input is too large or too # small. This ensures that no unchosen codepath is +/- inf. This is # necessary to ensure the gradient doesn't get NaNs. Recall that the # gradient of `where` behaves like `pred*pred_true + (1-pred)*pred_false` # thus an `inf` in an unselected path results in `0*inf=nan`. We are careful # to overwrite `x` with ones only when we will never actually use this # value. Note that we use ones and not zeros since `log(expm1(0.)) = -inf`. threshold = np . log ( np . finfo ( dtype_util . as_numpy_dtype ( x . dtype ) ) . eps ) + 2. is_too_small = tf . less ( x , np . exp ( threshold ) ) is_too_large = tf . greater ( x , - threshold ) too_small_value = tf . math . log ( x ) too_large_value = x # This `where` will ultimately be a NOP because we won't select this # codepath whenever we used the surrogate `ones_like`. x = tf . where ( tf . logical_or ( is_too_small , is_too_large ) , tf . ones_like ( x ) , x ) y = x + tf . math . log ( - tf . math . expm1 ( - x ) ) # == log(expm1(x)) return tf . where ( is_too_small , too_small_value , tf . where ( is_too_large , too_large_value , y ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dimension_size ( x , axis ) : # Since tf.gather isn't \"constant-in, constant-out\", we must first check the # static shape or fallback to dynamic shape. s = tf . compat . dimension_value ( tensorshape_util . with_rank_at_least ( x . shape , np . abs ( axis ) ) [ axis ] ) if s is not None : return s return tf . shape ( input = x ) [ axis ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def process_quadrature_grid_and_probs ( quadrature_grid_and_probs , dtype , validate_args , name = None ) : with tf . name_scope ( name or \"process_quadrature_grid_and_probs\" ) : if quadrature_grid_and_probs is None : grid , probs = np . polynomial . hermite . hermgauss ( deg = 8 ) grid = grid . astype ( dtype_util . as_numpy_dtype ( dtype ) ) probs = probs . astype ( dtype_util . as_numpy_dtype ( dtype ) ) probs /= np . linalg . norm ( probs , ord = 1 , keepdims = True ) grid = tf . convert_to_tensor ( value = grid , name = \"grid\" , dtype = dtype ) probs = tf . convert_to_tensor ( value = probs , name = \"probs\" , dtype = dtype ) return grid , probs grid , probs = tuple ( quadrature_grid_and_probs ) grid = tf . convert_to_tensor ( value = grid , name = \"grid\" , dtype = dtype ) probs = tf . convert_to_tensor ( value = probs , name = \"unnormalized_probs\" , dtype = dtype ) probs /= tf . norm ( tensor = probs , ord = 1 , axis = - 1 , keepdims = True , name = \"probs\" ) def _static_event_size ( x ) : \"\"\"Returns the static size of a specific dimension or `None`.\"\"\" return tf . compat . dimension_value ( tensorshape_util . with_rank_at_least ( x . shape , 1 ) [ - 1 ] ) m , n = _static_event_size ( probs ) , _static_event_size ( grid ) if m is not None and n is not None : if m != n : raise ValueError ( \"`quadrature_grid_and_probs` must be a `tuple` of \" \"same-length zero-th-dimension `Tensor`s \" \"(saw lengths {}, {})\" . format ( m , n ) ) elif validate_args : assertions = [ assert_util . assert_equal ( dimension_size ( probs , axis = - 1 ) , dimension_size ( grid , axis = - 1 ) , message = ( \"`quadrature_grid_and_probs` must be a `tuple` of \" \"same-length zero-th-dimension `Tensor`s\" ) ) , ] with tf . control_dependencies ( assertions ) : grid = tf . identity ( grid ) probs = tf . identity ( probs ) return grid , probs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pad ( x , axis , front = False , back = False , value = 0 , count = 1 , name = None ) : with tf . name_scope ( name or \"pad\" ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) value = tf . convert_to_tensor ( value = value , dtype = x . dtype , name = \"value\" ) count = tf . convert_to_tensor ( value = count , name = \"count\" ) if not dtype_util . is_integer ( count . dtype ) : raise TypeError ( \"`count.dtype` (`{}`) must be `int`-like.\" . format ( dtype_util . name ( count . dtype ) ) ) if not front and not back : raise ValueError ( \"At least one of `front`, `back` must be `True`.\" ) ndims = ( tensorshape_util . rank ( x . shape ) if tensorshape_util . rank ( x . shape ) is not None else tf . rank ( x , name = \"ndims\" ) ) axis = tf . convert_to_tensor ( value = axis , name = \"axis\" ) axis_ = tf . get_static_value ( axis ) if axis_ is not None : axis = axis_ if axis < 0 : axis = ndims + axis count_ = tf . get_static_value ( count ) if axis_ >= 0 or tensorshape_util . rank ( x . shape ) is not None : head = x . shape [ : axis ] mid_dim_value = tf . compat . dimension_value ( x . shape [ axis ] ) if count_ is None or mid_dim_value is None : middle = tf . TensorShape ( None ) else : middle = tf . TensorShape ( mid_dim_value + count_ * ( front + back ) ) tail = x . shape [ axis + 1 : ] final_shape = head . concatenate ( middle . concatenate ( tail ) ) else : final_shape = None else : axis = tf . where ( axis < 0 , ndims + axis , axis ) final_shape = None x = tf . pad ( tensor = x , paddings = tf . one_hot ( indices = tf . stack ( [ axis if front else - 1 , axis if back else - 1 ] ) , depth = ndims , axis = 0 , on_value = count , dtype = tf . int32 ) , constant_values = value ) if final_shape is not None : tensorshape_util . set_shape ( x , final_shape ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def parent_frame_arguments ( ) : # All arguments and the names used for *varargs, and **kwargs arg_names , variable_arg_name , keyword_arg_name , local_vars = ( tf_inspect . _inspect . getargvalues ( # pylint: disable=protected-access # Get the first frame of the caller of this method. tf_inspect . _inspect . stack ( ) [ 1 ] [ 0 ] ) ) # pylint: disable=protected-access # Remove the *varargs, and flatten the **kwargs. Both are # nested lists. local_vars . pop ( variable_arg_name , { } ) keyword_args = local_vars . pop ( keyword_arg_name , { } ) final_args = { } # Copy over arguments and their values. In general, local_vars # may contain more than just the arguments, since this method # can be called anywhere in a function. for arg_name in arg_names : final_args [ arg_name ] = local_vars . pop ( arg_name ) final_args . update ( keyword_args ) return final_args\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def expand_to_vector ( x , tensor_name = None , op_name = None , validate_args = False ) : with tf . name_scope ( op_name or \"expand_to_vector\" ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) ndims = tensorshape_util . rank ( x . shape ) if ndims is None : # Maybe expand ndims from 0 to 1. if validate_args : x = with_dependencies ( [ assert_util . assert_rank_at_most ( x , 1 , message = \"Input is neither scalar nor vector.\" ) ] , x ) ndims = tf . rank ( x ) expanded_shape = pick_vector ( tf . equal ( ndims , 0 ) , np . array ( [ 1 ] , dtype = np . int32 ) , tf . shape ( input = x ) ) return tf . reshape ( x , expanded_shape ) elif ndims == 0 : # Definitely expand ndims from 0 to 1. x_const = tf . get_static_value ( x ) if x_const is not None : return tf . convert_to_tensor ( value = dtype_util . as_numpy_dtype ( x . dtype ) ( [ x_const ] ) , name = tensor_name ) else : return tf . reshape ( x , [ 1 ] ) elif ndims != 1 : raise ValueError ( \"Input is neither scalar nor vector.\" ) # ndims == 1 return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def with_dependencies ( dependencies , output_tensor , name = None ) : if tf . executing_eagerly ( ) : return output_tensor with tf . name_scope ( name or \"control_dependency\" ) as name : with tf . control_dependencies ( d for d in dependencies if d is not None ) : output_tensor = tf . convert_to_tensor ( value = output_tensor ) if isinstance ( output_tensor , tf . Tensor ) : return tf . identity ( output_tensor , name = name ) else : return tf . IndexedSlices ( tf . identity ( output_tensor . values , name = name ) , output_tensor . indices , output_tensor . dense_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_validate_rightmost_transposed_ndims ( rightmost_transposed_ndims , validate_args , name = None ) : with tf . name_scope ( name or 'maybe_validate_rightmost_transposed_ndims' ) : assertions = [ ] if not dtype_util . is_integer ( rightmost_transposed_ndims . dtype ) : raise TypeError ( '`rightmost_transposed_ndims` must be integer type.' ) if tensorshape_util . rank ( rightmost_transposed_ndims . shape ) is not None : if tensorshape_util . rank ( rightmost_transposed_ndims . shape ) != 0 : raise ValueError ( '`rightmost_transposed_ndims` must be a scalar, ' 'saw rank: {}.' . format ( tensorshape_util . rank ( rightmost_transposed_ndims . shape ) ) ) elif validate_args : assertions += [ assert_util . assert_rank ( rightmost_transposed_ndims , 0 ) ] rightmost_transposed_ndims_ = tf . get_static_value ( rightmost_transposed_ndims ) msg = '`rightmost_transposed_ndims` must be non-negative.' if rightmost_transposed_ndims_ is not None : if rightmost_transposed_ndims_ < 0 : raise ValueError ( msg [ : - 1 ] + ', saw: {}.' . format ( rightmost_transposed_ndims_ ) ) elif validate_args : assertions += [ assert_util . assert_non_negative ( rightmost_transposed_ndims , message = msg ) ] return assertions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_validate_perm ( perm , validate_args , name = None ) : with tf . name_scope ( name or 'maybe_validate_perm' ) : assertions = [ ] if not dtype_util . is_integer ( perm . dtype ) : raise TypeError ( '`perm` must be integer type' ) msg = '`perm` must be a vector.' if tensorshape_util . rank ( perm . shape ) is not None : if tensorshape_util . rank ( perm . shape ) != 1 : raise ValueError ( msg [ : - 1 ] + ', saw rank: {}.' . format ( tensorshape_util . rank ( perm . shape ) ) ) elif validate_args : assertions += [ assert_util . assert_rank ( perm , 1 , message = msg ) ] perm_ = tf . get_static_value ( perm ) msg = '`perm` must be a valid permutation vector.' if perm_ is not None : if not np . all ( np . arange ( np . size ( perm_ ) ) == np . sort ( perm_ ) ) : raise ValueError ( msg [ : - 1 ] + ', saw: {}.' . format ( perm_ ) ) elif validate_args : assertions += [ assert_util . assert_equal ( tf . sort ( perm ) , tf . range ( tf . size ( input = perm ) ) , message = msg ) ] return assertions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _event_shape ( self , shape , static_perm_to_shape ) : rightmost_ = tf . get_static_value ( self . rightmost_transposed_ndims ) if tensorshape_util . rank ( shape ) is None or rightmost_ is None : return tf . TensorShape ( None ) if tensorshape_util . rank ( shape ) < rightmost_ : raise ValueError ( 'Invalid shape: min event ndims={} but got {}' . format ( rightmost_ , shape ) ) perm_ = tf . get_static_value ( self . perm , partial = True ) if perm_ is None : return shape [ : tensorshape_util . rank ( shape ) - rightmost_ ] . concatenate ( [ None ] * int ( rightmost_ ) ) # We can use elimination to reidentify a single None dimension. if sum ( p is None for p in perm_ ) == 1 : present = np . argsort ( [ - 1 if p is None else p for p in perm_ ] ) for i , p in enumerate ( present [ 1 : ] ) : # The -1 sorts to position 0. if i != p : perm_ = [ i if p is None else p for p in perm_ ] break return shape [ : tensorshape_util . rank ( shape ) - rightmost_ ] . concatenate ( static_perm_to_shape ( shape [ tensorshape_util . rank ( shape ) - rightmost_ : ] , perm_ ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def concatenate ( x , other ) : return type ( x ) ( tf . TensorShape ( x ) . concatenate ( other ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def constant_value_as_shape ( tensor ) : # pylint: disable=invalid-name shape = tf . get_static_value ( tensor ) if shape is not None : return [ None if dim == - 1 else dim for dim in shape ] return tensor_util . constant_value_as_shape ( tensor )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dims ( x ) : if isinstance ( x , tf . TensorShape ) : return x . dims r = tf . TensorShape ( x ) . dims return None if r is None else list ( map ( tf . compat . dimension_value , r ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def merge_with ( x , other ) : return type ( x ) ( tf . TensorShape ( x ) . merge_with ( other ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def with_rank_at_least ( x , rank ) : # pylint: disable=redefined-outer-name return type ( x ) ( tf . TensorShape ( x ) . with_rank_at_least ( rank ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _check_equal_shape ( name , static_shape , dynamic_shape , static_target_shape , dynamic_target_shape = None ) : static_target_shape = tf . TensorShape ( static_target_shape ) if tensorshape_util . is_fully_defined ( static_shape ) and tensorshape_util . is_fully_defined ( static_target_shape ) : if static_shape != static_target_shape : raise ValueError ( \"{}: required shape {} but found {}\" . format ( name , static_target_shape , static_shape ) ) return None else : if dynamic_target_shape is None : if tensorshape_util . is_fully_defined ( static_target_shape ) : dynamic_target_shape = tensorshape_util . as_list ( static_target_shape ) else : raise ValueError ( \"{}: cannot infer target shape: no dynamic shape \" \"specified and static shape {} is not fully defined\" . format ( name , static_target_shape ) ) return assert_util . assert_equal ( dynamic_shape , dynamic_target_shape , message = ( \"{}: required shape {}\" . format ( name , static_target_shape ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _augment_sample_shape ( partial_batch_dist , full_sample_and_batch_shape , validate_args = False ) : full_ndims = distribution_util . prefer_static_shape ( full_sample_and_batch_shape ) [ 0 ] partial_batch_ndims = ( tensorshape_util . rank ( partial_batch_dist . batch_shape ) # pylint: disable=g-long-ternary if tensorshape_util . rank ( partial_batch_dist . batch_shape ) is not None else distribution_util . prefer_static_shape ( partial_batch_dist . batch_shape_tensor ( ) ) [ 0 ] ) num_broadcast_dims = full_ndims - partial_batch_ndims expected_partial_batch_shape = ( full_sample_and_batch_shape [ num_broadcast_dims : ] ) expected_partial_batch_shape_static = tf . get_static_value ( full_sample_and_batch_shape [ num_broadcast_dims : ] ) # Raise errors statically if possible. num_broadcast_dims_static = tf . get_static_value ( num_broadcast_dims ) if num_broadcast_dims_static is not None : if num_broadcast_dims_static < 0 : raise ValueError ( \"Cannot broadcast distribution {} batch shape to \" \"target batch shape with fewer dimensions\" . format ( partial_batch_dist ) ) if ( expected_partial_batch_shape_static is not None and tensorshape_util . is_fully_defined ( partial_batch_dist . batch_shape ) ) : if ( partial_batch_dist . batch_shape and any ( expected_partial_batch_shape_static != tensorshape_util . as_list ( partial_batch_dist . batch_shape ) ) ) : raise NotImplementedError ( \"Broadcasting is not supported; \" \"unexpected batch shape \" \"(expected {}, saw {}).\" . format ( expected_partial_batch_shape_static , partial_batch_dist . batch_shape ) ) runtime_assertions = [ ] if validate_args : runtime_assertions . append ( assert_util . assert_greater_equal ( tf . convert_to_tensor ( value = num_broadcast_dims , dtype = tf . int32 ) , tf . zeros ( ( ) , dtype = tf . int32 ) , message = ( \"Cannot broadcast distribution {} batch shape to \" \"target batch shape with fewer dimensions.\" . format ( partial_batch_dist ) ) ) ) runtime_assertions . append ( assert_util . assert_equal ( expected_partial_batch_shape , partial_batch_dist . batch_shape_tensor ( ) , message = ( \"Broadcasting is not supported; \" \"unexpected batch shape.\" ) , name = \"assert_batch_shape_same\" ) ) with tf . control_dependencies ( runtime_assertions ) : return full_sample_and_batch_shape [ : num_broadcast_dims ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_backward_pass_step ( get_transition_matrix_for_timestep ) : def backward_pass_step ( state , filtered_parameters ) : \"\"\"Run a single step of backward smoothing.\"\"\" ( filtered_mean , filtered_cov , predicted_mean , predicted_cov ) = filtered_parameters transition_matrix = get_transition_matrix_for_timestep ( state . timestep ) next_posterior_mean = state . backward_mean next_posterior_cov = state . backward_cov posterior_mean , posterior_cov = backward_smoothing_update ( filtered_mean , filtered_cov , predicted_mean , predicted_cov , next_posterior_mean , next_posterior_cov , transition_matrix ) return BackwardPassState ( backward_mean = posterior_mean , backward_cov = posterior_cov , timestep = state . timestep - 1 ) return backward_pass_step\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def backward_smoothing_update ( filtered_mean , filtered_cov , predicted_mean , predicted_cov , next_posterior_mean , next_posterior_cov , transition_matrix ) : # Compute backward Kalman gain: # J = F * T' * P^{-1} # Since both F(iltered) and P(redictive) are cov matrices, # thus self-adjoint, we can take the transpose. # computation: # = (P^{-1} * T * F)' # = (P^{-1} * tmp_gain_cov) ' # = (P \\ tmp_gain_cov)' tmp_gain_cov = transition_matrix . matmul ( filtered_cov ) predicted_cov_chol = tf . linalg . cholesky ( predicted_cov ) gain_transpose = tf . linalg . cholesky_solve ( predicted_cov_chol , tmp_gain_cov ) posterior_mean = ( filtered_mean + tf . linalg . matmul ( gain_transpose , next_posterior_mean - predicted_mean , adjoint_a = True ) ) posterior_cov = ( filtered_cov + tf . linalg . matmul ( gain_transpose , tf . linalg . matmul ( next_posterior_cov - predicted_cov , gain_transpose ) , adjoint_a = True ) ) return ( posterior_mean , posterior_cov )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_kalman_filter_step ( get_transition_matrix_for_timestep , get_transition_noise_for_timestep , get_observation_matrix_for_timestep , get_observation_noise_for_timestep ) : def kalman_filter_step ( state , elems_t ) : \"\"\"Run a single step of Kalman filtering. Args: state: A `KalmanFilterState` object representing the previous filter state at time `t-1`. elems_t: A tuple of Tensors `(x_t, mask_t)`, or a `Tensor` `x_t`. `x_t` is a `Tensor` with rightmost shape dimensions `[observation_size, 1]` representing the vector observed at time `t`, and `mask_t` is a `Tensor` with rightmost dimensions`[1, 1]` representing the observation mask at time `t`. Both `x_t` and `mask_t` may have batch dimensions, which must be compatible with the batch dimensions of `state.predicted_mean` and `state.predictived_cov` respectively. If `mask_t` is not provided, it is assumed to be `None`. Returns: new_state: A `KalmanFilterState` object representing the new filter state at time `t`. \"\"\" if isinstance ( elems_t , tuple ) : x_t , mask_t = elems_t else : x_t = elems_t mask_t = None observation_matrix = get_observation_matrix_for_timestep ( state . timestep ) observation_noise = get_observation_noise_for_timestep ( state . timestep ) if mask_t is not None : # Before running the update, fill in masked observations using the prior # expectation. The precise filled value shouldn't matter since updates # from masked elements will not be selected below, but we need to ensure # that any results we incidently compute on masked values are at least # finite (not inf or NaN) so that they don't screw up gradient propagation # through `tf.where`, as described in # https://github.com/tensorflow/tensorflow/issues/2540. # We fill with the prior expectation because any fixed value such as zero # might be arbitrarily unlikely under the prior, leading to overflow in # the updates, but the prior expectation should always be a # 'reasonable' observation. x_expected = _propagate_mean ( state . predicted_mean , observation_matrix , observation_noise ) * tf . ones_like ( x_t ) x_t = tf . where ( tf . broadcast_to ( mask_t , tf . shape ( input = x_expected ) ) , x_expected , tf . broadcast_to ( x_t , tf . shape ( input = x_expected ) ) ) # Given predicted mean u_{t|t-1} and covariance P_{t|t-1} from the # previous step, incorporate the observation x_t, producing the # filtered mean u_t and covariance P_t. ( filtered_mean , filtered_cov , observation_dist ) = linear_gaussian_update ( state . predicted_mean , state . predicted_cov , observation_matrix , observation_noise , x_t ) # Compute the marginal likelihood p(x_{t} | x_{:t-1}) for this # observation. log_marginal_likelihood = observation_dist . log_prob ( x_t [ ... , 0 ] ) if mask_t is not None : filtered_mean = tf . where ( tf . broadcast_to ( mask_t , tf . shape ( input = filtered_mean ) ) , state . predicted_mean , filtered_mean ) filtered_cov = tf . where ( tf . broadcast_to ( mask_t , tf . shape ( input = filtered_cov ) ) , state . predicted_cov , filtered_cov ) log_marginal_likelihood = tf . where ( tf . broadcast_to ( mask_t [ ... , 0 , 0 ] , tf . shape ( input = log_marginal_likelihood ) ) , tf . zeros_like ( log_marginal_likelihood ) , log_marginal_likelihood ) # Run the filtered posterior through the transition # model to predict the next time step: # u_{t|t-1} = F_t u_{t-1} + b_t # P_{t|t-1} = F_t P_{t-1} F_t' + Q_t predicted_mean , predicted_cov = kalman_transition ( filtered_mean , filtered_cov , get_transition_matrix_for_timestep ( state . timestep ) , get_transition_noise_for_timestep ( state . timestep ) ) return KalmanFilterState ( filtered_mean , filtered_cov , predicted_mean , predicted_cov , observation_dist . mean ( ) [ ... , tf . newaxis ] , observation_dist . covariance ( ) , log_marginal_likelihood , state . timestep + 1 ) return kalman_filter_step\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def linear_gaussian_update ( prior_mean , prior_cov , observation_matrix , observation_noise , x_observed ) : # If observations are scalar, we can avoid some matrix ops. observation_size_is_static_and_scalar = ( tf . compat . dimension_value ( observation_matrix . shape [ - 2 ] ) == 1 ) # Push the predicted mean for the latent state through the # observation model x_expected = _propagate_mean ( prior_mean , observation_matrix , observation_noise ) # Push the predictive covariance of the latent state through the # observation model: # S = R + H * P * H'. # We use a temporary variable for H * P, # reused below to compute Kalman gain. tmp_obs_cov = observation_matrix . matmul ( prior_cov ) predicted_obs_cov = ( observation_matrix . matmul ( tmp_obs_cov , adjoint_arg = True ) + observation_noise . covariance ( ) ) # Compute optimal Kalman gain: # K = P * H' * S^{-1} # Since both S and P are cov matrices, thus symmetric, # we can take the transpose and reuse our previous # computation: # = (S^{-1} * H * P)' # = (S^{-1} * tmp_obs_cov) ' # = (S \\ tmp_obs_cov)' if observation_size_is_static_and_scalar : gain_transpose = tmp_obs_cov / predicted_obs_cov else : predicted_obs_cov_chol = tf . linalg . cholesky ( predicted_obs_cov ) gain_transpose = tf . linalg . cholesky_solve ( predicted_obs_cov_chol , tmp_obs_cov ) # Compute the posterior mean, incorporating the observation. # u* = u + K (x_observed - x_expected) posterior_mean = ( prior_mean + tf . linalg . matmul ( gain_transpose , x_observed - x_expected , adjoint_a = True ) ) # For the posterior covariance, we could use the simple update # P* = P - K * H * P # but this is prone to numerical issues because it subtracts a # value from a PSD matrix. We choose instead to use the more # expensive Jordan form update # P* = (I - K H) * P * (I - K H)' + K R K' # which always produces a PSD result. This uses # tmp_term = (I - K * H)' # as an intermediate quantity. tmp_term = - observation_matrix . matmul ( gain_transpose , adjoint = True ) # -K * H tmp_term = tf . linalg . set_diag ( tmp_term , tf . linalg . diag_part ( tmp_term ) + 1 ) posterior_cov = ( tf . linalg . matmul ( tmp_term , tf . linalg . matmul ( prior_cov , tmp_term ) , adjoint_a = True ) + tf . linalg . matmul ( gain_transpose , tf . linalg . matmul ( observation_noise . covariance ( ) , gain_transpose ) , adjoint_a = True ) ) if observation_size_is_static_and_scalar : # A plain Normal would have event shape `[]`; wrapping with Independent # ensures `event_shape=[1]` as required. predictive_dist = independent . Independent ( normal . Normal ( loc = x_expected [ ... , 0 ] , scale = tf . sqrt ( predicted_obs_cov [ ... , 0 ] ) ) , reinterpreted_batch_ndims = 1 ) # Minor hack to define the covariance, so that `predictive_dist` can pass as # an MVNTriL-like object. predictive_dist . covariance = lambda : predicted_obs_cov else : predictive_dist = mvn_tril . MultivariateNormalTriL ( loc = x_expected [ ... , 0 ] , scale_tril = predicted_obs_cov_chol ) return posterior_mean , posterior_cov , predictive_dist\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def kalman_transition ( filtered_mean , filtered_cov , transition_matrix , transition_noise ) : predicted_mean = _propagate_mean ( filtered_mean , transition_matrix , transition_noise ) predicted_cov = _propagate_cov ( filtered_cov , transition_matrix , transition_noise ) return predicted_mean , predicted_cov\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_kalman_mean_step ( get_transition_matrix_for_timestep , get_transition_noise_for_timestep , get_observation_matrix_for_timestep , get_observation_noise_for_timestep ) : def mean_step ( previous_means , t ) : \"\"\"Single step of prior mean recursion.\"\"\" previous_latent_mean , _ = previous_means latent_mean = _propagate_mean ( previous_latent_mean , get_transition_matrix_for_timestep ( t - 1 ) , get_transition_noise_for_timestep ( t - 1 ) ) observation_mean = _propagate_mean ( latent_mean , get_observation_matrix_for_timestep ( t ) , get_observation_noise_for_timestep ( t ) ) return ( latent_mean , observation_mean ) return mean_step\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_kalman_cov_step ( get_transition_matrix_for_timestep , get_transition_noise_for_timestep , get_observation_matrix_for_timestep , get_observation_noise_for_timestep ) : def cov_step ( previous_covs , t ) : \"\"\"Single step of prior covariance recursion.\"\"\" previous_latent_cov , _ = previous_covs latent_cov = _propagate_cov ( previous_latent_cov , get_transition_matrix_for_timestep ( t - 1 ) , get_transition_noise_for_timestep ( t - 1 ) ) observation_cov = _propagate_cov ( latent_cov , get_observation_matrix_for_timestep ( t ) , get_observation_noise_for_timestep ( t ) ) return ( latent_cov , observation_cov ) return cov_step\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_kalman_sample_step ( get_transition_matrix_for_timestep , get_transition_noise_for_timestep , get_observation_matrix_for_timestep , get_observation_noise_for_timestep , full_sample_and_batch_shape , stream , validate_args = False ) : def sample_step ( sampled_prev , t ) : \"\"\"Sample values for a single timestep.\"\"\" latent_prev , _ = sampled_prev transition_matrix = get_transition_matrix_for_timestep ( t - 1 ) transition_noise = get_transition_noise_for_timestep ( t - 1 ) latent_pred = transition_matrix . matmul ( latent_prev ) latent_sampled = latent_pred + transition_noise . sample ( sample_shape = _augment_sample_shape ( transition_noise , full_sample_and_batch_shape , validate_args ) , seed = stream ( ) ) [ ... , tf . newaxis ] observation_matrix = get_observation_matrix_for_timestep ( t ) observation_noise = get_observation_noise_for_timestep ( t ) observation_pred = observation_matrix . matmul ( latent_sampled ) observation_sampled = observation_pred + observation_noise . sample ( sample_shape = _augment_sample_shape ( observation_noise , full_sample_and_batch_shape , validate_args ) , seed = stream ( ) ) [ ... , tf . newaxis ] return ( latent_sampled , observation_sampled ) return sample_step\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_pushforward_latents_step ( get_observation_matrix_for_timestep , get_observation_noise_for_timestep ) : def pushforward_latents_step ( _ , latent_t_mean_cov ) : \"\"\"Loop body fn to pushforward latents to observations at a time step.\"\"\" t , latent_mean , latent_cov = latent_t_mean_cov observation_matrix = get_observation_matrix_for_timestep ( t ) observation_noise = get_observation_noise_for_timestep ( t ) observation_mean = _propagate_mean ( latent_mean , observation_matrix , observation_noise ) observation_cov = _propagate_cov ( latent_cov , observation_matrix , observation_noise ) return ( observation_mean , observation_cov ) return pushforward_latents_step\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _propagate_mean ( mean , linop , dist ) : return linop . matmul ( mean ) + dist . mean ( ) [ ... , tf . newaxis ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _propagate_cov ( cov , linop , dist ) : # For linop A and input cov P, returns `A P A' + dist.cov()` return linop . matmul ( linop . matmul ( cov ) , adjoint_arg = True ) + dist . covariance ( )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def backward_smoothing_pass ( self , filtered_means , filtered_covs , predicted_means , predicted_covs ) : with tf . name_scope ( \"backward_pass\" ) : filtered_means = tf . convert_to_tensor ( value = filtered_means , name = \"filtered_means\" ) filtered_covs = tf . convert_to_tensor ( value = filtered_covs , name = \"filtered_covs\" ) predicted_means = tf . convert_to_tensor ( value = predicted_means , name = \"predicted_means\" ) predicted_covs = tf . convert_to_tensor ( value = predicted_covs , name = \"predicted_covs\" ) # To scan over time dimension, we need to move 'num_timesteps' from the # event shape to the initial dimension of the tensor. filtered_means = distribution_util . move_dimension ( filtered_means , - 2 , 0 ) filtered_covs = distribution_util . move_dimension ( filtered_covs , - 3 , 0 ) predicted_means = distribution_util . move_dimension ( predicted_means , - 2 , 0 ) predicted_covs = distribution_util . move_dimension ( predicted_covs , - 3 , 0 ) # The means are assumed to be vectors. Adding a dummy index to # ensure the `matmul` op working smoothly. filtered_means = filtered_means [ ... , tf . newaxis ] predicted_means = predicted_means [ ... , tf . newaxis ] initial_backward_mean = predicted_means [ - 1 , ... ] initial_backward_cov = predicted_covs [ - 1 , ... ] num_timesteps = tf . shape ( input = filtered_means ) [ 0 ] initial_state = BackwardPassState ( backward_mean = initial_backward_mean , backward_cov = initial_backward_cov , timestep = self . initial_step + num_timesteps - 1 ) update_step_fn = build_backward_pass_step ( self . get_transition_matrix_for_timestep ) # For backward pass, it scans the `elems` from last to first. posterior_states = tf . scan ( update_step_fn , elems = ( filtered_means , filtered_covs , predicted_means , predicted_covs ) , initializer = initial_state , reverse = True ) # Move the time dimension back into the event shape. posterior_means = distribution_util . move_dimension ( posterior_states . backward_mean [ ... , 0 ] , 0 , - 2 ) posterior_covs = distribution_util . move_dimension ( posterior_states . backward_cov , 0 , - 3 ) return ( posterior_means , posterior_covs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _joint_sample_n ( self , n , seed = None ) : with tf . name_scope ( \"sample_n_joint\" ) : stream = seed_stream . SeedStream ( seed , salt = \"LinearGaussianStateSpaceModel_sample_n_joint\" ) sample_and_batch_shape = distribution_util . prefer_static_value ( tf . concat ( [ [ n ] , self . batch_shape_tensor ( ) ] , axis = 0 ) ) # Sample the initial timestep from the prior. Since we want # this sample to have full batch shape (not just the batch shape # of the self.initial_state_prior object which might in general be # smaller), we augment the sample shape to include whatever # extra batch dimensions are required. with tf . control_dependencies ( self . runtime_assertions ) : initial_latent = self . initial_state_prior . sample ( sample_shape = _augment_sample_shape ( self . initial_state_prior , sample_and_batch_shape , self . validate_args ) , seed = stream ( ) ) # Add a dummy dimension so that matmul() does matrix-vector # multiplication. initial_latent = initial_latent [ ... , tf . newaxis ] initial_observation_matrix = ( self . get_observation_matrix_for_timestep ( self . initial_step ) ) initial_observation_noise = ( self . get_observation_noise_for_timestep ( self . initial_step ) ) initial_observation_pred = initial_observation_matrix . matmul ( initial_latent ) initial_observation = ( initial_observation_pred + initial_observation_noise . sample ( sample_shape = _augment_sample_shape ( initial_observation_noise , sample_and_batch_shape , self . validate_args ) , seed = stream ( ) ) [ ... , tf . newaxis ] ) sample_step = build_kalman_sample_step ( self . get_transition_matrix_for_timestep , self . get_transition_noise_for_timestep , self . get_observation_matrix_for_timestep , self . get_observation_noise_for_timestep , full_sample_and_batch_shape = sample_and_batch_shape , stream = stream , validate_args = self . validate_args ) # Scan over all timesteps to sample latents and observations. ( latents , observations ) = tf . scan ( sample_step , elems = tf . range ( self . initial_step + 1 , self . final_step ) , initializer = ( initial_latent , initial_observation ) ) # Combine the initial sampled timestep with the remaining timesteps. latents = tf . concat ( [ initial_latent [ tf . newaxis , ... ] , latents ] , axis = 0 ) observations = tf . concat ( [ initial_observation [ tf . newaxis , ... ] , observations ] , axis = 0 ) # Put dimensions back in order. The samples we've computed are # ordered by timestep, with shape `[num_timesteps, num_samples, # batch_shape, size, 1]` where `size` represents `latent_size` # or `observation_size` respectively. But timesteps are really # part of each probabilistic event, so we need to return a Tensor # of shape `[num_samples, batch_shape, num_timesteps, size]`. latents = tf . squeeze ( latents , - 1 ) latents = distribution_util . move_dimension ( latents , 0 , - 2 ) observations = tf . squeeze ( observations , - 1 ) observations = distribution_util . move_dimension ( observations , 0 , - 2 ) return latents , observations\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def forward_filter ( self , x , mask = None ) : with tf . name_scope ( \"forward_filter\" ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) if mask is not None : mask = tf . convert_to_tensor ( value = mask , name = \"mask\" , dtype_hint = tf . bool ) # Check event shape statically if possible check_x_shape_op = _check_equal_shape ( \"x\" , x . shape [ - 2 : ] , tf . shape ( input = x ) [ - 2 : ] , self . event_shape , self . event_shape_tensor ( ) ) check_mask_dims_op = None check_mask_shape_op = None if mask is not None : if ( tensorshape_util . rank ( mask . shape ) is None or tensorshape_util . rank ( x . shape ) is None ) : check_mask_dims_op = assert_util . assert_greater_equal ( tf . rank ( x ) , tf . rank ( mask ) , message = ( \"mask cannot have higher rank than x!\" ) ) elif tensorshape_util . rank ( mask . shape ) > tensorshape_util . rank ( x . shape ) : raise ValueError ( \"mask cannot have higher rank than x! ({} vs {})\" . format ( tensorshape_util . rank ( mask . shape ) , tensorshape_util . rank ( x . shape ) ) ) check_mask_shape_op = _check_equal_shape ( \"mask\" , mask . shape [ - 1 : ] , tf . shape ( input = mask ) [ - 1 : ] , self . event_shape [ - 2 : - 1 ] , self . event_shape_tensor ( ) [ - 2 : - 1 ] ) if self . validate_args : runtime_assertions = self . runtime_assertions if check_x_shape_op is not None : runtime_assertions += [ check_x_shape_op ] if check_mask_shape_op is not None : runtime_assertions += [ check_mask_shape_op ] if check_mask_dims_op is not None : runtime_assertions += [ check_mask_dims_op ] with tf . control_dependencies ( runtime_assertions ) : x = tf . identity ( x ) # Get the full output sample_shape + batch shape. Usually # this will just be x[:-2], i.e. the input shape excluding # event shape. But users can specify inputs that broadcast # batch dimensions, so we need to broadcast this against # self.batch_shape. if tensorshape_util . is_fully_defined ( self . batch_shape ) and tensorshape_util . is_fully_defined ( x . shape ) : sample_and_batch_shape = tf . broadcast_static_shape ( x . shape [ : - 2 ] , self . batch_shape ) else : sample_and_batch_shape = tf . broadcast_dynamic_shape ( tf . shape ( input = x ) [ : - 2 ] , self . batch_shape_tensor ( ) ) # Get the full output shape for covariances. The posterior variances # in a LGSSM depend only on the model params (batch shape) and on the # missingness pattern (mask shape), so in general this may be smaller # than the full `sample_and_batch_shape`. if mask is None : mask_sample_and_batch_shape = self . batch_shape_tensor ( ) else : if ( tensorshape_util . is_fully_defined ( self . batch_shape ) and tensorshape_util . is_fully_defined ( mask . shape ) ) : mask_sample_and_batch_shape = tf . broadcast_static_shape ( mask . shape [ : - 1 ] , self . batch_shape ) else : mask_sample_and_batch_shape = tf . broadcast_dynamic_shape ( tf . shape ( input = mask ) [ : - 1 ] , self . batch_shape_tensor ( ) ) # To scan over timesteps we need to move `num_timsteps` from the # event shape to the initial dimension of the tensor. x = distribution_util . move_dimension ( x , - 2 , 0 ) if mask is not None : mask = distribution_util . move_dimension ( mask , - 1 , 0 ) # Observations are assumed to be vectors, but we add a dummy # extra dimension to allow us to use `matmul` throughout. x = x [ ... , tf . newaxis ] if mask is not None : # Align mask.shape with x.shape, including a unit dimension to broadcast # against `observation_size`. mask = mask [ ... , tf . newaxis , tf . newaxis ] # Initialize filtering distribution from the prior. The mean in # a Kalman filter depends on data, so should match the full # sample and batch shape. The covariance is data-independent, so # only has batch shape. prior_mean = _broadcast_to_shape ( self . initial_state_prior . mean ( ) [ ... , tf . newaxis ] , tf . concat ( [ sample_and_batch_shape , [ self . latent_size , 1 ] ] , axis = 0 ) ) prior_cov = _broadcast_to_shape ( self . initial_state_prior . covariance ( ) , tf . concat ( [ mask_sample_and_batch_shape , [ self . latent_size , self . latent_size ] ] , axis = 0 ) ) initial_observation_matrix = ( self . get_observation_matrix_for_timestep ( self . initial_step ) ) initial_observation_noise = ( self . get_observation_noise_for_timestep ( self . initial_step ) ) initial_observation_mean = _propagate_mean ( prior_mean , initial_observation_matrix , initial_observation_noise ) initial_observation_cov = _propagate_cov ( prior_cov , initial_observation_matrix , initial_observation_noise ) initial_state = KalmanFilterState ( predicted_mean = prior_mean , predicted_cov = prior_cov , filtered_mean = prior_mean , # establishes shape, value ignored filtered_cov = prior_cov , # establishes shape, value ignored observation_mean = initial_observation_mean , observation_cov = initial_observation_cov , log_marginal_likelihood = tf . zeros ( shape = sample_and_batch_shape , dtype = self . dtype ) , timestep = tf . convert_to_tensor ( value = self . initial_step , dtype = tf . int32 , name = \"initial_step\" ) ) update_step_fn = build_kalman_filter_step ( self . get_transition_matrix_for_timestep , self . get_transition_noise_for_timestep , self . get_observation_matrix_for_timestep , self . get_observation_noise_for_timestep ) filter_states = tf . scan ( update_step_fn , elems = x if mask is None else ( x , mask ) , initializer = initial_state ) log_likelihoods = distribution_util . move_dimension ( filter_states . log_marginal_likelihood , 0 , - 1 ) # Move the time dimension back into the event shape. filtered_means = distribution_util . move_dimension ( filter_states . filtered_mean [ ... , 0 ] , 0 , - 2 ) filtered_covs = distribution_util . move_dimension ( filter_states . filtered_cov , 0 , - 3 ) predicted_means = distribution_util . move_dimension ( filter_states . predicted_mean [ ... , 0 ] , 0 , - 2 ) predicted_covs = distribution_util . move_dimension ( filter_states . predicted_cov , 0 , - 3 ) observation_means = distribution_util . move_dimension ( filter_states . observation_mean [ ... , 0 ] , 0 , - 2 ) observation_covs = distribution_util . move_dimension ( filter_states . observation_cov , 0 , - 3 ) # We could directly construct the batch Distributions # filtered_marginals = tfd.MultivariateNormalFullCovariance( # filtered_means, filtered_covs) # predicted_marginals = tfd.MultivariateNormalFullCovariance( # predicted_means, predicted_covs) # but we choose not to: returning the raw means and covariances # saves computation in Eager mode (avoiding an immediate # Cholesky factorization that the user may not want) and aids # debugging of numerical issues. return ( log_likelihoods , filtered_means , filtered_covs , predicted_means , predicted_covs , observation_means , observation_covs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def posterior_marginals ( self , x , mask = None ) : with tf . name_scope ( \"smooth\" ) : x = tf . convert_to_tensor ( value = x , name = \"x\" ) ( _ , filtered_means , filtered_covs , predicted_means , predicted_covs , _ , _ ) = self . forward_filter ( x , mask = mask ) ( smoothed_means , smoothed_covs ) = self . backward_smoothing_pass ( filtered_means , filtered_covs , predicted_means , predicted_covs ) return ( smoothed_means , smoothed_covs )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _joint_mean ( self ) : with tf . name_scope ( \"mean_joint\" ) : # The initial timestep is a special case, since we sample the # latent state from the prior rather than the transition model. with tf . control_dependencies ( self . runtime_assertions ) : # Broadcast to ensure we represent the full batch shape. initial_latent_mean = _broadcast_to_shape ( self . initial_state_prior . mean ( ) [ ... , tf . newaxis ] , tf . concat ( [ self . batch_shape_tensor ( ) , [ self . latent_size , 1 ] ] , axis = 0 ) ) initial_observation_mean = _propagate_mean ( initial_latent_mean , self . get_observation_matrix_for_timestep ( self . initial_step ) , self . get_observation_noise_for_timestep ( self . initial_step ) ) mean_step = build_kalman_mean_step ( self . get_transition_matrix_for_timestep , self . get_transition_noise_for_timestep , self . get_observation_matrix_for_timestep , self . get_observation_noise_for_timestep ) # Scan over all timesteps following the initial step. ( latent_means , observation_means ) = tf . scan ( mean_step , elems = tf . range ( self . initial_step + 1 , self . final_step ) , initializer = ( initial_latent_mean , initial_observation_mean ) ) # Squish the initial step back on top of the other (scanned) timesteps latent_means = tf . concat ( [ initial_latent_mean [ tf . newaxis , ... ] , latent_means ] , axis = 0 ) observation_means = tf . concat ( [ initial_observation_mean [ tf . newaxis , ... ] , observation_means ] , axis = 0 ) # Put dimensions back in order. The samples we've computed have # shape `[num_timesteps, batch_shape, size, 1]`, where `size` # is the dimension of the latent or observation spaces # respectively, but we want to return values with shape # `[batch_shape, num_timesteps, size]`. latent_means = tf . squeeze ( latent_means , - 1 ) latent_means = distribution_util . move_dimension ( latent_means , 0 , - 2 ) observation_means = tf . squeeze ( observation_means , - 1 ) observation_means = distribution_util . move_dimension ( observation_means , 0 , - 2 ) return latent_means , observation_means\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _joint_covariances ( self ) : with tf . name_scope ( \"covariance_joint\" ) : with tf . control_dependencies ( self . runtime_assertions ) : initial_latent_cov = _broadcast_to_shape ( self . initial_state_prior . covariance ( ) , tf . concat ( [ self . batch_shape_tensor ( ) , [ self . latent_size , self . latent_size ] ] , axis = 0 ) ) initial_observation_cov = _propagate_cov ( initial_latent_cov , self . get_observation_matrix_for_timestep ( self . initial_step ) , self . get_observation_noise_for_timestep ( self . initial_step ) ) cov_step = build_kalman_cov_step ( self . get_transition_matrix_for_timestep , self . get_transition_noise_for_timestep , self . get_observation_matrix_for_timestep , self . get_observation_noise_for_timestep ) # Scan over all timesteps following the initial step. ( latent_covs , observation_covs ) = tf . scan ( cov_step , elems = tf . range ( self . initial_step + 1 , self . final_step ) , initializer = ( initial_latent_cov , initial_observation_cov ) ) # Squish the initial step back on top of the other (scanned) timesteps latent_covs = tf . concat ( [ initial_latent_cov [ tf . newaxis , ... ] , latent_covs ] , axis = 0 ) observation_covs = tf . concat ( [ initial_observation_cov [ tf . newaxis , ... ] , observation_covs ] , axis = 0 ) # Put dimensions back in order. The samples we've computed have # shape `[num_timesteps, batch_shape, size, size]`, where `size` # is the dimension of the state or observation spaces # respectively, but we want to return values with shape # `[batch_shape, num_timesteps, size, size]`. latent_covs = distribution_util . move_dimension ( latent_covs , 0 , - 3 ) observation_covs = distribution_util . move_dimension ( observation_covs , 0 , - 3 ) return latent_covs , observation_covs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def latents_to_observations ( self , latent_means , latent_covs ) : with tf . name_scope ( \"latents_to_observations\" ) : pushforward_latents_step = build_pushforward_latents_step ( self . get_observation_matrix_for_timestep , self . get_observation_noise_for_timestep ) latent_means = distribution_util . move_dimension ( latent_means , source_idx = - 2 , dest_idx = 0 ) latent_means = latent_means [ ... , tf . newaxis ] # Make matmul happy. latent_covs = distribution_util . move_dimension ( latent_covs , source_idx = - 3 , dest_idx = 0 ) ( initial_observation_mean , initial_observation_cov ) = pushforward_latents_step ( _ = None , # Loop body ignores previous observations. latent_t_mean_cov = ( self . initial_step , latent_means [ self . initial_step ] , latent_covs [ self . initial_step ] ) ) # TODO(davmre) this loop is embarassingly parallel; replace with `pfor`. timesteps = tf . range ( self . initial_step , self . initial_step + self . num_timesteps ) observation_means , observation_covs = tf . scan ( pushforward_latents_step , elems = ( timesteps , latent_means , latent_covs ) , initializer = ( initial_observation_mean , initial_observation_cov ) , parallel_iterations = 10000 ) observation_means = distribution_util . move_dimension ( observation_means [ ... , 0 ] , source_idx = 0 , dest_idx = - 2 ) observation_covs = distribution_util . move_dimension ( observation_covs , source_idx = 0 , dest_idx = - 3 ) return observation_means , observation_covs\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _bessel_ive ( v , z , cache = None ) : # TODO(b/67497980): Switch to a more numerically faithful implementation. z = tf . convert_to_tensor ( value = z ) wrap = lambda result : tf . debugging . check_numerics ( result , 'besseli{}' . format ( v ) ) if float ( v ) >= 2 : raise ValueError ( 'Evaluating bessel_i by recurrence becomes imprecise for large v' ) cache = cache or { } safe_z = tf . where ( z > 0 , z , tf . ones_like ( z ) ) if v in cache : return wrap ( cache [ v ] ) if v == 0 : cache [ v ] = tf . math . bessel_i0e ( z ) elif v == 1 : cache [ v ] = tf . math . bessel_i1e ( z ) elif v == 0.5 : # sinh(x)*exp(-abs(x)), sinh(x) = (e^x - e^{-x}) / 2 sinhe = lambda x : ( tf . exp ( x - tf . abs ( x ) ) - tf . exp ( - x - tf . abs ( x ) ) ) / 2 cache [ v ] = ( np . sqrt ( 2 / np . pi ) * sinhe ( z ) * tf . where ( z > 0 , tf . math . rsqrt ( safe_z ) , tf . ones_like ( safe_z ) ) ) elif v == - 0.5 : # cosh(x)*exp(-abs(x)), cosh(x) = (e^x + e^{-x}) / 2 coshe = lambda x : ( tf . exp ( x - tf . abs ( x ) ) + tf . exp ( - x - tf . abs ( x ) ) ) / 2 cache [ v ] = ( np . sqrt ( 2 / np . pi ) * coshe ( z ) * tf . where ( z > 0 , tf . math . rsqrt ( safe_z ) , tf . ones_like ( safe_z ) ) ) if v <= 1 : return wrap ( cache [ v ] ) # Recurrence relation: cache [ v ] = ( _bessel_ive ( v - 2 , z , cache ) - ( 2 * ( v - 1 ) ) * _bessel_ive ( v - 1 , z , cache ) / z ) return wrap ( cache [ v ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_normalization ( self ) : event_dim = tf . compat . dimension_value ( self . event_shape [ 0 ] ) if event_dim is None : raise ValueError ( 'vMF _log_normalizer currently only supports ' 'statically known event shape' ) safe_conc = tf . where ( self . concentration > 0 , self . concentration , tf . ones_like ( self . concentration ) ) safe_lognorm = ( ( event_dim / 2 - 1 ) * tf . math . log ( safe_conc ) - ( event_dim / 2 ) * np . log ( 2 * np . pi ) - tf . math . log ( _bessel_ive ( event_dim / 2 - 1 , safe_conc ) ) - tf . abs ( safe_conc ) ) log_nsphere_surface_area = ( np . log ( 2. ) + ( event_dim / 2 ) * np . log ( np . pi ) - tf . math . lgamma ( tf . cast ( event_dim / 2 , self . dtype ) ) ) return tf . where ( self . concentration > 0 , - safe_lognorm , log_nsphere_surface_area * tf . ones_like ( safe_lognorm ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_assert_valid_sample ( self , samples ) : if not self . validate_args : return samples with tf . control_dependencies ( [ assert_util . assert_near ( 1. , tf . linalg . norm ( tensor = samples , axis = - 1 ) , message = 'samples must be unit length' ) , assert_util . assert_equal ( tf . shape ( input = samples ) [ - 1 : ] , self . event_shape_tensor ( ) , message = ( 'samples must have innermost dimension matching that of ' '`self.mean_direction`' ) ) , ] ) : return tf . identity ( samples )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _mode ( self ) : return ( self . mean_direction + tf . zeros_like ( self . concentration ) [ ... , tf . newaxis ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _rotate ( self , samples ) : event_dim = ( tf . compat . dimension_value ( self . event_shape [ 0 ] ) or self . _event_shape_tensor ( ) [ 0 ] ) basis = tf . concat ( [ [ 1. ] , tf . zeros ( [ event_dim - 1 ] , dtype = self . dtype ) ] , axis = 0 ) , u = tf . nn . l2_normalize ( basis - self . mean_direction , axis = - 1 ) return samples - 2 * tf . reduce_sum ( input_tensor = samples * u , axis = - 1 , keepdims = True ) * u\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sample_3d ( self , n , seed = None ) : seed = seed_stream . SeedStream ( seed , salt = 'von_mises_fisher_3d' ) u_shape = tf . concat ( [ [ n ] , self . _batch_shape_tensor ( ) ] , axis = 0 ) z = tf . random . uniform ( u_shape , seed = seed ( ) , dtype = self . dtype ) # TODO(bjp): Higher-order odd dim analytic CDFs are available in [1], could # be bisected for bounded sampling runtime (i.e. not rejection sampling). # [1]: Inversion sampler via: https://ieeexplore.ieee.org/document/7347705/ # The inversion is: u = 1 + log(z + (1-z)*exp(-2*kappa)) / kappa # We must protect against both kappa and z being zero. safe_conc = tf . where ( self . concentration > 0 , self . concentration , tf . ones_like ( self . concentration ) ) safe_z = tf . where ( z > 0 , z , tf . ones_like ( z ) ) safe_u = 1 + tf . reduce_logsumexp ( input_tensor = [ tf . math . log ( safe_z ) , tf . math . log1p ( - safe_z ) - 2 * safe_conc ] , axis = 0 ) / safe_conc # Limit of the above expression as kappa->0 is 2*z-1 u = tf . where ( self . concentration > tf . zeros_like ( safe_u ) , safe_u , 2 * z - 1 ) # Limit of the expression as z->0 is -1. u = tf . where ( tf . equal ( z , 0 ) , - tf . ones_like ( u ) , u ) if not self . _allow_nan_stats : u = tf . debugging . check_numerics ( u , 'u in _sample_3d' ) return u [ ... , tf . newaxis ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _copy_fn ( fn ) : if not callable ( fn ) : raise TypeError ( \"fn is not callable: {}\" . format ( fn ) ) # The blessed way to copy a function. copy.deepcopy fails to create a # non-reference copy. Since: # types.FunctionType == type(lambda: None), # and the docstring for the function type states: # # function(code, globals[, name[, argdefs[, closure]]]) # # Create a function object from a code object and a dictionary. # ... # # Here we can use this to create a new function with the old function's # code, globals, closure, etc. return types . FunctionType ( code = fn . __code__ , globals = fn . __globals__ , name = fn . __name__ , argdefs = fn . __defaults__ , closure = fn . __closure__ )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _update_docstring ( old_str , append_str ) : old_str = old_str or \"\" old_str_lines = old_str . split ( \"\\n\" ) # Step 0: Prepend spaces to all lines of append_str. This is # necessary for correct markdown generation. append_str = \"\\n\" . join ( \" %s\" % line for line in append_str . split ( \"\\n\" ) ) # Step 1: Find mention of \"Args\": has_args_ix = [ ix for ix , line in enumerate ( old_str_lines ) if line . strip ( ) . lower ( ) == \"args:\" ] if has_args_ix : final_args_ix = has_args_ix [ - 1 ] return ( \"\\n\" . join ( old_str_lines [ : final_args_ix ] ) + \"\\n\\n\" + append_str + \"\\n\\n\" + \"\\n\" . join ( old_str_lines [ final_args_ix : ] ) ) else : return old_str + \"\\n\\n\" + append_str\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _convert_to_tensor ( value , dtype = None , dtype_hint = None , name = None ) : if ( tf . nest . is_nested ( dtype ) or tf . nest . is_nested ( dtype_hint ) ) : if dtype is None : fn = lambda v , pd : tf . convert_to_tensor ( v , dtype_hint = pd , name = name ) return tf . nest . map_structure ( fn , value , dtype_hint ) elif dtype_hint is None : fn = lambda v , d : tf . convert_to_tensor ( v , dtype = d , name = name ) return tf . nest . map_structure ( fn , value , dtype_hint ) else : fn = lambda v , d , pd : tf . convert_to_tensor ( # pylint: disable=g-long-lambda v , dtype = d , dtype_hint = pd , name = name ) return tf . nest . map_structure ( fn , value , dtype , dtype_hint ) return tf . convert_to_tensor ( value = value , dtype = dtype , dtype_hint = dtype_hint , name = name )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _recursively_replace_dict_for_pretty_dict ( x ) : # We use \"PrettyDict\" because collections.OrderedDict repr/str has the word # \"OrderedDict\" in it. We only want to print \"OrderedDict\" if in fact the # input really is an OrderedDict. if isinstance ( x , dict ) : return _PrettyDict ( { k : _recursively_replace_dict_for_pretty_dict ( v ) for k , v in x . items ( ) } ) if ( isinstance ( x , collections . Sequence ) and not isinstance ( x , six . string_types ) ) : args = ( _recursively_replace_dict_for_pretty_dict ( x_ ) for x_ in x ) is_named_tuple = ( isinstance ( x , tuple ) and hasattr ( x , \"_asdict\" ) and hasattr ( x , \"_fields\" ) ) return type ( x ) ( * args ) if is_named_tuple else type ( x ) ( args ) if isinstance ( x , collections . Mapping ) : return type ( x ) ( * * { k : _recursively_replace_dict_for_pretty_dict ( v ) for k , v in x . items ( ) } ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def expectation ( f , samples , log_prob = None , use_reparametrization = True , axis = 0 , keep_dims = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'expectation' , [ samples ] ) : if not callable ( f ) : raise ValueError ( '`f` must be a callable function.' ) if use_reparametrization : return tf . reduce_mean ( input_tensor = f ( samples ) , axis = axis , keepdims = keep_dims ) else : if not callable ( log_prob ) : raise ValueError ( '`log_prob` must be a callable function.' ) stop = tf . stop_gradient # For readability. x = stop ( samples ) logpx = log_prob ( x ) fx = f ( x ) # Call `f` once in case it has side-effects. # To achieve this, we use the fact that: # `h(x) - stop(h(x)) == zeros_like(h(x))` # but its gradient is grad[h(x)]. # # This technique was published as: # Jakob Foerster, Greg Farquhar, Maruan Al-Shedivat, Tim Rocktaeschel, # Eric P. Xing, Shimon Whiteson (ICML 2018) # \"DiCE: The Infinitely Differentiable Monte-Carlo Estimator\" # https://arxiv.org/abs/1802.05098 # # Unlike using: # fx = fx + stop(fx) * (logpx - stop(logpx)), # DiCE ensures that any order gradients of the objective # are unbiased gradient estimators. # # Note that IEEE754 specifies that `x - x == 0.` and `x + 0. == x`, hence # this trick loses no precision. For more discussion regarding the # relevant portions of the IEEE754 standard, see the StackOverflow # question, # \"Is there a floating point value of x, for which x-x == 0 is false?\" # http://stackoverflow.com/q/2686644 dice = fx * tf . exp ( logpx - stop ( logpx ) ) return tf . reduce_mean ( input_tensor = dice , axis = axis , keepdims = keep_dims )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_samples ( dist , z , n , seed ) : with tf . compat . v1 . name_scope ( 'get_samples' , values = [ z , n ] ) : if ( n is None ) == ( z is None ) : raise ValueError ( 'Must specify exactly one of arguments \"n\" and \"z\". Found: ' 'n = %s, z = %s' % ( n , z ) ) if n is not None : return dist . sample ( n , seed = seed ) else : return tf . convert_to_tensor ( value = z , name = 'z' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_namedtuple_like ( x ) : try : for fn in x . _fields : _ = getattr ( x , fn ) return True except AttributeError : return False\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_name ( super_name , default_super_name , sub_name ) : name = super_name if super_name is not None else default_super_name if sub_name is not None : name += '_' + sub_name return name\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _choose_base_case ( is_accepted , accepted , rejected , name = None ) : def _expand_is_accepted_like ( x ) : \"\"\"Helper to expand `is_accepted` like the shape of some input arg.\"\"\" with tf . compat . v1 . name_scope ( 'expand_is_accepted_like' ) : expand_shape = tf . concat ( [ tf . shape ( input = is_accepted ) , tf . ones ( [ tf . rank ( x ) - tf . rank ( is_accepted ) ] , dtype = tf . int32 ) , ] , axis = 0 ) multiples = tf . concat ( [ tf . ones ( [ tf . rank ( is_accepted ) ] , dtype = tf . int32 ) , tf . shape ( input = x ) [ tf . rank ( is_accepted ) : ] , ] , axis = 0 ) m = tf . tile ( tf . reshape ( is_accepted , expand_shape ) , multiples ) m . set_shape ( m . shape . merge_with ( x . shape ) ) return m def _where ( accepted , rejected ) : if accepted is rejected : return accepted accepted = tf . convert_to_tensor ( value = accepted , name = 'accepted' ) rejected = tf . convert_to_tensor ( value = rejected , name = 'rejected' ) r = tf . where ( _expand_is_accepted_like ( accepted ) , accepted , rejected ) r . set_shape ( r . shape . merge_with ( accepted . shape . merge_with ( rejected . shape ) ) ) return r with tf . compat . v1 . name_scope ( name , 'choose' , values = [ is_accepted , accepted , rejected ] ) : if not is_list_like ( accepted ) : return _where ( accepted , rejected ) return [ ( choose ( is_accepted , a , r , name = name ) if is_namedtuple_like ( a ) else _where ( a , r ) ) for a , r in zip ( accepted , rejected ) ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def choose ( is_accepted , accepted , rejected , name = None ) : if not is_namedtuple_like ( accepted ) : return _choose_base_case ( is_accepted , accepted , rejected , name = name ) if not isinstance ( accepted , type ( rejected ) ) : raise TypeError ( 'Type of `accepted` ({}) must be identical to ' 'type of `rejected` ({})' . format ( type ( accepted ) . __name__ , type ( rejected ) . __name__ ) ) return type ( accepted ) ( * * dict ( [ ( fn , choose ( is_accepted , getattr ( accepted , fn ) , getattr ( rejected , fn ) , name = name ) ) for fn in accepted . _fields ] ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def safe_sum ( x , alt_value = - np . inf , name = None ) : with tf . compat . v1 . name_scope ( name , 'safe_sum' , [ x , alt_value ] ) : if not is_list_like ( x ) : raise TypeError ( 'Expected list input.' ) if not x : raise ValueError ( 'Input should not be empty.' ) in_shape = x [ 0 ] . shape x = tf . stack ( x , axis = - 1 ) x = tf . reduce_sum ( input_tensor = x , axis = - 1 ) alt_value = np . array ( alt_value , x . dtype . as_numpy_dtype ) alt_fill = tf . fill ( tf . shape ( input = x ) , value = alt_value ) x = tf . where ( tf . math . is_finite ( x ) , x , alt_fill ) x . set_shape ( x . shape . merge_with ( in_shape ) ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _value_and_gradients ( fn , fn_arg_list , result = None , grads = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'value_and_gradients' , [ fn_arg_list , result , grads ] ) : def _convert_to_tensor ( x , name ) : ctt = lambda x_ : x_ if x_ is None else tf . convert_to_tensor ( value = x_ , name = name ) return [ ctt ( x_ ) for x_ in x ] if is_list_like ( x ) else ctt ( x ) fn_arg_list = ( list ( fn_arg_list ) if is_list_like ( fn_arg_list ) else [ fn_arg_list ] ) fn_arg_list = _convert_to_tensor ( fn_arg_list , 'fn_arg' ) if result is None : result = fn ( * fn_arg_list ) if grads is None and tf . executing_eagerly ( ) : # Ensure we disable bijector cacheing in eager mode. # TODO(b/72831017): Remove this once bijector cacheing is fixed for # eager mode. fn_arg_list = [ 0 + x for x in fn_arg_list ] result = _convert_to_tensor ( result , 'fn_result' ) if grads is not None : grads = _convert_to_tensor ( grads , 'fn_grad' ) return result , grads if is_list_like ( result ) and len ( result ) == len ( fn_arg_list ) : # Compute the block diagonal of Jacobian. # TODO(b/79158574): Guard this calculation by an arg which explicitly # requests block diagonal Jacobian calculation. def fn_slice ( i ) : \"\"\"Needed to prevent `cell-var-from-loop` pylint warning.\"\"\" return lambda x : fn ( * ( fn_arg_list [ : i ] + [ x ] + fn_arg_list [ i + 1 : ] ) ) grads = [ tfp_math_value_and_gradients ( fn_slice ( i ) , fn_arg_list [ i ] ) [ 1 ] for i in range ( len ( result ) ) ] else : _ , grads = tfp_math_value_and_gradients ( fn , fn_arg_list ) return result , grads\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def maybe_call_fn_and_grads ( fn , fn_arg_list , result = None , grads = None , check_non_none_grads = True , name = None ) : with tf . compat . v1 . name_scope ( name , 'maybe_call_fn_and_grads' , [ fn_arg_list , result , grads ] ) : fn_arg_list = ( list ( fn_arg_list ) if is_list_like ( fn_arg_list ) else [ fn_arg_list ] ) result , grads = _value_and_gradients ( fn , fn_arg_list , result , grads ) if not all ( r . dtype . is_floating for r in ( result if is_list_like ( result ) else [ result ] ) ) : # pylint: disable=superfluous-parens raise TypeError ( 'Function result must be a `Tensor` with `float` ' '`dtype`.' ) if len ( fn_arg_list ) != len ( grads ) : raise ValueError ( 'Function args must be in one-to-one correspondence ' 'with grads.' ) if check_non_none_grads and any ( g is None for g in grads ) : raise ValueError ( 'Encountered `None` gradient.\\n' ' fn_arg_list: {}\\n' ' grads: {}' . format ( fn_arg_list , grads ) ) return result , grads\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def smart_for_loop ( loop_num_iter , body_fn , initial_loop_vars , parallel_iterations = 10 , name = None ) : with tf . compat . v1 . name_scope ( name , 'smart_for_loop' , [ loop_num_iter , initial_loop_vars ] ) : loop_num_iter_ = tf . get_static_value ( loop_num_iter ) if ( loop_num_iter_ is None or tf . executing_eagerly ( ) or control_flow_util . GraphOrParentsInXlaContext ( tf . compat . v1 . get_default_graph ( ) ) ) : # Cast to int32 to run the comparison against i in host memory, # where while/LoopCond needs it. loop_num_iter = tf . cast ( loop_num_iter , dtype = tf . int32 ) return tf . while_loop ( cond = lambda i , * args : i < loop_num_iter , body = lambda i , * args : [ i + 1 ] + list ( body_fn ( * args ) ) , loop_vars = [ np . int32 ( 0 ) ] + initial_loop_vars , parallel_iterations = parallel_iterations ) [ 1 : ] result = initial_loop_vars for _ in range ( loop_num_iter_ ) : result = body_fn ( * result ) return result\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def trace_scan ( loop_fn , initial_state , elems , trace_fn , parallel_iterations = 10 , name = None ) : with tf . compat . v1 . name_scope ( name , 'trace_scan' , [ initial_state , elems ] ) , tf . compat . v1 . variable_scope ( tf . compat . v1 . get_variable_scope ( ) ) as vs : if vs . caching_device is None and not tf . executing_eagerly ( ) : vs . set_caching_device ( lambda op : op . device ) initial_state = tf . nest . map_structure ( lambda x : tf . convert_to_tensor ( value = x , name = 'initial_state' ) , initial_state ) elems = tf . convert_to_tensor ( value = elems , name = 'elems' ) static_length = elems . shape [ 0 ] if tf . compat . dimension_value ( static_length ) is None : length = tf . shape ( input = elems ) [ 0 ] else : length = tf . convert_to_tensor ( value = static_length , dtype = tf . int32 , name = 'length' ) # This is an TensorArray in part because of XLA, which had trouble with # non-statically known indices. I.e. elems[i] errored, but # elems_array.read(i) worked. elems_array = tf . TensorArray ( elems . dtype , size = length , element_shape = elems . shape [ 1 : ] ) elems_array = elems_array . unstack ( elems ) trace_arrays = tf . nest . map_structure ( lambda x : tf . TensorArray ( x . dtype , size = length , element_shape = x . shape ) , trace_fn ( initial_state ) ) def _body ( i , state , trace_arrays ) : state = loop_fn ( state , elems_array . read ( i ) ) trace_arrays = tf . nest . pack_sequence_as ( trace_arrays , [ a . write ( i , v ) for a , v in zip ( tf . nest . flatten ( trace_arrays ) , tf . nest . flatten ( trace_fn ( state ) ) ) ] ) return i + 1 , state , trace_arrays _ , final_state , trace_arrays = tf . while_loop ( cond = lambda i , * args : i < length , body = _body , loop_vars = ( 0 , initial_state , trace_arrays ) , parallel_iterations = parallel_iterations ) stacked_trace = tf . nest . map_structure ( lambda x : x . stack ( ) , trace_arrays ) # Restore the static length if we know it. def _merge_static_length ( x ) : x . set_shape ( tf . TensorShape ( static_length ) . concatenate ( x . shape [ 1 : ] ) ) return x stacked_trace = tf . nest . map_structure ( _merge_static_length , stacked_trace ) return final_state , stacked_trace\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_innermost_setter ( setter ) : @ functools . wraps ( setter ) def _new_setter ( kernel_results , * args , * * kwargs ) : \"\"\"Wrapped setter.\"\"\" results_stack = [ ] while hasattr ( kernel_results , 'inner_results' ) : results_stack . append ( kernel_results ) kernel_results = kernel_results . inner_results new_kernel_results = setter ( kernel_results , * args , * * kwargs ) for outer_results in reversed ( results_stack ) : new_kernel_results = outer_results . _replace ( inner_results = new_kernel_results ) return new_kernel_results return _new_setter\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_innermost_getter ( getter ) : @ functools . wraps ( getter ) def _new_getter ( kernel_results , * args , * * kwargs ) : \"\"\"Wrapped getter.\"\"\" results_stack = [ ] while hasattr ( kernel_results , 'inner_results' ) : results_stack . append ( kernel_results ) kernel_results = kernel_results . inner_results return getter ( kernel_results , * args , * * kwargs ) return _new_getter\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def enable_store_parameters_in_results ( kernel ) : kernel_stack = [ ] while hasattr ( kernel , 'parameters' ) and 'inner_kernel' in kernel . parameters : kernel_stack . append ( kernel ) kernel = kernel . parameters [ 'inner_kernel' ] def _recreate_kernel ( kernel , parameters ) : new_parameters = kernel . parameters . copy ( ) new_parameters . update ( parameters ) if 'store_parameters_in_results' in new_parameters : new_parameters [ 'store_parameters_in_results' ] = True with deprecation . silence ( ) : return type ( kernel ) ( * * new_parameters ) if hasattr ( kernel , 'parameters' ) : kernel = _recreate_kernel ( kernel , { } ) for outer_kernel in reversed ( kernel_stack ) : outer_kernel = _recreate_kernel ( outer_kernel , { 'inner_kernel' : kernel } ) kernel = outer_kernel return kernel\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _replace_event_shape_in_shape_tensor ( input_shape , event_shape_in , event_shape_out , validate_args ) : output_tensorshape , is_validated = _replace_event_shape_in_tensorshape ( tensorshape_util . constant_value_as_shape ( input_shape ) , event_shape_in , event_shape_out ) # TODO(b/124240153): Remove map(tf.identity, deps) once tf.function # correctly supports control_dependencies. validation_dependencies = ( map ( tf . identity , ( event_shape_in , event_shape_out ) ) if validate_args else ( ) ) if ( tensorshape_util . is_fully_defined ( output_tensorshape ) and ( is_validated or not validate_args ) ) : with tf . control_dependencies ( validation_dependencies ) : output_shape = tf . convert_to_tensor ( value = output_tensorshape , name = 'output_shape' , dtype_hint = tf . int32 ) return output_shape , output_tensorshape with tf . control_dependencies ( validation_dependencies ) : event_shape_in_ndims = ( tf . size ( input = event_shape_in ) if tensorshape_util . num_elements ( event_shape_in . shape ) is None else tensorshape_util . num_elements ( event_shape_in . shape ) ) input_non_event_shape , input_event_shape = tf . split ( input_shape , num_or_size_splits = [ - 1 , event_shape_in_ndims ] ) additional_assertions = [ ] if is_validated : pass elif validate_args : # Check that `input_event_shape` and `event_shape_in` are compatible in the # sense that they have equal entries in any position that isn't a `-1` in # `event_shape_in`. Note that our validations at construction time ensure # there is at most one such entry in `event_shape_in`. mask = event_shape_in >= 0 explicit_input_event_shape = tf . boolean_mask ( tensor = input_event_shape , mask = mask ) explicit_event_shape_in = tf . boolean_mask ( tensor = event_shape_in , mask = mask ) additional_assertions . append ( assert_util . assert_equal ( explicit_input_event_shape , explicit_event_shape_in , message = 'Input `event_shape` does not match `event_shape_in`.' ) ) # We don't explicitly additionally verify # `tf.size(input_shape) > tf.size(event_shape_in)` since `tf.split` # already makes this assertion. with tf . control_dependencies ( additional_assertions ) : output_shape = tf . concat ( [ input_non_event_shape , event_shape_out ] , axis = 0 , name = 'output_shape' ) return output_shape , output_tensorshape\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _replace_event_shape_in_tensorshape ( input_tensorshape , event_shape_in , event_shape_out ) : event_shape_in_ndims = tensorshape_util . num_elements ( event_shape_in . shape ) if tensorshape_util . rank ( input_tensorshape ) is None or event_shape_in_ndims is None : return tf . TensorShape ( None ) , False # Not is_validated. input_non_event_ndims = tensorshape_util . rank ( input_tensorshape ) - event_shape_in_ndims if input_non_event_ndims < 0 : raise ValueError ( 'Input has fewer ndims ({}) than event shape ndims ({}).' . format ( tensorshape_util . rank ( input_tensorshape ) , event_shape_in_ndims ) ) input_non_event_tensorshape = input_tensorshape [ : input_non_event_ndims ] input_event_tensorshape = input_tensorshape [ input_non_event_ndims : ] # Check that `input_event_shape_` and `event_shape_in` are compatible in the # sense that they have equal entries in any position that isn't a `-1` in # `event_shape_in`. Note that our validations at construction time ensure # there is at most one such entry in `event_shape_in`. event_shape_in_ = tf . get_static_value ( event_shape_in ) is_validated = ( tensorshape_util . is_fully_defined ( input_event_tensorshape ) and event_shape_in_ is not None ) if is_validated : input_event_shape_ = np . int32 ( input_event_tensorshape ) mask = event_shape_in_ >= 0 explicit_input_event_shape_ = input_event_shape_ [ mask ] explicit_event_shape_in_ = event_shape_in_ [ mask ] if not all ( explicit_input_event_shape_ == explicit_event_shape_in_ ) : raise ValueError ( 'Input `event_shape` does not match `event_shape_in`. ' '({} vs {}).' . format ( input_event_shape_ , event_shape_in_ ) ) event_tensorshape_out = tensorshape_util . constant_value_as_shape ( event_shape_out ) if tensorshape_util . rank ( event_tensorshape_out ) is None : output_tensorshape = tf . TensorShape ( None ) else : output_tensorshape = tensorshape_util . concatenate ( input_non_event_tensorshape , event_tensorshape_out ) return output_tensorshape , is_validated\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_check_valid_shape ( shape , validate_args ) : if not dtype_util . is_integer ( shape . dtype ) : raise TypeError ( '{} dtype ({}) should be `int`-like.' . format ( shape , dtype_util . name ( shape . dtype ) ) ) assertions = [ ] message = '`{}` rank should be <= 1.' if tensorshape_util . rank ( shape . shape ) is not None : if tensorshape_util . rank ( shape . shape ) > 1 : raise ValueError ( message . format ( shape ) ) elif validate_args : assertions . append ( assert_util . assert_less ( tf . rank ( shape ) , 2 , message = message . format ( shape ) ) ) shape_ = tf . get_static_value ( shape ) message = '`{}` elements must have at most one `-1`.' if shape_ is not None : if sum ( shape_ == - 1 ) > 1 : raise ValueError ( message . format ( shape ) ) elif validate_args : assertions . append ( assert_util . assert_less ( tf . reduce_sum ( input_tensor = tf . cast ( tf . equal ( shape , - 1 ) , tf . int32 ) ) , 2 , message = message . format ( shape ) ) ) message = '`{}` elements must be either positive integers or `-1`.' if shape_ is not None : if np . any ( shape_ < - 1 ) : raise ValueError ( message . format ( shape ) ) elif validate_args : assertions . append ( assert_util . assert_greater ( shape , - 2 , message = message . format ( shape ) ) ) return assertions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_beta_beta ( d1 , d2 , name = None ) : def delta ( fn , is_property = True ) : fn1 = getattr ( d1 , fn ) fn2 = getattr ( d2 , fn ) return ( fn2 - fn1 ) if is_property else ( fn2 ( ) - fn1 ( ) ) with tf . name_scope ( name or \"kl_beta_beta\" ) : return ( delta ( \"_log_normalization\" , is_property = False ) - tf . math . digamma ( d1 . concentration1 ) * delta ( \"concentration1\" ) - tf . math . digamma ( d1 . concentration0 ) * delta ( \"concentration0\" ) + ( tf . math . digamma ( d1 . total_concentration ) * delta ( \"total_concentration\" ) ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_assert_valid_sample ( self , x ) : if not self . validate_args : return x return distribution_util . with_dependencies ( [ assert_util . assert_positive ( x , message = \"sample must be positive\" ) , assert_util . assert_less ( x , 1. , message = \"sample must be less than `1`.\" ) , ] , x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def converged_any ( converged , failed ) : return ( tf . reduce_any ( input_tensor = converged ) | tf . reduce_all ( input_tensor = failed ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def get_initial_state_args ( value_and_gradients_function , initial_position , grad_tolerance , control_inputs = None ) : if control_inputs : with tf . control_dependencies ( control_inputs ) : f0 , df0 = value_and_gradients_function ( initial_position ) else : f0 , df0 = value_and_gradients_function ( initial_position ) converged = norm ( df0 , dims = 1 ) < grad_tolerance return dict ( converged = converged , failed = tf . zeros_like ( converged ) , # i.e. False. num_iterations = tf . convert_to_tensor ( value = 0 ) , num_objective_evaluations = tf . convert_to_tensor ( value = 1 ) , position = initial_position , objective_value = f0 , objective_gradient = df0 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def line_search_step ( state , value_and_gradients_function , search_direction , grad_tolerance , f_relative_tolerance , x_tolerance , stopping_condition ) : line_search_value_grad_func = _restrict_along_direction ( value_and_gradients_function , state . position , search_direction ) derivative_at_start_pt = tf . reduce_sum ( input_tensor = state . objective_gradient * search_direction , axis = - 1 ) val_0 = ValueAndGradient ( x = _broadcast ( 0 , state . position ) , f = state . objective_value , df = derivative_at_start_pt , full_gradient = state . objective_gradient ) inactive = state . failed | state . converged ls_result = linesearch . hager_zhang ( line_search_value_grad_func , initial_step_size = _broadcast ( 1 , state . position ) , value_at_zero = val_0 , converged = inactive ) # No search needed for these. state_after_ls = update_fields ( state , failed = state . failed | ~ ls_result . converged , num_iterations = state . num_iterations + 1 , num_objective_evaluations = ( state . num_objective_evaluations + ls_result . func_evals ) ) def _do_update_position ( ) : # For inactive batch members `left.x` is zero. However, their # `search_direction` might also be undefined, so we can't rely on # multiplication by zero to produce a `position_delta` of zero. position_delta = tf . where ( inactive , tf . zeros_like ( search_direction ) , search_direction * tf . expand_dims ( ls_result . left . x , axis = - 1 ) ) return _update_position ( state_after_ls , position_delta , ls_result . left . f , ls_result . left . full_gradient , grad_tolerance , f_relative_tolerance , x_tolerance ) return prefer_static . cond ( stopping_condition ( state . converged , state . failed ) , true_fn = lambda : state_after_ls , false_fn = _do_update_position )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _restrict_along_direction ( value_and_gradients_function , position , direction ) : def _restricted_func ( t ) : t = _broadcast ( t , position ) pt = position + tf . expand_dims ( t , axis = - 1 ) * direction objective_value , gradient = value_and_gradients_function ( pt ) return ValueAndGradient ( x = t , f = objective_value , df = tf . reduce_sum ( input_tensor = gradient * direction , axis = - 1 ) , full_gradient = gradient ) return _restricted_func\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _update_position ( state , position_delta , next_objective , next_gradient , grad_tolerance , f_relative_tolerance , x_tolerance ) : failed = state . failed | ~ tf . math . is_finite ( next_objective ) | ~ tf . reduce_all ( input_tensor = tf . math . is_finite ( next_gradient ) , axis = - 1 ) next_position = state . position + position_delta converged = ~ failed & _check_convergence ( state . position , next_position , state . objective_value , next_objective , next_gradient , grad_tolerance , f_relative_tolerance , x_tolerance ) return update_fields ( state , converged = state . converged | converged , failed = failed , position = next_position , objective_value = next_objective , objective_gradient = next_gradient )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def norm ( value , dims , order = None ) : if dims == 0 : return tf . math . abs ( value ) elif dims == 1 : axis = - 1 elif dims == 2 : axis = [ - 1 , - 2 ] else : ValueError ( dims ) if order is None : order = np . inf return tf . norm ( tensor = value , axis = axis , ord = order )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _check_convergence ( current_position , next_position , current_objective , next_objective , next_gradient , grad_tolerance , f_relative_tolerance , x_tolerance ) : grad_converged = norm ( next_gradient , dims = 1 ) <= grad_tolerance x_converged = norm ( next_position - current_position , dims = 1 ) <= x_tolerance f_converged = ( norm ( next_objective - current_objective , dims = 0 ) <= f_relative_tolerance * current_objective ) return grad_converged | x_converged | f_converged\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _broadcast ( value , target ) : return tf . broadcast_to ( tf . convert_to_tensor ( value = value , dtype = target . dtype ) , distribution_util . prefer_static_shape ( target ) [ : - 1 ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _harmonic_number ( x ) : one = tf . ones ( [ ] , dtype = x . dtype ) return tf . math . digamma ( x + one ) - tf . math . digamma ( one )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _moment ( self , n ) : total_concentration = self . concentration1 + self . concentration0 expanded_concentration1 = tf . ones_like ( total_concentration , dtype = self . dtype ) * self . concentration1 expanded_concentration0 = tf . ones_like ( total_concentration , dtype = self . dtype ) * self . concentration0 beta_arg0 = 1 + n / expanded_concentration1 beta_arg = tf . stack ( [ beta_arg0 , expanded_concentration0 ] , - 1 ) log_moment = tf . math . log ( expanded_concentration0 ) + tf . math . lbeta ( beta_arg ) return tf . exp ( log_moment )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_validate_target_accept_prob ( target_accept_prob , validate_args ) : if not validate_args : return target_accept_prob with tf . control_dependencies ( [ tf . compat . v1 . assert_positive ( target_accept_prob , message = '`target_accept_prob` must be > 0.' ) , tf . compat . v1 . assert_less ( target_accept_prob , tf . ones_like ( target_accept_prob ) , message = '`target_accept_prob` must be < 1.' ) ] ) : return tf . identity ( target_accept_prob )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def default_exchange_proposed_fn ( prob_exchange ) : def default_exchange_proposed_fn_ ( num_replica , seed = None ) : \"\"\"Default function for `exchange_proposed_fn` of `kernel`.\"\"\" seed_stream = distributions . SeedStream ( seed , 'default_exchange_proposed_fn' ) zero_start = tf . random . uniform ( [ ] , seed = seed_stream ( ) ) > 0.5 if num_replica % 2 == 0 : def _exchange ( ) : flat_exchange = tf . range ( num_replica ) if num_replica > 2 : start = tf . cast ( ~ zero_start , dtype = tf . int32 ) end = num_replica - start flat_exchange = flat_exchange [ start : end ] return tf . reshape ( flat_exchange , [ tf . size ( input = flat_exchange ) // 2 , 2 ] ) else : def _exchange ( ) : start = tf . cast ( zero_start , dtype = tf . int32 ) end = num_replica - tf . cast ( ~ zero_start , dtype = tf . int32 ) flat_exchange = tf . range ( num_replica ) [ start : end ] return tf . reshape ( flat_exchange , [ tf . size ( input = flat_exchange ) // 2 , 2 ] ) def _null_exchange ( ) : return tf . reshape ( tf . cast ( [ ] , dtype = tf . int32 ) , shape = [ 0 , 2 ] ) return tf . cond ( pred = tf . random . uniform ( [ ] , seed = seed_stream ( ) ) < prob_exchange , true_fn = _exchange , false_fn = _null_exchange ) return default_exchange_proposed_fn_\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_field ( kernel_results , field_name ) : if hasattr ( kernel_results , field_name ) : return getattr ( kernel_results , field_name ) if hasattr ( kernel_results , 'accepted_results' ) : return getattr ( kernel_results . accepted_results , field_name ) raise TypeError ( 'Cannot extract %s from %s' % ( field_name , kernel_results ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def one_step ( self , current_state , previous_kernel_results ) : # Key difficulty: The type of exchanges differs from one call to the # next...even the number of exchanges can differ. # As a result, exchanges must happen dynamically, in while loops. with tf . compat . v1 . name_scope ( name = mcmc_util . make_name ( self . name , 'remc' , 'one_step' ) , values = [ current_state , previous_kernel_results ] ) : # Each replica does `one_step` to get pre-exchange states/KernelResults. sampled_replica_states , sampled_replica_results = zip ( * [ rk . one_step ( previous_kernel_results . replica_states [ i ] , previous_kernel_results . replica_results [ i ] ) for i , rk in enumerate ( self . replica_kernels ) ] ) sampled_replica_states = list ( sampled_replica_states ) sampled_replica_results = list ( sampled_replica_results ) states_are_lists = mcmc_util . is_list_like ( sampled_replica_states [ 0 ] ) if not states_are_lists : sampled_replica_states = [ [ s ] for s in sampled_replica_states ] num_state_parts = len ( sampled_replica_states [ 0 ] ) dtype = sampled_replica_states [ 0 ] [ 0 ] . dtype # Must put states into TensorArrays. Why? We will read/write states # dynamically with Tensor index `i`, and you cannot do this with lists. # old_states[k][i] is Tensor of (old) state part k, for replica i. # The `k` will be known statically, and `i` is a Tensor. old_states = [ tf . TensorArray ( dtype , size = self . num_replica , dynamic_size = False , clear_after_read = False , tensor_array_name = 'old_states' , # State part k has same shape, regardless of replica. So use 0. element_shape = sampled_replica_states [ 0 ] [ k ] . shape ) for k in range ( num_state_parts ) ] for k in range ( num_state_parts ) : for i in range ( self . num_replica ) : old_states [ k ] = old_states [ k ] . write ( i , sampled_replica_states [ i ] [ k ] ) exchange_proposed = self . exchange_proposed_fn ( self . num_replica , seed = self . _seed_stream ( ) ) exchange_proposed_n = tf . shape ( input = exchange_proposed ) [ 0 ] exchanged_states = self . _get_exchanged_states ( old_states , exchange_proposed , exchange_proposed_n , sampled_replica_states , sampled_replica_results ) no_exchange_proposed , _ = tf . compat . v1 . setdiff1d ( tf . range ( self . num_replica ) , tf . reshape ( exchange_proposed , [ - 1 ] ) ) exchanged_states = self . _insert_old_states_where_no_exchange_was_proposed ( no_exchange_proposed , old_states , exchanged_states ) next_replica_states = [ ] for i in range ( self . num_replica ) : next_replica_states_i = [ ] for k in range ( num_state_parts ) : next_replica_states_i . append ( exchanged_states [ k ] . read ( i ) ) next_replica_states . append ( next_replica_states_i ) if not states_are_lists : next_replica_states = [ s [ 0 ] for s in next_replica_states ] sampled_replica_states = [ s [ 0 ] for s in sampled_replica_states ] # Now that states are/aren't exchanged, bootstrap next kernel_results. # The viewpoint is that after each exchange, we are starting anew. next_replica_results = [ rk . bootstrap_results ( state ) for rk , state in zip ( self . replica_kernels , next_replica_states ) ] next_state = next_replica_states [ 0 ] # Replica 0 is the returned state(s). kernel_results = ReplicaExchangeMCKernelResults ( replica_states = next_replica_states , replica_results = next_replica_results , sampled_replica_states = sampled_replica_states , sampled_replica_results = sampled_replica_results , ) return next_state , kernel_results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_exchanged_states ( self , old_states , exchange_proposed , exchange_proposed_n , sampled_replica_states , sampled_replica_results ) : with tf . compat . v1 . name_scope ( 'get_exchanged_states' ) : target_log_probs = [ ] for replica in range ( self . num_replica ) : replica_log_prob = _get_field ( sampled_replica_results [ replica ] , 'target_log_prob' ) inverse_temp = self . inverse_temperatures [ replica ] target_log_probs . append ( replica_log_prob / inverse_temp ) target_log_probs = tf . stack ( target_log_probs , axis = 0 ) dtype = target_log_probs . dtype num_state_parts = len ( sampled_replica_states [ 0 ] ) # exchanged_states[k][i] is Tensor of (new) state part k, for replica i. # The `k` will be known statically, and `i` is a Tensor. # We will insert values into indices `i` for every replica with a proposed # exchange. exchanged_states = [ tf . TensorArray ( dtype , size = self . num_replica , dynamic_size = False , tensor_array_name = 'exchanged_states' , # State part k has same shape, regardless of replica. So use 0. element_shape = sampled_replica_states [ 0 ] [ k ] . shape ) for k in range ( num_state_parts ) ] # Draw random variables here, to avoid sampling in the loop (and losing # reproducibility). This may mean we sample too many, but we will always # have enough. sample_shape = tf . concat ( ( [ self . num_replica // 2 ] , tf . shape ( input = target_log_probs ) [ 1 : ] ) , axis = 0 ) log_uniforms = tf . math . log ( tf . random . uniform ( shape = sample_shape , dtype = dtype , seed = self . _seed_stream ( ) ) ) def _swap ( is_exchange_accepted , x , y ) : \"\"\"Swap batches of x, y where accepted.\"\"\" with tf . compat . v1 . name_scope ( 'swap_where_exchange_accepted' ) : new_x = mcmc_util . choose ( is_exchange_accepted , y , x ) new_y = mcmc_util . choose ( is_exchange_accepted , x , y ) return new_x , new_y def cond ( i , unused_exchanged_states ) : return i < exchange_proposed_n def body ( i , exchanged_states ) : \"\"\"Body of while loop for exchanging states.\"\"\" # Propose exchange between replicas indexed by m and n. m , n = tf . unstack ( exchange_proposed [ i ] ) # Construct log_accept_ratio: -temp_diff * target_log_prob_diff. # Note target_log_prob_diff = -EnergyDiff (common definition is in terms # of energy). temp_diff = self . inverse_temperatures [ m ] - self . inverse_temperatures [ n ] # Difference of target log probs may be +- Inf or NaN. We want the # product of this with the temperature difference to have \"alt value\" of # -Inf. log_accept_ratio = mcmc_util . safe_sum ( [ - temp_diff * target_log_probs [ m ] , temp_diff * target_log_probs [ n ] ] ) is_exchange_accepted = log_uniforms [ i ] < log_accept_ratio for k in range ( num_state_parts ) : new_m , new_n = _swap ( is_exchange_accepted , old_states [ k ] . read ( m ) , old_states [ k ] . read ( n ) ) exchanged_states [ k ] = exchanged_states [ k ] . write ( m , new_m ) exchanged_states [ k ] = exchanged_states [ k ] . write ( n , new_n ) return i + 1 , exchanged_states # At this point, exchanged_states[k] is a length num_replicas TensorArray. return tf . while_loop ( cond = cond , body = body , loop_vars = [ tf . constant ( 0 ) , exchanged_states ] ) [ 1 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bootstrap_results ( self , init_state ) : with tf . compat . v1 . name_scope ( name = mcmc_util . make_name ( self . name , 'remc' , 'bootstrap_results' ) , values = [ init_state ] ) : replica_results = [ self . replica_kernels [ i ] . bootstrap_results ( init_state ) for i in range ( self . num_replica ) ] init_state_parts = ( list ( init_state ) if mcmc_util . is_list_like ( init_state ) else [ init_state ] ) # Convert all states parts to tensor... replica_states = [ [ tf . convert_to_tensor ( value = s ) for s in init_state_parts ] for i in range ( self . num_replica ) ] if not mcmc_util . is_list_like ( init_state ) : replica_states = [ s [ 0 ] for s in replica_states ] return ReplicaExchangeMCKernelResults ( replica_states = replica_states , replica_results = replica_results , sampled_replica_states = replica_states , sampled_replica_results = replica_results , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _variance_scale_term ( self ) : # Expand back the last dim so the shape of _variance_scale_term matches the # shape of self.concentration. c0 = self . total_concentration [ ... , tf . newaxis ] return tf . sqrt ( ( 1. + c0 / self . total_count [ ... , tf . newaxis ] ) / ( 1. + c0 ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_assert_valid_concentration ( self , concentration , validate_args ) : if not validate_args : return concentration concentration = distribution_util . embed_check_categorical_event_shape ( concentration ) return distribution_util . with_dependencies ( [ assert_util . assert_positive ( concentration , message = \"Concentration parameter must be positive.\" ) , ] , concentration )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_assert_valid_sample ( self , counts ) : if not self . validate_args : return counts counts = distribution_util . embed_check_nonnegative_integer_form ( counts ) return distribution_util . with_dependencies ( [ assert_util . assert_equal ( self . total_count , tf . reduce_sum ( input_tensor = counts , axis = - 1 ) , message = \"counts last-dimension must sum to `self.total_count`\" ) , ] , counts )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def forward_log_det_jacobian_fn ( bijector ) : if not mcmc_util . is_list_like ( bijector ) : bijector = [ bijector ] def fn ( transformed_state_parts , event_ndims ) : return sum ( [ b . forward_log_det_jacobian ( sp , event_ndims = e ) for b , e , sp in zip ( bijector , event_ndims , transformed_state_parts ) ] ) return fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def forward_transform_fn ( bijector ) : if not mcmc_util . is_list_like ( bijector ) : bijector = [ bijector ] def fn ( transformed_state_parts ) : return [ b . forward ( sp ) for b , sp in zip ( bijector , transformed_state_parts ) ] return fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def inverse_transform_fn ( bijector ) : if not mcmc_util . is_list_like ( bijector ) : bijector = [ bijector ] def fn ( state_parts ) : return [ b . inverse ( sp ) for b , sp in zip ( bijector , state_parts ) ] return fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def one_step ( self , current_state , previous_kernel_results ) : with tf . compat . v1 . name_scope ( name = mcmc_util . make_name ( self . name , 'transformed_kernel' , 'one_step' ) , values = [ previous_kernel_results ] ) : transformed_next_state , kernel_results = self . _inner_kernel . one_step ( previous_kernel_results . transformed_state , previous_kernel_results . inner_results ) transformed_next_state_parts = ( transformed_next_state if mcmc_util . is_list_like ( transformed_next_state ) else [ transformed_next_state ] ) next_state_parts = self . _forward_transform ( transformed_next_state_parts ) next_state = ( next_state_parts if mcmc_util . is_list_like ( transformed_next_state ) else next_state_parts [ 0 ] ) kernel_results = TransformedTransitionKernelResults ( transformed_state = transformed_next_state , inner_results = kernel_results ) return next_state , kernel_results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bootstrap_results ( self , init_state = None , transformed_init_state = None ) : if ( init_state is None ) == ( transformed_init_state is None ) : raise ValueError ( 'Must specify exactly one of `init_state` ' 'or `transformed_init_state`.' ) with tf . compat . v1 . name_scope ( name = mcmc_util . make_name ( self . name , 'transformed_kernel' , 'bootstrap_results' ) , values = [ init_state , transformed_init_state ] ) : if transformed_init_state is None : init_state_parts = ( init_state if mcmc_util . is_list_like ( init_state ) else [ init_state ] ) transformed_init_state_parts = self . _inverse_transform ( init_state_parts ) transformed_init_state = ( transformed_init_state_parts if mcmc_util . is_list_like ( init_state ) else transformed_init_state_parts [ 0 ] ) else : if mcmc_util . is_list_like ( transformed_init_state ) : transformed_init_state = [ tf . convert_to_tensor ( value = s , name = 'transformed_init_state' ) for s in transformed_init_state ] else : transformed_init_state = tf . convert_to_tensor ( value = transformed_init_state , name = 'transformed_init_state' ) kernel_results = TransformedTransitionKernelResults ( transformed_state = transformed_init_state , inner_results = self . _inner_kernel . bootstrap_results ( transformed_init_state ) ) return kernel_results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def val_where ( cond , tval , fval ) : if isinstance ( tval , tf . Tensor ) : return tf . where ( cond , tval , fval ) elif isinstance ( tval , tuple ) : cls = type ( tval ) return cls ( * ( val_where ( cond , t , f ) for t , f in zip ( tval , fval ) ) ) else : raise Exception ( TypeError )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def secant2 ( value_and_gradients_function , val_0 , search_interval , f_lim , sufficient_decrease_param = 0.1 , curvature_param = 0.9 , name = None ) : with tf . compat . v1 . name_scope ( name , 'secant2' , [ val_0 , search_interval , f_lim , sufficient_decrease_param , curvature_param ] ) : # This will always be s.t. left <= c <= right val_c = value_and_gradients_function ( _secant ( search_interval . left , search_interval . right ) ) failed = search_interval . failed | ~ is_finite ( val_c ) converged = search_interval . converged | ( ~ failed & _satisfies_wolfe ( val_0 , val_c , f_lim , sufficient_decrease_param , curvature_param ) ) new_converged = converged & ~ search_interval . converged val_left = val_where ( new_converged , val_c , search_interval . left ) val_right = val_where ( new_converged , val_c , search_interval . right ) initial_args = _Secant2Result ( active = ~ failed & ~ converged , converged = converged , failed = failed , num_evals = search_interval . func_evals + 1 , left = val_left , right = val_right ) def _apply_secant2_inner ( ) : return _secant2_inner ( value_and_gradients_function , initial_args , val_0 , val_c , f_lim , sufficient_decrease_param , curvature_param ) return prefer_static . cond ( tf . reduce_any ( input_tensor = initial_args . active ) , _apply_secant2_inner , lambda : initial_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _secant2_inner ( value_and_gradients_function , initial_args , val_0 , val_c , f_lim , sufficient_decrease_param , curvature_param ) : # Apply the `update` function on active branch members to squeeze their # bracketing interval. update_result = update ( value_and_gradients_function , initial_args . left , initial_args . right , val_c , f_lim , active = initial_args . active ) # Update active and failed flags, update left/right on non-failed entries. active = initial_args . active & ~ update_result . failed failed = initial_args . failed | update_result . failed val_left = val_where ( active , update_result . left , initial_args . left ) val_right = val_where ( active , update_result . right , initial_args . right ) # Check if new `c` points should be generated. updated_left = active & tf . equal ( val_left . x , val_c . x ) updated_right = active & tf . equal ( val_right . x , val_c . x ) is_new = updated_left | updated_right next_c = tf . where ( updated_left , _secant ( initial_args . left , val_left ) , val_c . x ) next_c = tf . where ( updated_right , _secant ( initial_args . right , val_right ) , next_c ) in_range = ( val_left . x <= next_c ) & ( next_c <= val_right . x ) # Figure out if an extra function evaluation is needed for new `c` points. needs_extra_eval = tf . reduce_any ( input_tensor = in_range & is_new ) num_evals = initial_args . num_evals + update_result . num_evals num_evals = num_evals + tf . cast ( needs_extra_eval , num_evals . dtype ) next_args = _Secant2Result ( active = active & in_range , # No longer active if `c` is out of range. converged = initial_args . converged , failed = failed , num_evals = num_evals , left = val_left , right = val_right ) def _apply_inner_update ( ) : next_val_c = prefer_static . cond ( needs_extra_eval , ( lambda : value_and_gradients_function ( next_c ) ) , ( lambda : val_c ) ) return _secant2_inner_update ( value_and_gradients_function , next_args , val_0 , next_val_c , f_lim , sufficient_decrease_param , curvature_param ) return prefer_static . cond ( tf . reduce_any ( input_tensor = next_args . active ) , _apply_inner_update , lambda : next_args )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _secant2_inner_update ( value_and_gradients_function , initial_args , val_0 , val_c , f_lim , sufficient_decrease_param , curvature_param ) : # Fail if `val_c` is no longer finite. new_failed = initial_args . active & ~ is_finite ( val_c ) active = initial_args . active & ~ new_failed failed = initial_args . failed | new_failed # We converge when we find a point satisfying the Wolfe conditions, in those # cases we set `val_left = val_right = val_c`. found_wolfe = active & _satisfies_wolfe ( val_0 , val_c , f_lim , sufficient_decrease_param , curvature_param ) val_left = val_where ( found_wolfe , val_c , initial_args . left ) val_right = val_where ( found_wolfe , val_c , initial_args . right ) converged = initial_args . converged | found_wolfe active = active & ~ found_wolfe # If any active batch members remain, we apply the `update` function to # squeeze further their corresponding left/right bracketing interval. def _apply_update ( ) : update_result = update ( value_and_gradients_function , val_left , val_right , val_c , f_lim , active = active ) return _Secant2Result ( active = tf . zeros_like ( active ) , # End of secant2, no actives anymore. converged = converged , failed = failed | update_result . failed , num_evals = initial_args . num_evals + update_result . num_evals , left = update_result . left , right = update_result . right ) # Otherwise just return the current results. def _default ( ) : return _Secant2Result ( active = active , converged = converged , failed = failed , num_evals = initial_args . num_evals , left = val_left , right = val_right ) return prefer_static . cond ( tf . reduce_any ( input_tensor = active ) , _apply_update , _default )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def update ( value_and_gradients_function , val_left , val_right , val_trial , f_lim , active = None ) : # We should only update if the trial point is within the interval. within_range = ( val_left . x < val_trial . x ) & ( val_trial . x < val_right . x ) if active is not None : within_range = within_range & active # The new point is a valid left end point if it has negative slope # and the value at the point is not too large. valid_left = ( val_trial . df < 0 ) & ( val_trial . f <= f_lim ) # If the trial point has a negative slope but the value at that point # is too high, bisect can narrow down an interval between the current left # and the trial point. needs_bisect = within_range & ( val_trial . df < 0 ) & ( val_trial . f > f_lim ) # Note that if `~valid_left` it is because either: # - the slope at the trial point is positive, so it is a valid right # point, or # - the needs_bisect condition is true. # In both cases we want to keep the current left and replace right # with the trial point. left = val_where ( within_range & valid_left , val_trial , val_left ) right = val_where ( within_range & ~ valid_left , val_trial , val_right ) bisect_args = _IntermediateResult ( iteration = tf . convert_to_tensor ( value = 0 ) , stopped = ~ needs_bisect , failed = tf . zeros_like ( within_range ) , # i.e. all false. num_evals = tf . convert_to_tensor ( value = 0 ) , left = left , right = right ) return _bisect ( value_and_gradients_function , bisect_args , f_lim )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bracket ( value_and_gradients_function , search_interval , f_lim , max_iterations , expansion_param = 5.0 ) : already_stopped = search_interval . failed | search_interval . converged # If the slope at right end point is positive, step B1 in [2], then the given # initial points already bracket a minimum. bracketed = search_interval . right . df >= 0 # Bisection is needed, step B2, if right end point almost works as a new left # end point but the objective value is too high. needs_bisect = ( search_interval . right . df < 0 ) & ( search_interval . right . f > f_lim ) # In these three cases bracketing is already `stopped` and there is no need # to perform further evaluations. Otherwise the bracketing loop is needed to # expand the interval, step B3, until the conditions are met. initial_args = _IntermediateResult ( iteration = search_interval . iterations , stopped = already_stopped | bracketed | needs_bisect , failed = search_interval . failed , num_evals = search_interval . func_evals , left = search_interval . left , right = search_interval . right ) def _loop_cond ( curr ) : return ( curr . iteration < max_iterations ) & ~ tf . reduce_all ( input_tensor = curr . stopped ) def _loop_body ( curr ) : \"\"\"Main body of bracketing loop.\"\"\" # The loop maintains the invariant that curr.stopped is true if we have # either: failed, successfully bracketed, or not yet bracketed but needs # bisect. On the only remaining case, step B3 in [2]. case we need to # expand and update the left/right values appropriately. new_right = value_and_gradients_function ( expansion_param * curr . right . x ) left = val_where ( curr . stopped , curr . left , curr . right ) right = val_where ( curr . stopped , curr . right , new_right ) # Updated the failed, bracketed, and needs_bisect conditions. failed = curr . failed | ~ is_finite ( right ) bracketed = right . df >= 0 needs_bisect = ( right . df < 0 ) & ( right . f > f_lim ) return [ _IntermediateResult ( iteration = curr . iteration + 1 , stopped = curr . stopped | failed | bracketed | needs_bisect , failed = failed , num_evals = curr . num_evals + 1 , left = left , right = right ) ] bracket_result = tf . while_loop ( cond = _loop_cond , body = _loop_body , loop_vars = [ initial_args ] ) [ 0 ] # For entries where bisect is still needed, mark them as not yet stopped, # reset the left end point, and run `_bisect` on them. needs_bisect = ( ( bracket_result . right . df < 0 ) & ( bracket_result . right . f > f_lim ) ) stopped = already_stopped | bracket_result . failed | ~ needs_bisect left = val_where ( stopped , bracket_result . left , search_interval . left ) bisect_args = bracket_result . _replace ( stopped = stopped , left = left ) return _bisect ( value_and_gradients_function , bisect_args , f_lim )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bisect ( value_and_gradients_function , initial_left , initial_right , f_lim ) : failed = ~ is_finite ( initial_left , initial_right ) needs_bisect = ( initial_right . df < 0 ) & ( initial_right . f > f_lim ) bisect_args = _IntermediateResult ( iteration = tf . convert_to_tensor ( value = 0 ) , stopped = failed | ~ needs_bisect , failed = failed , num_evals = tf . convert_to_tensor ( value = 0 ) , left = initial_left , right = initial_right ) return _bisect ( value_and_gradients_function , bisect_args , f_lim )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _bisect ( value_and_gradients_function , initial_args , f_lim ) : def _loop_cond ( curr ) : # TODO(b/112524024): Also take into account max_iterations. return ~ tf . reduce_all ( input_tensor = curr . stopped ) def _loop_body ( curr ) : \"\"\"Narrow down interval to satisfy opposite slope conditions.\"\"\" mid = value_and_gradients_function ( ( curr . left . x + curr . right . x ) / 2 ) # Fail if function values at mid point are no longer finite; or left/right # points are so close to it that we can't distinguish them any more. failed = ( curr . failed | ~ is_finite ( mid ) | tf . equal ( mid . x , curr . left . x ) | tf . equal ( mid . x , curr . right . x ) ) # If mid point has a negative slope and the function value at that point is # small enough, we can use it as a new left end point to narrow down the # interval. If mid point has a positive slope, then we have found a suitable # right end point to bracket a minima within opposite slopes. Otherwise, the # mid point has a negative slope but the function value at that point is too # high to work as left end point, we are in the same situation in which we # started the loop so we just update the right end point and continue. to_update = ~ ( curr . stopped | failed ) update_left = ( mid . df < 0 ) & ( mid . f <= f_lim ) left = val_where ( to_update & update_left , mid , curr . left ) right = val_where ( to_update & ~ update_left , mid , curr . right ) # We're done when the right end point has a positive slope. stopped = curr . stopped | failed | ( right . df >= 0 ) return [ _IntermediateResult ( iteration = curr . iteration , stopped = stopped , failed = failed , num_evals = curr . num_evals + 1 , left = left , right = right ) ] # The interval needs updating if the right end point has a negative slope and # the value of the function at that point is too high. It is not a valid left # end point but along with the current left end point, it encloses another # minima. The loop above tries to narrow the interval so that it satisfies the # opposite slope conditions. return tf . while_loop ( cond = _loop_cond , body = _loop_body , loop_vars = [ initial_args ] ) [ 0 ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def is_finite ( val_1 , val_2 = None ) : val_1_finite = tf . math . is_finite ( val_1 . f ) & tf . math . is_finite ( val_1 . df ) if val_2 is not None : return val_1_finite & tf . math . is_finite ( val_2 . f ) & tf . math . is_finite ( val_2 . df ) return val_1_finite\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _satisfies_wolfe ( val_0 , val_c , f_lim , sufficient_decrease_param , curvature_param ) : exact_wolfe_suff_dec = ( sufficient_decrease_param * val_0 . df >= ( val_c . f - val_0 . f ) / val_c . x ) wolfe_curvature = val_c . df >= curvature_param * val_0 . df exact_wolfe = exact_wolfe_suff_dec & wolfe_curvature approx_wolfe_applies = val_c . f <= f_lim approx_wolfe_suff_dec = ( ( 2 * sufficient_decrease_param - 1 ) * val_0 . df >= val_c . df ) approx_wolfe = approx_wolfe_applies & approx_wolfe_suff_dec & wolfe_curvature is_satisfied = exact_wolfe | approx_wolfe return is_satisfied\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _secant ( val_a , val_b ) : return ( val_a . x * val_b . df - val_b . x * val_a . df ) / ( val_b . df - val_a . df )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_simple_step_size_update_policy ( num_adaptation_steps , target_rate = 0.75 , decrement_multiplier = 0.01 , increment_multiplier = 0.01 , step_counter = None ) : if step_counter is None and num_adaptation_steps is not None : step_counter = tf . compat . v1 . get_variable ( name = 'step_size_adaptation_step_counter' , initializer = np . array ( - 1 , dtype = np . int32 ) , # Specify the dtype for variable sharing to work correctly # (b/120599991). dtype = tf . int32 , trainable = False , use_resource = True ) def step_size_simple_update_fn ( step_size_var , kernel_results ) : \"\"\"Updates (list of) `step_size` using a standard adaptive MCMC procedure. Args: step_size_var: (List of) `tf.Variable`s representing the per `state_part` HMC `step_size`. kernel_results: `collections.namedtuple` containing `Tensor`s representing values from most recent call to `one_step`. Returns: step_size_assign: (List of) `Tensor`(s) representing updated `step_size_var`(s). \"\"\" if kernel_results is None : if mcmc_util . is_list_like ( step_size_var ) : return [ tf . identity ( ss ) for ss in step_size_var ] return tf . identity ( step_size_var ) log_n = tf . math . log ( tf . cast ( tf . size ( input = kernel_results . log_accept_ratio ) , kernel_results . log_accept_ratio . dtype ) ) log_mean_accept_ratio = tf . reduce_logsumexp ( input_tensor = tf . minimum ( kernel_results . log_accept_ratio , 0. ) ) - log_n adjustment = tf . where ( log_mean_accept_ratio < tf . cast ( tf . math . log ( target_rate ) , log_mean_accept_ratio . dtype ) , - decrement_multiplier / ( 1. + decrement_multiplier ) , increment_multiplier ) def build_assign_op ( ) : if mcmc_util . is_list_like ( step_size_var ) : return [ ss . assign_add ( ss * tf . cast ( adjustment , ss . dtype ) ) for ss in step_size_var ] return step_size_var . assign_add ( step_size_var * tf . cast ( adjustment , step_size_var . dtype ) ) if num_adaptation_steps is None : return build_assign_op ( ) else : with tf . control_dependencies ( [ step_counter . assign_add ( 1 ) ] ) : return tf . cond ( pred = step_counter < num_adaptation_steps , true_fn = build_assign_op , false_fn = lambda : step_size_var ) return step_size_simple_update_fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _leapfrog_integrator_one_step ( target_log_prob_fn , independent_chain_ndims , step_sizes , current_momentum_parts , current_state_parts , current_target_log_prob , current_target_log_prob_grad_parts , state_gradients_are_stopped = False , name = None ) : # Note on per-variable step sizes: # # Using per-variable step sizes is equivalent to using the same step # size for all variables and adding a diagonal mass matrix in the # kinetic energy term of the Hamiltonian being integrated. This is # hinted at by Neal (2011) but not derived in detail there. # # Let x and v be position and momentum variables respectively. # Let g(x) be the gradient of `target_log_prob_fn(x)`. # Let S be a diagonal matrix of per-variable step sizes. # Let the Hamiltonian H(x, v) = -target_log_prob_fn(x) + 0.5 * ||v||**2. # # Using per-variable step sizes gives the updates # v' = v + 0.5 * matmul(S, g(x)) # x'' = x + matmul(S, v') # v'' = v' + 0.5 * matmul(S, g(x'')) # # Let u = matmul(inv(S), v). # Multiplying v by inv(S) in the updates above gives the transformed dynamics # u' = matmul(inv(S), v') = matmul(inv(S), v) + 0.5 * g(x) # = u + 0.5 * g(x) # x'' = x + matmul(S, v') = x + matmul(S**2, u') # u'' = matmul(inv(S), v'') = matmul(inv(S), v') + 0.5 * g(x'') # = u' + 0.5 * g(x'') # # These are exactly the leapfrog updates for the Hamiltonian # H'(x, u) = -target_log_prob_fn(x) + 0.5 * u^T S**2 u # = -target_log_prob_fn(x) + 0.5 * ||v||**2 = H(x, v). # # To summarize: # # * Using per-variable step sizes implicitly simulates the dynamics # of the Hamiltonian H' (which are energy-conserving in H'). We # keep track of v instead of u, but the underlying dynamics are # the same if we transform back. # * The value of the Hamiltonian H'(x, u) is the same as the value # of the original Hamiltonian H(x, v) after we transform back from # u to v. # * Sampling v ~ N(0, I) is equivalent to sampling u ~ N(0, S**-2). # # So using per-variable step sizes in HMC will give results that are # exactly identical to explicitly using a diagonal mass matrix. with tf . compat . v1 . name_scope ( name , 'hmc_leapfrog_integrator_one_step' , [ independent_chain_ndims , step_sizes , current_momentum_parts , current_state_parts , current_target_log_prob , current_target_log_prob_grad_parts ] ) : # Step 1: Update momentum. proposed_momentum_parts = [ v + 0.5 * tf . cast ( eps , v . dtype ) * g for v , eps , g in zip ( current_momentum_parts , step_sizes , current_target_log_prob_grad_parts ) ] # Step 2: Update state. proposed_state_parts = [ x + tf . cast ( eps , v . dtype ) * v for x , eps , v in zip ( current_state_parts , step_sizes , proposed_momentum_parts ) ] if state_gradients_are_stopped : proposed_state_parts = [ tf . stop_gradient ( x ) for x in proposed_state_parts ] # Step 3a: Re-evaluate target-log-prob (and grad) at proposed state. [ proposed_target_log_prob , proposed_target_log_prob_grad_parts , ] = mcmc_util . maybe_call_fn_and_grads ( target_log_prob_fn , proposed_state_parts ) if not proposed_target_log_prob . dtype . is_floating : raise TypeError ( '`target_log_prob_fn` must produce a `Tensor` ' 'with `float` `dtype`.' ) if any ( g is None for g in proposed_target_log_prob_grad_parts ) : raise ValueError ( 'Encountered `None` gradient. Does your target `target_log_prob_fn` ' 'access all `tf.Variable`s via `tf.get_variable`?\\n' ' current_state_parts: {}\\n' ' proposed_state_parts: {}\\n' ' proposed_target_log_prob_grad_parts: {}' . format ( current_state_parts , proposed_state_parts , proposed_target_log_prob_grad_parts ) ) # Step 3b: Update momentum (again). proposed_momentum_parts = [ v + 0.5 * tf . cast ( eps , v . dtype ) * g for v , eps , g in zip ( proposed_momentum_parts , step_sizes , proposed_target_log_prob_grad_parts ) ] return [ proposed_momentum_parts , proposed_state_parts , proposed_target_log_prob , proposed_target_log_prob_grad_parts , ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _compute_log_acceptance_correction ( current_momentums , proposed_momentums , independent_chain_ndims , name = None ) : with tf . compat . v1 . name_scope ( name , 'compute_log_acceptance_correction' , [ independent_chain_ndims , current_momentums , proposed_momentums ] ) : log_current_kinetic , log_proposed_kinetic = [ ] , [ ] for current_momentum , proposed_momentum in zip ( current_momentums , proposed_momentums ) : axis = tf . range ( independent_chain_ndims , tf . rank ( current_momentum ) ) log_current_kinetic . append ( _log_sum_sq ( current_momentum , axis ) ) log_proposed_kinetic . append ( _log_sum_sq ( proposed_momentum , axis ) ) current_kinetic = 0.5 * tf . exp ( tf . reduce_logsumexp ( input_tensor = tf . stack ( log_current_kinetic , axis = - 1 ) , axis = - 1 ) ) proposed_kinetic = 0.5 * tf . exp ( tf . reduce_logsumexp ( input_tensor = tf . stack ( log_proposed_kinetic , axis = - 1 ) , axis = - 1 ) ) return mcmc_util . safe_sum ( [ current_kinetic , - proposed_kinetic ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _prepare_args ( target_log_prob_fn , state , step_size , target_log_prob = None , grads_target_log_prob = None , maybe_expand = False , state_gradients_are_stopped = False ) : state_parts = list ( state ) if mcmc_util . is_list_like ( state ) else [ state ] state_parts = [ tf . convert_to_tensor ( value = s , name = 'current_state' ) for s in state_parts ] if state_gradients_are_stopped : state_parts = [ tf . stop_gradient ( x ) for x in state_parts ] target_log_prob , grads_target_log_prob = mcmc_util . maybe_call_fn_and_grads ( target_log_prob_fn , state_parts , target_log_prob , grads_target_log_prob ) step_sizes = ( list ( step_size ) if mcmc_util . is_list_like ( step_size ) else [ step_size ] ) step_sizes = [ tf . convert_to_tensor ( value = s , name = 'step_size' , dtype = target_log_prob . dtype ) for s in step_sizes ] if len ( step_sizes ) == 1 : step_sizes *= len ( state_parts ) if len ( state_parts ) != len ( step_sizes ) : raise ValueError ( 'There should be exactly one `step_size` or it should ' 'have same length as `current_state`.' ) def maybe_flatten ( x ) : return x if maybe_expand or mcmc_util . is_list_like ( state ) else x [ 0 ] return [ maybe_flatten ( state_parts ) , maybe_flatten ( step_sizes ) , target_log_prob , grads_target_log_prob , ]\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _log_sum_sq ( x , axis = None ) : return tf . reduce_logsumexp ( input_tensor = 2. * tf . math . log ( tf . abs ( x ) ) , axis = axis )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def one_step ( self , current_state , previous_kernel_results ) : previous_step_size_assign = ( [ ] if self . step_size_update_fn is None else ( previous_kernel_results . extra . step_size_assign if mcmc_util . is_list_like ( previous_kernel_results . extra . step_size_assign ) else [ previous_kernel_results . extra . step_size_assign ] ) ) with tf . control_dependencies ( previous_step_size_assign ) : next_state , kernel_results = self . _impl . one_step ( current_state , previous_kernel_results ) if self . step_size_update_fn is not None : step_size_assign = self . step_size_update_fn ( # pylint: disable=not-callable self . step_size , kernel_results ) kernel_results = kernel_results . _replace ( extra = HamiltonianMonteCarloExtraKernelResults ( step_size_assign = step_size_assign ) ) return next_state , kernel_results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bootstrap_results ( self , init_state ) : kernel_results = self . _impl . bootstrap_results ( init_state ) if self . step_size_update_fn is not None : step_size_assign = self . step_size_update_fn ( self . step_size , None ) # pylint: disable=not-callable kernel_results = kernel_results . _replace ( extra = HamiltonianMonteCarloExtraKernelResults ( step_size_assign = step_size_assign ) ) return kernel_results\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def bayesian_resnet ( input_shape , num_classes = 10 , kernel_posterior_scale_mean = - 9.0 , kernel_posterior_scale_stddev = 0.1 , kernel_posterior_scale_constraint = 0.2 ) : filters = [ 64 , 128 , 256 , 512 ] kernels = [ 3 , 3 , 3 , 3 ] strides = [ 1 , 2 , 2 , 2 ] def _untransformed_scale_constraint ( t ) : return tf . clip_by_value ( t , - 1000 , tf . math . log ( kernel_posterior_scale_constraint ) ) kernel_posterior_fn = tfp . layers . default_mean_field_normal_fn ( untransformed_scale_initializer = tf . compat . v1 . initializers . random_normal ( mean = kernel_posterior_scale_mean , stddev = kernel_posterior_scale_stddev ) , untransformed_scale_constraint = _untransformed_scale_constraint ) image = tf . keras . layers . Input ( shape = input_shape , dtype = 'float32' ) x = tfp . layers . Convolution2DFlipout ( 64 , 3 , strides = 1 , padding = 'same' , kernel_posterior_fn = kernel_posterior_fn ) ( image ) for i in range ( len ( kernels ) ) : x = _resnet_block ( x , filters [ i ] , kernels [ i ] , strides [ i ] , kernel_posterior_fn ) x = tf . keras . layers . BatchNormalization ( ) ( x ) x = tf . keras . layers . Activation ( 'relu' ) ( x ) x = tf . keras . layers . AveragePooling2D ( 4 , 1 ) ( x ) x = tf . keras . layers . Flatten ( ) ( x ) x = tfp . layers . DenseFlipout ( num_classes , kernel_posterior_fn = kernel_posterior_fn ) ( x ) model = tf . keras . Model ( inputs = image , outputs = x , name = 'resnet18' ) return model\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _resnet_block ( x , filters , kernel , stride , kernel_posterior_fn ) : x = tf . keras . layers . BatchNormalization ( ) ( x ) x = tf . keras . layers . Activation ( 'relu' ) ( x ) if stride != 1 or filters != x . shape [ 1 ] : shortcut = _projection_shortcut ( x , filters , stride , kernel_posterior_fn ) else : shortcut = x x = tfp . layers . Convolution2DFlipout ( filters , kernel , strides = stride , padding = 'same' , kernel_posterior_fn = kernel_posterior_fn ) ( x ) x = tf . keras . layers . BatchNormalization ( ) ( x ) x = tf . keras . layers . Activation ( 'relu' ) ( x ) x = tfp . layers . Convolution2DFlipout ( filters , kernel , strides = 1 , padding = 'same' , kernel_posterior_fn = kernel_posterior_fn ) ( x ) x = tf . keras . layers . add ( [ x , shortcut ] ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_encoder ( activation , num_topics , layer_sizes ) : encoder_net = tf . keras . Sequential ( ) for num_hidden_units in layer_sizes : encoder_net . add ( tf . keras . layers . Dense ( num_hidden_units , activation = activation , kernel_initializer = tf . compat . v1 . glorot_normal_initializer ( ) ) ) encoder_net . add ( tf . keras . layers . Dense ( num_topics , activation = tf . nn . softplus , kernel_initializer = tf . compat . v1 . glorot_normal_initializer ( ) ) ) def encoder ( bag_of_words ) : net = _clip_dirichlet_parameters ( encoder_net ( bag_of_words ) ) return tfd . Dirichlet ( concentration = net , name = \"topics_posterior\" ) return encoder\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_decoder ( num_topics , num_words ) : topics_words_logits = tf . compat . v1 . get_variable ( \"topics_words_logits\" , shape = [ num_topics , num_words ] , initializer = tf . compat . v1 . glorot_normal_initializer ( ) ) topics_words = tf . nn . softmax ( topics_words_logits , axis = - 1 ) def decoder ( topics ) : word_probs = tf . matmul ( topics , topics_words ) # The observations are bag of words and therefore not one-hot. However, # log_prob of OneHotCategorical computes the probability correctly in # this case. return tfd . OneHotCategorical ( probs = word_probs , name = \"bag_of_words\" ) return decoder , topics_words\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_prior ( num_topics , initial_value ) : def _softplus_inverse ( x ) : return np . log ( np . expm1 ( x ) ) logit_concentration = tf . compat . v1 . get_variable ( \"logit_concentration\" , shape = [ 1 , num_topics ] , initializer = tf . compat . v1 . initializers . constant ( _softplus_inverse ( initial_value ) ) ) concentration = _clip_dirichlet_parameters ( tf . nn . softplus ( logit_concentration ) ) def prior ( ) : return tfd . Dirichlet ( concentration = concentration , name = \"topics_prior\" ) prior_variables = [ logit_concentration ] return prior , prior_variables\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def model_fn ( features , labels , mode , params , config ) : del labels , config encoder = make_encoder ( params [ \"activation\" ] , params [ \"num_topics\" ] , params [ \"layer_sizes\" ] ) decoder , topics_words = make_decoder ( params [ \"num_topics\" ] , features . shape [ 1 ] ) prior , prior_variables = make_prior ( params [ \"num_topics\" ] , params [ \"prior_initial_value\" ] ) topics_prior = prior ( ) alpha = topics_prior . concentration topics_posterior = encoder ( features ) topics = topics_posterior . sample ( ) random_reconstruction = decoder ( topics ) reconstruction = random_reconstruction . log_prob ( features ) tf . compat . v1 . summary . scalar ( \"reconstruction\" , tf . reduce_mean ( input_tensor = reconstruction ) ) # Compute the KL-divergence between two Dirichlets analytically. # The sampled KL does not work well for \"sparse\" distributions # (see Appendix D of [2]). kl = tfd . kl_divergence ( topics_posterior , topics_prior ) tf . compat . v1 . summary . scalar ( \"kl\" , tf . reduce_mean ( input_tensor = kl ) ) # Ensure that the KL is non-negative (up to a very small slack). # Negative KL can happen due to numerical instability. with tf . control_dependencies ( [ tf . compat . v1 . assert_greater ( kl , - 1e-3 , message = \"kl\" ) ] ) : kl = tf . identity ( kl ) elbo = reconstruction - kl avg_elbo = tf . reduce_mean ( input_tensor = elbo ) tf . compat . v1 . summary . scalar ( \"elbo\" , avg_elbo ) loss = - avg_elbo # Perform variational inference by minimizing the -ELBO. global_step = tf . compat . v1 . train . get_or_create_global_step ( ) optimizer = tf . compat . v1 . train . AdamOptimizer ( params [ \"learning_rate\" ] ) # This implements the \"burn-in\" for prior parameters (see Appendix D of [2]). # For the first prior_burn_in_steps steps they are fixed, and then trained # jointly with the other parameters. grads_and_vars = optimizer . compute_gradients ( loss ) grads_and_vars_except_prior = [ x for x in grads_and_vars if x [ 1 ] not in prior_variables ] def train_op_except_prior ( ) : return optimizer . apply_gradients ( grads_and_vars_except_prior , global_step = global_step ) def train_op_all ( ) : return optimizer . apply_gradients ( grads_and_vars , global_step = global_step ) train_op = tf . cond ( pred = global_step < params [ \"prior_burn_in_steps\" ] , true_fn = train_op_except_prior , false_fn = train_op_all ) # The perplexity is an exponent of the average negative ELBO per word. words_per_document = tf . reduce_sum ( input_tensor = features , axis = 1 ) log_perplexity = - elbo / words_per_document tf . compat . v1 . summary . scalar ( \"perplexity\" , tf . exp ( tf . reduce_mean ( input_tensor = log_perplexity ) ) ) ( log_perplexity_tensor , log_perplexity_update ) = tf . compat . v1 . metrics . mean ( log_perplexity ) perplexity_tensor = tf . exp ( log_perplexity_tensor ) # Obtain the topics summary. Implemented as a py_func for simplicity. topics = tf . compat . v1 . py_func ( functools . partial ( get_topics_strings , vocabulary = params [ \"vocabulary\" ] ) , [ topics_words , alpha ] , tf . string , stateful = False ) tf . compat . v1 . summary . text ( \"topics\" , topics ) return tf . estimator . EstimatorSpec ( mode = mode , loss = loss , train_op = train_op , eval_metric_ops = { \"elbo\" : tf . compat . v1 . metrics . mean ( elbo ) , \"reconstruction\" : tf . compat . v1 . metrics . mean ( reconstruction ) , \"kl\" : tf . compat . v1 . metrics . mean ( kl ) , \"perplexity\" : ( perplexity_tensor , log_perplexity_update ) , \"topics\" : ( topics , tf . no_op ( ) ) , } , )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def sample_chain ( num_results , current_state , previous_kernel_results = None , kernel = None , num_burnin_steps = 0 , num_steps_between_results = 0 , trace_fn = lambda current_state , kernel_results : kernel_results , return_final_kernel_results = False , parallel_iterations = 10 , name = None , ) : if not kernel . is_calibrated : warnings . warn ( \"supplied `TransitionKernel` is not calibrated. Markov \" \"chain may not converge to intended target distribution.\" ) with tf . compat . v1 . name_scope ( name , \"mcmc_sample_chain\" , [ num_results , num_burnin_steps , num_steps_between_results ] ) : num_results = tf . convert_to_tensor ( value = num_results , dtype = tf . int32 , name = \"num_results\" ) num_burnin_steps = tf . convert_to_tensor ( value = num_burnin_steps , dtype = tf . int32 , name = \"num_burnin_steps\" ) num_steps_between_results = tf . convert_to_tensor ( value = num_steps_between_results , dtype = tf . int32 , name = \"num_steps_between_results\" ) current_state = tf . nest . map_structure ( lambda x : tf . convert_to_tensor ( value = x , name = \"current_state\" ) , current_state ) if previous_kernel_results is None : previous_kernel_results = kernel . bootstrap_results ( current_state ) if trace_fn is None : # It simplifies the logic to use a dummy function here. trace_fn = lambda * args : ( ) no_trace = True else : no_trace = False if trace_fn is sample_chain . __defaults__ [ 4 ] : warnings . warn ( \"Tracing all kernel results by default is deprecated. Set \" \"the `trace_fn` argument to None (the future default \" \"value) or an explicit callback that traces the values \" \"you are interested in.\" ) def _trace_scan_fn ( state_and_results , num_steps ) : next_state , current_kernel_results = mcmc_util . smart_for_loop ( loop_num_iter = num_steps , body_fn = kernel . one_step , initial_loop_vars = list ( state_and_results ) , parallel_iterations = parallel_iterations ) return next_state , current_kernel_results ( _ , final_kernel_results ) , ( all_states , trace ) = mcmc_util . trace_scan ( loop_fn = _trace_scan_fn , initial_state = ( current_state , previous_kernel_results ) , elems = tf . one_hot ( indices = 0 , depth = num_results , on_value = 1 + num_burnin_steps , off_value = 1 + num_steps_between_results , dtype = tf . int32 ) , # pylint: disable=g-long-lambda trace_fn = lambda state_and_results : ( state_and_results [ 0 ] , trace_fn ( * state_and_results ) ) , # pylint: enable=g-long-lambda parallel_iterations = parallel_iterations ) if return_final_kernel_results : return CheckpointableStatesAndTrace ( all_states = all_states , trace = trace , final_kernel_results = final_kernel_results ) else : if no_trace : return all_states else : return StatesAndTrace ( all_states = all_states , trace = trace )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def deep_exponential_family ( data_size , feature_size , units , shape ) : w2 = ed . Gamma ( 0.1 , 0.3 , sample_shape = [ units [ 2 ] , units [ 1 ] ] , name = \"w2\" ) w1 = ed . Gamma ( 0.1 , 0.3 , sample_shape = [ units [ 1 ] , units [ 0 ] ] , name = \"w1\" ) w0 = ed . Gamma ( 0.1 , 0.3 , sample_shape = [ units [ 0 ] , feature_size ] , name = \"w0\" ) z2 = ed . Gamma ( 0.1 , 0.1 , sample_shape = [ data_size , units [ 2 ] ] , name = \"z2\" ) z1 = ed . Gamma ( shape , shape / tf . matmul ( z2 , w2 ) , name = \"z1\" ) z0 = ed . Gamma ( shape , shape / tf . matmul ( z1 , w1 ) , name = \"z0\" ) x = ed . Poisson ( tf . matmul ( z0 , w0 ) , name = \"x\" ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def trainable_positive_deterministic ( shape , min_loc = 1e-3 , name = None ) : with tf . compat . v1 . variable_scope ( None , default_name = \"trainable_positive_deterministic\" ) : unconstrained_loc = tf . compat . v1 . get_variable ( \"unconstrained_loc\" , shape ) loc = tf . maximum ( tf . nn . softplus ( unconstrained_loc ) , min_loc ) rv = ed . Deterministic ( loc = loc , name = name ) return rv\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def trainable_gamma ( shape , min_concentration = 1e-3 , min_scale = 1e-5 , name = None ) : with tf . compat . v1 . variable_scope ( None , default_name = \"trainable_gamma\" ) : unconstrained_concentration = tf . compat . v1 . get_variable ( \"unconstrained_concentration\" , shape , initializer = tf . compat . v1 . initializers . random_normal ( mean = 0.5 , stddev = 0.1 ) ) unconstrained_scale = tf . compat . v1 . get_variable ( \"unconstrained_scale\" , shape , initializer = tf . compat . v1 . initializers . random_normal ( stddev = 0.1 ) ) concentration = tf . maximum ( tf . nn . softplus ( unconstrained_concentration ) , min_concentration ) rate = tf . maximum ( 1. / tf . nn . softplus ( unconstrained_scale ) , 1. / min_scale ) rv = ed . Gamma ( concentration = concentration , rate = rate , name = name ) return rv\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def deep_exponential_family_variational ( data_size , feature_size , units ) : qw2 = trainable_positive_deterministic ( [ units [ 2 ] , units [ 1 ] ] , name = \"qw2\" ) qw1 = trainable_positive_deterministic ( [ units [ 1 ] , units [ 0 ] ] , name = \"qw1\" ) qw0 = trainable_positive_deterministic ( [ units [ 0 ] , feature_size ] , name = \"qw0\" ) qz2 = trainable_gamma ( [ data_size , units [ 2 ] ] , name = \"qz2\" ) qz1 = trainable_gamma ( [ data_size , units [ 1 ] ] , name = \"qz1\" ) qz0 = trainable_gamma ( [ data_size , units [ 0 ] ] , name = \"qz0\" ) return qw2 , qw1 , qw0 , qz2 , qz1 , qz0\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def load_nips2011_papers ( path ) : path = os . path . expanduser ( path ) filename = \"NIPS_1987-2015.csv\" filepath = os . path . join ( path , filename ) if not os . path . exists ( filepath ) : url = ( \"https://archive.ics.uci.edu/ml/machine-learning-databases/\" \"00371/NIPS_1987-2015.csv\" ) if not tf . io . gfile . exists ( path ) : tf . io . gfile . makedirs ( path ) print ( \"Downloading %s to %s\" % ( url , filepath ) ) urllib . request . urlretrieve ( url , filepath ) with open ( filepath ) as f : iterator = csv . reader ( f ) documents = next ( iterator ) [ 1 : ] words = [ ] x_train = [ ] for row in iterator : words . append ( row [ 0 ] ) x_train . append ( row [ 1 : ] ) x_train = np . array ( x_train , dtype = np . int ) # Subset to documents in 2011 and words appearing in at least two documents # and have a total word count of at least 10. doc_idx = [ i for i , document in enumerate ( documents ) if document . startswith ( \"2011\" ) ] documents = [ documents [ doc ] for doc in doc_idx ] x_train = x_train [ : , doc_idx ] word_idx = np . logical_and ( np . sum ( x_train != 0 , 1 ) >= 2 , np . sum ( x_train , 1 ) >= 10 ) words = [ word for word , idx in zip ( words , word_idx ) if idx ] bag_of_words = x_train [ word_idx , : ] . T return bag_of_words , words\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _init_params ( self , amplitude , length_scale , validate_args ) : dtype = util . maybe_get_common_dtype ( [ amplitude , length_scale ] ) if amplitude is not None : amplitude = tf . convert_to_tensor ( value = amplitude , name = 'amplitude' , dtype = dtype ) self . _amplitude = _validate_arg_if_not_none ( amplitude , tf . compat . v1 . assert_positive , validate_args ) if length_scale is not None : length_scale = tf . convert_to_tensor ( value = length_scale , name = 'length_scale' , dtype = dtype ) self . _length_scale = _validate_arg_if_not_none ( length_scale , tf . compat . v1 . assert_positive , validate_args ) return dtype\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _registered_kl ( type_a , type_b ) : hierarchy_a = tf_inspect . getmro ( type_a ) hierarchy_b = tf_inspect . getmro ( type_b ) dist_to_children = None kl_fn = None for mro_to_a , parent_a in enumerate ( hierarchy_a ) : for mro_to_b , parent_b in enumerate ( hierarchy_b ) : candidate_dist = mro_to_a + mro_to_b candidate_kl_fn = _DIVERGENCES . get ( ( parent_a , parent_b ) , None ) if not kl_fn or ( candidate_kl_fn and candidate_dist < dist_to_children ) : dist_to_children = candidate_dist kl_fn = candidate_kl_fn return kl_fn\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def kl_divergence ( distribution_a , distribution_b , allow_nan_stats = True , name = None ) : kl_fn = _registered_kl ( type ( distribution_a ) , type ( distribution_b ) ) if kl_fn is None : raise NotImplementedError ( \"No KL(distribution_a || distribution_b) registered for distribution_a \" \"type {} and distribution_b type {}\" . format ( type ( distribution_a ) . __name__ , type ( distribution_b ) . __name__ ) ) with tf . name_scope ( \"KullbackLeibler\" ) : kl_t = kl_fn ( distribution_a , distribution_b , name = name ) if allow_nan_stats : return kl_t # Check KL for NaNs kl_t = tf . identity ( kl_t , name = \"kl\" ) with tf . control_dependencies ( [ tf . Assert ( tf . logical_not ( tf . reduce_any ( input_tensor = tf . math . is_nan ( kl_t ) ) ) , [ ( \"KL calculation between {} and {} returned NaN values \" \"(and was called with allow_nan_stats=False). Values:\" . format ( distribution_a . name , distribution_b . name ) ) , kl_t ] ) ] ) : return tf . identity ( kl_t , name = \"checked_kl\" )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def cross_entropy ( ref , other , allow_nan_stats = True , name = None ) : with tf . name_scope ( name or \"cross_entropy\" ) : return ref . entropy ( ) + kl_divergence ( ref , other , allow_nan_stats = allow_nan_stats )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def read_image ( filepath ) : im_bytes = tf . io . read_file ( filepath ) im = tf . image . decode_image ( im_bytes , channels = CHANNELS ) im = tf . image . convert_image_dtype ( im , tf . float32 ) return im\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def download_sprites ( ) : filepath = os . path . join ( FLAGS . data_dir , DATA_SPRITES_DIR ) if not tf . io . gfile . exists ( filepath ) : if not tf . io . gfile . exists ( FLAGS . data_dir ) : tf . io . gfile . makedirs ( FLAGS . data_dir ) zip_name = \"{}.zip\" . format ( filepath ) urllib . request . urlretrieve ( DATA_SPRITES_URL , zip_name ) with zipfile . ZipFile ( zip_name , \"r\" ) as zip_file : zip_file . extractall ( FLAGS . data_dir ) tf . io . gfile . remove ( zip_name ) return filepath\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_character ( skin , hair , top , pants ) : dtype = skin . dtype hair_mask = tf . cast ( hair [ ... , - 1 : ] <= 0 , dtype ) top_mask = tf . cast ( top [ ... , - 1 : ] <= 0 , dtype ) pants_mask = tf . cast ( pants [ ... , - 1 : ] <= 0 , dtype ) char = ( skin * hair_mask ) + hair char = ( char * top_mask ) + top char = ( char * pants_mask ) + pants return char\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_seq ( character , action_metadata , direction , length = 8 , start = 0 ) : sprite_start = ( action_metadata [ 0 ] + direction ) * FRAME_SIZE sprite_end = ( action_metadata [ 0 ] + direction + 1 ) * FRAME_SIZE sprite_line = character [ sprite_start : sprite_end , ... ] # Extract 64x64 patches that are side-by-side in the sprite, and limit # to the actual number of frames for the given action. frames = tf . stack ( tf . split ( sprite_line , 13 , axis = 1 ) ) # 13 is a hack frames = frames [ 0 : action_metadata [ 1 ] ] # Extract a slice of the desired length. # NOTE: Length could be longer than the number of frames, so tile as needed. frames = tf . roll ( frames , shift = - start , axis = 0 ) frames = tf . tile ( frames , [ 2 , 1 , 1 , 1 ] ) # 2 is a hack frames = frames [ : length ] frames = tf . cast ( frames , dtype = tf . float32 ) frames . set_shape ( [ length , FRAME_SIZE , FRAME_SIZE , CHANNELS ] ) return frames\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_random_seq ( character , action_metadata , direction , length = 8 ) : start = tf . random . uniform ( [ ] , maxval = action_metadata [ 1 ] , dtype = tf . int32 ) return create_seq ( character , action_metadata , direction , length , start )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def create_sprites_dataset ( characters , actions , directions , channels = 3 , length = 8 , shuffle = False , fake_data = False ) : if fake_data : dummy_image = tf . random . normal ( [ HEIGHT , WIDTH , CHANNELS ] ) else : basedir = download_sprites ( ) action_names = [ action . name for action in actions ] action_metadata = [ ( action . start_row , action . frames ) for action in actions ] direction_rows = [ direction . row_offset for direction in directions ] chars = tf . data . Dataset . from_tensor_slices ( characters ) act_names = tf . data . Dataset . from_tensor_slices ( action_names ) . repeat ( ) acts_metadata = tf . data . Dataset . from_tensor_slices ( action_metadata ) . repeat ( ) dir_rows = tf . data . Dataset . from_tensor_slices ( direction_rows ) . repeat ( ) if shuffle : chars = chars . shuffle ( len ( characters ) ) dataset = tf . data . Dataset . zip ( ( chars , act_names , acts_metadata , dir_rows ) ) skin_table = tf . contrib . lookup . index_table_from_tensor ( sorted ( SKIN_COLORS ) ) hair_table = tf . contrib . lookup . index_table_from_tensor ( sorted ( HAIRSTYLES ) ) top_table = tf . contrib . lookup . index_table_from_tensor ( sorted ( TOPS ) ) pants_table = tf . contrib . lookup . index_table_from_tensor ( sorted ( PANTS ) ) action_table = tf . contrib . lookup . index_table_from_tensor ( sorted ( action_names ) ) def process_example ( attrs , act_name , act_metadata , dir_row_offset ) : \"\"\"Processes a dataset row.\"\"\" skin_name = attrs [ 0 ] hair_name = attrs [ 1 ] top_name = attrs [ 2 ] pants_name = attrs [ 3 ] if fake_data : char = dummy_image else : skin = read_image ( basedir + os . sep + skin_name ) hair = read_image ( basedir + os . sep + hair_name ) top = read_image ( basedir + os . sep + top_name ) pants = read_image ( basedir + os . sep + pants_name ) char = create_character ( skin , hair , top , pants ) if shuffle : seq = create_random_seq ( char , act_metadata , dir_row_offset , length ) else : seq = create_seq ( char , act_metadata , dir_row_offset , length ) seq = seq [ ... , : channels ] # limit output channels skin_idx = skin_table . lookup ( skin_name ) hair_idx = hair_table . lookup ( hair_name ) top_idx = top_table . lookup ( top_name ) pants_idx = pants_table . lookup ( pants_name ) act_idx = action_table . lookup ( act_name ) return ( seq , skin_idx , hair_idx , top_idx , pants_idx , act_idx , skin_name , hair_name , top_name , pants_name , act_name ) dataset = dataset . map ( process_example ) return dataset\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _maybe_validate_distributions ( distributions , dtype_override , validate_args ) : assertions = [ ] if not _is_iterable ( distributions ) or not distributions : raise ValueError ( '`distributions` must be a list of one or more ' 'distributions.' ) if dtype_override is None : dts = [ dtype_util . base_dtype ( d . dtype ) for d in distributions if d . dtype is not None ] if dts [ 1 : ] != dts [ : - 1 ] : raise TypeError ( 'Distributions must have same dtype; found: {}.' . format ( set ( dtype_util . name ( dt ) for dt in dts ) ) ) # Validate event_ndims. for d in distributions : if tensorshape_util . rank ( d . event_shape ) is not None : if tensorshape_util . rank ( d . event_shape ) != 1 : raise ValueError ( '`Distribution` must be vector variate, ' 'found event nimds: {}.' . format ( tensorshape_util . rank ( d . event_shape ) ) ) elif validate_args : assertions . append ( assert_util . assert_equal ( 1 , tf . size ( input = d . event_shape_tensor ( ) ) , message = '`Distribution` must be vector variate.' ) ) batch_shapes = [ d . batch_shape for d in distributions ] if all ( tensorshape_util . is_fully_defined ( b ) for b in batch_shapes ) : if batch_shapes [ 1 : ] != batch_shapes [ : - 1 ] : raise ValueError ( 'Distributions must have the same `batch_shape`; ' 'found: {}.' . format ( batch_shapes ) ) elif validate_args : batch_shapes = [ tensorshape_util . as_list ( d . batch_shape ) # pylint: disable=g-complex-comprehension if tensorshape_util . is_fully_defined ( d . batch_shape ) else d . batch_shape_tensor ( ) for d in distributions ] assertions . extend ( assert_util . assert_equal ( # pylint: disable=g-complex-comprehension b1 , b2 , message = 'Distribution `batch_shape`s must be identical.' ) for b1 , b2 in zip ( batch_shapes [ 1 : ] , batch_shapes [ : - 1 ] ) ) return assertions\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_blockwise_blockwise ( b0 , b1 , name = None ) : if len ( b0 . distributions ) != len ( b1 . distributions ) : raise ValueError ( 'Can only compute KL divergence between Blockwise distributions with ' 'the same number of component distributions.' ) # We also need to check that the event shapes match for each one. b0_event_sizes = [ _event_size ( d ) for d in b0 . distributions ] b1_event_sizes = [ _event_size ( d ) for d in b1 . distributions ] assertions = [ ] message = ( 'Can only compute KL divergence between Blockwise distributions ' 'with the same pairwise event shapes.' ) if ( all ( isinstance ( event_size , int ) for event_size in b0_event_sizes ) and all ( isinstance ( event_size , int ) for event_size in b1_event_sizes ) ) : if b0_event_sizes != b1_event_sizes : raise ValueError ( message ) else : if b0 . validate_args or b1 . validate_args : assertions . extend ( assert_util . assert_equal ( # pylint: disable=g-complex-comprehension e1 , e2 , message = message ) for e1 , e2 in zip ( b0_event_sizes , b1_event_sizes ) ) with tf . name_scope ( name or 'kl_blockwise_blockwise' ) : with tf . control_dependencies ( assertions ) : return sum ( [ kullback_leibler . kl_divergence ( d1 , d2 ) for d1 , d2 in zip ( b0 . distributions , b1 . distributions ) ] )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _kl_half_normal_half_normal ( a , b , name = None ) : with tf . name_scope ( name or \"kl_half_normal_half_normal\" ) : # Consistent with # http://www.mast.queensu.ca/~communications/Papers/gil-msc11.pdf, page 119 return ( tf . math . log ( b . scale ) - tf . math . log ( a . scale ) + ( a . scale ** 2 - b . scale ** 2 ) / ( 2 * b . scale ** 2 ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _flatten_summand_list ( kernels ) : flattened = [ ] for k in kernels : if isinstance ( k , _SumKernel ) : flattened += k . kernels else : flattened . append ( k ) return flattened\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _flatten_multiplicand_list ( kernels ) : flattened = [ ] for k in kernels : if isinstance ( k , _ProductKernel ) : flattened += k . kernels else : flattened . append ( k ) return flattened\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_input_pipeline ( x_train , x_test , y_train , y_test , batch_size , valid_size ) : x_train = x_train . astype ( \"float32\" ) x_test = x_test . astype ( \"float32\" ) x_train /= 255 x_test /= 255 y_train = y_train . flatten ( ) y_test = y_test . flatten ( ) if FLAGS . subtract_pixel_mean : x_train_mean = np . mean ( x_train , axis = 0 ) x_train -= x_train_mean x_test -= x_train_mean print ( \"x_train shape:\" + str ( x_train . shape ) ) print ( str ( x_train . shape [ 0 ] ) + \" train samples\" ) print ( str ( x_test . shape [ 0 ] ) + \" test samples\" ) # Build an iterator over training batches. training_dataset = tf . data . Dataset . from_tensor_slices ( ( x_train , np . int32 ( y_train ) ) ) training_batches = training_dataset . shuffle ( 50000 , reshuffle_each_iteration = True ) . repeat ( ) . batch ( batch_size ) training_iterator = tf . compat . v1 . data . make_one_shot_iterator ( training_batches ) # Build a iterator over the heldout set with batch_size=heldout_size, # i.e., return the entire heldout set as a constant. heldout_dataset = tf . data . Dataset . from_tensor_slices ( ( x_test , np . int32 ( y_test ) ) ) heldout_batches = heldout_dataset . repeat ( ) . batch ( valid_size ) heldout_iterator = tf . compat . v1 . data . make_one_shot_iterator ( heldout_batches ) # Combine these into a feedable iterator that can switch between training # and validation inputs. handle = tf . compat . v1 . placeholder ( tf . string , shape = [ ] ) feedable_iterator = tf . compat . v1 . data . Iterator . from_string_handle ( handle , training_batches . output_types , training_batches . output_shapes ) images , labels = feedable_iterator . get_next ( ) return images , labels , handle , training_iterator , heldout_iterator\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def build_fake_data ( ) : num_examples = 10 x_train = np . random . rand ( num_examples , * IMAGE_SHAPE ) . astype ( np . float32 ) y_train = np . random . permutation ( np . arange ( num_examples ) ) . astype ( np . int32 ) x_test = np . random . rand ( num_examples , * IMAGE_SHAPE ) . astype ( np . float32 ) y_test = np . random . permutation ( np . arange ( num_examples ) ) . astype ( np . int32 ) return ( x_train , y_train ) , ( x_test , y_test )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def count_integers ( arr , weights = None , minlength = None , maxlength = None , axis = None , dtype = tf . int32 , name = None ) : with tf . compat . v1 . name_scope ( name , 'count_integers' , values = [ arr , weights , minlength , maxlength , axis ] ) : if axis is None : return tf . math . bincount ( arr , weights = weights , minlength = minlength , maxlength = maxlength , dtype = dtype ) arr = tf . convert_to_tensor ( value = arr , dtype = tf . int32 , name = 'arr' ) arr_ndims = _get_static_ndims ( arr , expect_static = True ) axis = _make_static_axis_non_negative_list ( axis , arr_ndims ) # ~axis from docstring. Dims in arr that are not in axis. not_axis = sorted ( set ( range ( arr_ndims ) ) . difference ( axis ) ) # If we're reducing over everything, just use standard bincount. if not not_axis : return tf . math . bincount ( arr , weights = weights , minlength = minlength , maxlength = maxlength , dtype = dtype ) # Move dims in ~axis to the left, so we can tf.map_fn bincount over them, # Producing counts for every index I in ~axis. # Thus, flat_arr is not totally flat, it just has the dims in ~axis # flattened. flat_arr = _move_dims_to_flat_end ( arr , not_axis , arr_ndims , right_end = False ) # tf.map_fn over dim 0. if weights is None : def one_bincount ( arr_slice ) : return tf . math . bincount ( arr_slice , weights = None , minlength = minlength , maxlength = maxlength , dtype = dtype ) flat_counts = tf . map_fn ( one_bincount , elems = flat_arr , dtype = dtype ) else : weights = tf . convert_to_tensor ( value = weights , name = 'weights' ) _get_static_ndims ( weights , expect_static = True , expect_ndims = arr_ndims ) flat_weights = _move_dims_to_flat_end ( weights , not_axis , arr_ndims , right_end = False ) def one_bincount ( arr_and_weights_slices ) : arr_slice , weights_slice = arr_and_weights_slices return tf . math . bincount ( arr_slice , weights = weights_slice , minlength = minlength , maxlength = maxlength , dtype = dtype ) flat_counts = tf . map_fn ( one_bincount , elems = [ flat_arr , flat_weights ] , dtype = weights . dtype ) # flat_counts.shape = [prod(~axis), K], because map_fn stacked on axis 0. # bincount needs to have the K bins in axis 0, so transpose... flat_counts_t = tf . transpose ( a = flat_counts , perm = [ 1 , 0 ] ) # Throw in this assert, to ensure shape assumptions are correct. _get_static_ndims ( flat_counts_t , expect_ndims = 2 , expect_static = True ) # not_axis_shape = arr.shape[~axis] not_axis_shape = tf . gather ( tf . shape ( input = arr ) , indices = not_axis ) # The first index of flat_counts_t indexes bins 0,..,K-1, the rest are ~axis out_shape = tf . concat ( [ [ - 1 ] , not_axis_shape ] , axis = 0 ) return tf . reshape ( flat_counts_t , out_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def find_bins ( x , edges , extend_lower_interval = False , extend_upper_interval = False , dtype = None , name = None ) : # TFP users may be surprised to see the \"action\" in the leftmost dim of # edges, rather than the rightmost (event) dim. Why? # 1. Most likely you created edges by getting quantiles over samples, and # quantile/percentile return these edges in the leftmost (sample) dim. # 2. Say you have event_shape = [5], then we expect the bin will be different # for all 5 events, so the index of the bin should not be in the event dim. with tf . compat . v1 . name_scope ( name , default_name = 'find_bins' , values = [ x , edges ] ) : in_type = dtype_util . common_dtype ( [ x , edges ] , preferred_dtype = tf . float32 ) edges = tf . convert_to_tensor ( value = edges , name = 'edges' , dtype = in_type ) x = tf . convert_to_tensor ( value = x , name = 'x' , dtype = in_type ) if ( tf . compat . dimension_value ( edges . shape [ 0 ] ) is not None and tf . compat . dimension_value ( edges . shape [ 0 ] ) < 2 ) : raise ValueError ( 'First dimension of `edges` must have length > 1 to index 1 or ' 'more bin. Found: {}' . format ( edges . shape ) ) flattening_x = edges . shape . ndims == 1 and x . shape . ndims > 1 if flattening_x : x_orig_shape = tf . shape ( input = x ) x = tf . reshape ( x , [ - 1 ] ) if dtype is None : dtype = in_type dtype = tf . as_dtype ( dtype ) # Move first dims into the rightmost. x_permed = distribution_util . rotate_transpose ( x , shift = - 1 ) edges_permed = distribution_util . rotate_transpose ( edges , shift = - 1 ) # If... # x_permed = [0, 1, 6., 10] # edges = [0, 5, 10.] # ==> almost_output = [0, 1, 2, 2] searchsorted_type = dtype if dtype in [ tf . int32 , tf . int64 ] else None almost_output_permed = tf . searchsorted ( sorted_sequence = edges_permed , values = x_permed , side = 'right' , out_type = searchsorted_type ) # Move the rightmost dims back to the leftmost. almost_output = tf . cast ( distribution_util . rotate_transpose ( almost_output_permed , shift = 1 ) , dtype ) # In above example, we want [0, 0, 1, 1], so correct this here. bins = tf . clip_by_value ( almost_output - 1 , tf . cast ( 0 , dtype ) , tf . cast ( tf . shape ( input = edges ) [ 0 ] - 2 , dtype ) ) if not extend_lower_interval : low_fill = np . nan if dtype . is_floating else - 1 bins = tf . where ( x < tf . expand_dims ( edges [ 0 ] , 0 ) , tf . fill ( tf . shape ( input = x ) , tf . cast ( low_fill , dtype ) ) , bins ) if not extend_upper_interval : up_fill = np . nan if dtype . is_floating else tf . shape ( input = edges ) [ 0 ] - 1 bins = tf . where ( x > tf . expand_dims ( edges [ - 1 ] , 0 ) , tf . fill ( tf . shape ( input = x ) , tf . cast ( up_fill , dtype ) ) , bins ) if flattening_x : bins = tf . reshape ( bins , x_orig_shape ) return bins\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def histogram ( x , edges , axis = None , extend_lower_interval = False , extend_upper_interval = False , dtype = None , name = None ) : with tf . compat . v1 . name_scope ( name , 'histogram' , values = [ x , edges , axis ] ) : # Tensor conversions. in_dtype = dtype_util . common_dtype ( [ x , edges ] , preferred_dtype = tf . float32 ) x = tf . convert_to_tensor ( value = x , name = 'x' , dtype = in_dtype ) edges = tf . convert_to_tensor ( value = edges , name = 'edges' , dtype = in_dtype ) # Move dims in axis to the left end as one flattened dim. # After this, x.shape = [n_samples] + E. if axis is None : x = tf . reshape ( x , shape = [ - 1 ] ) else : x_ndims = _get_static_ndims ( x , expect_static = True , expect_ndims_at_least = 1 ) axis = _make_static_axis_non_negative_list ( axis , x_ndims ) if not axis : raise ValueError ( '`axis` cannot be empty. Found: {}' . format ( axis ) ) x = _move_dims_to_flat_end ( x , axis , x_ndims , right_end = False ) # bins.shape = x.shape = [n_samples] + E, # and bins[i] is a shape E Tensor of the bins that sample `i` fell into. # E is the \"event shape\", which is [] if axis is None. bins = find_bins ( x , edges = edges , # If not extending intervals, then values outside the edges will return # -1, which gives an error when fed to bincount. extend_lower_interval = extend_lower_interval , extend_upper_interval = extend_upper_interval , dtype = tf . int32 ) # TODO(b/124015136) Use standard tf.math.bincount once it supports `axis`. counts = count_integers ( bins , # Ensure we get correct output, even if x did not fall into every bin minlength = tf . shape ( input = edges ) [ 0 ] - 1 , maxlength = tf . shape ( input = edges ) [ 0 ] - 1 , axis = 0 , dtype = dtype or in_dtype ) n_edges = tf . compat . dimension_value ( edges . shape [ 0 ] ) if n_edges is not None : counts . set_shape ( tf . TensorShape ( [ n_edges - 1 ] ) . concatenate ( counts . shape [ 1 : ] ) ) return counts\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def percentile ( x , q , axis = None , interpolation = None , keep_dims = False , validate_args = False , preserve_gradients = True , name = None ) : name = name or 'percentile' allowed_interpolations = { 'linear' , 'lower' , 'higher' , 'nearest' , 'midpoint' } if interpolation is None : interpolation = 'nearest' else : if interpolation not in allowed_interpolations : raise ValueError ( 'Argument `interpolation` must be in %s. Found %s' % ( allowed_interpolations , interpolation ) ) with tf . compat . v1 . name_scope ( name , values = [ x , q ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) if interpolation in { 'linear' , 'midpoint' } and x . dtype . is_integer : raise TypeError ( '{} interpolation not allowed with dtype {}' . format ( interpolation , x . dtype ) ) # Double is needed here and below, else we get the wrong index if the array # is huge along axis. q = tf . cast ( q , tf . float64 ) _get_static_ndims ( q , expect_ndims_no_more_than = 1 ) if validate_args : q = distribution_util . with_dependencies ( [ tf . compat . v1 . assert_rank_in ( q , [ 0 , 1 ] ) , tf . compat . v1 . assert_greater_equal ( q , tf . cast ( 0. , tf . float64 ) ) , tf . compat . v1 . assert_less_equal ( q , tf . cast ( 100. , tf . float64 ) ) ] , q ) # Move `axis` dims of `x` to the rightmost, call it `y`. if axis is None : y = tf . reshape ( x , [ - 1 ] ) else : x_ndims = _get_static_ndims ( x , expect_static = True , expect_ndims_at_least = 1 ) axis = _make_static_axis_non_negative_list ( axis , x_ndims ) y = _move_dims_to_flat_end ( x , axis , x_ndims , right_end = True ) frac_at_q_or_above = 1. - q / 100. # Sort everything, not just the top 'k' entries, which allows multiple calls # to sort only once (under the hood) and use CSE. sorted_y = _sort_tensor ( y ) d = tf . cast ( tf . shape ( input = y ) [ - 1 ] , tf . float64 ) def _get_indices ( interp_type ) : \"\"\"Get values of y at the indices implied by interp_type.\"\"\" # Note `lower` <--> ceiling. Confusing, huh? Due to the fact that # _sort_tensor sorts highest to lowest, tf.ceil corresponds to the higher # index, but the lower value of y! if interp_type == 'lower' : indices = tf . math . ceil ( ( d - 1 ) * frac_at_q_or_above ) elif interp_type == 'higher' : indices = tf . floor ( ( d - 1 ) * frac_at_q_or_above ) elif interp_type == 'nearest' : indices = tf . round ( ( d - 1 ) * frac_at_q_or_above ) # d - 1 will be distinct from d in int32, but not necessarily double. # So clip to avoid out of bounds errors. return tf . clip_by_value ( tf . cast ( indices , tf . int32 ) , 0 , tf . shape ( input = y ) [ - 1 ] - 1 ) if interpolation in [ 'nearest' , 'lower' , 'higher' ] : gathered_y = tf . gather ( sorted_y , _get_indices ( interpolation ) , axis = - 1 ) elif interpolation == 'midpoint' : gathered_y = 0.5 * ( tf . gather ( sorted_y , _get_indices ( 'lower' ) , axis = - 1 ) + tf . gather ( sorted_y , _get_indices ( 'higher' ) , axis = - 1 ) ) elif interpolation == 'linear' : # Copy-paste of docstring on interpolation: # linear: i + (j - i) * fraction, where fraction is the fractional part # of the index surrounded by i and j. larger_y_idx = _get_indices ( 'lower' ) exact_idx = ( d - 1 ) * frac_at_q_or_above if preserve_gradients : # If q corresponds to a point in x, we will initially have # larger_y_idx == smaller_y_idx. # This results in the gradient w.r.t. fraction being zero (recall `q` # enters only through `fraction`...and see that things cancel). # The fix is to ensure that smaller_y_idx and larger_y_idx are always # separated by exactly 1. smaller_y_idx = tf . maximum ( larger_y_idx - 1 , 0 ) larger_y_idx = tf . minimum ( smaller_y_idx + 1 , tf . shape ( input = y ) [ - 1 ] - 1 ) fraction = tf . cast ( larger_y_idx , tf . float64 ) - exact_idx else : smaller_y_idx = _get_indices ( 'higher' ) fraction = tf . math . ceil ( ( d - 1 ) * frac_at_q_or_above ) - exact_idx fraction = tf . cast ( fraction , y . dtype ) gathered_y = ( tf . gather ( sorted_y , larger_y_idx , axis = - 1 ) * ( 1 - fraction ) + tf . gather ( sorted_y , smaller_y_idx , axis = - 1 ) * fraction ) # Propagate NaNs if x . dtype in ( tf . bfloat16 , tf . float16 , tf . float32 , tf . float64 ) : # Apparently tf.is_nan doesn't like other dtypes nan_batch_members = tf . reduce_any ( input_tensor = tf . math . is_nan ( x ) , axis = axis ) right_rank_matched_shape = tf . pad ( tensor = tf . shape ( input = nan_batch_members ) , paddings = [ [ 0 , tf . rank ( input = q ) ] ] , constant_values = 1 ) nan_batch_members = tf . reshape ( nan_batch_members , shape = right_rank_matched_shape ) shape_gathered_y = tf . shape ( input = gathered_y ) nan = np . array ( np . nan , gathered_y . dtype . as_numpy_dtype ) gathered_y = tf . where ( tf . broadcast_to ( nan_batch_members , shape_gathered_y ) , tf . fill ( shape_gathered_y , nan ) , gathered_y ) # Expand dimensions if requested if keep_dims : if axis is None : ones_vec = tf . ones ( shape = [ _get_best_effort_ndims ( x ) + _get_best_effort_ndims ( q ) ] , dtype = tf . int32 ) gathered_y *= tf . ones ( ones_vec , dtype = x . dtype ) else : gathered_y = _insert_back_keep_dims ( gathered_y , axis ) # If q is a scalar, then result has the right shape. # If q is a vector, then result has trailing dim of shape q.shape, which # needs to be rotated to dim 0. return distribution_util . rotate_transpose ( gathered_y , tf . rank ( q ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def quantiles ( x , num_quantiles , axis = None , interpolation = None , keep_dims = False , validate_args = False , name = None ) : with tf . compat . v1 . name_scope ( name , 'quantiles' , values = [ x , num_quantiles , axis ] ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) return percentile ( x , q = tf . linspace ( # percentile casts q to float64 before using it...so may as well use # float64 here. Note that using x.dtype won't work with linspace # if x is integral type (which is anothe motivation for hard-coding # float64). tf . convert_to_tensor ( value = 0 , dtype = tf . float64 ) , tf . convert_to_tensor ( value = 100 , dtype = tf . float64 ) , num = num_quantiles + 1 ) , axis = axis , interpolation = interpolation , keep_dims = keep_dims , validate_args = validate_args , preserve_gradients = False )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_static_ndims ( x , expect_static = False , expect_ndims = None , expect_ndims_no_more_than = None , expect_ndims_at_least = None ) : ndims = x . shape . ndims if ndims is None : shape_const = tf . get_static_value ( tf . shape ( input = x ) ) if shape_const is not None : ndims = shape_const . ndim if ndims is None : if expect_static : raise ValueError ( 'Expected argument `x` to have statically defined `ndims`. Found: ' % x ) return if expect_ndims is not None : ndims_message = ( 'Expected argument `x` to have ndims %s. Found tensor %s' % ( expect_ndims , x ) ) if ndims != expect_ndims : raise ValueError ( ndims_message ) if expect_ndims_at_least is not None : ndims_at_least_message = ( 'Expected argument `x` to have ndims >= %d. Found tensor %s' % ( expect_ndims_at_least , x ) ) if ndims < expect_ndims_at_least : raise ValueError ( ndims_at_least_message ) if expect_ndims_no_more_than is not None : ndims_no_more_than_message = ( 'Expected argument `x` to have ndims <= %d. Found tensor %s' % ( expect_ndims_no_more_than , x ) ) if ndims > expect_ndims_no_more_than : raise ValueError ( ndims_no_more_than_message ) return ndims\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _get_best_effort_ndims ( x , expect_ndims = None , expect_ndims_at_least = None , expect_ndims_no_more_than = None ) : ndims_static = _get_static_ndims ( x , expect_ndims = expect_ndims , expect_ndims_at_least = expect_ndims_at_least , expect_ndims_no_more_than = expect_ndims_no_more_than ) if ndims_static is not None : return ndims_static return tf . rank ( x )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _insert_back_keep_dims ( x , axis ) : for i in sorted ( axis ) : x = tf . expand_dims ( x , axis = i ) return x\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _make_static_axis_non_negative_list ( axis , ndims ) : axis = distribution_util . make_non_negative_axis ( axis , ndims ) axis_const = tf . get_static_value ( axis ) if axis_const is None : raise ValueError ( 'Expected argument `axis` to be statically available. Found: %s' % axis ) # Make at least 1-D. axis = axis_const + np . zeros ( [ 1 ] , dtype = axis_const . dtype ) return list ( int ( dim ) for dim in axis )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _move_dims_to_flat_end ( x , axis , x_ndims , right_end = True ) : if not axis : return x # Suppose x.shape = [a, b, c, d] # Suppose axis = [1, 3] # other_dims = [0, 2] in example above. other_dims = sorted ( set ( range ( x_ndims ) ) . difference ( axis ) ) # x_permed.shape = [a, c, b, d] perm = other_dims + list ( axis ) if right_end else list ( axis ) + other_dims x_permed = tf . transpose ( a = x , perm = perm ) if x . shape . is_fully_defined ( ) : x_shape = x . shape . as_list ( ) # other_shape = [a, c], end_shape = [b * d] other_shape = [ x_shape [ i ] for i in other_dims ] end_shape = [ np . prod ( [ x_shape [ i ] for i in axis ] ) ] full_shape = ( other_shape + end_shape if right_end else end_shape + other_shape ) else : other_shape = tf . gather ( tf . shape ( input = x ) , other_dims ) full_shape = tf . concat ( [ other_shape , [ - 1 ] ] if right_end else [ [ - 1 ] , other_shape ] , axis = 0 ) return tf . reshape ( x_permed , shape = full_shape )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _sort_tensor ( tensor ) : sorted_ , _ = tf . nn . top_k ( tensor , k = tf . shape ( input = tensor ) [ - 1 ] ) sorted_ . set_shape ( tensor . shape ) return sorted_\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def make_component_state_space_models ( self , num_timesteps , param_vals , initial_step = 0 ) : with tf . compat . v1 . name_scope ( 'make_component_state_space_models' ) : # List the model parameters in canonical order param_map = self . _canonicalize_param_vals_as_map ( param_vals ) param_vals_list = [ param_map [ p . name ] for p in self . parameters ] # Build SSMs for each component model. We process the components in # canonical order, extracting the parameters for each component from the # (ordered) list of parameters. remaining_param_vals = param_vals_list [ 1 : ] component_ssms = [ ] for component in self . components : num_parameters = len ( component . parameters ) component_param_vals = remaining_param_vals [ : num_parameters ] remaining_param_vals = remaining_param_vals [ num_parameters : ] component_ssms . append ( component . make_state_space_model ( num_timesteps , param_vals = component_param_vals , initial_step = initial_step ) ) return component_ssms\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def amari_alpha ( logu , alpha = 1. , self_normalized = False , name = None ) : with tf . compat . v1 . name_scope ( name , \"amari_alpha\" , [ logu ] ) : if alpha is None or tf . is_tensor ( alpha ) : raise TypeError ( \"`alpha` cannot be `None` or `Tensor` type.\" ) if ( self_normalized is None or tf . is_tensor ( self_normalized ) ) : raise TypeError ( \"`self_normalized` cannot be `None` or `Tensor` type.\" ) logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) if alpha == 0. : f = - logu elif alpha == 1. : f = tf . exp ( logu ) * logu else : f = tf . math . expm1 ( alpha * logu ) / ( alpha * ( alpha - 1. ) ) if not self_normalized : return f if alpha == 0. : return f + tf . math . expm1 ( logu ) elif alpha == 1. : return f - tf . math . expm1 ( logu ) else : return f - tf . math . expm1 ( logu ) / ( alpha - 1. )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def kl_reverse ( logu , self_normalized = False , name = None ) : with tf . compat . v1 . name_scope ( name , \"kl_reverse\" , [ logu ] ) : return amari_alpha ( logu , alpha = 0. , self_normalized = self_normalized )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def jensen_shannon ( logu , self_normalized = False , name = None ) : with tf . compat . v1 . name_scope ( name , \"jensen_shannon\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) npdt = logu . dtype . as_numpy_dtype y = tf . nn . softplus ( logu ) if self_normalized : y -= np . log ( 2 ) . astype ( npdt ) return tf . exp ( logu ) * logu - ( 1. + tf . exp ( logu ) ) * y\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def pearson ( logu , name = None ) : with tf . compat . v1 . name_scope ( name , \"pearson\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) return tf . square ( tf . math . expm1 ( logu ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def squared_hellinger ( logu , name = None ) : with tf . compat . v1 . name_scope ( name , \"squared_hellinger\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) return pearson ( 0.5 * logu )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def triangular ( logu , name = None ) : with tf . compat . v1 . name_scope ( name , \"triangular\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) return pearson ( logu ) / ( 1. + tf . exp ( logu ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def t_power ( logu , t , self_normalized = False , name = None ) : with tf . compat . v1 . name_scope ( name , \"t_power\" , [ logu , t ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) t = tf . convert_to_tensor ( value = t , dtype = logu . dtype . base_dtype , name = \"t\" ) fu = tf . math . expm1 ( t * logu ) if self_normalized : fu -= t * tf . math . expm1 ( logu ) fu *= tf . where ( tf . logical_and ( 0. < t , t < 1. ) , - tf . ones_like ( t ) , tf . ones_like ( t ) ) return fu\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def log1p_abs ( logu , name = None ) : with tf . compat . v1 . name_scope ( name , \"log1p_abs\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) return tf . math . expm1 ( tf . abs ( logu ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def jeffreys ( logu , name = None ) : with tf . compat . v1 . name_scope ( name , \"jeffreys\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) return 0.5 * tf . math . expm1 ( logu ) * logu\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def modified_gan ( logu , self_normalized = False , name = None ) : with tf . compat . v1 . name_scope ( name , \"chi_square\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) y = tf . nn . softplus ( logu ) - logu if self_normalized : y += 0.5 * tf . math . expm1 ( logu ) return y\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def dual_csiszar_function ( logu , csiszar_function , name = None ) : with tf . compat . v1 . name_scope ( name , \"dual_csiszar_function\" , [ logu ] ) : return tf . exp ( logu ) * csiszar_function ( - logu )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def symmetrized_csiszar_function ( logu , csiszar_function , name = None ) : with tf . compat . v1 . name_scope ( name , \"symmetrized_csiszar_function\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) return 0.5 * ( csiszar_function ( logu ) + dual_csiszar_function ( logu , csiszar_function ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def monte_carlo_csiszar_f_divergence ( f , p_log_prob , q , num_draws , use_reparametrization = None , seed = None , name = None ) : reparameterization_types = tf . nest . flatten ( q . reparameterization_type ) with tf . compat . v1 . name_scope ( name , \"monte_carlo_csiszar_f_divergence\" , [ num_draws ] ) : if use_reparametrization is None : use_reparametrization = all ( reparameterization_type == tfd . FULLY_REPARAMETERIZED for reparameterization_type in reparameterization_types ) elif ( use_reparametrization and any ( reparameterization_type != tfd . FULLY_REPARAMETERIZED for reparameterization_type in reparameterization_types ) ) : # TODO(jvdillon): Consider only raising an exception if the gradient is # requested. raise ValueError ( \"Distribution `q` must be reparameterized, i.e., a diffeomorphic \" \"transformation of a parameterless distribution. (Otherwise this \" \"function has a biased gradient.)\" ) if not callable ( p_log_prob ) : raise TypeError ( \"`p_log_prob` must be a Python `callable` function.\" ) return monte_carlo . expectation ( f = lambda q_samples : f ( p_log_prob ( q_samples ) - q . log_prob ( q_samples ) ) , samples = q . sample ( num_draws , seed = seed ) , log_prob = q . log_prob , # Only used if use_reparametrization=False. use_reparametrization = use_reparametrization )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def csiszar_vimco ( f , p_log_prob , q , num_draws , num_batch_draws = 1 , seed = None , name = None ) : with tf . compat . v1 . name_scope ( name , \"csiszar_vimco\" , [ num_draws , num_batch_draws ] ) : if num_draws < 2 : raise ValueError ( \"Must specify num_draws > 1.\" ) stop = tf . stop_gradient # For readability. x = stop ( q . sample ( sample_shape = [ num_draws , num_batch_draws ] , seed = seed ) ) logqx = q . log_prob ( x ) logu = p_log_prob ( x ) - logqx f_log_avg_u , f_log_sooavg_u = [ f ( r ) for r in csiszar_vimco_helper ( logu ) ] dotprod = tf . reduce_sum ( input_tensor = logqx * stop ( f_log_avg_u - f_log_sooavg_u ) , axis = 0 ) # Sum over iid samples. # We now rewrite f_log_avg_u so that: # `grad[f_log_avg_u] := grad[f_log_avg_u + dotprod]`. # To achieve this, we use a trick that # `f(x) - stop(f(x)) == zeros_like(f(x))` # but its gradient is grad[f(x)]. # Note that IEEE754 specifies that `x - x == 0.` and `x + 0. == x`, hence # this trick loses no precision. For more discussion regarding the relevant # portions of the IEEE754 standard, see the StackOverflow question, # \"Is there a floating point value of x, for which x-x == 0 is false?\" # http://stackoverflow.com/q/2686644 f_log_avg_u += dotprod - stop ( dotprod ) # Add zeros_like(dot_prod). return tf . reduce_mean ( input_tensor = f_log_avg_u , axis = 0 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def csiszar_vimco_helper ( logu , name = None ) : with tf . compat . v1 . name_scope ( name , \"csiszar_vimco_helper\" , [ logu ] ) : logu = tf . convert_to_tensor ( value = logu , name = \"logu\" ) n = tf . compat . dimension_value ( logu . shape . with_rank_at_least ( 1 ) [ 0 ] ) if n is None : n = tf . shape ( input = logu ) [ 0 ] log_n = tf . math . log ( tf . cast ( n , dtype = logu . dtype ) ) nm1 = tf . cast ( n - 1 , dtype = logu . dtype ) else : log_n = np . log ( n ) . astype ( logu . dtype . as_numpy_dtype ) nm1 = np . asarray ( n - 1 , dtype = logu . dtype . as_numpy_dtype ) # Throughout we reduce across axis=0 since this is presumed to be iid # samples. log_max_u = tf . reduce_max ( input_tensor = logu , axis = 0 ) log_sum_u_minus_log_max_u = tf . reduce_logsumexp ( input_tensor = logu - log_max_u , axis = 0 ) # log_loosum_u[i] = # = logsumexp(logu[j] : j != i) # = log( exp(logsumexp(logu)) - exp(logu[i]) ) # = log( exp(logsumexp(logu - logu[i])) exp(logu[i]) - exp(logu[i])) # = logu[i] + log(exp(logsumexp(logu - logu[i])) - 1) # = logu[i] + log(exp(logsumexp(logu) - logu[i]) - 1) # = logu[i] + softplus_inverse(logsumexp(logu) - logu[i]) d = log_sum_u_minus_log_max_u + ( log_max_u - logu ) # We use `d != 0` rather than `d > 0.` because `d < 0.` should never # happens; if it does we want to complain loudly (which `softplus_inverse` # will). d_ok = tf . not_equal ( d , 0. ) safe_d = tf . where ( d_ok , d , tf . ones_like ( d ) ) d_ok_result = logu + tfd . softplus_inverse ( safe_d ) inf = np . array ( np . inf , dtype = logu . dtype . as_numpy_dtype ) # When not(d_ok) and is_positive_and_largest then we manually compute the # log_loosum_u. (We can efficiently do this for any one point but not all, # hence we still need the above calculation.) This is good because when # this condition is met, we cannot use the above calculation; its -inf. # We now compute the log-leave-out-max-sum, replicate it to every # point and make sure to select it only when we need to. is_positive_and_largest = tf . logical_and ( logu > 0. , tf . equal ( logu , log_max_u [ tf . newaxis , ... ] ) ) log_lomsum_u = tf . reduce_logsumexp ( input_tensor = tf . where ( is_positive_and_largest , tf . fill ( tf . shape ( input = logu ) , - inf ) , logu ) , axis = 0 , keepdims = True ) log_lomsum_u = tf . tile ( log_lomsum_u , multiples = 1 + tf . pad ( tensor = [ n - 1 ] , paddings = [ [ 0 , tf . rank ( logu ) - 1 ] ] ) ) d_not_ok_result = tf . where ( is_positive_and_largest , log_lomsum_u , tf . fill ( tf . shape ( input = d ) , - inf ) ) log_loosum_u = tf . where ( d_ok , d_ok_result , d_not_ok_result ) # The swap-one-out-sum (\"soosum\") is n different sums, each of which # replaces the i-th item with the i-th-left-out average, i.e., # soo_sum_u[i] = [exp(logu) - exp(logu[i])] + exp(mean(logu[!=i])) # = exp(log_loosum_u[i]) + exp(looavg_logu[i]) looavg_logu = ( tf . reduce_sum ( input_tensor = logu , axis = 0 ) - logu ) / nm1 log_soosum_u = tf . reduce_logsumexp ( input_tensor = tf . stack ( [ log_loosum_u , looavg_logu ] ) , axis = 0 ) log_avg_u = log_sum_u_minus_log_max_u + log_max_u - log_n log_sooavg_u = log_soosum_u - log_n log_avg_u . set_shape ( logu . shape . with_rank_at_least ( 1 ) [ 1 : ] ) log_sooavg_u . set_shape ( logu . shape ) return log_avg_u , log_sooavg_u\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _interp_regular_1d_grid_impl ( x , x_ref_min , x_ref_max , y_ref , axis = - 1 , batch_y_ref = False , fill_value = 'constant_extension' , fill_value_below = None , fill_value_above = None , grid_regularizing_transform = None , name = None ) : # To understand the implemention differences between the batch/no-batch # versions of this function, you should probably understand the difference # between tf.gather and tf.batch_gather. In particular, we do *not* make the # no-batch version a special case of the batch version, because that would # an inefficient use of batch_gather with unnecessarily broadcast args. with tf . compat . v1 . name_scope ( name , values = [ x , x_ref_min , x_ref_max , y_ref , axis , fill_value , fill_value_below , fill_value_above ] ) : # Arg checking. allowed_fv_st = ( 'constant_extension' , 'extrapolate' ) for fv in ( fill_value , fill_value_below , fill_value_above ) : if isinstance ( fv , str ) and fv not in allowed_fv_st : raise ValueError ( 'A fill value ({}) was not an allowed string ({})' . format ( fv , allowed_fv_st ) ) # Separate value fills for below/above incurs extra cost, so keep track of # whether this is needed. need_separate_fills = ( fill_value_above is not None or fill_value_below is not None or fill_value == 'extrapolate' # always requries separate below/above ) if need_separate_fills and fill_value_above is None : fill_value_above = fill_value if need_separate_fills and fill_value_below is None : fill_value_below = fill_value dtype = dtype_util . common_dtype ( [ x , x_ref_min , x_ref_max , y_ref ] , preferred_dtype = tf . float32 ) x = tf . convert_to_tensor ( value = x , name = 'x' , dtype = dtype ) x_ref_min = tf . convert_to_tensor ( value = x_ref_min , name = 'x_ref_min' , dtype = dtype ) x_ref_max = tf . convert_to_tensor ( value = x_ref_max , name = 'x_ref_max' , dtype = dtype ) if not batch_y_ref : _assert_ndims_statically ( x_ref_min , expect_ndims = 0 ) _assert_ndims_statically ( x_ref_max , expect_ndims = 0 ) y_ref = tf . convert_to_tensor ( value = y_ref , name = 'y_ref' , dtype = dtype ) if batch_y_ref : # If we're batching, # x.shape ~ [A1,...,AN, D], x_ref_min/max.shape ~ [A1,...,AN] # So to add together we'll append a singleton. # If not batching, x_ref_min/max are scalar, so this isn't an issue, # moreover, if not batching, x can be scalar, and expanding x_ref_min/max # would cause a bad expansion of x when added to x (confused yet?). x_ref_min = x_ref_min [ ... , tf . newaxis ] x_ref_max = x_ref_max [ ... , tf . newaxis ] axis = tf . convert_to_tensor ( value = axis , name = 'axis' , dtype = tf . int32 ) axis = distribution_util . make_non_negative_axis ( axis , tf . rank ( y_ref ) ) _assert_ndims_statically ( axis , expect_ndims = 0 ) ny = tf . cast ( tf . shape ( input = y_ref ) [ axis ] , dtype ) # Map [x_ref_min, x_ref_max] to [0, ny - 1]. # This is the (fractional) index of x. if grid_regularizing_transform is None : g = lambda x : x else : g = grid_regularizing_transform fractional_idx = ( ( g ( x ) - g ( x_ref_min ) ) / ( g ( x_ref_max ) - g ( x_ref_min ) ) ) x_idx_unclipped = fractional_idx * ( ny - 1 ) # Wherever x is NaN, x_idx_unclipped will be NaN as well. # Keep track of the nan indices here (so we can impute NaN later). # Also eliminate any NaN indices, since there is not NaN in 32bit. nan_idx = tf . math . is_nan ( x_idx_unclipped ) x_idx_unclipped = tf . where ( nan_idx , tf . zeros_like ( x_idx_unclipped ) , x_idx_unclipped ) x_idx = tf . clip_by_value ( x_idx_unclipped , tf . zeros ( ( ) , dtype = dtype ) , ny - 1 ) # Get the index above and below x_idx. # Naively we could set idx_below = floor(x_idx), idx_above = ceil(x_idx), # however, this results in idx_below == idx_above whenever x is on a grid. # This in turn results in y_ref_below == y_ref_above, and then the gradient # at this point is zero. So here we \"jitter\" one of idx_below, idx_above, # so that they are at different values. This jittering does not affect the # interpolated value, but does make the gradient nonzero (unless of course # the y_ref values are the same). idx_below = tf . floor ( x_idx ) idx_above = tf . minimum ( idx_below + 1 , ny - 1 ) idx_below = tf . maximum ( idx_above - 1 , 0 ) # These are the values of y_ref corresponding to above/below indices. idx_below_int32 = tf . cast ( idx_below , dtype = tf . int32 ) idx_above_int32 = tf . cast ( idx_above , dtype = tf . int32 ) if batch_y_ref : # If y_ref.shape ~ [A1,...,AN, C, B1,...,BN], # and x.shape, x_ref_min/max.shape ~ [A1,...,AN, D] # Then y_ref_below.shape ~ [A1,...,AN, D, B1,...,BN] y_ref_below = _batch_gather_with_broadcast ( y_ref , idx_below_int32 , axis ) y_ref_above = _batch_gather_with_broadcast ( y_ref , idx_above_int32 , axis ) else : # Here, y_ref_below.shape = # y_ref.shape[:axis] + x.shape + y_ref.shape[axis + 1:] y_ref_below = tf . gather ( y_ref , idx_below_int32 , axis = axis ) y_ref_above = tf . gather ( y_ref , idx_above_int32 , axis = axis ) # Use t to get a convex combination of the below/above values. t = x_idx - idx_below # x, and tensors shaped like x, need to be added to, and selected with # (using tf.where) the output y. This requires appending singletons. # Make functions appropriate for batch/no-batch. if batch_y_ref : # In the non-batch case, the output shape is going to be # y_ref.shape[:axis] + x.shape + y_ref.shape[axis+1:] expand_x_fn = _make_expand_x_fn_for_batch_interpolation ( y_ref , axis ) else : # In the batch case, the output shape is going to be # Broadcast(y_ref.shape[:axis], x.shape[:-1]) + # x.shape[-1:] + y_ref.shape[axis+1:] expand_x_fn = _make_expand_x_fn_for_non_batch_interpolation ( y_ref , axis ) t = expand_x_fn ( t ) nan_idx = expand_x_fn ( nan_idx , broadcast = True ) x_idx_unclipped = expand_x_fn ( x_idx_unclipped , broadcast = True ) y = t * y_ref_above + ( 1 - t ) * y_ref_below # Now begins a long excursion to fill values outside [x_min, x_max]. # Re-insert NaN wherever x was NaN. y = tf . where ( nan_idx , tf . fill ( tf . shape ( input = y ) , tf . constant ( np . nan , y . dtype ) ) , y ) if not need_separate_fills : if fill_value == 'constant_extension' : pass # Already handled by clipping x_idx_unclipped. else : y = tf . where ( ( x_idx_unclipped < 0 ) | ( x_idx_unclipped > ny - 1 ) , fill_value + tf . zeros_like ( y ) , y ) else : # Fill values below x_ref_min <==> x_idx_unclipped < 0. if fill_value_below == 'constant_extension' : pass # Already handled by the clipping that created x_idx_unclipped. elif fill_value_below == 'extrapolate' : if batch_y_ref : # For every batch member, gather the first two elements of y across # `axis`. y_0 = tf . gather ( y_ref , [ 0 ] , axis = axis ) y_1 = tf . gather ( y_ref , [ 1 ] , axis = axis ) else : # If not batching, we want to gather the first two elements, just like # above. However, these results need to be replicated for every # member of x. An easy way to do that is to gather using # indices = zeros/ones(x.shape). y_0 = tf . gather ( y_ref , tf . zeros ( tf . shape ( input = x ) , dtype = tf . int32 ) , axis = axis ) y_1 = tf . gather ( y_ref , tf . ones ( tf . shape ( input = x ) , dtype = tf . int32 ) , axis = axis ) x_delta = ( x_ref_max - x_ref_min ) / ( ny - 1 ) x_factor = expand_x_fn ( ( x - x_ref_min ) / x_delta , broadcast = True ) y = tf . where ( x_idx_unclipped < 0 , y_0 + x_factor * ( y_1 - y_0 ) , y ) else : y = tf . where ( x_idx_unclipped < 0 , fill_value_below + tf . zeros_like ( y ) , y ) # Fill values above x_ref_min <==> x_idx_unclipped > ny - 1. if fill_value_above == 'constant_extension' : pass # Already handled by the clipping that created x_idx_unclipped. elif fill_value_above == 'extrapolate' : ny_int32 = tf . shape ( input = y_ref ) [ axis ] if batch_y_ref : y_n1 = tf . gather ( y_ref , [ tf . shape ( input = y_ref ) [ axis ] - 1 ] , axis = axis ) y_n2 = tf . gather ( y_ref , [ tf . shape ( input = y_ref ) [ axis ] - 2 ] , axis = axis ) else : y_n1 = tf . gather ( y_ref , tf . fill ( tf . shape ( input = x ) , ny_int32 - 1 ) , axis = axis ) y_n2 = tf . gather ( y_ref , tf . fill ( tf . shape ( input = x ) , ny_int32 - 2 ) , axis = axis ) x_delta = ( x_ref_max - x_ref_min ) / ( ny - 1 ) x_factor = expand_x_fn ( ( x - x_ref_max ) / x_delta , broadcast = True ) y = tf . where ( x_idx_unclipped > ny - 1 , y_n1 + x_factor * ( y_n1 - y_n2 ) , y ) else : y = tf . where ( x_idx_unclipped > ny - 1 , fill_value_above + tf . zeros_like ( y ) , y ) return y\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def interp_regular_1d_grid ( x , x_ref_min , x_ref_max , y_ref , axis = - 1 , fill_value = 'constant_extension' , fill_value_below = None , fill_value_above = None , grid_regularizing_transform = None , name = None ) : return _interp_regular_1d_grid_impl ( x , x_ref_min , x_ref_max , y_ref , axis = axis , batch_y_ref = False , fill_value = fill_value , fill_value_below = fill_value_below , fill_value_above = fill_value_above , grid_regularizing_transform = grid_regularizing_transform , name = name or 'interp_regular_1d_grid' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def batch_interp_regular_1d_grid ( x , x_ref_min , x_ref_max , y_ref , axis = - 1 , fill_value = 'constant_extension' , fill_value_below = None , fill_value_above = None , grid_regularizing_transform = None , name = None ) : return _interp_regular_1d_grid_impl ( x , x_ref_min , x_ref_max , y_ref , axis = axis , batch_y_ref = True , fill_value = fill_value , fill_value_below = fill_value_below , fill_value_above = fill_value_above , grid_regularizing_transform = grid_regularizing_transform , name = name or 'batch_interp_regular_1d_grid' )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def batch_interp_regular_nd_grid ( x , x_ref_min , x_ref_max , y_ref , axis , fill_value = 'constant_extension' , name = None ) : with tf . compat . v1 . name_scope ( name , default_name = 'interp_regular_nd_grid' , values = [ x , x_ref_min , x_ref_max , y_ref , fill_value ] ) : dtype = dtype_util . common_dtype ( [ x , x_ref_min , x_ref_max , y_ref ] , preferred_dtype = tf . float32 ) # Arg checking. if isinstance ( fill_value , str ) : if fill_value != 'constant_extension' : raise ValueError ( 'A fill value ({}) was not an allowed string ({})' . format ( fill_value , 'constant_extension' ) ) else : fill_value = tf . convert_to_tensor ( value = fill_value , name = 'fill_value' , dtype = dtype ) _assert_ndims_statically ( fill_value , expect_ndims = 0 ) # x.shape = [..., nd]. x = tf . convert_to_tensor ( value = x , name = 'x' , dtype = dtype ) _assert_ndims_statically ( x , expect_ndims_at_least = 2 ) # y_ref.shape = [..., C1,...,Cnd, B1,...,BM] y_ref = tf . convert_to_tensor ( value = y_ref , name = 'y_ref' , dtype = dtype ) # x_ref_min.shape = [nd] x_ref_min = tf . convert_to_tensor ( value = x_ref_min , name = 'x_ref_min' , dtype = dtype ) x_ref_max = tf . convert_to_tensor ( value = x_ref_max , name = 'x_ref_max' , dtype = dtype ) _assert_ndims_statically ( x_ref_min , expect_ndims_at_least = 1 , expect_static = True ) _assert_ndims_statically ( x_ref_max , expect_ndims_at_least = 1 , expect_static = True ) # nd is the number of dimensions indexing the interpolation table, it's the # \"nd\" in the function name. nd = tf . compat . dimension_value ( x_ref_min . shape [ - 1 ] ) if nd is None : raise ValueError ( '`x_ref_min.shape[-1]` must be known statically.' ) x_ref_max . shape [ - 1 : ] . assert_is_compatible_with ( x_ref_min . shape [ - 1 : ] ) # Convert axis and check it statically. axis = tf . convert_to_tensor ( value = axis , dtype = tf . int32 , name = 'axis' ) axis = distribution_util . make_non_negative_axis ( axis , tf . rank ( y_ref ) ) axis . shape . assert_has_rank ( 0 ) axis_ = tf . get_static_value ( axis ) y_ref_rank_ = tf . get_static_value ( tf . rank ( y_ref ) ) if axis_ is not None and y_ref_rank_ is not None : if axis_ + nd > y_ref_rank_ : raise ValueError ( 'Since dims `[axis, axis + nd)` index the interpolation table, we ' 'must have `axis + nd <= rank(y_ref)`. Found: ' '`axis`: {}, rank(y_ref): {}, and inferred `nd` from trailing ' 'dimensions of `x_ref_min` to be {}.' . format ( axis_ , y_ref_rank_ , nd ) ) x_batch_shape = tf . shape ( input = x ) [ : - 2 ] x_ref_min_batch_shape = tf . shape ( input = x_ref_min ) [ : - 1 ] x_ref_max_batch_shape = tf . shape ( input = x_ref_max ) [ : - 1 ] y_ref_batch_shape = tf . shape ( input = y_ref ) [ : axis ] # Do a brute-force broadcast of batch dims (add zeros). batch_shape = y_ref_batch_shape for tensor in [ x_batch_shape , x_ref_min_batch_shape , x_ref_max_batch_shape ] : batch_shape = tf . broadcast_dynamic_shape ( batch_shape , tensor ) def _batch_of_zeros_with_rightmost_singletons ( n_singletons ) : \"\"\"Return Tensor of zeros with some singletons on the rightmost dims.\"\"\" ones = tf . ones ( shape = [ n_singletons ] , dtype = tf . int32 ) return tf . zeros ( shape = tf . concat ( [ batch_shape , ones ] , axis = 0 ) , dtype = dtype ) x += _batch_of_zeros_with_rightmost_singletons ( n_singletons = 2 ) x_ref_min += _batch_of_zeros_with_rightmost_singletons ( n_singletons = 1 ) x_ref_max += _batch_of_zeros_with_rightmost_singletons ( n_singletons = 1 ) y_ref += _batch_of_zeros_with_rightmost_singletons ( n_singletons = tf . rank ( y_ref ) - axis ) return _batch_interp_with_gather_nd ( x = x , x_ref_min = x_ref_min , x_ref_max = x_ref_max , y_ref = y_ref , nd = nd , fill_value = fill_value , batch_dims = tf . get_static_value ( tf . rank ( x ) ) - 2 )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _batch_interp_with_gather_nd ( x , x_ref_min , x_ref_max , y_ref , nd , fill_value , batch_dims ) : dtype = x . dtype # In this function, # x.shape = [A1, ..., An, D, nd], where n = batch_dims # and # y_ref.shape = [A1, ..., An, C1, C2,..., Cnd, B1,...,BM] # y_ref[A1, ..., An, i1,...,ind] is a shape [B1,...,BM] Tensor with the value # at index [i1,...,ind] in the interpolation table. # and x_ref_max have shapes [A1, ..., An, nd]. # ny[k] is number of y reference points in interp dim k. ny = tf . cast ( tf . shape ( input = y_ref ) [ batch_dims : batch_dims + nd ] , dtype ) # Map [x_ref_min, x_ref_max] to [0, ny - 1]. # This is the (fractional) index of x. # x_idx_unclipped[A1, ..., An, d, k] is the fractional index into dim k of # interpolation table for the dth x value. x_ref_min_expanded = tf . expand_dims ( x_ref_min , axis = - 2 ) x_ref_max_expanded = tf . expand_dims ( x_ref_max , axis = - 2 ) x_idx_unclipped = ( ny - 1 ) * ( x - x_ref_min_expanded ) / ( x_ref_max_expanded - x_ref_min_expanded ) # Wherever x is NaN, x_idx_unclipped will be NaN as well. # Keep track of the nan indices here (so we can impute NaN later). # Also eliminate any NaN indices, since there is not NaN in 32bit. nan_idx = tf . math . is_nan ( x_idx_unclipped ) x_idx_unclipped = tf . where ( nan_idx , tf . zeros_like ( x_idx_unclipped ) , x_idx_unclipped ) # x_idx.shape = [A1, ..., An, D, nd] x_idx = tf . clip_by_value ( x_idx_unclipped , tf . zeros ( ( ) , dtype = dtype ) , ny - 1 ) # Get the index above and below x_idx. # Naively we could set idx_below = floor(x_idx), idx_above = ceil(x_idx), # however, this results in idx_below == idx_above whenever x is on a grid. # This in turn results in y_ref_below == y_ref_above, and then the gradient # at this point is zero. So here we \"jitter\" one of idx_below, idx_above, # so that they are at different values. This jittering does not affect the # interpolated value, but does make the gradient nonzero (unless of course # the y_ref values are the same). idx_below = tf . floor ( x_idx ) idx_above = tf . minimum ( idx_below + 1 , ny - 1 ) idx_below = tf . maximum ( idx_above - 1 , 0 ) # These are the values of y_ref corresponding to above/below indices. # idx_below_int32.shape = x.shape[:-1] + [nd] idx_below_int32 = tf . cast ( idx_below , dtype = tf . int32 ) idx_above_int32 = tf . cast ( idx_above , dtype = tf . int32 ) # idx_below_list is a length nd list of shape x.shape[:-1] int32 tensors. idx_below_list = tf . unstack ( idx_below_int32 , axis = - 1 ) idx_above_list = tf . unstack ( idx_above_int32 , axis = - 1 ) # Use t to get a convex combination of the below/above values. # t.shape = [A1, ..., An, D, nd] t = x_idx - idx_below # x, and tensors shaped like x, need to be added to, and selected with # (using tf.where) the output y. This requires appending singletons. def _expand_x_fn ( tensor ) : # Reshape tensor to tensor.shape + [1] * M. extended_shape = tf . concat ( [ tf . shape ( input = tensor ) , tf . ones_like ( tf . shape ( input = y_ref ) [ batch_dims + nd : ] ) ] , axis = 0 ) return tf . reshape ( tensor , extended_shape ) # Now, t.shape = [A1, ..., An, D, nd] + [1] * (rank(y_ref) - nd - batch_dims) t = _expand_x_fn ( t ) s = 1 - t # Re-insert NaN wherever x was NaN. nan_idx = _expand_x_fn ( nan_idx ) t = tf . where ( nan_idx , tf . fill ( tf . shape ( input = t ) , tf . constant ( np . nan , dtype ) ) , t ) terms = [ ] # Our work above has located x's fractional index inside a cube of above/below # indices. The distance to the below indices is t, and to the above indices # is s. # Drawing lines from x to the cube walls, we get 2**nd smaller cubes. Each # term in the result is a product of a reference point, gathered from y_ref, # multiplied by a volume. The volume is that of the cube opposite to the # reference point. E.g. if the reference point is below x in every axis, the # volume is that of the cube with corner above x in every axis, s[0]*...*s[nd] # We could probably do this with one massive gather, but that would be very # unreadable and un-debuggable. It also would create a large Tensor. for zero_ones_list in _binary_count ( nd ) : gather_from_y_ref_idx = [ ] opposite_volume_t_idx = [ ] opposite_volume_s_idx = [ ] for k , zero_or_one in enumerate ( zero_ones_list ) : if zero_or_one == 0 : # If the kth iterate has zero_or_one = 0, # Will gather from the \"below\" reference point along axis k. gather_from_y_ref_idx . append ( idx_below_list [ k ] ) # Now append the index to gather for computing opposite_volume. # This could be done by initializing opposite_volume to 1, then here: # opposite_volume *= tf.gather(s, indices=k, axis=tf.rank(x) - 1) # but that puts a gather in the \"inner loop.\" Better to append the # index and do one larger gather down below. opposite_volume_s_idx . append ( k ) else : gather_from_y_ref_idx . append ( idx_above_list [ k ] ) # Append an index to gather, having the same effect as # opposite_volume *= tf.gather(t, indices=k, axis=tf.rank(x) - 1) opposite_volume_t_idx . append ( k ) # Compute opposite_volume (volume of cube opposite the ref point): # Recall t.shape = s.shape = [D, nd] + [1, ..., 1] # Gather from t and s along the \"nd\" axis, which is rank(x) - 1. ov_axis = tf . rank ( x ) - 1 opposite_volume = ( tf . reduce_prod ( input_tensor = tf . gather ( t , indices = tf . cast ( opposite_volume_t_idx , dtype = tf . int32 ) , axis = ov_axis ) , axis = ov_axis ) * tf . reduce_prod ( input_tensor = tf . gather ( s , indices = tf . cast ( opposite_volume_s_idx , dtype = tf . int32 ) , axis = ov_axis ) , axis = ov_axis ) ) # pyformat: disable y_ref_pt = tf . gather_nd ( y_ref , tf . stack ( gather_from_y_ref_idx , axis = - 1 ) , batch_dims = batch_dims ) terms . append ( y_ref_pt * opposite_volume ) y = tf . math . add_n ( terms ) if tf . debugging . is_numeric_tensor ( fill_value ) : # Recall x_idx_unclipped.shape = [D, nd], # so here we check if it was out of bounds in any of the nd dims. # Thus, oob_idx.shape = [D]. oob_idx = tf . reduce_any ( input_tensor = ( x_idx_unclipped < 0 ) | ( x_idx_unclipped > ny - 1 ) , axis = - 1 ) # Now, y.shape = [D, B1,...,BM], so we'll have to broadcast oob_idx. oob_idx = _expand_x_fn ( oob_idx ) # Shape [D, 1,...,1] oob_idx |= tf . fill ( tf . shape ( input = y ) , False ) y = tf . where ( oob_idx , tf . fill ( tf . shape ( input = y ) , fill_value ) , y ) return y\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def get_vid_from_url ( url ) : return match1 ( url , r'youtu\\.be/([^?/]+)' ) or match1 ( url , r'youtube\\.com/embed/([^/?]+)' ) or match1 ( url , r'youtube\\.com/v/([^/?]+)' ) or match1 ( url , r'youtube\\.com/watch/([^/?]+)' ) or parse_query_param ( url , 'v' ) or parse_query_param ( parse_query_param ( url , 'u' ) , 'v' )\n\n    Summary:\n    Extracts video ID from URL .\n\n    Here is the task you should finish:\n\n    Code Snippet: \n    def _assert_ndims_statically ( x , expect_ndims = None , expect_ndims_at_least = None , expect_static = False ) : ndims = x . shape . ndims if ndims is None : if expect_static : raise ValueError ( 'Expected static ndims. Found: {}' . format ( x ) ) return if expect_ndims is not None and ndims != expect_ndims : raise ValueError ( 'ndims must be {}. Found: {}' . format ( expect_ndims , ndims ) ) if expect_ndims_at_least is not None and ndims < expect_ndims_at_least : raise ValueError ( 'ndims must be at least {}. Found {}' . format ( expect_ndims_at_least , ndims ) )\n    \n    \n    Summary:", "Here is a Python code, and I hope you can generate a brief code summary based on the code.\n    Note: You only need to generate a concise code summary, without saying any extra words or providing any extra content. \n\n\n    For Example:\n\n    Code Snippet:\n    def g